; Listing generated by Microsoft (R) Optimizing Compiler Version 19.32.31332.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CA@BBMKAOPO@Fatal?3?5KMSv?$CFhu?4?$CFhu?5unsupported?6@ ; `string'
PUBLIC	??_C@_0DP@CJEHLGPD@Fatal?3?5Received?5wrong?5RPC?5packe@ ; `string'
PUBLIC	??_C@_0FA@EFGNKFML@Fatal?3?5RPC?5response?5does?5not?5co@ ; `string'
PUBLIC	??_C@_0CN@JIFMCEFK@Fatal?3?5RPC?5response?5requests?5au@ ; `string'
PUBLIC	??_C@_0EI@BKAOLKDE@Fatal?3?5RPC?5packet?5flags?5RPC_PF_@ ; `string'
PUBLIC	??_C@_0BG@HLJBDNGA@RPC_PF_CANCEL_PENDING@	; `string'
PUBLIC	??_C@_0BP@EPFAGCLK@Warning?3?5?$CFs?5should?5not?5be?5set?6@ ; `string'
PUBLIC	??_C@_0BA@LFBPBNOH@RPC_PF_RESERVED@		; `string'
PUBLIC	??_C@_0BA@HEJPAFFP@RPC_PF_NOT_EXEC@		; `string'
PUBLIC	??_C@_0N@HEOOBKKP@RPC_PF_MAYBE@			; `string'
PUBLIC	??_C@_0O@DHNLACON@RPC_PF_OBJECT@		; `string'
PUBLIC	??_C@_0CP@HOOBBENO@Fatal?3?5Expected?5RPC?5version?55?40@ ; `string'
PUBLIC	??_C@_0EE@GLJICDBO@Warning?3?5RPC_PF_MULTIPLEX?5of?5RP@ ; `string'
PUBLIC	??_C@_0BB@MIHFLBDG@RPC_PF_MULTIPLEX@		; `string'
PUBLIC	??_C@_0EG@HDABALOO@Warning?3?5Buggy?5RPC?5of?5Wine?5dete@ ; `string'
PUBLIC	??_C@_0DL@NKMJHEP@Fatal?3?5Sent?5Call?5Id?5?$CFu?5but?5rece@ ; `string'
PUBLIC	??_C@_0CE@JLEJBEGP@?6Fatal?3?5Could?5not?5send?5RPC?5requ@ ; `string'
PUBLIC	??_C@_0CO@NNOGDDAG@?6Fatal?3?5No?5RPC?5response?5receive@ ; `string'
PUBLIC	??_C@_0CE@ENNHKCJO@?6Fatal?3?5RPC?5response?5is?5incompl@ ; `string'
PUBLIC	??_C@_0CM@HKIEGAIN@?6Fatal?3?5RPC?5response?5cancel?5cou@ ; `string'
PUBLIC	??_C@_0DB@LCKBGPNI@?6Fatal?3?5RPC?5response?5context?5id@ ; `string'
PUBLIC	??_C@_0EA@FIBHBLDN@?6Fatal?3?5NDR?5data?5length?5?$CI?$CFu?$CJ?5do@ ; `string'
PUBLIC	??_C@_0FD@KCALNIFM@?6Fatal?3?5No?5or?5incomplete?5KMS?5re@ ; `string'
PUBLIC	??_C@_0EK@EDAGGGNP@?6Warning?3?5RPC?5stub?5size?5is?5?$CFu?0?5@ ; `string'
PUBLIC	??_C@_0EN@IFHPELIC@?6Warning?3?5RPC?5stub?5data?5not?5pad@ ; `string'
PUBLIC	??_C@_0CJ@ELGOCPLL@?6Fatal?3?5Sending?5RPC?5bind?5reques@ ; `string'
PUBLIC	??_C@_0DA@NCIGIHDA@?6Fatal?3?5Did?5not?5receive?5a?5respo@ ; `string'
PUBLIC	??_C@_0DG@CDFCGJFH@?6Fatal?3?5Incomplete?5RPC?5bind?5ack@ ; `string'
PUBLIC	??_C@_0CK@HPNJNCNH@?6Fatal?3?5Expected?5?$CFu?5CTX?5items?5b@ ; `string'
PUBLIC	??_C@_04EFGMAIMH@BTFN@				; `string'
PUBLIC	??_C@_05CMNEGGDF@NDR64@				; `string'
PUBLIC	??_C@_05HMEFADFI@NDR32@				; `string'
PUBLIC	??_C@_0EA@FALBNLMF@?6Warning?3?5Rejected?5transfer?5syn@ ; `string'
PUBLIC	??_C@_0EO@LKGEJEDI@?6Warning?3?5Rejected?5transfer?5syn@ ; `string'
PUBLIC	??_C@_0DO@PHEPNPBJ@?6Warning?3?5Transfer?5syntax?5?$CFs?5do@ ; `string'
PUBLIC	??_C@_0FI@PEIELJGO@?6Warning?3?5Rejected?5transfer?5syn@ ; `string'
PUBLIC	??_C@_0ED@ONOBBCGN@?6Warning?3?5BTFN?5did?5not?5respond?5@ ; `string'
PUBLIC	??_C@_0EC@EDPPOAMK@?6Warning?3?5BTFN?5did?5not?5return?5e@ ; `string'
PUBLIC	??_C@_09PKGPPFMG@?4?4?4?5BTFN?5@		; `string'
PUBLIC	??_C@_0GC@NGOEMPDA@?6Fatal?3?5transfer?5syntax?5?$CFs?5retu@ ; `string'
PUBLIC	??_C@_0EJ@PGIIMLOK@?6Fatal?3?5Transfer?5syntax?5of?5RPC?5@ ; `string'
PUBLIC	??_C@_0DP@BHGLCOFK@?6Fatal?3?5Expected?5transfer?5synta@ ; `string'
PUBLIC	??_C@_0CM@HGMDMAM@?6Warning?3?5Ack?5reason?5should?5be?5@ ; `string'
PUBLIC	??_C@_0L@DMLPGKA@?4?4?4?5NDR64?5@		; `string'
PUBLIC	??_C@_0L@DAJIHKCA@?4?4?4?5NDR32?5@		; `string'
PUBLIC	??_C@_0EF@PFAMEHMF@?6Fatal?3?5Could?5neither?5negotiate@ ; `string'
COMM	RpcFlags:DWORD
_DATA	ENDS
;	COMDAT ??_C@_0EF@PFAMEHMF@?6Fatal?3?5Could?5neither?5negotiate@
CONST	SEGMENT
??_C@_0EF@PFAMEHMF@?6Fatal?3?5Could?5neither?5negotiate@ DB 0aH, 'Fatal: '
	DB	'Could neither negotiate NDR32 nor NDR64 with the RPC server', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DAJIHKCA@?4?4?4?5NDR32?5@
CONST	SEGMENT
??_C@_0L@DAJIHKCA@?4?4?4?5NDR32?5@ DB '... NDR32 ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DMLPGKA@?4?4?4?5NDR64?5@
CONST	SEGMENT
??_C@_0L@DMLPGKA@?4?4?4?5NDR64?5@ DB '... NDR64 ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HGMDMAM@?6Warning?3?5Ack?5reason?5should?5be?5@
CONST	SEGMENT
??_C@_0CM@HGMDMAM@?6Warning?3?5Ack?5reason?5should?5be?5@ DB 0aH, 'Warnin'
	DB	'g: Ack reason should be 0 but is %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@BHGLCOFK@?6Fatal?3?5Expected?5transfer?5synta@
CONST	SEGMENT
??_C@_0DP@BHGLCOFK@?6Fatal?3?5Expected?5transfer?5synta@ DB 0aH, 'Fatal: '
	DB	'Expected transfer syntax version %u for %s but got %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@PGIIMLOK@?6Fatal?3?5Transfer?5syntax?5of?5RPC?5@
CONST	SEGMENT
??_C@_0EJ@PGIIMLOK@?6Fatal?3?5Transfer?5syntax?5of?5RPC?5@ DB 0aH, 'Fatal'
	DB	': Transfer syntax of RPC bind request and response does not m'
	DB	'atch', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@NGOEMPDA@?6Fatal?3?5transfer?5syntax?5?$CFs?5retu@
CONST	SEGMENT
??_C@_0GC@NGOEMPDA@?6Fatal?3?5transfer?5syntax?5?$CFs?5retu@ DB 0aH, 'Fat'
	DB	'al: transfer syntax %s returned an invalid status, neither RP'
	DB	'C_BIND_ACCEPT nor RPC_BIND_NACK', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKGPPFMG@?4?4?4?5BTFN?5@
CONST	SEGMENT
??_C@_09PKGPPFMG@?4?4?4?5BTFN?5@ DB '... BTFN ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@EDPPOAMK@?6Warning?3?5BTFN?5did?5not?5return?5e@
CONST	SEGMENT
??_C@_0EC@EDPPOAMK@?6Warning?3?5BTFN?5did?5not?5return?5e@ DB 0aH, 'Warni'
	DB	'ng: BTFN did not return expected feature mask 0x3 but 0x%X', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@ONOBBCGN@?6Warning?3?5BTFN?5did?5not?5respond?5@
CONST	SEGMENT
??_C@_0ED@ONOBBCGN@?6Warning?3?5BTFN?5did?5not?5respond?5@ DB 0aH, 'Warni'
	DB	'ng: BTFN did not respond with RPC_BIND_ACK or RPC_BIND_NACK', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@PEIELJGO@?6Warning?3?5Rejected?5transfer?5syn@
CONST	SEGMENT
??_C@_0FI@PEIELJGO@?6Warning?3?5Rejected?5transfer?5syn@ DB 0aH, 'Warning'
	DB	': Rejected transfer syntax %s did not return ack reason RPC_S'
	DB	'YNTAX_UNSUPPORTED', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@PHEPNPBJ@?6Warning?3?5Transfer?5syntax?5?$CFs?5do@
CONST	SEGMENT
??_C@_0DO@PHEPNPBJ@?6Warning?3?5Transfer?5syntax?5?$CFs?5do@ DB 0aH, 'War'
	DB	'ning: Transfer syntax %s does not support KMS activation', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@LKGEJEDI@?6Warning?3?5Rejected?5transfer?5syn@
CONST	SEGMENT
??_C@_0EO@LKGEJEDI@?6Warning?3?5Rejected?5transfer?5syn@ DB 0aH, 'Warning'
	DB	': Rejected transfer syntax %s did not return syntax version 0'
	DB	' but %u', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@FALBNLMF@?6Warning?3?5Rejected?5transfer?5syn@
CONST	SEGMENT
??_C@_0EA@FALBNLMF@?6Warning?3?5Rejected?5transfer?5syn@ DB 0aH, 'Warning'
	DB	': Rejected transfer syntax %s did not return NULL Guid', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05HMEFADFI@NDR32@
CONST	SEGMENT
??_C@_05HMEFADFI@NDR32@ DB 'NDR32', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CMNEGGDF@NDR64@
CONST	SEGMENT
??_C@_05CMNEGGDF@NDR64@ DB 'NDR64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EFGMAIMH@BTFN@
CONST	SEGMENT
??_C@_04EFGMAIMH@BTFN@ DB 'BTFN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@HPNJNCNH@?6Fatal?3?5Expected?5?$CFu?5CTX?5items?5b@
CONST	SEGMENT
??_C@_0CK@HPNJNCNH@?6Fatal?3?5Expected?5?$CFu?5CTX?5items?5b@ DB 0aH, 'Fa'
	DB	'tal: Expected %u CTX items but got %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@CDFCGJFH@?6Fatal?3?5Incomplete?5RPC?5bind?5ack@
CONST	SEGMENT
??_C@_0DG@CDFCGJFH@?6Fatal?3?5Incomplete?5RPC?5bind?5ack@ DB 0aH, 'Fatal:'
	DB	' Incomplete RPC bind acknowledgement received', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NCIGIHDA@?6Fatal?3?5Did?5not?5receive?5a?5respo@
CONST	SEGMENT
??_C@_0DA@NCIGIHDA@?6Fatal?3?5Did?5not?5receive?5a?5respo@ DB 0aH, 'Fatal'
	DB	': Did not receive a response from server', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@ELGOCPLL@?6Fatal?3?5Sending?5RPC?5bind?5reques@
CONST	SEGMENT
??_C@_0CJ@ELGOCPLL@?6Fatal?3?5Sending?5RPC?5bind?5reques@ DB 0aH, 'Fatal:'
	DB	' Sending RPC bind request failed', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@IFHPELIC@?6Warning?3?5RPC?5stub?5data?5not?5pad@
CONST	SEGMENT
??_C@_0EN@IFHPELIC@?6Warning?3?5RPC?5stub?5data?5not?5pad@ DB 0aH, 'Warni'
	DB	'ng: RPC stub data not padded to zeros according to Microsoft '
	DB	'standard', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@EDAGGGNP@?6Warning?3?5RPC?5stub?5size?5is?5?$CFu?0?5@
CONST	SEGMENT
??_C@_0EK@EDAGGGNP@?6Warning?3?5RPC?5stub?5size?5is?5?$CFu?0?5@ DB 0aH, 'W'
	DB	'arning: RPC stub size is %u, should be %u (probably incorrect'
	DB	' padding)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@KCALNIFM@?6Fatal?3?5No?5or?5incomplete?5KMS?5re@
CONST	SEGMENT
??_C@_0FD@KCALNIFM@?6Fatal?3?5No?5or?5incomplete?5KMS?5re@ DB 0aH, 'Fatal'
	DB	': No or incomplete KMS response received. Required %u bytes b'
	DB	'ut only got %i', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@FIBHBLDN@?6Fatal?3?5NDR?5data?5length?5?$CI?$CFu?$CJ?5do@
CONST	SEGMENT
??_C@_0EA@FIBHBLDN@?6Fatal?3?5NDR?5data?5length?5?$CI?$CFu?$CJ?5do@ DB 0aH
	DB	'Fatal: NDR data length (%u) does not match NDR data size (%u)'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LCKBGPNI@?6Fatal?3?5RPC?5response?5context?5id@
CONST	SEGMENT
??_C@_0DB@LCKBGPNI@?6Fatal?3?5RPC?5response?5context?5id@ DB 0aH, 'Fatal:'
	DB	' RPC response context id %u is not bound', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HKIEGAIN@?6Fatal?3?5RPC?5response?5cancel?5cou@
CONST	SEGMENT
??_C@_0CM@HKIEGAIN@?6Fatal?3?5RPC?5response?5cancel?5cou@ DB 0aH, 'Fatal:'
	DB	' RPC response cancel count is not 0', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@ENNHKCJO@?6Fatal?3?5RPC?5response?5is?5incompl@
CONST	SEGMENT
??_C@_0CE@ENNHKCJO@?6Fatal?3?5RPC?5response?5is?5incompl@ DB 0aH, 'Fatal:'
	DB	' RPC response is incomplete', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@NNOGDDAG@?6Fatal?3?5No?5RPC?5response?5receive@
CONST	SEGMENT
??_C@_0CO@NNOGDDAG@?6Fatal?3?5No?5RPC?5response?5receive@ DB 0aH, 'Fatal:'
	DB	' No RPC response received from server', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JLEJBEGP@?6Fatal?3?5Could?5not?5send?5RPC?5requ@
CONST	SEGMENT
??_C@_0CE@JLEJBEGP@?6Fatal?3?5Could?5not?5send?5RPC?5requ@ DB 0aH, 'Fatal'
	DB	': Could not send RPC request', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@NKMJHEP@Fatal?3?5Sent?5Call?5Id?5?$CFu?5but?5rece@
CONST	SEGMENT
??_C@_0DL@NKMJHEP@Fatal?3?5Sent?5Call?5Id?5?$CFu?5but?5rece@ DB 'Fatal: S'
	DB	'ent Call Id %u but received answer for Call Id %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@HDABALOO@Warning?3?5Buggy?5RPC?5of?5Wine?5dete@
CONST	SEGMENT
??_C@_0EG@HDABALOO@Warning?3?5Buggy?5RPC?5of?5Wine?5dete@ DB 'Warning: Bu'
	DB	'ggy RPC of Wine detected. Call Id of Response is always 1', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MIHFLBDG@RPC_PF_MULTIPLEX@
CONST	SEGMENT
??_C@_0BB@MIHFLBDG@RPC_PF_MULTIPLEX@ DB 'RPC_PF_MULTIPLEX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@GLJICDBO@Warning?3?5RPC_PF_MULTIPLEX?5of?5RP@
CONST	SEGMENT
??_C@_0EE@GLJICDBO@Warning?3?5RPC_PF_MULTIPLEX?5of?5RP@ DB 'Warning: RPC_'
	DB	'PF_MULTIPLEX of RPC request and response should match', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HOOBBENO@Fatal?3?5Expected?5RPC?5version?55?40@
CONST	SEGMENT
??_C@_0CP@HOOBBENO@Fatal?3?5Expected?5RPC?5version?55?40@ DB 'Fatal: Expe'
	DB	'cted RPC version 5.0 and got %u.%u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DHNLACON@RPC_PF_OBJECT@
CONST	SEGMENT
??_C@_0O@DHNLACON@RPC_PF_OBJECT@ DB 'RPC_PF_OBJECT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HEOOBKKP@RPC_PF_MAYBE@
CONST	SEGMENT
??_C@_0N@HEOOBKKP@RPC_PF_MAYBE@ DB 'RPC_PF_MAYBE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HEJPAFFP@RPC_PF_NOT_EXEC@
CONST	SEGMENT
??_C@_0BA@HEJPAFFP@RPC_PF_NOT_EXEC@ DB 'RPC_PF_NOT_EXEC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LFBPBNOH@RPC_PF_RESERVED@
CONST	SEGMENT
??_C@_0BA@LFBPBNOH@RPC_PF_RESERVED@ DB 'RPC_PF_RESERVED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EPFAGCLK@Warning?3?5?$CFs?5should?5not?5be?5set?6@
CONST	SEGMENT
??_C@_0BP@EPFAGCLK@Warning?3?5?$CFs?5should?5not?5be?5set?6@ DB 'Warning:'
	DB	' %s should not be set', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HLJBDNGA@RPC_PF_CANCEL_PENDING@
CONST	SEGMENT
??_C@_0BG@HLJBDNGA@RPC_PF_CANCEL_PENDING@ DB 'RPC_PF_CANCEL_PENDING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@BKAOLKDE@Fatal?3?5RPC?5packet?5flags?5RPC_PF_@
CONST	SEGMENT
??_C@_0EI@BKAOLKDE@Fatal?3?5RPC?5packet?5flags?5RPC_PF_@ DB 'Fatal: RPC p'
	DB	'acket flags RPC_PF_FIRST and RPC_PF_LAST are not both set.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JIFMCEFK@Fatal?3?5RPC?5response?5requests?5au@
CONST	SEGMENT
??_C@_0CN@JIFMCEFK@Fatal?3?5RPC?5response?5requests?5au@ DB 'Fatal: RPC r'
	DB	'esponse requests authentication', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@EFGNKFML@Fatal?3?5RPC?5response?5does?5not?5co@
CONST	SEGMENT
??_C@_0FA@EFGNKFML@Fatal?3?5RPC?5response?5does?5not?5co@ DB 'Fatal: RPC '
	DB	'response does not conform to Microsoft''s limited support of '
	DB	'DCE RPC', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@CJEHLGPD@Fatal?3?5Received?5wrong?5RPC?5packe@
CONST	SEGMENT
??_C@_0DP@CJEHLGPD@Fatal?3?5Received?5wrong?5RPC?5packe@ DB 'Fatal: Recei'
	DB	'ved wrong RPC packet type. Expected %u but got %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BBMKAOPO@Fatal?3?5KMSv?$CFhu?4?$CFhu?5unsupported?6@
CONST	SEGMENT
??_C@_0CA@BBMKAOPO@Fatal?3?5KMSv?$CFhu?4?$CFhu?5unsupported?6@ DB 'Fatal:'
	DB	' KMSv%hu.%hu unsupported', 0aH, 00H		; `string'
TransferSyntaxNDR64 DB 033H
	DB	05H
	DB	071H
	DB	071H
	DB	0baH
	DB	0beH
	DB	037H
	DB	049H
	DB	083H
	DB	019H
	DB	0b5H
	DB	0dbH
	DB	0efH
	DB	09cH
	DB	0ccH
	DB	036H
TransferSyntaxNDR32 DB 04H
	DB	05dH
	DB	088H
	DB	08aH
	DB	0ebH
	DB	01cH
	DB	0c9H
	DB	011H
	DB	09fH
	DB	0e8H
	DB	08H
	DB	00H
	DB	02bH
	DB	010H
	DB	048H
	DB	060H
_Versions DD	0fcH
	ORG $+4
	DQ	FLAT:CreateResponseV4
	DD	0104H
	ORG $+4
	DQ	FLAT:CreateResponseV6
	DD	0104H
	ORG $+4
	DQ	FLAT:CreateResponseV6
_Actions DB	0cH
	ORG $+7
	DQ	FLAT:checkRpcBindSize
	DQ	FLAT:rpcBind
	DB	02H
	ORG $+7
	DQ	FLAT:checkRpcRequestSize
	DQ	FLAT:rpcRequest
	DB	0fH
	ORG $+7
	DQ	FLAT:checkRpcBindSize
	DQ	FLAT:rpcBind
InterfaceUuid DB 075H
	DB	021H
	DB	0c8H
	DB	051H
	DB	04eH
	DB	084H
	DB	050H
	DB	047H
	DB	0b0H
	DB	0d8H
	DB	0ecH
	DB	025H
	DB	055H
	DB	055H
	DB	0bcH
	DB	06H
BindTimeFeatureNegotiation DB 02cH
	DB	01cH
	DB	0b7H
	DB	06cH
	DB	012H
	DB	098H
	DB	040H
	DB	045H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
PUBLIC	rpcBindClient
PUBLIC	rpcSendRequest
PUBLIC	rpcServer
?WineBugDetected@?1??checkRpcResponseHeader@@9@9 DB 01H DUP (?) ; `checkRpcResponseHeader'::`2'::WineBugDetected
	ALIGN	4

firstPacketSent DB 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rpcBindClient DD imagerel $LN6
	DD	imagerel $LN6+139
	DD	imagerel $unwind$rpcBindClient
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rpcBindOrAlterClientContext DD imagerel rpcBindOrAlterClientContext
	DD	imagerel rpcBindOrAlterClientContext+1175
	DD	imagerel $unwind$rpcBindOrAlterClientContext
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rpcSendRequest DD imagerel $LN52
	DD	imagerel $LN52+801
	DD	imagerel $unwind$rpcSendRequest
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$checkRpcResponseHeader DD imagerel checkRpcResponseHeader
	DD	imagerel checkRpcResponseHeader+188
	DD	imagerel $unwind$checkRpcResponseHeader
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$checkRpcHeader DD imagerel checkRpcHeader
	DD	imagerel checkRpcHeader+299
	DD	imagerel $unwind$checkRpcHeader
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rpcBind DD imagerel rpcBind
	DD	imagerel rpcBind+663
	DD	imagerel $unwind$rpcBind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rpcRequest DD imagerel rpcRequest
	DD	imagerel rpcRequest+347
	DD	imagerel $unwind$rpcRequest
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$checkRpcRequestSize DD imagerel checkRpcRequestSize
	DD	imagerel checkRpcRequestSize+130
	DD	imagerel $unwind$checkRpcRequestSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rpcServer DD imagerel $LN38
	DD	imagerel $LN38+527
	DD	imagerel $unwind$rpcServer
;	COMDAT xdata
xdata	SEGMENT
$unwind$rpcServer DD 0d2601H
	DD	0707426H
	DD	06f6426H
	DD	06e3426H
	DD	0680126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$checkRpcRequestSize DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rpcRequest DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rpcBind DD 0d1f01H
	DD	021641fH
	DD	01f541fH
	DD	01e341fH
	DD	018011fH
	DD	0e016f018H
	DD	0c012d014H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$checkRpcHeader DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$checkRpcResponseHeader DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rpcSendRequest DD 0c1f01H
	DD	012741fH
	DD	011641fH
	DD	010341fH
	DD	0f018921fH
	DD	0d014e016H
	DD	05010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rpcBindOrAlterClientContext DD 0250b2001H
	DD	0123420H
	DD	092142319H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rpcBindClient DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
CallId	DD	02H
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
;	COMDAT rpcServer
_TEXT	SEGMENT
NdrCtx$ = 64
rpcRequestHeader$ = 72
responseBuffer$1 = 96
requestBuffer$2 = 528
sock$ = 880
rpcAssocGroup$ = 888
ipstr$ = 896
Ndr64Ctx$ = 904
rpcServer PROC						; COMDAT

; 614  : {

$LN38:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000f	55		 push	 rbp
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 8d a8 98 fd
	ff ff		 lea	 rbp, QWORD PTR [rax-616]
  0001f	48 81 ec 40 03
	00 00		 sub	 rsp, 832		; 00000340H

; 615  : 	RPC_HEADER  rpcRequestHeader;
; 616  : 	WORD NdrCtx = RPC_INVALID_CTX, Ndr64Ctx = RPC_INVALID_CTX;

  00026	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0002b	4d 8b e0	 mov	 r12, r8
  0002e	66 89 44 24 40	 mov	 WORD PTR NdrCtx$[rsp], ax
  00033	44 8b ea	 mov	 r13d, edx
  00036	66 89 85 88 02
	00 00		 mov	 WORD PTR Ndr64Ctx$[rbp-256], ax
  0003d	4c 8b f9	 mov	 r15, rcx
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 346  : 	srand(GetTickCount());

  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  00046	8b c8		 mov	 ecx, eax
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_srand
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c

; 620  : 	while (_recv(sock, &rpcRequestHeader, sizeof(rpcRequestHeader)))

  0004e	e9 7f 01 00 00	 jmp	 $LN18@rpcServer
$LL2@rpcServer:

; 621  : 	{
; 622  : 		//int_fast8_t  _st;
; 623  : 		unsigned int request_len, response_len;
; 624  : 		uint_fast8_t _a;
; 625  : 
; 626  : #if defined(_PEDANTIC) && !defined(NO_LOG)
; 627  : 		checkRpcHeader(&rpcRequestHeader, rpcRequestHeader.PacketType, &logger);
; 628  : #endif // defined(_PEDANTIC) && !defined(NO_LOG)
; 629  : 
; 630  : 		switch (rpcRequestHeader.PacketType)

  00053	8a 44 24 4a	 mov	 al, BYTE PTR rpcRequestHeader$[rsp+2]
  00057	84 c0		 test	 al, al
  00059	74 3a		 je	 SHORT $LN7@rpcServer
  0005b	3c 0b		 cmp	 al, 11
  0005d	74 1f		 je	 SHORT $LN6@rpcServer
  0005f	3c 0e		 cmp	 al, 14
  00061	0f 85 87 01 00
	00		 jne	 $LN26@rpcServer

; 634  : 		case RPC_PT_ALTERCONTEXT_REQ: _a = 2; break;

  00067	48 8d 35 38 00
	00 00		 lea	 rsi, OFFSET FLAT:_Actions+56
  0006e	4c 8d 35 40 00
	00 00		 lea	 r14, OFFSET FLAT:_Actions+64
  00075	48 8d 3d 30 00
	00 00		 lea	 rdi, OFFSET FLAT:_Actions+48
  0007c	eb 2c		 jmp	 SHORT $LN4@rpcServer
$LN6@rpcServer:

; 631  : 		{
; 632  : 		case RPC_PT_BIND_REQ:         _a = 0; break;

  0007e	48 8d 35 08 00
	00 00		 lea	 rsi, OFFSET FLAT:_Actions+8
  00085	4c 8d 35 10 00
	00 00		 lea	 r14, OFFSET FLAT:_Actions+16
  0008c	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Actions
  00093	eb 15		 jmp	 SHORT $LN4@rpcServer
$LN7@rpcServer:

; 633  : 		case RPC_PT_REQUEST:          _a = 1; break;

  00095	48 8d 35 20 00
	00 00		 lea	 rsi, OFFSET FLAT:_Actions+32
  0009c	4c 8d 35 28 00
	00 00		 lea	 r14, OFFSET FLAT:_Actions+40
  000a3	48 8d 3d 18 00
	00 00		 lea	 rdi, OFFSET FLAT:_Actions+24
$LN4@rpcServer:

; 635  : 		default: return;
; 636  : 		}
; 637  : 
; 638  : 		request_len = LE16(rpcRequestHeader.FragLength) - sizeof(rpcRequestHeader);

  000aa	0f b7 5c 24 50	 movzx	 ebx, WORD PTR rpcRequestHeader$[rsp+8]
  000af	83 eb 10	 sub	 ebx, 16

; 639  : 
; 640  : 		BYTE requestBuffer[MAX_REQUEST_SIZE + sizeof(RPC_RESPONSE64)];
; 641  : 		BYTE responseBuffer[MAX_RESPONSE_SIZE + sizeof(RPC_HEADER) + sizeof(RPC_RESPONSE64)];
; 642  : 
; 643  : 		RPC_HEADER *rpcResponseHeader = (RPC_HEADER *)responseBuffer;
; 644  : 		RPC_RESPONSE* rpcResponse = (RPC_RESPONSE*)(responseBuffer + sizeof(rpcRequestHeader));
; 645  : 
; 646  : 		// The request is larger than the buffer size
; 647  : 		if (request_len > MAX_REQUEST_SIZE + sizeof(RPC_REQUEST64)) return;

  000b2	81 fb 1c 01 00
	00		 cmp	 ebx, 284		; 0000011cH
  000b8	0f 87 30 01 00
	00		 ja	 $LN26@rpcServer

; 648  : 
; 649  : 		// Unable to receive the complete request
; 650  : 		if (!_recv(sock, requestBuffer, request_len)) return;

  000be	45 33 c9	 xor	 r9d, r9d
  000c1	48 8d 95 10 01
	00 00		 lea	 rdx, QWORD PTR requestBuffer$2[rbp-256]
  000c8	44 8b c3	 mov	 r8d, ebx
  000cb	49 8b cf	 mov	 rcx, r15
  000ce	e8 00 00 00 00	 call	 sendrecv
  000d3	84 c0		 test	 al, al
  000d5	0f 84 13 01 00
	00		 je	 $LN26@rpcServer

; 651  : 
; 652  : #       if !defined(SIMPLE_RPC) && defined(_PEDANTIC)
; 653  : 		if (rpcRequestHeader.PacketType == RPC_PT_REQUEST && (rpcRequestHeader.VersionMajor != 5 || rpcRequestHeader.VersionMinor != 0))
; 654  : 		{
; 655  : 			response_len = SendError((RPC_RESPONSE64*)rpcResponse, RPC_NCA_PROTO_ERROR);
; 656  : 		}
; 657  : 		else
; 658  : #		endif // !defined(SIMPLE_RPC) && defined(_PEDANTIC)
; 659  : 		{
; 660  : 			BYTE isValid = (BYTE)_Actions[_a].CheckRequest(requestBuffer, request_len, &NdrCtx, &Ndr64Ctx);

  000db	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000de	4c 8d 8d 88 02
	00 00		 lea	 r9, QWORD PTR Ndr64Ctx$[rbp-256]
  000e5	4c 8d 44 24 40	 lea	 r8, QWORD PTR NdrCtx$[rsp]
  000ea	8b d3		 mov	 edx, ebx
  000ec	48 8d 8d 10 01
	00 00		 lea	 rcx, QWORD PTR requestBuffer$2[rbp-256]
  000f3	ff d0		 call	 rax

; 661  : 			if (rpcRequestHeader.PacketType != RPC_PT_REQUEST && !isValid) return;

  000f5	0f b6 54 24 4a	 movzx	 edx, BYTE PTR rpcRequestHeader$[rsp+2]
  000fa	33 db		 xor	 ebx, ebx
  000fc	84 d2		 test	 dl, dl
  000fe	74 08		 je	 SHORT $LN12@rpcServer
  00100	84 c0		 test	 al, al
  00102	0f 84 e6 00 00
	00		 je	 $LN26@rpcServer
$LN12@rpcServer:

; 662  : 
; 663  : 			// Unable to create a valid response from request
; 664  : 			if (!((response_len = _Actions[_a].GetResponse(requestBuffer, rpcResponse, rpcAssocGroup, sock, &NdrCtx, &Ndr64Ctx, rpcRequestHeader.PacketType != RPC_PT_REQUEST ? rpcRequestHeader.PacketType : isValid, ipstr)))) return;

  00108	0f b6 c8	 movzx	 ecx, al
  0010b	84 d2		 test	 dl, dl
  0010d	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  00112	48 8d 85 88 02
	00 00		 lea	 rax, QWORD PTR Ndr64Ctx$[rbp-256]
  00119	0f 45 ca	 cmovne	 ecx, edx
  0011c	4d 8b cf	 mov	 r9, r15
  0011f	88 4c 24 30	 mov	 BYTE PTR [rsp+48], cl
  00123	48 8d 54 24 70	 lea	 rdx, QWORD PTR responseBuffer$1[rsp+16]
  00128	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0012d	48 8d 8d 10 01
	00 00		 lea	 rcx, QWORD PTR requestBuffer$2[rbp-256]
  00134	48 8d 44 24 40	 lea	 rax, QWORD PTR NdrCtx$[rsp]
  00139	45 8b c5	 mov	 r8d, r13d
  0013c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00141	41 ff 16	 call	 QWORD PTR [r14]
  00144	44 8b c0	 mov	 r8d, eax
  00147	85 c0		 test	 eax, eax
  00149	0f 84 9f 00 00
	00		 je	 $LN26@rpcServer

; 665  : 		}
; 666  : 
; 667  : 		memcpy(rpcResponseHeader, &rpcRequestHeader, sizeof(RPC_HEADER));

  0014f	0f 10 44 24 48	 movups	 xmm0, XMMWORD PTR rpcRequestHeader$[rsp]
  00154	f3 0f 7f 44 24
	60		 movdqu	 XMMWORD PTR responseBuffer$1[rsp], xmm0

; 668  : 
; 669  : #       ifndef SIMPLE_RPC
; 670  : 		if (response_len == 32)

  0015a	83 f8 20	 cmp	 eax, 32			; 00000020H
  0015d	75 2a		 jne	 SHORT $LN14@rpcServer

; 604  : 	header->CallId = LE32(CallId);

  0015f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR CallId
  00165	89 44 24 6c	 mov	 DWORD PTR responseBuffer$1[rsp+12], eax
  00169	66 c7 44 24 61
	00 03		 mov	 WORD PTR responseBuffer$1[rsp+1], 768 ; 00000300H
  00170	c6 44 24 60 05	 mov	 BYTE PTR responseBuffer$1[rsp], 5
  00175	66 89 5c 24 6a	 mov	 WORD PTR responseBuffer$1[rsp+10], bx
  0017a	c7 44 24 64 10
	00 00 00	 mov	 DWORD PTR responseBuffer$1[rsp+4], 16

; 671  : 		{
; 672  : 			createRpcHeader(rpcResponseHeader, RPC_PT_FAULT, 0);
; 673  : 			rpcResponseHeader->PacketFlags = RPC_PF_FIRST | RPC_PF_LAST | RPC_PF_NOT_EXEC;

  00182	c6 44 24 63 23	 mov	 BYTE PTR responseBuffer$1[rsp+3], 35 ; 00000023H

; 674  : 		}

  00187	eb 1d		 jmp	 SHORT $LN16@rpcServer
$LN14@rpcServer:

; 675  : 		else
; 676  : #		endif // SIMPLE_RPC
; 677  : 		{
; 678  : 			response_len += sizeof(RPC_HEADER);
; 679  : 			rpcResponseHeader->PacketType = _Actions[_a].ResponsePacketType;

  00189	8a 07		 mov	 al, BYTE PTR [rdi]
  0018b	41 83 c0 10	 add	 r8d, 16

; 680  : 
; 681  : 			if (rpcResponseHeader->PacketType == RPC_PT_ALTERCONTEXT_ACK)

  0018f	0f b6 4c 24 63	 movzx	 ecx, BYTE PTR responseBuffer$1[rsp+3]
  00194	3c 0f		 cmp	 al, 15
  00196	88 44 24 62	 mov	 BYTE PTR responseBuffer$1[rsp+2], al
  0019a	b8 03 00 00 00	 mov	 eax, 3
  0019f	0f 44 c8	 cmove	 ecx, eax
  001a2	88 4c 24 63	 mov	 BYTE PTR responseBuffer$1[rsp+3], cl
$LN16@rpcServer:

; 682  : 			{
; 683  : 				rpcResponseHeader->PacketFlags = RPC_PF_FIRST | RPC_PF_LAST;
; 684  : 			}
; 685  : 		}
; 686  : 
; 687  : 		rpcResponseHeader->FragLength = LE16((WORD)response_len);
; 688  : 
; 689  : 		if (!_send(sock, responseBuffer, response_len)) return;

  001a6	41 b1 01	 mov	 r9b, 1
  001a9	66 44 89 44 24
	68		 mov	 WORD PTR responseBuffer$1[rsp+8], r8w
  001af	48 8d 54 24 60	 lea	 rdx, QWORD PTR responseBuffer$1[rsp]
  001b4	49 8b cf	 mov	 rcx, r15
  001b7	e8 00 00 00 00	 call	 sendrecv
  001bc	84 c0		 test	 al, al
  001be	74 2e		 je	 SHORT $LN26@rpcServer

; 690  : 
; 691  : 		if (DisconnectImmediately && (rpcResponseHeader->PacketType == RPC_PT_RESPONSE || rpcResponseHeader->PacketType == RPC_PT_FAULT))

  001c0	38 1d 00 00 00
	00		 cmp	 BYTE PTR DisconnectImmediately, bl
  001c6	74 0a		 je	 SHORT $LN18@rpcServer
  001c8	8a 44 24 62	 mov	 al, BYTE PTR responseBuffer$1[rsp+2]
  001cc	2c 02		 sub	 al, 2
  001ce	3c 01		 cmp	 al, 1
  001d0	76 1c		 jbe	 SHORT $LN26@rpcServer
$LN18@rpcServer:

; 620  : 	while (_recv(sock, &rpcRequestHeader, sizeof(rpcRequestHeader)))

  001d2	45 33 c9	 xor	 r9d, r9d
  001d5	48 8d 54 24 48	 lea	 rdx, QWORD PTR rpcRequestHeader$[rsp]
  001da	49 8b cf	 mov	 rcx, r15
  001dd	45 8d 41 10	 lea	 r8d, QWORD PTR [r9+16]
  001e1	e8 00 00 00 00	 call	 sendrecv
  001e6	84 c0		 test	 al, al
  001e8	0f 85 65 fe ff
	ff		 jne	 $LL2@rpcServer
$LN26@rpcServer:

; 692  : 			return;
; 693  : 	}
; 694  : }

  001ee	4c 8d 9c 24 40
	03 00 00	 lea	 r11, QWORD PTR [rsp+832]
  001f6	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  001fa	49 8b 73 38	 mov	 rsi, QWORD PTR [r11+56]
  001fe	49 8b 7b 40	 mov	 rdi, QWORD PTR [r11+64]
  00202	49 8b e3	 mov	 rsp, r11
  00205	41 5f		 pop	 r15
  00207	41 5e		 pop	 r14
  00209	41 5d		 pop	 r13
  0020b	41 5c		 pop	 r12
  0020d	5d		 pop	 rbp
  0020e	c3		 ret	 0
rpcServer ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
;	COMDAT checkRpcRequestSize
_TEXT	SEGMENT
Request$ = 48
requestSize$ = 56
NdrCtx$ = 64
Ndr64Ctx$ = 72
checkRpcRequestSize PROC				; COMDAT

; 181  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 182  : 	WORD Ctx = LE16(Request->ContextId);
; 183  : 
; 184  : #	if defined(_PEDANTIC) && !defined(NO_LOG)
; 185  : 	CheckRpcRequest(Request, requestSize, NdrCtx, Ndr64Ctx, Ctx);
; 186  : #	endif // defined(_PEDANTIC) && !defined(NO_LOG)
; 187  : 
; 188  : 	// Anything that is smaller than a v4 request is illegal
; 189  : 	if (requestSize < sizeof(REQUEST_V4) + (Ctx != *Ndr64Ctx ? sizeof(RPC_REQUEST) : sizeof(RPC_REQUEST64))) return 0;

  00004	45 0f b7 11	 movzx	 r10d, WORD PTR [r9]
  00008	b8 0c 01 00 00	 mov	 eax, 268		; 0000010cH
  0000d	66 44 39 51 04	 cmp	 WORD PTR [rcx+4], r10w
  00012	44 8b da	 mov	 r11d, edx
  00015	44 8d 40 08	 lea	 r8d, QWORD PTR [rax+8]
  00019	44 0f 45 c0	 cmovne	 r8d, eax
  0001d	4d 3b d8	 cmp	 r11, r8
  00020	72 59		 jb	 SHORT $LN8@checkRpcRe

; 190  : 
; 191  : 	// Get KMS major version
; 192  : 	uint16_t majorIndex, minor;
; 193  : 	DWORD version;
; 194  : 
; 195  : #	ifndef SIMPLE_RPC
; 196  : 
; 197  : 	if (Ctx != *Ndr64Ctx)

  00022	66 44 39 51 04	 cmp	 WORD PTR [rcx+4], r10w
  00027	74 05		 je	 SHORT $LN3@checkRpcRe

; 198  : 	{
; 199  : 		version = LE32(*(DWORD*)Request->Ndr.Data);

  00029	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]

; 200  : 	}

  0002c	eb 03		 jmp	 SHORT $LN4@checkRpcRe
$LN3@checkRpcRe:

; 201  : 	else
; 202  : 	{
; 203  : 		version = LE32(*(DWORD*)Request->Ndr64.Data);

  0002e	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
$LN4@checkRpcRe:

; 204  : 	}
; 205  : 
; 206  : #	else // SIMPLE_RPC
; 207  : 
; 208  : 	version = LE32(*(DWORD*)Request->Ndr.Data);
; 209  : 
; 210  : #	endif // SIMPLE_RPC
; 211  : 
; 212  : 	majorIndex = (uint16_t)(version >> 16) - 4;

  00031	8b c8		 mov	 ecx, eax
  00033	41 b9 04 00 00
	00		 mov	 r9d, 4
  00039	c1 e9 10	 shr	 ecx, 16
  0003c	66 41 2b c9	 sub	 cx, r9w

; 213  : 	minor = (uint16_t)(version & 0xffff);
; 214  : 
; 215  : 	// Only KMS v4, v5 and v6 are supported
; 216  : 	if (majorIndex >= vlmcsd_countof(_Versions) || minor)

  00040	66 83 f9 03	 cmp	 cx, 3
  00044	73 1f		 jae	 SHORT $LN6@checkRpcRe
  00046	33 d2		 xor	 edx, edx
  00048	66 85 c0	 test	 ax, ax
  0004b	75 18		 jne	 SHORT $LN6@checkRpcRe

; 220  : #		endif // NO_LOG
; 221  : 		return 0;
; 222  : 	}
; 223  : 
; 224  : 	// Could check for equality but allow bigger requests to support buggy RPC clients (e.g. wine)
; 225  : 	// Buffer overrun is check by caller.
; 226  : 	return (requestSize >= _Versions[majorIndex].RequestSize);

  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Versions
  00054	0f b7 c9	 movzx	 ecx, cx
  00057	48 03 c9	 add	 rcx, rcx
  0005a	44 3b 1c c8	 cmp	 r11d, DWORD PTR [rax+rcx*8]
  0005e	0f 93 c2	 setae	 dl
  00061	8b c2		 mov	 eax, edx
  00063	eb 18		 jmp	 SHORT $LN1@checkRpcRe
$LN6@checkRpcRe:

; 217  : 	{
; 218  : #		ifndef NO_LOG
; 219  : 		logger("Fatal: KMSv%hu.%hu unsupported\n", (unsigned short)majorIndex + 4, (unsigned short)minor);

  00065	0f b7 d1	 movzx	 edx, cx
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@BBMKAOPO@Fatal?3?5KMSv?$CFhu?4?$CFhu?5unsupported?6@
  0006f	41 03 d1	 add	 edx, r9d
  00072	44 0f b7 c0	 movzx	 r8d, ax
  00076	e8 00 00 00 00	 call	 logger
$LN8@checkRpcRe:

; 227  : }

  0007b	33 c0		 xor	 eax, eax
$LN1@checkRpcRe:
  0007d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00081	c3		 ret	 0
checkRpcRequestSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
;	COMDAT SendError
_TEXT	SEGMENT
Response$ = 8
nca_error$dead$ = 16
SendError PROC						; COMDAT

; 232  : 	Response->Error.Code = nca_error;
; 233  : 	Response->Error.Padding = 0;

  00000	33 d2		 xor	 edx, edx
  00002	48 c7 41 08 03
	00 01 1c	 mov	 QWORD PTR [rcx+8], 469827587 ; 1c010003H

; 234  : 	Response->AllocHint = LE32(32);
; 235  : 	Response->ContextId = 0;

  0000a	66 89 51 04	 mov	 WORD PTR [rcx+4], dx
  0000e	8d 42 20	 lea	 eax, QWORD PTR [rdx+32]
  00011	89 01		 mov	 DWORD PTR [rcx], eax

; 236  : 	return 32;
; 237  : }

  00013	c3		 ret	 0
SendError ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
;	COMDAT rpcRequest
_TEXT	SEGMENT
Request$ = 80
Response$ = 88
RpcAssocGroup_unused$ = 96
sock_unused$ = 104
NdrCtx$ = 112
Ndr64Ctx$ = 120
isValid$ = 128
ipstr$ = 136
rpcRequest PROC						; COMDAT

; 248  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 249  : 	int ResponseSize; // <0 = Errorcode (HRESULT)
; 250  : 	BYTE* requestData;
; 251  : 	BYTE* responseData;
; 252  : 	BYTE* pRpcReturnCode;
; 253  : 	int len;
; 254  : 
; 255  : #	ifndef SIMPLE_RPC
; 256  : 
; 257  : 	const WORD Ctx = LE16(Request->ContextId);
; 258  : 
; 259  : 	if (Ctx == *NdrCtx)

  0001c	48 8b 44 24 70	 mov	 rax, QWORD PTR NdrCtx$[rsp]
  00021	48 8b fa	 mov	 rdi, rdx
  00024	44 0f b7 71 04	 movzx	 r14d, WORD PTR [rcx+4]
  00029	4c 8b e9	 mov	 r13, rcx
  0002c	4c 8b 7c 24 78	 mov	 r15, QWORD PTR Ndr64Ctx$[rsp]
  00031	bd 10 00 00 00	 mov	 ebp, 16
  00036	66 44 3b 30	 cmp	 r14w, WORD PTR [rax]
  0003a	75 07		 jne	 SHORT $LN2@rpcRequest

; 260  : 	{
; 261  : 		requestData = (BYTE*)&Request->Ndr.Data;
; 262  : 		responseData = (BYTE*)&Response->Ndr.Data;

  0003c	8b c5		 mov	 eax, ebp
  0003e	8d 55 04	 lea	 edx, QWORD PTR [rbp+4]

; 263  : 	}

  00041	eb 12		 jmp	 SHORT $LN5@rpcRequest
$LN2@rpcRequest:

; 264  : 	else if (Ctx == *Ndr64Ctx)

  00043	66 45 3b 37	 cmp	 r14w, WORD PTR [r15]
  00047	0f 85 dc 00 00
	00		 jne	 $LN4@rpcRequest

; 265  : 	{
; 266  : 		requestData = (BYTE*)&Request->Ndr64.Data;
; 267  : 		responseData = (BYTE*)&Response->Ndr64.Data;

  0004d	b8 18 00 00 00	 mov	 eax, 24
  00052	8d 50 08	 lea	 edx, QWORD PTR [rax+8]
$LN5@rpcRequest:

; 272  : 	}
; 273  : 
; 274  : #	else // SIMPLE_RPC
; 275  : 
; 276  : 	requestData = (BYTE*)&Request->Ndr.Data;
; 277  : 	responseData = (BYTE*)&Response->Ndr.Data;
; 278  : 
; 279  : #	endif // SIMPLE_RPC
; 280  : 
; 281  : 	ResponseSize = 0x8007000D; // Invalid Data
; 282  : 
; 283  : 	if (isValid)

  00055	33 f6		 xor	 esi, esi
  00057	48 03 c8	 add	 rcx, rax
  0005a	bb 0d 00 07 80	 mov	 ebx, -2147024883	; ffffffff8007000dH
  0005f	44 8d 66 04	 lea	 r12d, QWORD PTR [rsi+4]
  00063	40 38 b4 24 80
	00 00 00	 cmp	 BYTE PTR isValid$[rsp], sil
  0006b	74 2c		 je	 SHORT $LN7@rpcRequest

; 284  : 	{
; 285  : 		const uint16_t majorIndex = LE16(((WORD*)requestData)[1]) - 4;

  0006d	0f b7 41 02	 movzx	 eax, WORD PTR [rcx+2]
  00071	48 03 d7	 add	 rdx, rdi

; 286  : 		if (!((ResponseSize = _Versions[majorIndex].CreateResponse(requestData, responseData, ipstr)))) ResponseSize = 0x8007000D;

  00074	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR ipstr$[rsp]
  0007c	66 41 2b c4	 sub	 ax, r12w
  00080	44 0f b7 c8	 movzx	 r9d, ax
  00084	48 8d 05 08 00
	00 00		 lea	 rax, OFFSET FLAT:_Versions+8
  0008b	4d 03 c9	 add	 r9, r9
  0008e	42 ff 14 c8	 call	 QWORD PTR [rax+r9*8]
  00092	85 c0		 test	 eax, eax
  00094	0f 44 c3	 cmove	 eax, ebx
  00097	8b d8		 mov	 ebx, eax
$LN7@rpcRequest:

; 287  : 	}
; 288  : 
; 289  : #	ifndef SIMPLE_RPC
; 290  : 
; 291  : 	if (Ctx != *Ndr64Ctx)

  00099	66 45 3b 37	 cmp	 r14w, WORD PTR [r15]
  0009d	74 24		 je	 SHORT $LN8@rpcRequest

; 292  : 	{
; 293  : 
; 294  : #	endif // !SIMPLE_RPC
; 295  : 		if (ResponseSize < 0)

  0009f	85 db		 test	 ebx, ebx
  000a1	79 0b		 jns	 SHORT $LN10@rpcRequest

; 296  : 		{
; 297  : 			Response->Ndr.DataSizeMax = Response->Ndr.DataLength = 0;
; 298  : 			len = sizeof(Response->Ndr) - sizeof(Response->Ndr.DataSizeIs);

  000a3	bd 08 00 00 00	 mov	 ebp, 8
  000a8	8b c6		 mov	 eax, esi
  000aa	8b ce		 mov	 ecx, esi

; 299  : 		}

  000ac	eb 0d		 jmp	 SHORT $LN11@rpcRequest
$LN10@rpcRequest:

; 300  : 		else
; 301  : 		{
; 302  : 			Response->Ndr.DataSizeMax = LE32(0x00020000);
; 303  : 			Response->Ndr.DataLength = Response->Ndr.DataSizeIs = LE32(ResponseSize);

  000ae	89 5f 10	 mov	 DWORD PTR [rdi+16], ebx

; 304  : 			len = ResponseSize + sizeof(Response->Ndr);

  000b1	8d 6b 0c	 lea	 ebp, DWORD PTR [rbx+12]
  000b4	b8 00 00 02 00	 mov	 eax, 131072		; 00020000H
  000b9	8b cb		 mov	 ecx, ebx
$LN11@rpcRequest:

; 305  : 		}
; 306  : 
; 307  : #	ifndef SIMPLE_RPC
; 308  : 
; 309  : 	}

  000bb	89 4f 08	 mov	 DWORD PTR [rdi+8], ecx
  000be	89 47 0c	 mov	 DWORD PTR [rdi+12], eax
  000c1	eb 25		 jmp	 SHORT $LN13@rpcRequest
$LN8@rpcRequest:

; 310  : 	else
; 311  : 	{
; 312  : 		if (ResponseSize < 0)

  000c3	85 db		 test	 ebx, ebx
  000c5	79 0a		 jns	 SHORT $LN12@rpcRequest

; 313  : 		{
; 314  : 			Response->Ndr64.DataSizeMax = Response->Ndr64.DataLength = 0;

  000c7	48 89 77 08	 mov	 QWORD PTR [rdi+8], rsi
  000cb	48 89 77 10	 mov	 QWORD PTR [rdi+16], rsi

; 315  : 			len = sizeof(Response->Ndr64) - sizeof(Response->Ndr64.DataSizeIs);
; 316  : 		}

  000cf	eb 17		 jmp	 SHORT $LN13@rpcRequest
$LN12@rpcRequest:

; 317  : 		else
; 318  : 		{
; 319  : 			Response->Ndr64.DataSizeMax = LE64(0x00020000ULL);

  000d1	b8 00 00 02 00	 mov	 eax, 131072		; 00020000H

; 320  : 			Response->Ndr64.DataLength = Response->Ndr64.DataSizeIs = LE64((uint64_t)ResponseSize);
; 321  : 			len = ResponseSize + sizeof(Response->Ndr64);

  000d6	8d 6b 18	 lea	 ebp, DWORD PTR [rbx+24]
  000d9	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  000dd	48 63 c3	 movsxd	 rax, ebx
  000e0	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax
  000e4	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
$LN13@rpcRequest:

; 322  : 		}
; 323  : 	}
; 324  : 
; 325  : #	endif // !SIMPLE_RPC
; 326  : 
; 327  : 	pRpcReturnCode = ((BYTE*)&Response->Ndr) + len;

  000e8	48 63 cd	 movsxd	 rcx, ebp

; 328  : 	PUT_UA32LE(pRpcReturnCode, ResponseSize < 0 ? ResponseSize : 0);

  000eb	85 db		 test	 ebx, ebx
  000ed	8b c6		 mov	 eax, esi
  000ef	0f 48 c3	 cmovs	 eax, ebx

; 329  : 	len += sizeof(DWORD);

  000f2	41 03 ec	 add	 ebp, r12d

; 330  : 
; 331  : 	// Pad zeros to 32-bit align (seems not neccassary but Windows RPC does it this way)
; 332  : 	const int pad = ((~len & 3) + 1) & 3;
; 333  : 	memset(pRpcReturnCode + sizeof(DWORD), 0, pad);

  000f5	33 d2		 xor	 edx, edx
  000f7	89 44 39 08	 mov	 DWORD PTR [rcx+rdi+8], eax
  000fb	8b c5		 mov	 eax, ebp
  000fd	f7 d8		 neg	 eax
  000ff	48 83 c1 0c	 add	 rcx, 12
  00103	83 e0 03	 and	 eax, 3
  00106	48 03 cf	 add	 rcx, rdi
  00109	44 8b c0	 mov	 r8d, eax
  0010c	8b d8		 mov	 ebx, eax
  0010e	e8 00 00 00 00	 call	 memset

; 334  : 	len += pad;

  00113	03 eb		 add	 ebp, ebx

; 335  : 
; 336  : 	Response->AllocHint = LE32(len);

  00115	89 2f		 mov	 DWORD PTR [rdi], ebp

; 337  : 	Response->ContextId = Request->ContextId;

  00117	41 0f b7 45 04	 movzx	 eax, WORD PTR [r13+4]
  0011c	66 89 47 04	 mov	 WORD PTR [rdi+4], ax

; 338  : 
; 339  : 	*((WORD*)&Response->CancelCount) = 0; // CancelCount + Pad1
; 340  : 
; 341  : 	return len + 8;

  00120	8d 45 08	 lea	 eax, DWORD PTR [rbp+8]
  00123	66 89 77 06	 mov	 WORD PTR [rdi+6], si
  00127	eb 15		 jmp	 SHORT $LN1@rpcRequest
$LN4@rpcRequest:

; 233  : 	Response->Error.Padding = 0;

  00129	33 f6		 xor	 esi, esi
  0012b	48 c7 42 08 03
	00 01 1c	 mov	 QWORD PTR [rdx+8], 469827587 ; 1c010003H

; 234  : 	Response->AllocHint = LE32(32);
; 235  : 	Response->ContextId = 0;

  00133	66 89 77 04	 mov	 WORD PTR [rdi+4], si
  00137	8d 56 20	 lea	 edx, QWORD PTR [rsi+32]
  0013a	89 17		 mov	 DWORD PTR [rdi], edx

; 268  : 	}
; 269  : 	else
; 270  : 	{
; 271  : 		return SendError(Response, RPC_NCA_UNK_IF);

  0013c	8b c2		 mov	 eax, edx
$LN1@rpcRequest:

; 342  : }

  0013e	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00143	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00148	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0014d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00151	41 5f		 pop	 r15
  00153	41 5e		 pop	 r14
  00155	41 5d		 pop	 r13
  00157	41 5c		 pop	 r12
  00159	5f		 pop	 rdi
  0015a	c3		 ret	 0
rpcRequest ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
;	COMDAT checkRpcBindSize
_TEXT	SEGMENT
Request$ = 8
RequestSize$ = 16
NdrCtx_unused$ = 24
Ndr64Ctx_unused$ = 32
checkRpcBindSize PROC					; COMDAT

; 411  : 	if (RequestSize < sizeof(RPC_BIND_REQUEST)) return FALSE;

  00000	83 fa 38	 cmp	 edx, 56			; 00000038H
  00003	72 16		 jb	 SHORT $LN5@checkRpcBi

; 412  : 
; 413  : 	const unsigned int numCtxItems = LE32(Request->NumCtxItems);
; 414  : 
; 415  : 	if (RequestSize < sizeof(RPC_BIND_REQUEST) - sizeof(Request->CtxItems[0]) + numCtxItems * sizeof(Request->CtxItems[0])) return FALSE;

  00005	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00008	4c 6b c0 2c	 imul	 r8, rax, 44		; 0000002cH
  0000c	33 c0		 xor	 eax, eax
  0000e	8b ca		 mov	 ecx, edx
  00010	49 83 c0 0c	 add	 r8, 12
  00014	49 3b c8	 cmp	 rcx, r8
  00017	0f 93 c0	 setae	 al

; 416  : 
; 417  : #if defined(_PEDANTIC) && !defined(NO_LOG)
; 418  : 	CheckRpcBindRequest(Request, RequestSize);
; 419  : #endif // defined(_PEDANTIC) && !defined(NO_LOG)
; 420  : 
; 421  : 	return TRUE;
; 422  : }

  0001a	c3		 ret	 0
$LN5@checkRpcBi:

; 412  : 
; 413  : 	const unsigned int numCtxItems = LE32(Request->NumCtxItems);
; 414  : 
; 415  : 	if (RequestSize < sizeof(RPC_BIND_REQUEST) - sizeof(Request->CtxItems[0]) + numCtxItems * sizeof(Request->CtxItems[0])) return FALSE;

  0001b	33 c0		 xor	 eax, eax

; 416  : 
; 417  : #if defined(_PEDANTIC) && !defined(NO_LOG)
; 418  : 	CheckRpcBindRequest(Request, RequestSize);
; 419  : #endif // defined(_PEDANTIC) && !defined(NO_LOG)
; 420  : 
; 421  : 	return TRUE;
; 422  : }

  0001d	c3		 ret	 0
checkRpcBindSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
;	COMDAT rpcBind
_TEXT	SEGMENT
addr$ = 64
Request$ = 240
Response$ = 248
socklen$ = 256
RpcAssocGroup$ = 256
sock$ = 264
NdrCtx$ = 272
Ndr64Ctx$ = 280
packetType$ = 288
ipstr_unused$ = 296
rpcBind	PROC						; COMDAT

; 433  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H

; 434  : 	unsigned int i;
; 435  : 	const DWORD numCtxItems = LE32(Request->NumCtxItems);

  0001f	44 8b 71 08	 mov	 r14d, DWORD PTR [rcx+8]

; 436  : 	int_fast8_t IsNDR64possible = FALSE;

  00023	45 33 e4	 xor	 r12d, r12d

; 437  : 	uint_fast8_t portNumberSize;
; 438  : 
; 439  : 	socklen_t socklen;
; 440  : 	struct sockaddr_storage addr;
; 441  : 
; 442  : 	// M$ RPC does not do this. Pad bytes contain apparently random data
; 443  : 	// memset(Response->SecondaryAddress, 0, sizeof(Response->SecondaryAddress));
; 444  : 
; 445  : 	socklen = sizeof addr;
; 446  : 
; 447  : 	if (
; 448  : 		packetType == RPC_PT_ALTERCONTEXT_REQ ||
; 449  : 		getsockname(sock, (struct sockaddr*)&addr, &socklen) ||

  00026	80 bc 24 20 01
	00 00 0e	 cmp	 BYTE PTR packetType$[rsp], 14
  0002e	41 8b e8	 mov	 ebp, r8d
  00031	48 8b da	 mov	 rbx, rdx
  00034	c7 40 18 80 00
	00 00		 mov	 DWORD PTR [rax+24], 128	; 00000080H
  0003b	48 8b f1	 mov	 rsi, rcx
  0003e	45 8a fc	 mov	 r15b, r12b
  00041	45 8d 6c 24 01	 lea	 r13d, QWORD PTR [r12+1]
  00046	74 61		 je	 SHORT $LN10@rpcBind
  00048	4c 8d 40 18	 lea	 r8, QWORD PTR [rax+24]
  0004c	49 8b c9	 mov	 rcx, r9
  0004f	48 8d 54 24 40	 lea	 rdx, QWORD PTR addr$[rsp]
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getsockname
  0005a	85 c0		 test	 eax, eax
  0005c	75 4b		 jne	 SHORT $LN10@rpcBind
  0005e	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR socklen$[rsp]
  00065	48 8d 7b 0a	 lea	 rdi, QWORD PTR [rbx+10]
  00069	c7 44 24 30 08
	00 00 00	 mov	 DWORD PTR [rsp+48], 8
  00071	48 8d 4c 24 40	 lea	 rcx, QWORD PTR addr$[rsp]
  00076	c7 44 24 28 06
	00 00 00	 mov	 DWORD PTR [rsp+40], 6
  0007e	45 33 c9	 xor	 r9d, r9d
  00081	45 33 c0	 xor	 r8d, r8d
  00084	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getnameinfo
  0008f	85 c0		 test	 eax, eax
  00091	75 16		 jne	 SHORT $LN10@rpcBind

; 454  : 	}
; 455  : 	else
; 456  : 	{
; 457  : 		portNumberSize = (uint_fast8_t)strlen((char*)Response->SecondaryAddress) + 1;

  00093	49 83 c9 ff	 or	 r9, -1
$LL33@rpcBind:
  00097	49 ff c1	 inc	 r9
  0009a	46 38 24 0f	 cmp	 BYTE PTR [rdi+r9], r12b
  0009e	75 f7		 jne	 SHORT $LL33@rpcBind
  000a0	45 02 cd	 add	 r9b, r13b

; 458  : 		Response->SecondaryAddressLength = LE16(portNumberSize);

  000a3	41 0f b6 c1	 movzx	 eax, r9b
  000a7	eb 06		 jmp	 SHORT $LN9@rpcBind
$LN10@rpcBind:

; 450  : 		getnameinfo((struct sockaddr*)&addr, socklen, NULL, 0, (char*)Response->SecondaryAddress, sizeof(Response->SecondaryAddress), NI_NUMERICSERV))
; 451  : 	{
; 452  : 		portNumberSize = 0;

  000a9	45 8a cc	 mov	 r9b, r12b

; 453  : 		Response->SecondaryAddressLength = 0;

  000ac	41 8b c4	 mov	 eax, r12d
$LN9@rpcBind:

; 459  : 	}
; 460  : 
; 461  : 	Response->MaxXmitFrag = Request->MaxXmitFrag;

  000af	66 89 43 08	 mov	 WORD PTR [rbx+8], ax

; 462  : 	Response->MaxRecvFrag = Request->MaxRecvFrag;
; 463  : 	Response->AssocGroup = LE32(RpcAssocGroup);
; 464  : 
; 465  : 	// This is really ugly (but efficient) code to support padding after the secondary address field
; 466  : 	if (portNumberSize < 3)
; 467  : 	{
; 468  : 		Response = (RPC_BIND_RESPONSE*)((BYTE*)Response - 4);
; 469  : 	}
; 470  : 
; 471  : 	Response->NumResults = Request->NumCtxItems;

  000b3	4c 8d 53 fc	 lea	 r10, QWORD PTR [rbx-4]
  000b7	0f b7 06	 movzx	 eax, WORD PTR [rsi]
  000ba	bf 03 00 00 00	 mov	 edi, 3
  000bf	66 89 03	 mov	 WORD PTR [rbx], ax
  000c2	44 3a cf	 cmp	 r9b, dil
  000c5	0f b7 46 02	 movzx	 eax, WORD PTR [rsi+2]
  000c9	4c 0f 43 d3	 cmovae	 r10, rbx
  000cd	66 89 43 02	 mov	 WORD PTR [rbx+2], ax
  000d1	89 6b 04	 mov	 DWORD PTR [rbx+4], ebp
  000d4	8b 46 08	 mov	 eax, DWORD PTR [rsi+8]
  000d7	41 89 42 10	 mov	 DWORD PTR [r10+16], eax

; 472  : 
; 473  : #	ifndef SIMPLE_RPC
; 474  : 
; 475  : 	for (i = 0; i < numCtxItems; i++)

  000db	45 85 f6	 test	 r14d, r14d
  000de	0f 84 7e 01 00
	00		 je	 $LN6@rpcBind
  000e4	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR Ndr64Ctx$[rsp]
  000ec	48 8d 4e 0c	 lea	 rcx, QWORD PTR [rsi+12]
  000f0	4c 8b 9c 24 10
	01 00 00	 mov	 r11, QWORD PTR NdrCtx$[rsp]
  000f8	49 8b de	 mov	 rbx, r14
  000fb	49 8b d6	 mov	 rdx, r14
$LL4@rpcBind:

; 476  : 	{
; 477  : 		const struct CtxItem* ctxItem = &Request->CtxItems[i];
; 478  : 		if (IsEqualGUID((GUID*)TransferSyntaxNDR32, &ctxItem->TransferSyntax))

  000fe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR TransferSyntaxNDR32
  00105	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]
  00109	75 14		 jne	 SHORT $LN12@rpcBind
  0010b	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR TransferSyntaxNDR32+8
  00112	48 3b 41 20	 cmp	 rax, QWORD PTR [rcx+32]
  00116	75 07		 jne	 SHORT $LN12@rpcBind

; 479  : 		{
; 480  : 			/*if (packetType == RPC_PT_BIND_REQ)*/
; 481  : 			*NdrCtx = LE16(ctxItem->ContextId);

  00118	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  0011b	66 41 89 03	 mov	 WORD PTR [r11], ax
$LN12@rpcBind:

; 482  : 		}
; 483  : 
; 484  : 		if (UseServerRpcNDR64 && IsEqualGUID((GUID*)TransferSyntaxNDR64, &ctxItem->TransferSyntax))

  0011f	44 38 25 00 00
	00 00		 cmp	 BYTE PTR UseServerRpcNDR64, r12b
  00126	74 24		 je	 SHORT $LN2@rpcBind
  00128	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR TransferSyntaxNDR64
  0012f	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]
  00133	75 17		 jne	 SHORT $LN2@rpcBind
  00135	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR TransferSyntaxNDR64+8
  0013c	48 3b 41 20	 cmp	 rax, QWORD PTR [rcx+32]
  00140	75 0a		 jne	 SHORT $LN2@rpcBind

; 485  : 		{
; 486  : 			IsNDR64possible = TRUE;
; 487  : 
; 488  : 			/*if (packetType == RPC_PT_BIND_REQ)*/
; 489  : 			*Ndr64Ctx = LE16(ctxItem->ContextId);

  00142	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00145	45 8a fd	 mov	 r15b, r13b
  00148	66 41 89 00	 mov	 WORD PTR [r8], ax
$LN2@rpcBind:

; 472  : 
; 473  : #	ifndef SIMPLE_RPC
; 474  : 
; 475  : 	for (i = 0; i < numCtxItems; i++)

  0014c	48 83 c1 2c	 add	 rcx, 44			; 0000002cH
  00150	49 2b d5	 sub	 rdx, r13
  00153	75 a9		 jne	 SHORT $LL4@rpcBind
  00155	4c 8d 46 24	 lea	 r8, QWORD PTR [rsi+36]
  00159	48 83 c6 10	 add	 rsi, 16
  0015d	49 8d 4a 28	 lea	 rcx, QWORD PTR [r10+40]
  00161	44 8d 5a 02	 lea	 r11d, QWORD PTR [rdx+2]
$LL7@rpcBind:
  00165	0f 57 c0	 xorps	 xmm0, xmm0

; 496  : 	{
; 497  : 		struct CtxResults* result = Response->Results + i;
; 498  : 		const GUID* ctxTransferSyntax = &Request->CtxItems[i].TransferSyntax;
; 499  : 
; 500  : #		ifndef SIMPLE_RPC
; 501  : 		WORD nackReason = RPC_ABSTRACTSYNTAX_UNSUPPORTED;
; 502  : #		endif // !SIMPLE_RPC
; 503  : 
; 504  : 		memset(&result->TransferSyntax, 0, sizeof(GUID));

  00168	0f 11 41 f0	 movups	 XMMWORD PTR [rcx-16], xmm0

; 505  : 
; 506  : #		ifndef SIMPLE_RPC
; 507  : 		const int isInterfaceUUID = IsEqualGUID(&Request->CtxItems[i].InterfaceUUID, (GUID*)InterfaceUuid);

  0016c	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0016f	48 2b 05 00 00
	00 00		 sub	 rax, QWORD PTR InterfaceUuid
  00176	75 0b		 jne	 SHORT $LN32@rpcBind
  00178	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  0017c	48 2b 05 08 00
	00 00		 sub	 rax, QWORD PTR InterfaceUuid+8
$LN32@rpcBind:
  00183	48 85 c0	 test	 rax, rax
  00186	45 8b d4	 mov	 r10d, r12d
  00189	41 0f 94 c2	 sete	 r10b

; 508  : 		if (isInterfaceUUID) nackReason = RPC_SYNTAX_UNSUPPORTED;
; 509  : #		else // SIMPLE_RPC
; 510  : #		define isInterfaceUUID TRUE
; 511  : #		endif // SIMPLE_RPC
; 512  : 
; 513  : 		if (isInterfaceUUID && !IsNDR64possible && IsEqualGUID((GUID*)TransferSyntaxNDR32, ctxTransferSyntax))

  0018d	41 8b c2	 mov	 eax, r10d
  00190	f7 d8		 neg	 eax
  00192	66 1b d2	 sbb	 dx, dx
  00195	66 f7 da	 neg	 dx
  00198	66 41 03 d5	 add	 dx, r13w
  0019c	45 85 d2	 test	 r10d, r10d
  0019f	74 33		 je	 SHORT $LN15@rpcBind
  001a1	45 84 ff	 test	 r15b, r15b
  001a4	75 2e		 jne	 SHORT $LN15@rpcBind
  001a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR TransferSyntaxNDR32
  001ad	49 3b 00	 cmp	 rax, QWORD PTR [r8]
  001b0	75 22		 jne	 SHORT $LN15@rpcBind
  001b2	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR TransferSyntaxNDR32+8
  001b9	49 3b 40 08	 cmp	 rax, QWORD PTR [r8+8]
  001bd	75 15		 jne	 SHORT $LN15@rpcBind

; 514  : 		{
; 515  : 			result->SyntaxVersion = LE32(2);

  001bf	44 89 19	 mov	 DWORD PTR [rcx], r11d

; 516  : 			result->AckResult = result->AckReason = RPC_BIND_ACCEPT;

  001c2	44 89 61 ec	 mov	 DWORD PTR [rcx-20], r12d

; 517  : 			memcpy(&result->TransferSyntax, TransferSyntaxNDR32, sizeof(GUID));

  001c6	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR TransferSyntaxNDR32
$LN34@rpcBind:

; 490  : 		}
; 491  : 	}
; 492  : 
; 493  : #	endif // !SIMPLE_RPC
; 494  : 
; 495  : 	for (i = 0; i < numCtxItems; i++)

  001cd	f3 0f 7f 41 f0	 movdqu	 XMMWORD PTR [rcx-16], xmm0
  001d2	eb 79		 jmp	 SHORT $LN5@rpcBind
$LN15@rpcBind:

; 518  : 			continue;
; 519  : 		}
; 520  : 
; 521  : #		ifndef SIMPLE_RPC
; 522  : 
; 523  : 		if (IsEqualGUID((GUID*)TransferSyntaxNDR64, ctxTransferSyntax))

  001d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR TransferSyntaxNDR64
  001db	49 3b 00	 cmp	 rax, QWORD PTR [r8]
  001de	75 33		 jne	 SHORT $LN18@rpcBind
  001e0	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR TransferSyntaxNDR64+8
  001e7	49 3b 40 08	 cmp	 rax, QWORD PTR [r8+8]
  001eb	75 26		 jne	 SHORT $LN18@rpcBind

; 524  : 		{
; 525  : 			if (!UseServerRpcNDR64) nackReason = RPC_SYNTAX_UNSUPPORTED;

  001ed	44 38 25 00 00
	00 00		 cmp	 BYTE PTR UseServerRpcNDR64, r12b
  001f4	75 03		 jne	 SHORT $LN17@rpcBind
  001f6	41 8b d3	 mov	 edx, r11d
$LN17@rpcBind:

; 526  : 
; 527  : 			if (isInterfaceUUID && IsNDR64possible)

  001f9	45 85 d2	 test	 r10d, r10d
  001fc	74 15		 je	 SHORT $LN18@rpcBind
  001fe	45 84 ff	 test	 r15b, r15b
  00201	74 10		 je	 SHORT $LN18@rpcBind

; 528  : 			{
; 529  : 				result->SyntaxVersion = LE32(1);

  00203	44 89 29	 mov	 DWORD PTR [rcx], r13d

; 530  : 				result->AckResult = result->AckReason = RPC_BIND_ACCEPT;

  00206	44 89 61 ec	 mov	 DWORD PTR [rcx-20], r12d

; 531  : 				memcpy(&result->TransferSyntax, TransferSyntaxNDR64, sizeof(GUID));

  0020a	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR TransferSyntaxNDR64

; 532  : 				continue;

  00211	eb ba		 jmp	 SHORT $LN34@rpcBind
$LN18@rpcBind:

; 533  : 			}
; 534  : 		}
; 535  : 
; 536  : 		if (!memcmp(BindTimeFeatureNegotiation, ctxTransferSyntax, 8))

  00213	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BindTimeFeatureNegotiation
  0021a	49 3b 00	 cmp	 rax, QWORD PTR [r8]
  0021d	75 22		 jne	 SHORT $LN20@rpcBind

; 537  : 		{
; 538  : 			nackReason = RPC_SYNTAX_UNSUPPORTED;
; 539  : 
; 540  : 			if (UseServerRpcBTFN)

  0021f	44 38 25 00 00
	00 00		 cmp	 BYTE PTR UseServerRpcBTFN, r12b
  00226	41 0f b7 d3	 movzx	 edx, r11w
  0022a	74 15		 je	 SHORT $LN20@rpcBind

; 541  : 			{
; 542  : 				result->SyntaxVersion = 0;

  0022c	44 89 21	 mov	 DWORD PTR [rcx], r12d

; 543  : 				result->AckResult = RPC_BIND_ACK;

  0022f	66 89 79 ec	 mov	 WORD PTR [rcx-20], di

; 544  : 
; 545  : 				// Features requested are actually encoded in the GUID
; 546  : 				result->AckReason =

  00233	41 0f b7 40 08	 movzx	 eax, WORD PTR [r8+8]
  00238	66 23 c7	 and	 ax, di
  0023b	66 89 41 ee	 mov	 WORD PTR [rcx-18], ax

; 547  : 					((WORD*)(ctxTransferSyntax))[4] &
; 548  : 					(RPC_BTFN_SEC_CONTEXT_MULTIPLEX | RPC_BTFN_KEEP_ORPHAN);
; 549  : 
; 550  : 				continue;

  0023f	eb 0c		 jmp	 SHORT $LN5@rpcBind
$LN20@rpcBind:

; 551  : 			}
; 552  : 		}
; 553  : 
; 554  : #		endif // !SIMPLE_RPC
; 555  : 
; 556  : 		result->SyntaxVersion = 0;

  00241	44 89 21	 mov	 DWORD PTR [rcx], r12d

; 557  : 		result->AckResult = RPC_BIND_NACK;

  00244	66 44 89 59 ec	 mov	 WORD PTR [rcx-20], r11w

; 558  : #		ifndef SIMPLE_RPC
; 559  : 		result->AckReason = nackReason;

  00249	66 89 51 ee	 mov	 WORD PTR [rcx-18], dx
$LN5@rpcBind:

; 490  : 		}
; 491  : 	}
; 492  : 
; 493  : #	endif // !SIMPLE_RPC
; 494  : 
; 495  : 	for (i = 0; i < numCtxItems; i++)

  0024d	48 83 c6 2c	 add	 rsi, 44			; 0000002cH
  00251	48 83 c1 18	 add	 rcx, 24
  00255	49 83 c0 2c	 add	 r8, 44			; 0000002cH
  00259	49 2b dd	 sub	 rbx, r13
  0025c	0f 85 03 ff ff
	ff		 jne	 $LL7@rpcBind
$LN6@rpcBind:

; 560  : #		else // SIMPLE_RPC
; 561  : #		undef isInterfaceUUID
; 562  : 		result->AckReason = RPC_SYNTAX_UNSUPPORTED;
; 563  : #		endif // SIMPLE_RPC
; 564  : 	}
; 565  : 
; 566  : 	//if (!_st) return 0;
; 567  : 
; 568  : 	return sizeof(RPC_BIND_RESPONSE) + numCtxItems * sizeof(struct CtxResults) - (portNumberSize < 3 ? 4 : 0);
; 569  : }

  00262	4c 8d 9c 24 c0
	00 00 00	 lea	 r11, QWORD PTR [rsp+192]
  0026a	44 3a cf	 cmp	 r9b, dil
  0026d	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  00271	43 8d 04 76	 lea	 eax, DWORD PTR [r14+r14*2]
  00275	49 8b 6b 38	 mov	 rbp, QWORD PTR [r11+56]
  00279	1b c9		 sbb	 ecx, ecx
  0027b	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  0027f	83 e1 04	 and	 ecx, 4
  00282	c1 e0 03	 shl	 eax, 3
  00285	2b c1		 sub	 eax, ecx
  00287	83 c0 14	 add	 eax, 20
  0028a	49 8b e3	 mov	 rsp, r11
  0028d	41 5f		 pop	 r15
  0028f	41 5e		 pop	 r14
  00291	41 5d		 pop	 r13
  00293	41 5c		 pop	 r12
  00295	5f		 pop	 rdi
  00296	c3		 ret	 0
rpcBind	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
;	COMDAT createRpcHeader
_TEXT	SEGMENT
header$ = 8
packetType$ = 16
size$ = 24
createRpcHeader PROC					; COMDAT

; 598  : 	header->PacketType = packetType;
; 599  : 	header->PacketFlags = RPC_PF_FIRST | RPC_PF_LAST;
; 600  : 	header->VersionMajor = 5;
; 601  : 	header->VersionMinor = 0;

  00000	33 c0		 xor	 eax, eax
  00002	88 51 02	 mov	 BYTE PTR [rcx+2], dl

; 602  : 	header->AuthLength = 0;

  00005	66 89 41 0a	 mov	 WORD PTR [rcx+10], ax

; 603  : 	header->DataRepresentation = BE32(0x10000000); // Little endian, ASCII charset, IEEE floating point
; 604  : 	header->CallId = LE32(CallId);

  00009	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR CallId
  0000f	89 41 0c	 mov	 DWORD PTR [rcx+12], eax
  00012	c6 41 03 03	 mov	 BYTE PTR [rcx+3], 3
  00016	66 c7 01 05 00	 mov	 WORD PTR [rcx], 5
  0001b	c7 41 04 10 00
	00 00		 mov	 DWORD PTR [rcx+4], 16

; 605  : 	header->FragLength = LE16(size);

  00022	66 44 89 41 08	 mov	 WORD PTR [rcx+8], r8w

; 606  : }

  00027	c3		 ret	 0
createRpcHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
;	COMDAT checkRpcHeader
_TEXT	SEGMENT
header$ = 48
desiredPacketType$ = 56
p$dead$ = 64
checkRpcHeader PROC					; COMDAT

; 705  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 706  : 	int status = 0;

  00014	33 ed		 xor	 ebp, ebp
  00016	48 8b d9	 mov	 rbx, rcx
  00019	8b fd		 mov	 edi, ebp

; 707  : 
; 708  : 	if (header->PacketType != desiredPacketType)

  0001b	be c0 06 00 00	 mov	 esi, 1728		; 000006c0H
  00020	38 51 02	 cmp	 BYTE PTR [rcx+2], dl
  00023	74 16		 je	 SHORT $LN2@checkRpcHe

; 709  : 	{
; 710  : 		p("Fatal: Received wrong RPC packet type. Expected %u but got %u\n",

  00025	44 0f b6 41 02	 movzx	 r8d, BYTE PTR [rcx+2]
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DP@CJEHLGPD@Fatal?3?5Received?5wrong?5RPC?5packe@
  00031	0f b6 d2	 movzx	 edx, dl
  00034	e8 00 00 00 00	 call	 printerrorf

; 711  : 			(uint32_t)desiredPacketType,
; 712  : 			header->PacketType
; 713  : 		);
; 714  : 		status = RPC_S_PROTOCOL_ERROR;

  00039	8b fe		 mov	 edi, esi
$LN2@checkRpcHe:

; 715  : 	}
; 716  : 
; 717  : 	if (header->DataRepresentation != BE32(0x10000000))

  0003b	83 7b 04 10	 cmp	 DWORD PTR [rbx+4], 16
  0003f	74 0e		 je	 SHORT $LN3@checkRpcHe

; 718  : 	{
; 719  : 		p("Fatal: RPC response does not conform to Microsoft's limited support of DCE RPC\n");

  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0FA@EFGNKFML@Fatal?3?5RPC?5response?5does?5not?5co@
  00048	e8 00 00 00 00	 call	 printerrorf

; 720  : 		status = RPC_S_PROTOCOL_ERROR;

  0004d	8b fe		 mov	 edi, esi
$LN3@checkRpcHe:

; 721  : 	}
; 722  : 
; 723  : 	if (header->AuthLength != 0)

  0004f	66 39 6b 0a	 cmp	 WORD PTR [rbx+10], bp
  00053	74 11		 je	 SHORT $LN4@checkRpcHe

; 724  : 	{
; 725  : 		p("Fatal: RPC response requests authentication\n");

  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CN@JIFMCEFK@Fatal?3?5RPC?5response?5requests?5au@
  0005c	e8 00 00 00 00	 call	 printerrorf

; 726  : 		status = RPC_S_UNKNOWN_AUTHN_TYPE;

  00061	bf cd 06 00 00	 mov	 edi, 1741		; 000006cdH
$LN4@checkRpcHe:

; 727  : 	}
; 728  : 
; 729  : 	// vlmcsd does not support fragmented packets (not yet neccassary)
; 730  : 	if ((header->PacketFlags & (RPC_PF_FIRST | RPC_PF_LAST)) != (RPC_PF_FIRST | RPC_PF_LAST))

  00066	8a 43 03	 mov	 al, BYTE PTR [rbx+3]
  00069	24 03		 and	 al, 3
  0006b	3c 03		 cmp	 al, 3
  0006d	74 11		 je	 SHORT $LN5@checkRpcHe

; 731  : 	{
; 732  : 		p("Fatal: RPC packet flags RPC_PF_FIRST and RPC_PF_LAST are not both set.\n");

  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EI@BKAOLKDE@Fatal?3?5RPC?5packet?5flags?5RPC_PF_@
  00076	e8 00 00 00 00	 call	 printerrorf

; 733  : 		status = RPC_S_CANNOT_SUPPORT;

  0007b	bf e4 06 00 00	 mov	 edi, 1764		; 000006e4H
$LN5@checkRpcHe:

; 734  : 	}
; 735  : 
; 736  : 	if (header->PacketFlags & RPC_PF_CANCEL_PENDING)	p("Warning: %s should not be set\n", "RPC_PF_CANCEL_PENDING");

  00080	f6 43 03 04	 test	 BYTE PTR [rbx+3], 4
  00084	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:??_C@_0BP@EPFAGCLK@Warning?3?5?$CFs?5should?5not?5be?5set?6@
  0008b	74 0f		 je	 SHORT $LN6@checkRpcHe
  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@HLJBDNGA@RPC_PF_CANCEL_PENDING@
  00094	48 8b ce	 mov	 rcx, rsi
  00097	e8 00 00 00 00	 call	 printerrorf
$LN6@checkRpcHe:

; 737  : 	if (header->PacketFlags & RPC_PF_RESERVED)			p("Warning: %s should not be set\n", "RPC_PF_RESERVED");

  0009c	f6 43 03 08	 test	 BYTE PTR [rbx+3], 8
  000a0	74 0f		 je	 SHORT $LN7@checkRpcHe
  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@LFBPBNOH@RPC_PF_RESERVED@
  000a9	48 8b ce	 mov	 rcx, rsi
  000ac	e8 00 00 00 00	 call	 printerrorf
$LN7@checkRpcHe:

; 738  : 	if (header->PacketFlags & RPC_PF_NOT_EXEC)			p("Warning: %s should not be set\n", "RPC_PF_NOT_EXEC");

  000b1	f6 43 03 20	 test	 BYTE PTR [rbx+3], 32	; 00000020H
  000b5	74 0f		 je	 SHORT $LN8@checkRpcHe
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@HEJPAFFP@RPC_PF_NOT_EXEC@
  000be	48 8b ce	 mov	 rcx, rsi
  000c1	e8 00 00 00 00	 call	 printerrorf
$LN8@checkRpcHe:

; 739  : 	if (header->PacketFlags & RPC_PF_MAYBE)				p("Warning: %s should not be set\n", "RPC_PF_MAYBE");

  000c6	f6 43 03 40	 test	 BYTE PTR [rbx+3], 64	; 00000040H
  000ca	74 0f		 je	 SHORT $LN9@checkRpcHe
  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@HEOOBKKP@RPC_PF_MAYBE@
  000d3	48 8b ce	 mov	 rcx, rsi
  000d6	e8 00 00 00 00	 call	 printerrorf
$LN9@checkRpcHe:

; 740  : 	if (header->PacketFlags & RPC_PF_OBJECT)			p("Warning: %s should not be set\n", "RPC_PF_OBJECT");

  000db	40 38 6b 03	 cmp	 BYTE PTR [rbx+3], bpl
  000df	7d 0f		 jge	 SHORT $LN10@checkRpcHe
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@DHNLACON@RPC_PF_OBJECT@
  000e8	48 8b ce	 mov	 rcx, rsi
  000eb	e8 00 00 00 00	 call	 printerrorf
$LN10@checkRpcHe:

; 741  : 
; 742  : 	if (header->VersionMajor != 5 || header->VersionMinor != 0)

  000f0	80 3b 05	 cmp	 BYTE PTR [rbx], 5
  000f3	75 06		 jne	 SHORT $LN14@checkRpcHe
  000f5	40 38 6b 01	 cmp	 BYTE PTR [rbx+1], bpl
  000f9	74 19		 je	 SHORT $LN11@checkRpcHe
$LN14@checkRpcHe:

; 743  : 	{
; 744  : 		p("Fatal: Expected RPC version 5.0 and got %u.%u\n", header->VersionMajor, header->VersionMinor);

  000fb	44 0f b6 43 01	 movzx	 r8d, BYTE PTR [rbx+1]
  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CP@HOOBBENO@Fatal?3?5Expected?5RPC?5version?55?40@
  00107	0f b6 13	 movzx	 edx, BYTE PTR [rbx]
  0010a	e8 00 00 00 00	 call	 printerrorf

; 745  : 		status = RPC_S_INVALID_VERS_OPTION;

  0010f	bf dc 06 00 00	 mov	 edi, 1756		; 000006dcH
$LN11@checkRpcHe:

; 746  : 	}
; 747  : 
; 748  : 	return status;
; 749  : }

  00114	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00119	8b c7		 mov	 eax, edi
  0011b	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00120	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00125	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00129	5f		 pop	 rdi
  0012a	c3		 ret	 0
checkRpcHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
;	COMDAT checkRpcResponseHeader
_TEXT	SEGMENT
ResponseHeader$ = 48
RequestHeader$ = 56
desiredPacketType$ = 64
p$dead$ = 72
checkRpcResponseHeader PROC				; COMDAT

; 760  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b ea	 mov	 rbp, rdx
  00017	41 8a d8	 mov	 bl, r8b

; 761  : 	static int_fast8_t WineBugDetected = FALSE;
; 762  : 	int status = checkRpcHeader(ResponseHeader, desiredPacketType, p);

  0001a	41 8a d0	 mov	 dl, r8b
  0001d	48 8b f1	 mov	 rsi, rcx
  00020	e8 00 00 00 00	 call	 checkRpcHeader
  00025	8b f8		 mov	 edi, eax
  00027	8a 46 03	 mov	 al, BYTE PTR [rsi+3]
  0002a	24 10		 and	 al, 16

; 763  : 
; 764  : 	if (desiredPacketType == RPC_PT_BIND_ACK)

  0002c	80 fb 0c	 cmp	 bl, 12
  0002f	75 18		 jne	 SHORT $LN2@checkRpcRe

; 765  : 	{
; 766  : 		if ((ResponseHeader->PacketFlags & RPC_PF_MULTIPLEX) != (RequestHeader->PacketFlags & RPC_PF_MULTIPLEX))

  00031	8a 4d 03	 mov	 cl, BYTE PTR [rbp+3]
  00034	80 e1 10	 and	 cl, 16
  00037	3a c1		 cmp	 al, cl
  00039	74 25		 je	 SHORT $LN5@checkRpcRe

; 767  : 		{
; 768  : 			p("Warning: RPC_PF_MULTIPLEX of RPC request and response should match\n");

  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EE@GLJICDBO@Warning?3?5RPC_PF_MULTIPLEX?5of?5RP@
  00042	e8 00 00 00 00	 call	 printerrorf

; 769  : 		}
; 770  : 	}

  00047	eb 17		 jmp	 SHORT $LN5@checkRpcRe
$LN2@checkRpcRe:

; 771  : 	else
; 772  : 	{
; 773  : 		if (ResponseHeader->PacketFlags & RPC_PF_MULTIPLEX)

  00049	84 c0		 test	 al, al
  0004b	74 13		 je	 SHORT $LN5@checkRpcRe

; 774  : 		{
; 775  : 			p("Warning: %s should not be set\n", "RPC_PF_MULTIPLEX");

  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@MIHFLBDG@RPC_PF_MULTIPLEX@
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@EPFAGCLK@Warning?3?5?$CFs?5should?5not?5be?5set?6@
  0005b	e8 00 00 00 00	 call	 printerrorf
$LN5@checkRpcRe:

; 776  : 		}
; 777  : 	}
; 778  : 
; 779  : 	if (!status && ResponseHeader->CallId == LE32(1))

  00060	85 ff		 test	 edi, edi
  00062	75 24		 jne	 SHORT $LN11@checkRpcRe
  00064	83 7e 0c 01	 cmp	 DWORD PTR [rsi+12], 1
  00068	75 1e		 jne	 SHORT $LN11@checkRpcRe

; 780  : 	{
; 781  : 		if (!WineBugDetected)

  0006a	40 38 3d 00 00
	00 00		 cmp	 BYTE PTR ?WineBugDetected@?1??checkRpcResponseHeader@@9@9, dil
  00071	75 32		 jne	 SHORT $LN9@checkRpcRe

; 782  : 		{
; 783  : 			p("Warning: Buggy RPC of Wine detected. Call Id of Response is always 1\n");

  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EG@HDABALOO@Warning?3?5Buggy?5RPC?5of?5Wine?5dete@
  0007a	e8 00 00 00 00	 call	 printerrorf

; 784  : 			WineBugDetected = TRUE;

  0007f	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?WineBugDetected@?1??checkRpcResponseHeader@@9@9, 1

; 785  : 		}
; 786  : 	}

  00086	eb 1d		 jmp	 SHORT $LN9@checkRpcRe
$LN11@checkRpcRe:

; 787  : 	else if (ResponseHeader->CallId != RequestHeader->CallId)

  00088	44 8b 46 0c	 mov	 r8d, DWORD PTR [rsi+12]
  0008c	8b 55 0c	 mov	 edx, DWORD PTR [rbp+12]
  0008f	44 3b c2	 cmp	 r8d, edx
  00092	74 11		 je	 SHORT $LN9@checkRpcRe

; 788  : 	{
; 789  : 		p("Fatal: Sent Call Id %u but received answer for Call Id %u\n",

  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DL@NKMJHEP@Fatal?3?5Sent?5Call?5Id?5?$CFu?5but?5rece@
  0009b	e8 00 00 00 00	 call	 printerrorf

; 790  : 			(uint32_t)LE32(RequestHeader->CallId),
; 791  : 			(uint32_t)LE32(ResponseHeader->CallId)
; 792  : 		);
; 793  : 
; 794  : 		status = RPC_S_PROTOCOL_ERROR;

  000a0	bf c0 06 00 00	 mov	 edi, 1728		; 000006c0H
$LN9@checkRpcRe:

; 795  : 	}
; 796  : 
; 797  : 	return status;
; 798  : }

  000a5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000aa	8b c7		 mov	 eax, edi
  000ac	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000b1	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000b6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
checkRpcResponseHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
;	COMDAT rpcSendRequest
_TEXT	SEGMENT
ResponseHeader$ = 32
_Response$ = 48
sock$ = 128
kmsRequest$ = 136
requestSize$ = 144
kmsResponse$ = 152
responseSize$ = 160
rpcSendRequest PROC					; COMDAT

; 806  : {

$LN52:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	55		 push	 rbp
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 8b ec	 mov	 rbp, rsp
  0001b	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 807  : #define MAX_EXCESS_BYTES 16
; 808  : 	RPC_HEADER *RequestHeader, ResponseHeader;
; 809  : 	RPC_REQUEST64 *RpcRequest;
; 810  : 	RPC_RESPONSE64 _Response;
; 811  : 	int status;
; 812  : 	const int_fast8_t useNdr64 = RpcFlags.HasNDR64 && UseClientRpcNDR64 && firstPacketSent;

  0001f	f7 05 00 00 00
	00 00 00 02 00	 test	 DWORD PTR RpcFlags, 131072 ; 00020000H
  00029	4d 8b f9	 mov	 r15, r9
  0002c	49 8b d8	 mov	 rbx, r8
  0002f	4c 8b ea	 mov	 r13, rdx
  00032	4c 8b e1	 mov	 r12, rcx
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	74 0e		 je	 SHORT $LN27@rpcSendReq
  0003c	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR firstPacketSent, 0
  00043	74 05		 je	 SHORT $LN27@rpcSendReq
  00045	44 8a f0	 mov	 r14b, al
  00048	eb 03		 jmp	 SHORT $LN28@rpcSendReq
$LN27@rpcSendReq:
  0004a	45 32 f6	 xor	 r14b, r14b
$LN28@rpcSendReq:

; 813  : 	size_t size = sizeof(RPC_HEADER) + (useNdr64 ? sizeof(RPC_REQUEST64) : sizeof(RPC_REQUEST)) + requestSize;
; 814  : 	size_t responseSize2;
; 815  : 
; 816  : 	*kmsResponse = NULL;

  0004d	49 83 21 00	 and	 QWORD PTR [r9], 0
  00051	49 83 c0 20	 add	 r8, 32			; 00000020H
  00055	41 0f b6 c6	 movzx	 eax, r14b
  00059	49 8d 34 c0	 lea	 rsi, QWORD PTR [r8+rax*8]
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  0005d	48 8b ce	 mov	 rcx, rsi
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00066	48 8b f8	 mov	 rdi, rax

; 366  : 	if (!buf) OutOfMemory();

  00069	33 c0		 xor	 eax, eax
  0006b	48 85 ff	 test	 rdi, rdi
  0006e	0f 84 a7 02 00
	00		 je	 $LN43@rpcSendReq
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c

; 604  : 	header->CallId = LE32(CallId);

  00074	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR CallId

; 817  : 
; 818  : 	BYTE *_Request = (BYTE*)vlmcsd_malloc(size);
; 819  : 
; 820  : 	RequestHeader = (RPC_HEADER*)_Request;
; 821  : 	RpcRequest = (RPC_REQUEST64*)(_Request + sizeof(RPC_HEADER));
; 822  : 
; 823  : 	createRpcHeader(RequestHeader, RPC_PT_REQUEST, (WORD)size);
; 824  : 
; 825  : 	// Increment CallId for next Request
; 826  : 	CallId++;

  0007a	8d 50 01	 lea	 edx, QWORD PTR [rax+1]

; 604  : 	header->CallId = LE32(CallId);

  0007d	89 4f 0c	 mov	 DWORD PTR [rdi+12], ecx

; 829  : 
; 830  : 	if (useNdr64)

  00080	4c 8b c3	 mov	 r8, rbx
  00083	03 ca		 add	 ecx, edx

; 600  : 	header->VersionMajor = 5;

  00085	c7 07 05 00 00
	03		 mov	 DWORD PTR [rdi], 50331653 ; 03000005H

; 817  : 
; 818  : 	BYTE *_Request = (BYTE*)vlmcsd_malloc(size);
; 819  : 
; 820  : 	RequestHeader = (RPC_HEADER*)_Request;
; 821  : 	RpcRequest = (RPC_REQUEST64*)(_Request + sizeof(RPC_HEADER));
; 822  : 
; 823  : 	createRpcHeader(RequestHeader, RPC_PT_REQUEST, (WORD)size);
; 824  : 
; 825  : 	// Increment CallId for next Request
; 826  : 	CallId++;

  0008b	89 0d 00 00 00
	00		 mov	 DWORD PTR CallId, ecx

; 827  : 
; 828  : 	RpcRequest->Opnum = 0;

  00091	48 8d 4f 20	 lea	 rcx, QWORD PTR [rdi+32]

; 602  : 	header->AuthLength = 0;

  00095	66 89 47 0a	 mov	 WORD PTR [rdi+10], ax

; 603  : 	header->DataRepresentation = BE32(0x10000000); // Little endian, ASCII charset, IEEE floating point

  00099	c7 47 04 10 00
	00 00		 mov	 DWORD PTR [rdi+4], 16

; 605  : 	header->FragLength = LE16(size);

  000a0	66 89 77 08	 mov	 WORD PTR [rdi+8], si

; 827  : 
; 828  : 	RpcRequest->Opnum = 0;

  000a4	66 89 47 16	 mov	 WORD PTR [rdi+22], ax

; 829  : 
; 830  : 	if (useNdr64)

  000a8	45 84 f6	 test	 r14b, r14b
  000ab	74 14		 je	 SHORT $LN8@rpcSendReq

; 831  : 	{
; 832  : 		RpcRequest->ContextId = LE16(1); // We negotiate NDR64 always as context 1
; 833  : 		RpcRequest->AllocHint = LE32((DWORD)(requestSize + sizeof(RpcRequest->Ndr64)));
; 834  : 		RpcRequest->Ndr64.DataLength = LE64((uint64_t)requestSize);
; 835  : 		RpcRequest->Ndr64.DataSizeIs = LE64((uint64_t)requestSize);

  000ad	48 89 19	 mov	 QWORD PTR [rcx], rbx
  000b0	8d 43 10	 lea	 eax, DWORD PTR [rbx+16]

; 836  : 		memcpy(RpcRequest->Ndr64.Data, kmsRequest, requestSize);

  000b3	48 8d 4f 28	 lea	 rcx, QWORD PTR [rdi+40]
  000b7	66 89 57 14	 mov	 WORD PTR [rdi+20], dx
  000bb	48 89 5f 18	 mov	 QWORD PTR [rdi+24], rbx

; 837  : 	}

  000bf	eb 0d		 jmp	 SHORT $LN46@rpcSendReq
$LN8@rpcSendReq:

; 838  : 	else
; 839  : 	{
; 840  : 		RpcRequest->ContextId = 0; // We negotiate NDR32 always as context 0

  000c1	66 89 47 14	 mov	 WORD PTR [rdi+20], ax

; 841  : 		RpcRequest->AllocHint = LE32((DWORD)(requestSize + sizeof(RpcRequest->Ndr)));

  000c5	8d 43 08	 lea	 eax, DWORD PTR [rbx+8]

; 842  : 		RpcRequest->Ndr.DataLength = LE32((DWORD)requestSize);

  000c8	89 5f 18	 mov	 DWORD PTR [rdi+24], ebx

; 843  : 		RpcRequest->Ndr.DataSizeIs = LE32((DWORD)requestSize);

  000cb	89 5f 1c	 mov	 DWORD PTR [rdi+28], ebx
$LN46@rpcSendReq:

; 844  : 		memcpy(RpcRequest->Ndr.Data, kmsRequest, requestSize);
; 845  : 	}
; 846  : 
; 847  : 	for (;;)
; 848  : 	{
; 849  : 		int bytesread;
; 850  : 
; 851  : 		if (!_send(sock, _Request, (int)size))

  000ce	49 8b d5	 mov	 rdx, r13
  000d1	89 47 10	 mov	 DWORD PTR [rdi+16], eax
  000d4	e8 00 00 00 00	 call	 memcpy
  000d9	41 b1 01	 mov	 r9b, 1
  000dc	44 8b c6	 mov	 r8d, esi
  000df	48 8b d7	 mov	 rdx, rdi
  000e2	49 8b cc	 mov	 rcx, r12
  000e5	e8 00 00 00 00	 call	 sendrecv
  000ea	45 33 ed	 xor	 r13d, r13d
  000ed	84 c0		 test	 al, al
  000ef	75 16		 jne	 SHORT $LN10@rpcSendReq

; 852  : 		{
; 853  : 			printerrorf("\nFatal: Could not send RPC request\n");

  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@JLEJBEGP@?6Fatal?3?5Could?5not?5send?5RPC?5requ@
$LN48@rpcSendReq:

; 974  : 		//status = LE32(UA32(pReturnCode));
; 975  : 
; 976  : 		break;
; 977  : 	}
; 978  : 
; 979  : 	free(_Request);

  000f8	e8 00 00 00 00	 call	 printerrorf
  000fd	bb 1c 07 00 00	 mov	 ebx, 1820		; 0000071cH
  00102	e9 e4 01 00 00	 jmp	 $LN3@rpcSendReq
$LN10@rpcSendReq:

; 854  : 			status = RPC_S_COMM_FAILURE;
; 855  : 			break;
; 856  : 		}
; 857  : 
; 858  : 		if (!_recv(sock, &ResponseHeader, sizeof(RPC_HEADER)))

  00107	45 33 c9	 xor	 r9d, r9d
  0010a	48 8d 55 d0	 lea	 rdx, QWORD PTR ResponseHeader$[rbp-80]
  0010e	49 8b cc	 mov	 rcx, r12
  00111	45 8d 41 10	 lea	 r8d, QWORD PTR [r9+16]
  00115	e8 00 00 00 00	 call	 sendrecv
  0011a	84 c0		 test	 al, al
  0011c	75 09		 jne	 SHORT $LN11@rpcSendReq

; 859  : 		{
; 860  : 			printerrorf("\nFatal: No RPC response received from server\n");

  0011e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@NNOGDDAG@?6Fatal?3?5No?5RPC?5response?5receive@

; 861  : 			status = RPC_S_COMM_FAILURE;
; 862  : 			break;

  00125	eb d1		 jmp	 SHORT $LN48@rpcSendReq
$LN11@rpcSendReq:

; 863  : 		}
; 864  : 
; 865  : 		if ((status = checkRpcResponseHeader(&ResponseHeader, RequestHeader, RPC_PT_RESPONSE, &printerrorf))) break;

  00127	41 b0 02	 mov	 r8b, 2
  0012a	48 8d 4d d0	 lea	 rcx, QWORD PTR ResponseHeader$[rbp-80]
  0012e	48 8b d7	 mov	 rdx, rdi
  00131	e8 00 00 00 00	 call	 checkRpcResponseHeader
  00136	8b d8		 mov	 ebx, eax
  00138	85 c0		 test	 eax, eax
  0013a	0f 85 ab 01 00
	00		 jne	 $LN3@rpcSendReq

; 866  : 
; 867  : 		size = useNdr64 ? sizeof(RPC_RESPONSE64) : sizeof(RPC_RESPONSE);

  00140	41 8a c6	 mov	 al, r14b

; 868  : 
; 869  : 		if (size > LE16(ResponseHeader.FragLength) - sizeof(ResponseHeader))
; 870  : 			size = LE16(ResponseHeader.FragLength) - sizeof(ResponseHeader);
; 871  : 
; 872  : 		if (!_recv(sock, &_Response, (int)size))

  00143	48 8d 55 e0	 lea	 rdx, QWORD PTR _Response$[rbp-80]
  00147	f6 d8		 neg	 al
  00149	0f b7 45 d8	 movzx	 eax, WORD PTR ResponseHeader$[rbp-72]
  0014d	48 1b c9	 sbb	 rcx, rcx
  00150	48 83 c0 f0	 add	 rax, -16
  00154	83 e1 0c	 and	 ecx, 12
  00157	48 83 c1 14	 add	 rcx, 20
  0015b	48 3b c8	 cmp	 rcx, rax
  0015e	0f 46 c1	 cmovbe	 eax, ecx
  00161	45 33 c9	 xor	 r9d, r9d
  00164	44 8b c0	 mov	 r8d, eax
  00167	49 8b cc	 mov	 rcx, r12
  0016a	e8 00 00 00 00	 call	 sendrecv
  0016f	84 c0		 test	 al, al
  00171	75 0c		 jne	 SHORT $LN14@rpcSendReq

; 873  : 		{
; 874  : 			printerrorf("\nFatal: RPC response is incomplete\n");

  00173	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@ENNHKCJO@?6Fatal?3?5RPC?5response?5is?5incompl@

; 875  : 			status = RPC_S_COMM_FAILURE;
; 876  : 			break;

  0017a	e9 79 ff ff ff	 jmp	 $LN48@rpcSendReq
$LN14@rpcSendReq:

; 877  : 		}
; 878  : 
; 879  : 		if (_Response.CancelCount != 0)

  0017f	44 38 6d e6	 cmp	 BYTE PTR _Response$[rbp-74], r13b
  00183	74 16		 je	 SHORT $LN15@rpcSendReq

; 880  : 		{
; 881  : 			printerrorf("\nFatal: RPC response cancel count is not 0\n");

  00185	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CM@HKIEGAIN@?6Fatal?3?5RPC?5response?5cancel?5cou@
  0018c	e8 00 00 00 00	 call	 printerrorf

; 882  : 			status = RPC_S_CALL_CANCELLED;

  00191	bb 1a 07 00 00	 mov	 ebx, 1818		; 0000071aH

; 883  : 			break;

  00196	e9 50 01 00 00	 jmp	 $LN3@rpcSendReq
$LN15@rpcSendReq:

; 884  : 		}
; 885  : 
; 886  : 		if (_Response.ContextId != (useNdr64 ? LE16(1) : 0))

  0019b	0f b7 55 e4	 movzx	 edx, WORD PTR _Response$[rbp-76]
  0019f	41 0f b6 c6	 movzx	 eax, r14b
  001a3	3b d0		 cmp	 edx, eax
  001a5	74 16		 je	 SHORT $LN16@rpcSendReq

; 887  : 		{
; 888  : 			printerrorf("\nFatal: RPC response context id %u is not bound\n", (unsigned int)LE16(_Response.ContextId));

  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@LCKBGPNI@?6Fatal?3?5RPC?5response?5context?5id@
  001ae	e8 00 00 00 00	 call	 printerrorf

; 889  : 			status = RPC_X_SS_CONTEXT_DAMAGED;

  001b3	bb f1 06 00 00	 mov	 ebx, 1777		; 000006f1H

; 890  : 			break;

  001b8	e9 2e 01 00 00	 jmp	 $LN3@rpcSendReq
$LN16@rpcSendReq:

; 891  : 		}
; 892  : 
; 893  : 		int_fast8_t sizesMatch;
; 894  : 
; 895  : 		if (useNdr64)

  001bd	48 8b 75 50	 mov	 rsi, QWORD PTR responseSize$[rbp-80]
  001c1	45 84 f6	 test	 r14b, r14b
  001c4	74 1e		 je	 SHORT $LN17@rpcSendReq

; 896  : 		{
; 897  : 			*responseSize = (size_t)LE64(_Response.Ndr64.DataLength);
; 898  : 			responseSize2 = (size_t)LE64(_Response.Ndr64.DataSizeIs);
; 899  : 
; 900  : 			if (/*!*responseSize ||*/ !_Response.Ndr64.DataSizeMax)

  001c6	48 8b 45 f0	 mov	 rax, QWORD PTR _Response$[rbp-64]
  001ca	48 8b 4d e8	 mov	 rcx, QWORD PTR _Response$[rbp-72]
  001ce	48 89 0e	 mov	 QWORD PTR [rsi], rcx
  001d1	48 85 c0	 test	 rax, rax
  001d4	75 08		 jne	 SHORT $LN19@rpcSendReq

; 901  : 			{
; 902  : 				status = (int)LE32(_Response.Ndr64.status);

  001d6	8b 5d f8	 mov	 ebx, DWORD PTR _Response$[rbp-56]

; 903  : 				break;

  001d9	e9 0d 01 00 00	 jmp	 $LN3@rpcSendReq
$LN19@rpcSendReq:

; 904  : 			}
; 905  : 
; 906  : 			sizesMatch = (size_t)LE64(_Response.Ndr64.DataLength) == responseSize2;

  001de	48 3b 4d f8	 cmp	 rcx, QWORD PTR _Response$[rbp-56]

; 907  : 		}

  001e2	eb 1b		 jmp	 SHORT $LN47@rpcSendReq
$LN17@rpcSendReq:

; 908  : 		else
; 909  : 		{
; 910  : 			*responseSize = (size_t)LE32(_Response.Ndr.DataLength);

  001e4	8b 4d e8	 mov	 ecx, DWORD PTR _Response$[rbp-72]
  001e7	48 89 0e	 mov	 QWORD PTR [rsi], rcx

; 911  : 			responseSize2 = (size_t)LE32(_Response.Ndr.DataSizeIs);
; 912  : 
; 913  : 			if (/*!*responseSize ||*/ !_Response.Ndr.DataSizeMax)

  001ea	44 39 6d ec	 cmp	 DWORD PTR _Response$[rbp-68], r13d
  001ee	75 08		 jne	 SHORT $LN20@rpcSendReq

; 914  : 			{
; 915  : 				status = (int)LE32(_Response.Ndr.status);

  001f0	8b 5d f0	 mov	 ebx, DWORD PTR _Response$[rbp-64]

; 916  : 				break;

  001f3	e9 f3 00 00 00	 jmp	 $LN3@rpcSendReq
$LN20@rpcSendReq:

; 917  : 			}
; 918  : 
; 919  : 			sizesMatch = (size_t)LE32(_Response.Ndr.DataLength) == responseSize2;

  001f8	48 8b 45 f0	 mov	 rax, QWORD PTR _Response$[rbp-64]
  001fc	39 45 e8	 cmp	 DWORD PTR _Response$[rbp-72], eax
$LN47@rpcSendReq:

; 920  : 		}
; 921  : 
; 922  : 		if (!sizesMatch)

  001ff	0f 94 c2	 sete	 dl
  00202	84 d2		 test	 dl, dl
  00204	75 1b		 jne	 SHORT $LN21@rpcSendReq

; 923  : 		{
; 924  : 			printerrorf("\nFatal: NDR data length (%u) does not match NDR data size (%u)\n",

  00206	8b 16		 mov	 edx, DWORD PTR [rsi]
  00208	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EA@FIBHBLDN@?6Fatal?3?5NDR?5data?5length?5?$CI?$CFu?$CJ?5do@
$LN50@rpcSendReq:

; 974  : 		//status = LE32(UA32(pReturnCode));
; 975  : 
; 976  : 		break;
; 977  : 	}
; 978  : 
; 979  : 	free(_Request);

  0020f	44 8b c0	 mov	 r8d, eax
  00212	e8 00 00 00 00	 call	 printerrorf
  00217	bb c0 06 00 00	 mov	 ebx, 1728		; 000006c0H
  0021c	e9 ca 00 00 00	 jmp	 $LN3@rpcSendReq
$LN21@rpcSendReq:

; 925  : 				(uint32_t)*responseSize,
; 926  : 				(uint32_t)LE32(_Response.Ndr.DataSizeIs)
; 927  : 			);
; 928  : 
; 929  : 			status = RPC_S_PROTOCOL_ERROR;
; 930  : 			break;
; 931  : 		}
; 932  : 
; 933  : 		*kmsResponse = (BYTE*)vlmcsd_malloc(*responseSize + MAX_EXCESS_BYTES);

  00221	48 83 c1 10	 add	 rcx, 16
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  00225	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 366  : 	if (!buf) OutOfMemory();

  0022b	48 85 c0	 test	 rax, rax
  0022e	0f 84 e7 00 00
	00		 je	 $LN43@rpcSendReq
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c

; 936  : 		memset(*kmsResponse, 0, *responseSize + MAX_EXCESS_BYTES);

  00234	49 89 07	 mov	 QWORD PTR [r15], rax
  00237	33 d2		 xor	 edx, edx
  00239	4c 8b 06	 mov	 r8, QWORD PTR [rsi]
  0023c	48 8b c8	 mov	 rcx, rax
  0023f	49 83 c0 10	 add	 r8, 16
  00243	e8 00 00 00 00	 call	 memset

; 937  : 
; 938  : 		// Read up to 16 bytes more than bytes expected to detect faulty KMS emulators
; 939  : 		if ((bytesread = recv(sock, (char*)*kmsResponse, (int)(*responseSize) + MAX_EXCESS_BYTES, 0)) < (int)*responseSize)

  00248	44 8b 06	 mov	 r8d, DWORD PTR [rsi]
  0024b	45 33 c9	 xor	 r9d, r9d
  0024e	49 8b 17	 mov	 rdx, QWORD PTR [r15]
  00251	41 83 c0 10	 add	 r8d, 16
  00255	49 8b cc	 mov	 rcx, r12
  00258	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv
  0025e	8b 16		 mov	 edx, DWORD PTR [rsi]
  00260	3b c2		 cmp	 eax, edx
  00262	7d 0f		 jge	 SHORT $LN22@rpcSendReq

; 940  : 		{
; 941  : 			printerrorf("\nFatal: No or incomplete KMS response received. Required %u bytes but only got %i\n",

  00264	85 c0		 test	 eax, eax
  00266	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0FD@KCALNIFM@?6Fatal?3?5No?5or?5incomplete?5KMS?5re@
  0026d	41 0f 48 c5	 cmovs	 eax, r13d

; 942  : 				(uint32_t)*responseSize,
; 943  : 				(int32_t)(bytesread < 0 ? 0 : bytesread)
; 944  : 			);
; 945  : 
; 946  : 			status = RPC_S_PROTOCOL_ERROR;
; 947  : 			break;

  00271	eb 9c		 jmp	 SHORT $LN50@rpcSendReq
$LN22@rpcSendReq:

; 948  : 		}
; 949  : 
; 950  : 		DWORD *pReturnCode;
; 951  : 
; 952  : 		const size_t len = *responseSize + (useNdr64 ? sizeof(_Response.Ndr64) : sizeof(_Response.Ndr)) + sizeof(*pReturnCode);

  00273	4c 8b 0e	 mov	 r9, QWORD PTR [rsi]
  00276	41 f6 de	 neg	 r14b

; 953  : 		const size_t pad = ((~len & 3) + 1) & 3;
; 954  : 
; 955  : 		if (len + pad != LE32(_Response.AllocHint))

  00279	8b 55 e0	 mov	 edx, DWORD PTR _Response$[rbp-80]
  0027c	4d 1b c0	 sbb	 r8, r8
  0027f	41 83 e0 0c	 and	 r8d, 12
  00283	49 83 c0 10	 add	 r8, 16
  00287	4d 03 c1	 add	 r8, r9
  0028a	49 8b d8	 mov	 rbx, r8
  0028d	48 f7 db	 neg	 rbx
  00290	83 e3 03	 and	 ebx, 3
  00293	4a 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+r8]
  00297	48 3b ca	 cmp	 rcx, rdx
  0029a	74 11		 je	 SHORT $LN23@rpcSendReq

; 956  : 		{
; 957  : 			printerrorf("\nWarning: RPC stub size is %u, should be %u (probably incorrect padding)\n", (uint32_t)LE32(_Response.AllocHint), (uint32_t)(len + pad));

  0029c	44 03 c3	 add	 r8d, ebx
  0029f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EK@EDAGGGNP@?6Warning?3?5RPC?5stub?5size?5is?5?$CFu?0?5@
  002a6	e8 00 00 00 00	 call	 printerrorf

; 958  : 		}

  002ab	eb 35		 jmp	 SHORT $LN6@rpcSendReq
$LN23@rpcSendReq:

; 959  : 		else
; 960  : 		{
; 961  : 			size_t i;
; 962  : 			for (i = 0; i < pad; i++)

  002ad	49 8b d5	 mov	 rdx, r13
  002b0	48 85 db	 test	 rbx, rbx
  002b3	74 2d		 je	 SHORT $LN6@rpcSendReq

; 963  : 			{
; 964  : 				if (*(*kmsResponse + *responseSize + sizeof(*pReturnCode) + i))

  002b5	49 8b 0f	 mov	 rcx, QWORD PTR [r15]
  002b8	b8 01 00 00 00	 mov	 eax, 1
  002bd	48 83 c1 04	 add	 rcx, 4
  002c1	49 03 c9	 add	 rcx, r9
$LL7@rpcSendReq:
  002c4	44 38 29	 cmp	 BYTE PTR [rcx], r13b
  002c7	75 0d		 jne	 SHORT $LN39@rpcSendReq

; 959  : 		else
; 960  : 		{
; 961  : 			size_t i;
; 962  : 			for (i = 0; i < pad; i++)

  002c9	48 03 d0	 add	 rdx, rax
  002cc	48 03 c8	 add	 rcx, rax
  002cf	48 3b d3	 cmp	 rdx, rbx
  002d2	72 f0		 jb	 SHORT $LL7@rpcSendReq

; 963  : 			{
; 964  : 				if (*(*kmsResponse + *responseSize + sizeof(*pReturnCode) + i))

  002d4	eb 0c		 jmp	 SHORT $LN6@rpcSendReq
$LN39@rpcSendReq:

; 965  : 				{
; 966  : 					printerrorf("\nWarning: RPC stub data not padded to zeros according to Microsoft standard\n");

  002d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EN@IFHPELIC@?6Warning?3?5RPC?5stub?5data?5not?5pad@
  002dd	e8 00 00 00 00	 call	 printerrorf
$LN6@rpcSendReq:

; 967  : 					break;
; 968  : 				}
; 969  : 			}
; 970  : 		}
; 971  : 
; 972  : 		pReturnCode = (DWORD*)(*kmsResponse + *responseSize + pad);
; 973  : 		status = GET_UA32LE(pReturnCode);

  002e2	49 8b 07	 mov	 rax, QWORD PTR [r15]
  002e5	48 03 06	 add	 rax, QWORD PTR [rsi]
  002e8	8b 1c 18	 mov	 ebx, DWORD PTR [rax+rbx]
$LN3@rpcSendReq:

; 974  : 		//status = LE32(UA32(pReturnCode));
; 975  : 
; 976  : 		break;
; 977  : 	}
; 978  : 
; 979  : 	free(_Request);

  002eb	48 8b cf	 mov	 rcx, rdi
  002ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 983  : }

  002f4	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  002f9	c6 05 00 00 00
	00 01		 mov	 BYTE PTR firstPacketSent, 1
  00300	49 8b 73 38	 mov	 rsi, QWORD PTR [r11+56]
  00304	8b c3		 mov	 eax, ebx
  00306	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  0030a	49 8b 7b 40	 mov	 rdi, QWORD PTR [r11+64]
  0030e	49 8b e3	 mov	 rsp, r11
  00311	41 5f		 pop	 r15
  00313	41 5e		 pop	 r14
  00315	41 5d		 pop	 r13
  00317	41 5c		 pop	 r12
  00319	5d		 pop	 rbp
  0031a	c3		 ret	 0
$LN43@rpcSendReq:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 366  : 	if (!buf) OutOfMemory();

  0031b	e8 00 00 00 00	 call	 OutOfMemory
  00320	cc		 int	 3
$LN45@rpcSendReq:
rpcSendRequest ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
;	COMDAT IsNullGuid
_TEXT	SEGMENT
guidPtr$ = 8
IsNullGuid PROC						; COMDAT

; 988  : 	int_fast8_t i;
; 989  : 
; 990  : 	for (i = 0; i < 16; i++)

  00000	45 32 c0	 xor	 r8b, r8b
  00003	b0 01		 mov	 al, 1
$LL4@IsNullGuid:

; 991  : 	{
; 992  : 		if (guidPtr[i]) return FALSE;

  00005	49 0f be d0	 movsx	 rdx, r8b
  00009	80 3c 0a 00	 cmp	 BYTE PTR [rdx+rcx], 0
  0000d	75 0a		 jne	 SHORT $LN8@IsNullGuid

; 988  : 	int_fast8_t i;
; 989  : 
; 990  : 	for (i = 0; i < 16; i++)

  0000f	44 02 c0	 add	 r8b, al
  00012	41 80 f8 10	 cmp	 r8b, 16
  00016	7c ed		 jl	 SHORT $LL4@IsNullGuid

; 993  : 	}
; 994  : 
; 995  : 	return TRUE;
; 996  : }

  00018	c3		 ret	 0
$LN8@IsNullGuid:

; 991  : 	{
; 992  : 		if (guidPtr[i]) return FALSE;

  00019	32 c0		 xor	 al, al

; 993  : 	}
; 994  : 
; 995  : 	return TRUE;
; 996  : }

  0001b	c3		 ret	 0
IsNullGuid ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
;	COMDAT rpcBindOrAlterClientContext
_TEXT	SEGMENT
tv917 = 0
bindResponse$1$ = 8
buf$1$ = 16
ResponseHeader$ = 24
sock$ = 112
tv1078 = 120
packetType$ = 120
verbose$ = 128
tv1004 = 136
rpcBindOrAlterClientContext PROC			; COMDAT

; 1004 : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]

; 1005 : 	RPC_HEADER *RequestHeader, ResponseHeader;
; 1006 : 	RPC_BIND_REQUEST *bindRequest;
; 1007 : 	RPC_BIND_RESPONSE *bindResponse;
; 1008 : 	int status;
; 1009 : 	const WORD ctxItems = 1 + (packetType == RPC_PT_BIND_REQ ? UseClientRpcNDR64 + UseClientRpcBTFN : 0);

  00019	80 fa 0b	 cmp	 dl, 11
  0001c	48 89 5d 70	 mov	 QWORD PTR [rbp+112], rbx
  00020	4c 8b f9	 mov	 r15, rcx
  00023	40 8a fa	 mov	 dil, dl
  00026	b9 01 00 00 00	 mov	 ecx, 1

; 1010 : 	const size_t rpcBindSize = (sizeof(RPC_HEADER) + sizeof(RPC_BIND_REQUEST) + (ctxItems - 1) * sizeof(bindRequest->CtxItems[0]));
; 1011 : 	WORD ctxIndex = 0;
; 1012 : 	WORD i;
; 1013 : 	WORD CtxBTFN = RPC_INVALID_CTX, CtxNDR64 = RPC_INVALID_CTX;

  0002b	41 bd ff ff 00
	00		 mov	 r13d, 65535		; 0000ffffH
  00031	44 8b f1	 mov	 r14d, ecx
  00034	44 89 6d 78	 mov	 DWORD PTR tv1078[rbp], r13d
  00038	8d 41 02	 lea	 eax, QWORD PTR [rcx+2]
  0003b	66 44 0f 44 f0	 cmove	 r14w, ax

; 1014 : 	BYTE* request = (BYTE*)alloca(rpcBindSize);

  00040	8d 71 0e	 lea	 esi, QWORD PTR [rcx+14]
  00043	41 0f b7 d6	 movzx	 edx, r14w
  00047	8b c2		 mov	 eax, edx
  00049	44 89 75 00	 mov	 DWORD PTR tv917[rbp], r14d
  0004d	48 2b c1	 sub	 rax, rcx
  00050	4c 6b c0 2c	 imul	 r8, rax, 44		; 0000002cH
  00054	49 83 c0 48	 add	 r8, 72			; 00000048H
  00058	4a 8d 04 06	 lea	 rax, QWORD PTR [rsi+r8]
  0005c	49 3b c0	 cmp	 rax, r8
  0005f	77 0a		 ja	 SHORT $LN65@rpcBindOrA
  00061	48 b8 f0 ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846960 ; 0ffffffffffffff0H
$LN65@rpcBindOrA:
  0006b	48 83 e0 f0	 and	 rax, -16
  0006f	e8 00 00 00 00	 call	 __chkstk
  00074	48 2b e0	 sub	 rsp, rax
  00077	4c 8b e9	 mov	 r13, rcx

; 604  : 	header->CallId = LE32(CallId);

  0007a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR CallId
  00080	45 33 e4	 xor	 r12d, r12d

; 1025 : 
; 1026 : 	// data that is identical in all Ctx items
; 1027 : 	for (i = 0; i < ctxItems; i++)

  00083	45 0f b7 cc	 movzx	 r9d, r12w
  00087	48 8d 5c 24 20	 lea	 rbx, QWORD PTR [rsp+32]

; 598  : 	header->PacketType = packetType;

  0008c	40 88 7b 02	 mov	 BYTE PTR [rbx+2], dil

; 1005 : 	RPC_HEADER *RequestHeader, ResponseHeader;
; 1006 : 	RPC_BIND_REQUEST *bindRequest;
; 1007 : 	RPC_BIND_RESPONSE *bindResponse;
; 1008 : 	int status;
; 1009 : 	const WORD ctxItems = 1 + (packetType == RPC_PT_BIND_REQ ? UseClientRpcNDR64 + UseClientRpcBTFN : 0);

  00090	45 8d 54 24 02	 lea	 r10d, QWORD PTR [r12+2]

; 600  : 	header->VersionMajor = 5;

  00095	66 c7 03 05 00	 mov	 WORD PTR [rbx], 5

; 601  : 	header->VersionMinor = 0;
; 602  : 	header->AuthLength = 0;

  0009a	66 44 89 63 0a	 mov	 WORD PTR [rbx+10], r12w

; 603  : 	header->DataRepresentation = BE32(0x10000000); // Little endian, ASCII charset, IEEE floating point

  0009f	c7 43 04 10 00
	00 00		 mov	 DWORD PTR [rbx+4], 16

; 604  : 	header->CallId = LE32(CallId);

  000a6	89 43 0c	 mov	 DWORD PTR [rbx+12], eax

; 605  : 	header->FragLength = LE16(size);

  000a9	66 44 89 43 08	 mov	 WORD PTR [rbx+8], r8w

; 1015 : 
; 1016 : 	RequestHeader = (RPC_HEADER*)request;
; 1017 : 	bindRequest = (RPC_BIND_REQUEST*)(request + sizeof(RPC_HEADER));
; 1018 : 
; 1019 : 	createRpcHeader(RequestHeader, packetType, (WORD)rpcBindSize);
; 1020 : 	RequestHeader->PacketFlags |= UseMultiplexedRpc ? RPC_PF_MULTIPLEX : 0;

  000ae	c6 43 03 13	 mov	 BYTE PTR [rbx+3], 19

; 1021 : 
; 1022 : 	bindRequest->AssocGroup = 0;
; 1023 : 	bindRequest->MaxRecvFrag = bindRequest->MaxXmitFrag = LE16(5840);
; 1024 : 	bindRequest->NumCtxItems = LE32(ctxItems);

  000b2	89 53 18	 mov	 DWORD PTR [rbx+24], edx
  000b5	48 8d 53 32	 lea	 rdx, QWORD PTR [rbx+50]
  000b9	48 c7 43 10 d0
	16 d0 16	 mov	 QWORD PTR [rbx+16], 382736080 ; 16d016d0H
$LL4@rpcBindOrA:

; 1028 : 	{
; 1029 : 		struct CtxItem* ctxItem = bindRequest->CtxItems + i;
; 1030 : 		ctxItem->ContextId = LE16(i);

  000c1	66 44 89 4a ea	 mov	 WORD PTR [rdx-22], r9w

; 1031 : 		ctxItem->InterfaceVerMajor = LE16(1);
; 1032 : 		ctxItem->InterfaceVerMinor = 0;
; 1033 : 		ctxItem->NumTransItems = LE16(1);
; 1034 : 		ctxItem->SyntaxVersion = i ? LE32(1) : LE32(2);

  000c6	41 0f b7 c1	 movzx	 eax, r9w
  000ca	44 89 6a fe	 mov	 DWORD PTR [rdx-2], r13d
  000ce	66 f7 d8	 neg	 ax
  000d1	66 44 89 6a ec	 mov	 WORD PTR [rdx-20], r13w
  000d6	48 8d 52 2c	 lea	 rdx, QWORD PTR [rdx+44]
  000da	1b c9		 sbb	 ecx, ecx
  000dc	66 45 03 cd	 add	 r9w, r13w
  000e0	41 03 ca	 add	 ecx, r10d
  000e3	89 4a e6	 mov	 DWORD PTR [rdx-26], ecx

; 1035 : 
; 1036 : 		memcpy(&ctxItem->InterfaceUUID, InterfaceUuid, sizeof(GUID));

  000e6	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR InterfaceUuid
  000ed	f3 0f 7f 42 c2	 movdqu	 XMMWORD PTR [rdx-62], xmm0
  000f2	66 45 3b ce	 cmp	 r9w, r14w
  000f6	72 c9		 jb	 SHORT $LL4@rpcBindOrA

; 1037 : 	}
; 1038 : 
; 1039 : 	memcpy(&bindRequest->CtxItems[0].TransferSyntax, TransferSyntaxNDR32, sizeof(GUID));
; 1040 : 
; 1041 : 	if (UseClientRpcNDR64 && packetType == RPC_PT_BIND_REQ)

  000f8	41 bd ff ff 00
	00		 mov	 r13d, 65535		; 0000ffffH
  000fe	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR TransferSyntaxNDR32
  00105	f3 0f 7f 43 34	 movdqu	 XMMWORD PTR [rbx+52], xmm0
  0010a	40 80 ff 0b	 cmp	 dil, 11
  0010e	75 30		 jne	 SHORT $LN8@rpcBindOrA

; 1042 : 	{
; 1043 : 		memcpy(&bindRequest->CtxItems[++ctxIndex].TransferSyntax, TransferSyntaxNDR64, sizeof(GUID));

  00110	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR TransferSyntaxNDR64

; 1044 : 		CtxNDR64 = ctxIndex;

  00117	b8 01 00 00 00	 mov	 eax, 1

; 1048 : 	{
; 1049 : 		memcpy(&bindRequest->CtxItems[++ctxIndex].TransferSyntax, BindTimeFeatureNegotiation, sizeof(GUID));
; 1050 : 		CtxBTFN = ctxIndex;

  0011c	45 0f b7 ea	 movzx	 r13d, r10w
  00120	89 85 88 00 00
	00		 mov	 DWORD PTR tv1004[rbp], eax
  00126	f3 0f 7f 43 60	 movdqu	 XMMWORD PTR [rbx+96], xmm0
  0012b	44 89 6d 78	 mov	 DWORD PTR tv1078[rbp], r13d
  0012f	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR BindTimeFeatureNegotiation
  00136	f3 0f 7f 83 8c
	00 00 00	 movdqu	 XMMWORD PTR [rbx+140], xmm0
  0013e	eb 07		 jmp	 SHORT $LN9@rpcBindOrA
$LN8@rpcBindOrA:

; 1045 : 	}
; 1046 : 
; 1047 : 	if (UseClientRpcBTFN && packetType == RPC_PT_BIND_REQ)

  00140	44 89 ad 88 00
	00 00		 mov	 DWORD PTR tv1004[rbp], r13d
$LN9@rpcBindOrA:

; 1051 : 	}
; 1052 : 
; 1053 : 	if (!_send(sock, request, (int)rpcBindSize))

  00147	41 b9 01 00 00
	00		 mov	 r9d, 1
  0014d	48 8b d3	 mov	 rdx, rbx
  00150	49 8b cf	 mov	 rcx, r15
  00153	e8 00 00 00 00	 call	 sendrecv
  00158	84 c0		 test	 al, al
  0015a	75 16		 jne	 SHORT $LN10@rpcBindOrA

; 1054 : 	{
; 1055 : 		printerrorf("\nFatal: Sending RPC bind request failed\n");

  0015c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CJ@ELGOCPLL@?6Fatal?3?5Sending?5RPC?5bind?5reques@
$LN69@rpcBindOrA:

; 1233 : }

  00163	e8 00 00 00 00	 call	 printerrorf
$LN70@rpcBindOrA:
  00168	b8 1c 07 00 00	 mov	 eax, 1820		; 0000071cH
  0016d	e9 0b 03 00 00	 jmp	 $LN1@rpcBindOrA
$LN10@rpcBindOrA:

; 1056 : 		return RPC_S_COMM_FAILURE;
; 1057 : 	}
; 1058 : 
; 1059 : 	if (!_recv(sock, &ResponseHeader, sizeof(RPC_HEADER)))

  00172	45 33 c9	 xor	 r9d, r9d
  00175	48 8d 55 18	 lea	 rdx, QWORD PTR ResponseHeader$[rbp]
  00179	49 8b cf	 mov	 rcx, r15
  0017c	45 8d 41 10	 lea	 r8d, QWORD PTR [r9+16]
  00180	e8 00 00 00 00	 call	 sendrecv
  00185	84 c0		 test	 al, al
  00187	75 09		 jne	 SHORT $LN11@rpcBindOrA

; 1060 : 	{
; 1061 : 		printerrorf("\nFatal: Did not receive a response from server\n");

  00189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DA@NCIGIHDA@?6Fatal?3?5Did?5not?5receive?5a?5respo@

; 1062 : 		return RPC_S_COMM_FAILURE;

  00190	eb d1		 jmp	 SHORT $LN69@rpcBindOrA
$LN11@rpcBindOrA:

; 1063 : 	}
; 1064 : 
; 1065 : 	if ((status = checkRpcResponseHeader

  00192	b8 0c 00 00 00	 mov	 eax, 12
  00197	48 8d 4d 18	 lea	 rcx, QWORD PTR ResponseHeader$[rbp]
  0019b	40 80 ff 0b	 cmp	 dil, 11
  0019f	48 8b d3	 mov	 rdx, rbx
  001a2	0f 44 f0	 cmove	 esi, eax
  001a5	44 8a c6	 mov	 r8b, sil
  001a8	e8 00 00 00 00	 call	 checkRpcResponseHeader
  001ad	85 c0		 test	 eax, eax
  001af	0f 85 c8 02 00
	00		 jne	 $LN1@rpcBindOrA

; 1066 : 	(
; 1067 : 		&ResponseHeader,
; 1068 : 		RequestHeader,
; 1069 : 		packetType == RPC_PT_BIND_REQ ? RPC_PT_BIND_ACK : RPC_PT_ALTERCONTEXT_ACK,
; 1070 : 		&printerrorf
; 1071 : 	)))
; 1072 : 	{
; 1073 : 		return status;
; 1074 : 	}
; 1075 : 
; 1076 : 	bindResponse = (RPC_BIND_RESPONSE*)vlmcsd_malloc(LE16(ResponseHeader.FragLength) - sizeof(RPC_HEADER));

  001b5	0f b7 4d 20	 movzx	 ecx, WORD PTR ResponseHeader$[rbp+8]
  001b9	48 83 e9 10	 sub	 rcx, 16
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  001bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  001c3	48 89 45 10	 mov	 QWORD PTR buf$1$[rbp], rax
  001c7	4c 8b f0	 mov	 r14, rax

; 366  : 	if (!buf) OutOfMemory();

  001ca	48 85 c0	 test	 rax, rax
  001cd	0f 84 be 02 00
	00		 je	 $LN73@rpcBindOrA
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c

; 1079 : 	if (!_recv(sock, bindResponse, LE16(ResponseHeader.FragLength) - sizeof(RPC_HEADER)))

  001d3	44 0f b7 45 20	 movzx	 r8d, WORD PTR ResponseHeader$[rbp+8]
  001d8	45 33 c9	 xor	 r9d, r9d
  001db	41 83 e8 10	 sub	 r8d, 16
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 367  : 	return buf;

  001df	48 89 45 08	 mov	 QWORD PTR bindResponse$1$[rbp], rax
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c

; 1079 : 	if (!_recv(sock, bindResponse, LE16(ResponseHeader.FragLength) - sizeof(RPC_HEADER)))

  001e3	48 8b d0	 mov	 rdx, rax
  001e6	49 8b cf	 mov	 rcx, r15
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 367  : 	return buf;

  001e9	48 8b f8	 mov	 rdi, rax
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c

; 1079 : 	if (!_recv(sock, bindResponse, LE16(ResponseHeader.FragLength) - sizeof(RPC_HEADER)))

  001ec	e8 00 00 00 00	 call	 sendrecv
  001f1	84 c0		 test	 al, al
  001f3	75 1a		 jne	 SHORT $LN13@rpcBindOrA

; 1080 : 	{
; 1081 : 		printerrorf("\nFatal: Incomplete RPC bind acknowledgement received\n");

  001f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DG@CDFCGJFH@?6Fatal?3?5Incomplete?5RPC?5bind?5ack@
  001fc	e8 00 00 00 00	 call	 printerrorf

; 1082 : 		free(bindResponseBytePtr);

  00201	48 8b cf	 mov	 rcx, rdi
  00204	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1083 : 		return RPC_S_COMM_FAILURE;

  0020a	e9 59 ff ff ff	 jmp	 $LN70@rpcBindOrA
$LN13@rpcBindOrA:

; 1084 : 	}
; 1085 : 
; 1086 : 	/*
; 1087 : 	 * checking, whether a bind or alter context response is as expected.
; 1088 : 	 * This check is very strict and checks whether a KMS emulator behaves exactly the same way
; 1089 : 	 * as Microsoft's RPC does.
; 1090 : 	 */
; 1091 : 	status = 0;
; 1092 : 
; 1093 : 	if (bindResponse->SecondaryAddressLength < LE16(3))

  0020f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00215	41 8b f4	 mov	 esi, r12d
  00218	66 45 39 4e 08	 cmp	 WORD PTR [r14+8], r9w
  0021d	73 08		 jae	 SHORT $LN14@rpcBindOrA

; 1094 : 		bindResponse = (RPC_BIND_RESPONSE*)(bindResponseBytePtr - 4);

  0021f	49 8d 7e fc	 lea	 rdi, QWORD PTR [r14-4]
  00223	48 89 7d 08	 mov	 QWORD PTR bindResponse$1$[rbp], rdi
$LN14@rpcBindOrA:

; 1095 : 
; 1096 : 	if (bindResponse->NumResults != bindRequest->NumCtxItems)

  00227	44 8b 47 10	 mov	 r8d, DWORD PTR [rdi+16]
  0022b	8b 53 18	 mov	 edx, DWORD PTR [rbx+24]
  0022e	44 3b c2	 cmp	 r8d, edx
  00231	74 17		 je	 SHORT $LN15@rpcBindOrA

; 1097 : 	{
; 1098 : 		printerrorf("\nFatal: Expected %u CTX items but got %u\n",

  00233	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CK@HPNJNCNH@?6Fatal?3?5Expected?5?$CFu?5CTX?5items?5b@
  0023a	e8 00 00 00 00	 call	 printerrorf

; 1099 : 			(uint32_t)LE32(bindRequest->NumCtxItems),
; 1100 : 			(uint32_t)LE32(bindResponse->NumResults)
; 1101 : 		);
; 1102 : 
; 1103 : 		status = RPC_S_PROTOCOL_ERROR;

  0023f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00245	be c0 06 00 00	 mov	 esi, 1728		; 000006c0H
$LN15@rpcBindOrA:
  0024a	44 8b b5 88 00
	00 00		 mov	 r14d, DWORD PTR tv1004[rbp]
$LL7@rpcBindOrA:

; 1107 : 	{
; 1108 : 		const char* transferSyntaxName =

  00251	66 45 3b e6	 cmp	 r12w, r14w

; 1109 : 			i == CtxBTFN ? "BTFN" : i == CtxNDR64 ? "NDR64" : "NDR32";
; 1110 : 
; 1111 : 		struct CtxResults* ctxResult = bindResponse->Results + i;

  00255	41 0f b7 cc	 movzx	 ecx, r12w
  00259	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05CMNEGGDF@NDR64@
  00260	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:??_C@_05HMEFADFI@NDR32@
  00267	4c 0f 44 f8	 cmove	 r15, rax
  0026b	66 45 3b e5	 cmp	 r12w, r13w
  0026f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04EFGMAIMH@BTFN@
  00276	4c 0f 44 f8	 cmove	 r15, rax
  0027a	48 8d 04 49	 lea	 rax, QWORD PTR [rcx+rcx*2]
  0027e	48 8d 3c c7	 lea	 rdi, QWORD PTR [rdi+rax*8]

; 1112 : 		struct CtxItem* ctxItem = bindRequest->CtxItems + i;
; 1113 : 		if (ctxResult->AckResult == RPC_BIND_NACK) // transfer syntax was declined

  00282	b8 02 00 00 00	 mov	 eax, 2
  00287	4c 6b e9 2c	 imul	 r13, rcx, 44		; 0000002cH
  0028b	66 39 47 14	 cmp	 WORD PTR [rdi+20], ax
  0028f	75 79		 jne	 SHORT $LN16@rpcBindOrA

; 990  : 	for (i = 0; i < 16; i++)

  00291	45 33 ed	 xor	 r13d, r13d
  00294	41 8a cd	 mov	 cl, r13b
$LL42@rpcBindOrA:

; 991  : 	{
; 992  : 		if (guidPtr[i]) return FALSE;

  00297	48 0f be c1	 movsx	 rax, cl
  0029b	44 38 6c 38 18	 cmp	 BYTE PTR [rax+rdi+24], r13b
  002a0	75 0a		 jne	 SHORT $LN62@rpcBindOrA

; 606  : }
; 607  : 
; 608  : 
; 609  : /*
; 610  :  * This is the main RPC server loop. Returns after KMS request has been serviced
; 611  :  * or a timeout has occured.
; 612  :  */
; 613  : void rpcServer(const SOCKET sock, const DWORD rpcAssocGroup, const char* const ipstr)
; 614  : {
; 615  : 	RPC_HEADER  rpcRequestHeader;
; 616  : 	WORD NdrCtx = RPC_INVALID_CTX, Ndr64Ctx = RPC_INVALID_CTX;
; 617  : 
; 618  : 	randomNumberInit();
; 619  : 
; 620  : 	while (_recv(sock, &rpcRequestHeader, sizeof(rpcRequestHeader)))
; 621  : 	{
; 622  : 		//int_fast8_t  _st;
; 623  : 		unsigned int request_len, response_len;
; 624  : 		uint_fast8_t _a;
; 625  : 
; 626  : #if defined(_PEDANTIC) && !defined(NO_LOG)
; 627  : 		checkRpcHeader(&rpcRequestHeader, rpcRequestHeader.PacketType, &logger);
; 628  : #endif // defined(_PEDANTIC) && !defined(NO_LOG)
; 629  : 
; 630  : 		switch (rpcRequestHeader.PacketType)
; 631  : 		{
; 632  : 		case RPC_PT_BIND_REQ:         _a = 0; break;
; 633  : 		case RPC_PT_REQUEST:          _a = 1; break;
; 634  : 		case RPC_PT_ALTERCONTEXT_REQ: _a = 2; break;
; 635  : 		default: return;
; 636  : 		}
; 637  : 
; 638  : 		request_len = LE16(rpcRequestHeader.FragLength) - sizeof(rpcRequestHeader);
; 639  : 
; 640  : 		BYTE requestBuffer[MAX_REQUEST_SIZE + sizeof(RPC_RESPONSE64)];
; 641  : 		BYTE responseBuffer[MAX_RESPONSE_SIZE + sizeof(RPC_HEADER) + sizeof(RPC_RESPONSE64)];
; 642  : 
; 643  : 		RPC_HEADER *rpcResponseHeader = (RPC_HEADER *)responseBuffer;
; 644  : 		RPC_RESPONSE* rpcResponse = (RPC_RESPONSE*)(responseBuffer + sizeof(rpcRequestHeader));
; 645  : 
; 646  : 		// The request is larger than the buffer size
; 647  : 		if (request_len > MAX_REQUEST_SIZE + sizeof(RPC_REQUEST64)) return;
; 648  : 
; 649  : 		// Unable to receive the complete request
; 650  : 		if (!_recv(sock, requestBuffer, request_len)) return;
; 651  : 
; 652  : #       if !defined(SIMPLE_RPC) && defined(_PEDANTIC)
; 653  : 		if (rpcRequestHeader.PacketType == RPC_PT_REQUEST && (rpcRequestHeader.VersionMajor != 5 || rpcRequestHeader.VersionMinor != 0))
; 654  : 		{
; 655  : 			response_len = SendError((RPC_RESPONSE64*)rpcResponse, RPC_NCA_PROTO_ERROR);
; 656  : 		}
; 657  : 		else
; 658  : #		endif // !defined(SIMPLE_RPC) && defined(_PEDANTIC)
; 659  : 		{
; 660  : 			BYTE isValid = (BYTE)_Actions[_a].CheckRequest(requestBuffer, request_len, &NdrCtx, &Ndr64Ctx);
; 661  : 			if (rpcRequestHeader.PacketType != RPC_PT_REQUEST && !isValid) return;
; 662  : 
; 663  : 			// Unable to create a valid response from request
; 664  : 			if (!((response_len = _Actions[_a].GetResponse(requestBuffer, rpcResponse, rpcAssocGroup, sock, &NdrCtx, &Ndr64Ctx, rpcRequestHeader.PacketType != RPC_PT_REQUEST ? rpcRequestHeader.PacketType : isValid, ipstr)))) return;
; 665  : 		}
; 666  : 
; 667  : 		memcpy(rpcResponseHeader, &rpcRequestHeader, sizeof(RPC_HEADER));
; 668  : 
; 669  : #       ifndef SIMPLE_RPC
; 670  : 		if (response_len == 32)
; 671  : 		{
; 672  : 			createRpcHeader(rpcResponseHeader, RPC_PT_FAULT, 0);
; 673  : 			rpcResponseHeader->PacketFlags = RPC_PF_FIRST | RPC_PF_LAST | RPC_PF_NOT_EXEC;
; 674  : 		}
; 675  : 		else
; 676  : #		endif // SIMPLE_RPC
; 677  : 		{
; 678  : 			response_len += sizeof(RPC_HEADER);
; 679  : 			rpcResponseHeader->PacketType = _Actions[_a].ResponsePacketType;
; 680  : 
; 681  : 			if (rpcResponseHeader->PacketType == RPC_PT_ALTERCONTEXT_ACK)
; 682  : 			{
; 683  : 				rpcResponseHeader->PacketFlags = RPC_PF_FIRST | RPC_PF_LAST;
; 684  : 			}
; 685  : 		}
; 686  : 
; 687  : 		rpcResponseHeader->FragLength = LE16((WORD)response_len);
; 688  : 
; 689  : 		if (!_send(sock, responseBuffer, response_len)) return;
; 690  : 
; 691  : 		if (DisconnectImmediately && (rpcResponseHeader->PacketType == RPC_PT_RESPONSE || rpcResponseHeader->PacketType == RPC_PT_FAULT))
; 692  : 			return;
; 693  : 	}
; 694  : }
; 695  : 
; 696  : 
; 697  : /* RPC client functions */
; 698  : 
; 699  : 
; 700  : /*
; 701  :  * Checks RPC header. Returns 0 on success.
; 702  :  * This is mainly for debugging a non Microsoft KMS server that uses its own RPC code.
; 703  :  */
; 704  : static int checkRpcHeader(const RPC_HEADER *const header, const BYTE desiredPacketType, const PRINTFUNC p)
; 705  : {
; 706  : 	int status = 0;
; 707  : 
; 708  : 	if (header->PacketType != desiredPacketType)
; 709  : 	{
; 710  : 		p("Fatal: Received wrong RPC packet type. Expected %u but got %u\n",
; 711  : 			(uint32_t)desiredPacketType,
; 712  : 			header->PacketType
; 713  : 		);
; 714  : 		status = RPC_S_PROTOCOL_ERROR;
; 715  : 	}
; 716  : 
; 717  : 	if (header->DataRepresentation != BE32(0x10000000))
; 718  : 	{
; 719  : 		p("Fatal: RPC response does not conform to Microsoft's limited support of DCE RPC\n");
; 720  : 		status = RPC_S_PROTOCOL_ERROR;
; 721  : 	}
; 722  : 
; 723  : 	if (header->AuthLength != 0)
; 724  : 	{
; 725  : 		p("Fatal: RPC response requests authentication\n");
; 726  : 		status = RPC_S_UNKNOWN_AUTHN_TYPE;
; 727  : 	}
; 728  : 
; 729  : 	// vlmcsd does not support fragmented packets (not yet neccassary)
; 730  : 	if ((header->PacketFlags & (RPC_PF_FIRST | RPC_PF_LAST)) != (RPC_PF_FIRST | RPC_PF_LAST))
; 731  : 	{
; 732  : 		p("Fatal: RPC packet flags RPC_PF_FIRST and RPC_PF_LAST are not both set.\n");
; 733  : 		status = RPC_S_CANNOT_SUPPORT;
; 734  : 	}
; 735  : 
; 736  : 	if (header->PacketFlags & RPC_PF_CANCEL_PENDING)	p("Warning: %s should not be set\n", "RPC_PF_CANCEL_PENDING");
; 737  : 	if (header->PacketFlags & RPC_PF_RESERVED)			p("Warning: %s should not be set\n", "RPC_PF_RESERVED");
; 738  : 	if (header->PacketFlags & RPC_PF_NOT_EXEC)			p("Warning: %s should not be set\n", "RPC_PF_NOT_EXEC");
; 739  : 	if (header->PacketFlags & RPC_PF_MAYBE)				p("Warning: %s should not be set\n", "RPC_PF_MAYBE");
; 740  : 	if (header->PacketFlags & RPC_PF_OBJECT)			p("Warning: %s should not be set\n", "RPC_PF_OBJECT");
; 741  : 
; 742  : 	if (header->VersionMajor != 5 || header->VersionMinor != 0)
; 743  : 	{
; 744  : 		p("Fatal: Expected RPC version 5.0 and got %u.%u\n", header->VersionMajor, header->VersionMinor);
; 745  : 		status = RPC_S_INVALID_VERS_OPTION;
; 746  : 	}
; 747  : 
; 748  : 	return status;
; 749  : }
; 750  : 
; 751  : 
; 752  : /*
; 753  :  * Checks an RPC response header. Does basic header checks by calling checkRpcHeader()
; 754  :  * and then does additional checks if response header complies with the respective request header.
; 755  :  * PRINTFUNC p can be anything that has the same prototype as printf.
; 756  :  * Returns 0 on success.
; 757  :  */
; 758  :  // ReSharper disable once CppIncompatiblePointerConversion
; 759  : static int checkRpcResponseHeader(const RPC_HEADER *const ResponseHeader, const RPC_HEADER *const RequestHeader, const BYTE desiredPacketType, const PRINTFUNC p)
; 760  : {
; 761  : 	static int_fast8_t WineBugDetected = FALSE;
; 762  : 	int status = checkRpcHeader(ResponseHeader, desiredPacketType, p);
; 763  : 
; 764  : 	if (desiredPacketType == RPC_PT_BIND_ACK)
; 765  : 	{
; 766  : 		if ((ResponseHeader->PacketFlags & RPC_PF_MULTIPLEX) != (RequestHeader->PacketFlags & RPC_PF_MULTIPLEX))
; 767  : 		{
; 768  : 			p("Warning: RPC_PF_MULTIPLEX of RPC request and response should match\n");
; 769  : 		}
; 770  : 	}
; 771  : 	else
; 772  : 	{
; 773  : 		if (ResponseHeader->PacketFlags & RPC_PF_MULTIPLEX)
; 774  : 		{
; 775  : 			p("Warning: %s should not be set\n", "RPC_PF_MULTIPLEX");
; 776  : 		}
; 777  : 	}
; 778  : 
; 779  : 	if (!status && ResponseHeader->CallId == LE32(1))
; 780  : 	{
; 781  : 		if (!WineBugDetected)
; 782  : 		{
; 783  : 			p("Warning: Buggy RPC of Wine detected. Call Id of Response is always 1\n");
; 784  : 			WineBugDetected = TRUE;
; 785  : 		}
; 786  : 	}
; 787  : 	else if (ResponseHeader->CallId != RequestHeader->CallId)
; 788  : 	{
; 789  : 		p("Fatal: Sent Call Id %u but received answer for Call Id %u\n",
; 790  : 			(uint32_t)LE32(RequestHeader->CallId),
; 791  : 			(uint32_t)LE32(ResponseHeader->CallId)
; 792  : 		);
; 793  : 
; 794  : 		status = RPC_S_PROTOCOL_ERROR;
; 795  : 	}
; 796  : 
; 797  : 	return status;
; 798  : }
; 799  : 
; 800  : /*
; 801  :  * Sends a KMS request via RPC and receives a response.
; 802  :  * Parameters are raw (encrypted) reqeuests / responses.
; 803  :  * Returns 0 on success.
; 804  :  */
; 805  : RpcStatus rpcSendRequest(const RpcCtx sock, const BYTE *const kmsRequest, const size_t requestSize, BYTE **kmsResponse, size_t *const responseSize)
; 806  : {
; 807  : #define MAX_EXCESS_BYTES 16
; 808  : 	RPC_HEADER *RequestHeader, ResponseHeader;
; 809  : 	RPC_REQUEST64 *RpcRequest;
; 810  : 	RPC_RESPONSE64 _Response;
; 811  : 	int status;
; 812  : 	const int_fast8_t useNdr64 = RpcFlags.HasNDR64 && UseClientRpcNDR64 && firstPacketSent;
; 813  : 	size_t size = sizeof(RPC_HEADER) + (useNdr64 ? sizeof(RPC_REQUEST64) : sizeof(RPC_REQUEST)) + requestSize;
; 814  : 	size_t responseSize2;
; 815  : 
; 816  : 	*kmsResponse = NULL;
; 817  : 
; 818  : 	BYTE *_Request = (BYTE*)vlmcsd_malloc(size);
; 819  : 
; 820  : 	RequestHeader = (RPC_HEADER*)_Request;
; 821  : 	RpcRequest = (RPC_REQUEST64*)(_Request + sizeof(RPC_HEADER));
; 822  : 
; 823  : 	createRpcHeader(RequestHeader, RPC_PT_REQUEST, (WORD)size);
; 824  : 
; 825  : 	// Increment CallId for next Request
; 826  : 	CallId++;
; 827  : 
; 828  : 	RpcRequest->Opnum = 0;
; 829  : 
; 830  : 	if (useNdr64)
; 831  : 	{
; 832  : 		RpcRequest->ContextId = LE16(1); // We negotiate NDR64 always as context 1
; 833  : 		RpcRequest->AllocHint = LE32((DWORD)(requestSize + sizeof(RpcRequest->Ndr64)));
; 834  : 		RpcRequest->Ndr64.DataLength = LE64((uint64_t)requestSize);
; 835  : 		RpcRequest->Ndr64.DataSizeIs = LE64((uint64_t)requestSize);
; 836  : 		memcpy(RpcRequest->Ndr64.Data, kmsRequest, requestSize);
; 837  : 	}
; 838  : 	else
; 839  : 	{
; 840  : 		RpcRequest->ContextId = 0; // We negotiate NDR32 always as context 0
; 841  : 		RpcRequest->AllocHint = LE32((DWORD)(requestSize + sizeof(RpcRequest->Ndr)));
; 842  : 		RpcRequest->Ndr.DataLength = LE32((DWORD)requestSize);
; 843  : 		RpcRequest->Ndr.DataSizeIs = LE32((DWORD)requestSize);
; 844  : 		memcpy(RpcRequest->Ndr.Data, kmsRequest, requestSize);
; 845  : 	}
; 846  : 
; 847  : 	for (;;)
; 848  : 	{
; 849  : 		int bytesread;
; 850  : 
; 851  : 		if (!_send(sock, _Request, (int)size))
; 852  : 		{
; 853  : 			printerrorf("\nFatal: Could not send RPC request\n");
; 854  : 			status = RPC_S_COMM_FAILURE;
; 855  : 			break;
; 856  : 		}
; 857  : 
; 858  : 		if (!_recv(sock, &ResponseHeader, sizeof(RPC_HEADER)))
; 859  : 		{
; 860  : 			printerrorf("\nFatal: No RPC response received from server\n");
; 861  : 			status = RPC_S_COMM_FAILURE;
; 862  : 			break;
; 863  : 		}
; 864  : 
; 865  : 		if ((status = checkRpcResponseHeader(&ResponseHeader, RequestHeader, RPC_PT_RESPONSE, &printerrorf))) break;
; 866  : 
; 867  : 		size = useNdr64 ? sizeof(RPC_RESPONSE64) : sizeof(RPC_RESPONSE);
; 868  : 
; 869  : 		if (size > LE16(ResponseHeader.FragLength) - sizeof(ResponseHeader))
; 870  : 			size = LE16(ResponseHeader.FragLength) - sizeof(ResponseHeader);
; 871  : 
; 872  : 		if (!_recv(sock, &_Response, (int)size))
; 873  : 		{
; 874  : 			printerrorf("\nFatal: RPC response is incomplete\n");
; 875  : 			status = RPC_S_COMM_FAILURE;
; 876  : 			break;
; 877  : 		}
; 878  : 
; 879  : 		if (_Response.CancelCount != 0)
; 880  : 		{
; 881  : 			printerrorf("\nFatal: RPC response cancel count is not 0\n");
; 882  : 			status = RPC_S_CALL_CANCELLED;
; 883  : 			break;
; 884  : 		}
; 885  : 
; 886  : 		if (_Response.ContextId != (useNdr64 ? LE16(1) : 0))
; 887  : 		{
; 888  : 			printerrorf("\nFatal: RPC response context id %u is not bound\n", (unsigned int)LE16(_Response.ContextId));
; 889  : 			status = RPC_X_SS_CONTEXT_DAMAGED;
; 890  : 			break;
; 891  : 		}
; 892  : 
; 893  : 		int_fast8_t sizesMatch;
; 894  : 
; 895  : 		if (useNdr64)
; 896  : 		{
; 897  : 			*responseSize = (size_t)LE64(_Response.Ndr64.DataLength);
; 898  : 			responseSize2 = (size_t)LE64(_Response.Ndr64.DataSizeIs);
; 899  : 
; 900  : 			if (/*!*responseSize ||*/ !_Response.Ndr64.DataSizeMax)
; 901  : 			{
; 902  : 				status = (int)LE32(_Response.Ndr64.status);
; 903  : 				break;
; 904  : 			}
; 905  : 
; 906  : 			sizesMatch = (size_t)LE64(_Response.Ndr64.DataLength) == responseSize2;
; 907  : 		}
; 908  : 		else
; 909  : 		{
; 910  : 			*responseSize = (size_t)LE32(_Response.Ndr.DataLength);
; 911  : 			responseSize2 = (size_t)LE32(_Response.Ndr.DataSizeIs);
; 912  : 
; 913  : 			if (/*!*responseSize ||*/ !_Response.Ndr.DataSizeMax)
; 914  : 			{
; 915  : 				status = (int)LE32(_Response.Ndr.status);
; 916  : 				break;
; 917  : 			}
; 918  : 
; 919  : 			sizesMatch = (size_t)LE32(_Response.Ndr.DataLength) == responseSize2;
; 920  : 		}
; 921  : 
; 922  : 		if (!sizesMatch)
; 923  : 		{
; 924  : 			printerrorf("\nFatal: NDR data length (%u) does not match NDR data size (%u)\n",
; 925  : 				(uint32_t)*responseSize,
; 926  : 				(uint32_t)LE32(_Response.Ndr.DataSizeIs)
; 927  : 			);
; 928  : 
; 929  : 			status = RPC_S_PROTOCOL_ERROR;
; 930  : 			break;
; 931  : 		}
; 932  : 
; 933  : 		*kmsResponse = (BYTE*)vlmcsd_malloc(*responseSize + MAX_EXCESS_BYTES);
; 934  : 
; 935  : 		// If RPC stub is too short, assume missing bytes are zero (same ill behavior as MS RPC)
; 936  : 		memset(*kmsResponse, 0, *responseSize + MAX_EXCESS_BYTES);
; 937  : 
; 938  : 		// Read up to 16 bytes more than bytes expected to detect faulty KMS emulators
; 939  : 		if ((bytesread = recv(sock, (char*)*kmsResponse, (int)(*responseSize) + MAX_EXCESS_BYTES, 0)) < (int)*responseSize)
; 940  : 		{
; 941  : 			printerrorf("\nFatal: No or incomplete KMS response received. Required %u bytes but only got %i\n",
; 942  : 				(uint32_t)*responseSize,
; 943  : 				(int32_t)(bytesread < 0 ? 0 : bytesread)
; 944  : 			);
; 945  : 
; 946  : 			status = RPC_S_PROTOCOL_ERROR;
; 947  : 			break;
; 948  : 		}
; 949  : 
; 950  : 		DWORD *pReturnCode;
; 951  : 
; 952  : 		const size_t len = *responseSize + (useNdr64 ? sizeof(_Response.Ndr64) : sizeof(_Response.Ndr)) + sizeof(*pReturnCode);
; 953  : 		const size_t pad = ((~len & 3) + 1) & 3;
; 954  : 
; 955  : 		if (len + pad != LE32(_Response.AllocHint))
; 956  : 		{
; 957  : 			printerrorf("\nWarning: RPC stub size is %u, should be %u (probably incorrect padding)\n", (uint32_t)LE32(_Response.AllocHint), (uint32_t)(len + pad));
; 958  : 		}
; 959  : 		else
; 960  : 		{
; 961  : 			size_t i;
; 962  : 			for (i = 0; i < pad; i++)
; 963  : 			{
; 964  : 				if (*(*kmsResponse + *responseSize + sizeof(*pReturnCode) + i))
; 965  : 				{
; 966  : 					printerrorf("\nWarning: RPC stub data not padded to zeros according to Microsoft standard\n");
; 967  : 					break;
; 968  : 				}
; 969  : 			}
; 970  : 		}
; 971  : 
; 972  : 		pReturnCode = (DWORD*)(*kmsResponse + *responseSize + pad);
; 973  : 		status = GET_UA32LE(pReturnCode);
; 974  : 		//status = LE32(UA32(pReturnCode));
; 975  : 
; 976  : 		break;
; 977  : 	}
; 978  : 
; 979  : 	free(_Request);
; 980  : 	firstPacketSent = TRUE;
; 981  : 	return status;
; 982  : #undef MAX_EXCESS_BYTES
; 983  : }
; 984  : 
; 985  : 
; 986  : static int_fast8_t IsNullGuid(const BYTE* guidPtr)
; 987  : {
; 988  : 	int_fast8_t i;
; 989  : 
; 990  : 	for (i = 0; i < 16; i++)

  002a2	80 c1 01	 add	 cl, 1
  002a5	80 f9 10	 cmp	 cl, 16
  002a8	7c ed		 jl	 SHORT $LL42@rpcBindOrA

; 991  : 	{
; 992  : 		if (guidPtr[i]) return FALSE;

  002aa	eb 0f		 jmp	 SHORT $LN17@rpcBindOrA
$LN62@rpcBindOrA:

; 1114 : 		{
; 1115 : 			if (!IsNullGuid((BYTE*)&ctxResult->TransferSyntax))
; 1116 : 			{
; 1117 : 				printerrorf(

  002ac	49 8b d7	 mov	 rdx, r15
  002af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EA@FALBNLMF@?6Warning?3?5Rejected?5transfer?5syn@
  002b6	e8 00 00 00 00	 call	 printerrorf
$LN17@rpcBindOrA:

; 1118 : 					"\nWarning: Rejected transfer syntax %s did not return NULL Guid\n",
; 1119 : 					transferSyntaxName
; 1120 : 				);
; 1121 : 			}
; 1122 : 
; 1123 : 			if (ctxResult->SyntaxVersion)

  002bb	44 8b 47 28	 mov	 r8d, DWORD PTR [rdi+40]
  002bf	45 85 c0	 test	 r8d, r8d
  002c2	74 0f		 je	 SHORT $LN18@rpcBindOrA

; 1124 : 			{
; 1125 : 				printerrorf(

  002c4	49 8b d7	 mov	 rdx, r15
  002c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EO@LKGEJEDI@?6Warning?3?5Rejected?5transfer?5syn@
  002ce	e8 00 00 00 00	 call	 printerrorf
$LN18@rpcBindOrA:

; 1126 : 					"\nWarning: Rejected transfer syntax %s did not return syntax version 0 but %u\n",
; 1127 : 					transferSyntaxName,
; 1128 : 					LE32(ctxResult->SyntaxVersion)
; 1129 : 				);
; 1130 : 			}
; 1131 : 
; 1132 : 			if (ctxResult->AckReason == RPC_ABSTRACTSYNTAX_UNSUPPORTED)

  002d3	b8 01 00 00 00	 mov	 eax, 1
  002d8	66 39 47 16	 cmp	 WORD PTR [rdi+22], ax
  002dc	75 09		 jne	 SHORT $LN19@rpcBindOrA

; 1133 : 			{
; 1134 : 				printerrorf(

  002de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DO@PHEPNPBJ@?6Warning?3?5Transfer?5syntax?5?$CFs?5do@

; 1135 : 					"\nWarning: Transfer syntax %s does not support KMS activation\n",
; 1136 : 					transferSyntaxName
; 1137 : 				);
; 1138 : 			}

  002e5	eb 16		 jmp	 SHORT $LN71@rpcBindOrA
$LN19@rpcBindOrA:

; 1139 : 			else if (ctxResult->AckReason != RPC_SYNTAX_UNSUPPORTED)

  002e7	b8 02 00 00 00	 mov	 eax, 2
  002ec	66 39 47 16	 cmp	 WORD PTR [rdi+22], ax
  002f0	0f 84 3b 01 00
	00		 je	 $LN5@rpcBindOrA

; 1140 : 			{
; 1141 : 				printerrorf(

  002f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0FI@PEIELJGO@?6Warning?3?5Rejected?5transfer?5syn@
$LN71@rpcBindOrA:

; 1104 : 	}
; 1105 : 
; 1106 : 	for (i = 0; i < ctxItems; i++)

  002fd	49 8b d7	 mov	 rdx, r15
  00300	e8 00 00 00 00	 call	 printerrorf
  00305	e9 27 01 00 00	 jmp	 $LN5@rpcBindOrA
$LN16@rpcBindOrA:

; 1142 : 					"\nWarning: Rejected transfer syntax %s did not return ack reason RPC_SYNTAX_UNSUPPORTED\n",
; 1143 : 					transferSyntaxName
; 1144 : 				);
; 1145 : 			}
; 1146 : 
; 1147 : 			continue;
; 1148 : 		}
; 1149 : 
; 1150 : 		if (i == CtxBTFN) // BTFN

  0030a	66 44 3b 65 78	 cmp	 r12w, WORD PTR tv1078[rbp]
  0030f	75 55		 jne	 SHORT $LN22@rpcBindOrA

; 1151 : 		{
; 1152 : 			if (ctxResult->AckResult != RPC_BIND_ACK)

  00311	66 44 39 4f 14	 cmp	 WORD PTR [rdi+20], r9w
  00316	74 12		 je	 SHORT $LN23@rpcBindOrA

; 1153 : 			{
; 1154 : 				printerrorf("\nWarning: BTFN did not respond with RPC_BIND_ACK or RPC_BIND_NACK\n");

  00318	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0ED@ONOBBCGN@?6Warning?3?5BTFN?5did?5not?5respond?5@
  0031f	e8 00 00 00 00	 call	 printerrorf
  00324	41 b9 03 00 00
	00		 mov	 r9d, 3
$LN23@rpcBindOrA:

; 1155 : 			}
; 1156 : 
; 1157 : 			if (ctxResult->AckReason != LE16(3))

  0032a	66 44 39 4f 16	 cmp	 WORD PTR [rdi+22], r9w
  0032f	74 10		 je	 SHORT $LN24@rpcBindOrA

; 1158 : 			{
; 1159 : 				printerrorf("\nWarning: BTFN did not return expected feature mask 0x3 but 0x%X\n", (unsigned int)LE16(ctxResult->AckReason));

  00331	0f b7 57 16	 movzx	 edx, WORD PTR [rdi+22]
  00335	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EC@EDPPOAMK@?6Warning?3?5BTFN?5did?5not?5return?5e@
  0033c	e8 00 00 00 00	 call	 printerrorf
$LN24@rpcBindOrA:

; 1160 : 			}
; 1161 : 
; 1162 : 			if (verbose) printf("... BTFN ");

  00341	45 33 ff	 xor	 r15d, r15d
  00344	44 38 bd 80 00
	00 00		 cmp	 BYTE PTR verbose$[rbp], r15b
  0034b	74 0c		 je	 SHORT $LN25@rpcBindOrA
  0034d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09PKGPPFMG@?4?4?4?5BTFN?5@
  00354	e8 00 00 00 00	 call	 printf
$LN25@rpcBindOrA:

; 1163 : 			RpcFlags.HasBTFN = TRUE;

  00359	0f ba 2d 00 00
	00 00 12	 bts	 DWORD PTR RpcFlags, 18

; 1164 : 
; 1165 : 			continue;

  00361	e9 cb 00 00 00	 jmp	 $LN5@rpcBindOrA
$LN22@rpcBindOrA:

; 1166 : 		}
; 1167 : 
; 1168 : 		// NDR32 or NDR64 Ctx
; 1169 : 		if (ctxResult->AckResult != RPC_BIND_ACCEPT)

  00366	33 c0		 xor	 eax, eax
  00368	66 39 47 14	 cmp	 WORD PTR [rdi+20], ax
  0036c	74 14		 je	 SHORT $LN26@rpcBindOrA

; 1170 : 		{
; 1171 : 			printerrorf(

  0036e	49 8b d7	 mov	 rdx, r15
  00371	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0GC@NGOEMPDA@?6Fatal?3?5transfer?5syntax?5?$CFs?5retu@
  00378	e8 00 00 00 00	 call	 printerrorf

; 1172 : 				"\nFatal: transfer syntax %s returned an invalid status, neither RPC_BIND_ACCEPT nor RPC_BIND_NACK\n",
; 1173 : 				transferSyntaxName
; 1174 : 			);
; 1175 : 
; 1176 : 			status = RPC_S_PROTOCOL_ERROR;

  0037d	be c0 06 00 00	 mov	 esi, 1728		; 000006c0H
$LN26@rpcBindOrA:

; 1177 : 		}
; 1178 : 
; 1179 : 		if (!IsEqualGUID(&ctxResult->TransferSyntax, &ctxItem->TransferSyntax))

  00382	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00386	4a 3b 44 2b 34	 cmp	 rax, QWORD PTR [rbx+r13+52]
  0038b	75 0b		 jne	 SHORT $LN64@rpcBindOrA
  0038d	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00391	4a 3b 44 2b 3c	 cmp	 rax, QWORD PTR [rbx+r13+60]
  00396	74 11		 je	 SHORT $LN27@rpcBindOrA
$LN64@rpcBindOrA:

; 1180 : 		{
; 1181 : 			printerrorf(

  00398	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EJ@PGIIMLOK@?6Fatal?3?5Transfer?5syntax?5of?5RPC?5@
  0039f	e8 00 00 00 00	 call	 printerrorf

; 1182 : 				"\nFatal: Transfer syntax of RPC bind request and response does not match\n"
; 1183 : 			);
; 1184 : 
; 1185 : 			status = RPC_S_UNSUPPORTED_TRANS_SYN;

  003a4	be c2 06 00 00	 mov	 esi, 1730		; 000006c2H
$LN27@rpcBindOrA:

; 1186 : 		}
; 1187 : 
; 1188 : 		if (ctxResult->SyntaxVersion != ctxItem->SyntaxVersion)

  003a9	44 8b 4f 28	 mov	 r9d, DWORD PTR [rdi+40]
  003ad	42 8b 54 2b 44	 mov	 edx, DWORD PTR [rbx+r13+68]
  003b2	44 3b ca	 cmp	 r9d, edx
  003b5	74 14		 je	 SHORT $LN28@rpcBindOrA

; 1189 : 		{
; 1190 : 			printerrorf("\nFatal: Expected transfer syntax version %u for %s but got %u\n",

  003b7	4d 8b c7	 mov	 r8, r15
  003ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DP@BHGLCOFK@?6Fatal?3?5Expected?5transfer?5synta@
  003c1	e8 00 00 00 00	 call	 printerrorf

; 1191 : 				(uint32_t)LE32(ctxItem->SyntaxVersion),
; 1192 : 				transferSyntaxName,
; 1193 : 				(uint32_t)LE32(ctxResult->SyntaxVersion)
; 1194 : 			);
; 1195 : 
; 1196 : 			status = RPC_S_UNSUPPORTED_TRANS_SYN;

  003c6	be c2 06 00 00	 mov	 esi, 1730		; 000006c2H
$LN28@rpcBindOrA:

; 1197 : 		}
; 1198 : 
; 1199 : 		// The ack reason field is actually undefined here but Microsoft sets this to 0
; 1200 : 		if (ctxResult->AckReason != 0)

  003cb	45 33 ff	 xor	 r15d, r15d
  003ce	66 44 39 7f 16	 cmp	 WORD PTR [rdi+22], r15w
  003d3	74 10		 je	 SHORT $LN29@rpcBindOrA

; 1201 : 		{
; 1202 : 			printerrorf(

  003d5	0f b7 57 16	 movzx	 edx, WORD PTR [rdi+22]
  003d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CM@HGMDMAM@?6Warning?3?5Ack?5reason?5should?5be?5@
  003e0	e8 00 00 00 00	 call	 printerrorf
$LN29@rpcBindOrA:

; 1203 : 				"\nWarning: Ack reason should be 0 but is %u\n",
; 1204 : 				LE16(ctxResult->AckReason)
; 1205 : 			);
; 1206 : 		}
; 1207 : 
; 1208 : 		if (!status)

  003e5	85 f6		 test	 esi, esi
  003e7	75 48		 jne	 SHORT $LN5@rpcBindOrA

; 1209 : 		{
; 1210 : 			if (i == CtxNDR64)

  003e9	8a 85 80 00 00
	00		 mov	 al, BYTE PTR verbose$[rbp]
  003ef	66 45 3b e6	 cmp	 r12w, r14w
  003f3	75 1e		 jne	 SHORT $LN32@rpcBindOrA

; 1211 : 			{
; 1212 : 				RpcFlags.HasNDR64 = TRUE;

  003f5	0f ba 2d 00 00
	00 00 11	 bts	 DWORD PTR RpcFlags, 17

; 1213 : 				if (verbose) printf("... NDR64 ");

  003fd	84 c0		 test	 al, al
  003ff	74 12		 je	 SHORT $LN32@rpcBindOrA
  00401	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMLPGKA@?4?4?4?5NDR64?5@
  00408	e8 00 00 00 00	 call	 printf
  0040d	8a 85 80 00 00
	00		 mov	 al, BYTE PTR verbose$[rbp]
$LN32@rpcBindOrA:

; 1214 : 			}
; 1215 : 			if (!i)

  00413	66 45 85 e4	 test	 r12w, r12w
  00417	75 18		 jne	 SHORT $LN5@rpcBindOrA

; 1216 : 			{
; 1217 : 				RpcFlags.HasNDR32 = TRUE;

  00419	0f ba 2d 00 00
	00 00 10	 bts	 DWORD PTR RpcFlags, 16

; 1218 : 				if (verbose) printf("... NDR32 ");

  00421	84 c0		 test	 al, al
  00423	74 0c		 je	 SHORT $LN5@rpcBindOrA
  00425	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DAJIHKCA@?4?4?4?5NDR32?5@
  0042c	e8 00 00 00 00	 call	 printf
$LN5@rpcBindOrA:

; 1104 : 	}
; 1105 : 
; 1106 : 	for (i = 0; i < ctxItems; i++)

  00431	48 8b 7d 08	 mov	 rdi, QWORD PTR bindResponse$1$[rbp]
  00435	66 41 ff c4	 inc	 r12w
  00439	41 b9 03 00 00
	00		 mov	 r9d, 3
  0043f	44 8b 6d 78	 mov	 r13d, DWORD PTR tv1078[rbp]
  00443	66 44 3b 65 00	 cmp	 r12w, WORD PTR tv917[rbp]
  00448	0f 82 03 fe ff
	ff		 jb	 $LL7@rpcBindOrA

; 1219 : 			}
; 1220 : 
; 1221 : 		}
; 1222 : 	}
; 1223 : 
; 1224 : 	free(bindResponseBytePtr);

  0044e	48 8b 4d 10	 mov	 rcx, QWORD PTR buf$1$[rbp]
  00452	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1225 : 
; 1226 : 	if (!RpcFlags.HasNDR64 && !RpcFlags.HasNDR32)

  00458	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR RpcFlags
  0045e	0f ba e0 11	 bt	 eax, 17
  00462	72 17		 jb	 SHORT $LN35@rpcBindOrA
  00464	0f ba e0 10	 bt	 eax, 16
  00468	72 11		 jb	 SHORT $LN35@rpcBindOrA

; 1227 : 	{
; 1228 : 		printerrorf("\nFatal: Could neither negotiate NDR32 nor NDR64 with the RPC server\n");

  0046a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EF@PFAMEHMF@?6Fatal?3?5Could?5neither?5negotiate@
  00471	e8 00 00 00 00	 call	 printerrorf

; 1229 : 		status = RPC_S_NO_PROTSEQS;

  00476	be b7 06 00 00	 mov	 esi, 1719		; 000006b7H
$LN35@rpcBindOrA:

; 1230 : 	}
; 1231 : 
; 1232 : 	return status;

  0047b	8b c6		 mov	 eax, esi
$LN1@rpcBindOrA:

; 1233 : }

  0047d	48 8b 5d 70	 mov	 rbx, QWORD PTR [rbp+112]
  00481	48 8d 65 30	 lea	 rsp, QWORD PTR [rbp+48]
  00485	41 5f		 pop	 r15
  00487	41 5e		 pop	 r14
  00489	41 5d		 pop	 r13
  0048b	41 5c		 pop	 r12
  0048d	5f		 pop	 rdi
  0048e	5e		 pop	 rsi
  0048f	5d		 pop	 rbp
  00490	c3		 ret	 0
$LN73@rpcBindOrA:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 366  : 	if (!buf) OutOfMemory();

  00491	e8 00 00 00 00	 call	 OutOfMemory
  00496	cc		 int	 3
$LN67@rpcBindOrA:
rpcBindOrAlterClientContext ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\rpc.c
;	COMDAT rpcBindClient
_TEXT	SEGMENT
sock$ = 48
verbose$ = 56
rpcDiag$ = 64
rpcBindClient PROC					; COMDAT

; 1236 : {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1237 : 	firstPacketSent = FALSE;
; 1238 : 	RpcFlags.mask = 0;

  0000f	83 25 00 00 00
	00 00		 and	 DWORD PTR RpcFlags, 0
  00016	49 8b d8	 mov	 rbx, r8

; 1239 : 
; 1240 : 	RpcStatus status =

  00019	44 8a c2	 mov	 r8b, dl
  0001c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR firstPacketSent, 0
  00023	40 8a fa	 mov	 dil, dl
  00026	48 8b f1	 mov	 rsi, rcx
  00029	b2 0b		 mov	 dl, 11
  0002b	e8 00 00 00 00	 call	 rpcBindOrAlterClientContext
  00030	44 8b c0	 mov	 r8d, eax

; 1241 : 		rpcBindOrAlterClientContext(sock, RPC_PT_BIND_REQ, verbose);
; 1242 : 
; 1243 : 	if (status) goto end;

  00033	85 c0		 test	 eax, eax
  00035	75 1c		 jne	 SHORT $end$7

; 1244 : 
; 1245 : 	if (!RpcFlags.HasNDR32)

  00037	f7 05 00 00 00
	00 00 00 01 00	 test	 DWORD PTR RpcFlags, 65536 ; 00010000H
  00041	75 10		 jne	 SHORT $end$7

; 1246 : 		status = rpcBindOrAlterClientContext(sock, RPC_PT_ALTERCONTEXT_REQ, verbose);

  00043	44 8a c7	 mov	 r8b, dil
  00046	b2 0e		 mov	 dl, 14
  00048	48 8b ce	 mov	 rcx, rsi
  0004b	e8 00 00 00 00	 call	 rpcBindOrAlterClientContext
  00050	44 8b c0	 mov	 r8d, eax
$end$7:

; 1247 : 
; 1248 : end:
; 1249 : 	rpcDiag->HasRpcDiag = TRUE;
; 1250 : 	rpcDiag->HasNDR64 = !!RpcFlags.HasNDR64;
; 1251 : 	rpcDiag->HasBTFN = !!RpcFlags.HasBTFN;
; 1252 : 	return status;
; 1253 : }

  00053	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00058	c6 03 01	 mov	 BYTE PTR [rbx], 1
  0005b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR RpcFlags
  00061	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  00066	c1 e8 11	 shr	 eax, 17
  00069	88 43 02	 mov	 BYTE PTR [rbx+2], al
  0006c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR RpcFlags
  00072	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00077	c1 e8 12	 shr	 eax, 18
  0007a	88 43 01	 mov	 BYTE PTR [rbx+1], al
  0007d	41 8b c0	 mov	 eax, r8d
  00080	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00085	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00089	5f		 pop	 rdi
  0008a	c3		 ret	 0
rpcBindClient ENDP
_TEXT	ENDS
END
