; Listing generated by Microsoft (R) Optimizing Compiler Version 19.32.31332.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_07NBCGADJA@Unknown@			; `string'
PUBLIC	??_C@_01FGNFDNOH@?$CF@				; `string'
PUBLIC	??_C@_01OMGOGALD@u@				; `string'
PUBLIC	??_C@_04PGKABKNA@?903?9@			; `string'
PUBLIC	??_C@_06KMCAJKLF@?40000?9@			; `string'
PUBLIC	??_C@_0BM@KDKADHPB@randomized?5at?5program?5start@ ; `string'
PUBLIC	??_C@_0BK@PGELFKLD@?$DM?$DM?$DM?5Incoming?5KMS?5request?6@ ; `string'
PUBLIC	??_C@_0CD@NIMMPCGA@KMS?5v?$CFi?4?$CFi?5request?5from?5?$CFs?5for?5@ ; `string'
PUBLIC	??_C@_0BM@JLIHBDJL@randomized?5on?5every?5request@ ; `string'
PUBLIC	??_C@_0P@CACDFLGA@vlmcsd?5default@		; `string'
PUBLIC	??_C@_0BH@ECOFGFLJ@Sending?5ePID?5?$CI?$CFs?$CJ?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CI@NLELAFGA@?$DO?$DO?$DO?5Sending?5response?0?5ePID?5sour@ ; `string'
PUBLIC	??_C@_0EE@GPFGCDIC@Rejecting?5request?5with?5more?5tha@ ; `string'
PUBLIC	??_C@_0EF@NBMAOLBH@Client?5time?5differs?5more?5than?54@ ; `string'
PUBLIC	??_C@_0CO@GEBKAAHB@Refusing?5retail?5or?5beta?5product@ ; `string'
PUBLIC	??_C@_0CH@OKECOFDM@Refusing?5unknown?5product?5?$CI0xC00@ ; `string'
PUBLIC	??_C@_0DN@KPFNIABO@Refusing?5product?5with?5incorrect@ ; `string'
PUBLIC	??_C@_0CO@CIIKPOBH@Rejecting?5more?5than?5671?5clients@ ; `string'
PUBLIC	CreateResponseBase
EXTRN	__imp__time64:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp_rand:PROC
EXTRN	__imp__gmtime64:PROC
EXTRN	__imp_InitializeCriticalSection:PROC
EXTRN	__imp_LeaveCriticalSection:PROC
EXTRN	__imp_EnterCriticalSection:PROC
COMM	mutex:QWORD
_DATA	ENDS
_DATA	ENDS
;	COMDAT ??_C@_0CO@CIIKPOBH@Rejecting?5more?5than?5671?5clients@
CONST	SEGMENT
??_C@_0CO@CIIKPOBH@Rejecting?5more?5than?5671?5clients@ DB 'Rejecting mor'
	DB	'e than 671 clients (0xC004D104)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@KPFNIABO@Refusing?5product?5with?5incorrect@
CONST	SEGMENT
??_C@_0DN@KPFNIABO@Refusing?5product?5with?5incorrect@ DB 'Refusing produ'
	DB	'ct with incorrect Application ID (0xC004F042)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OKECOFDM@Refusing?5unknown?5product?5?$CI0xC00@
CONST	SEGMENT
??_C@_0CH@OKECOFDM@Refusing?5unknown?5product?5?$CI0xC00@ DB 'Refusing un'
	DB	'known product (0xC004F042)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GEBKAAHB@Refusing?5retail?5or?5beta?5product@
CONST	SEGMENT
??_C@_0CO@GEBKAAHB@Refusing?5retail?5or?5beta?5product@ DB 'Refusing reta'
	DB	'il or beta product (0xC004F042)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@NBMAOLBH@Client?5time?5differs?5more?5than?54@
CONST	SEGMENT
??_C@_0EF@NBMAOLBH@Client?5time?5differs?5more?5than?54@ DB 'Client time '
	DB	'differs more than 4 hours from system time (0xC004F06C)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@GPFGCDIC@Rejecting?5request?5with?5more?5tha@
CONST	SEGMENT
??_C@_0EE@GPFGCDIC@Rejecting?5request?5with?5more?5tha@ DB 'Rejecting req'
	DB	'uest with more than 1000 minimum clients (0x8007000D)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NLELAFGA@?$DO?$DO?$DO?5Sending?5response?0?5ePID?5sour@
CONST	SEGMENT
??_C@_0CI@NLELAFGA@?$DO?$DO?$DO?5Sending?5response?0?5ePID?5sour@ DB '>>>'
	DB	' Sending response, ePID source = %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@ECOFGFLJ@Sending?5ePID?5?$CI?$CFs?$CJ?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@ECOFGFLJ@Sending?5ePID?5?$CI?$CFs?$CJ?3?5?$CFs?6@ DB 'Sending e'
	DB	'PID (%s): %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CACDFLGA@vlmcsd?5default@
CONST	SEGMENT
??_C@_0P@CACDFLGA@vlmcsd?5default@ DB 'vlmcsd default', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JLIHBDJL@randomized?5on?5every?5request@
CONST	SEGMENT
??_C@_0BM@JLIHBDJL@randomized?5on?5every?5request@ DB 'randomized on ever'
	DB	'y request', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NIMMPCGA@KMS?5v?$CFi?4?$CFi?5request?5from?5?$CFs?5for?5@
CONST	SEGMENT
??_C@_0CD@NIMMPCGA@KMS?5v?$CFi?4?$CFi?5request?5from?5?$CFs?5for?5@ DB 'K'
	DB	'MS v%i.%i request from %s for %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PGELFKLD@?$DM?$DM?$DM?5Incoming?5KMS?5request?6@
CONST	SEGMENT
??_C@_0BK@PGELFKLD@?$DM?$DM?$DM?5Incoming?5KMS?5request?6@ DB '<<< Incomi'
	DB	'ng KMS request', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KDKADHPB@randomized?5at?5program?5start@
CONST	SEGMENT
??_C@_0BM@KDKADHPB@randomized?5at?5program?5start@ DB 'randomized at prog'
	DB	'ram start', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06KMCAJKLF@?40000?9@
CONST	SEGMENT
??_C@_06KMCAJKLF@?40000?9@ DB '.0000-', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PGKABKNA@?903?9@
CONST	SEGMENT
??_C@_04PGKABKNA@?903?9@ DB '-03-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OMGOGALD@u@
CONST	SEGMENT
??_C@_01OMGOGALD@u@ DB 'u', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01FGNFDNOH@?$CF@
CONST	SEGMENT
??_C@_01FGNFDNOH@?$CF@ DB '%', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown@ DB 'Unknown', 00H		; `string'
LcidList DW	0436H
	DW	041cH
	DW	0401H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01401H
	DW	01801H
	DW	01c01H
	DW	02001H
	DW	02401H
	DW	02801H
	DW	02c01H
	DW	03001H
	DW	03401H
	DW	03801H
	DW	03c01H
	DW	04001H
	DW	042bH
	DW	042cH
	DW	082cH
	DW	042dH
	DW	0423H
	DW	0445H
	DW	0141aH
	DW	0402H
	DW	0403H
	DW	0404H
	DW	0804H
	DW	0c04H
	DW	01004H
	DW	01404H
	DW	041aH
	DW	0101aH
	DW	0405H
	DW	0406H
	DW	0465H
	DW	0413H
	DW	0813H
	DW	0409H
	DW	0809H
	DW	0c09H
	DW	01009H
	DW	01409H
	DW	01809H
	DW	01c09H
	DW	02009H
	DW	02409H
	DW	02809H
	DW	02c09H
	DW	03009H
	DW	03409H
	DW	0425H
	DW	0438H
	DW	0429H
	DW	040bH
	DW	040cH
	DW	080cH
	DW	0c0cH
	DW	0100cH
	DW	0140cH
	DW	0180cH
	DW	0437H
	DW	0456H
	DW	0407H
	DW	0807H
	DW	0c07H
	DW	01007H
	DW	01407H
	DW	0408H
	DW	0447H
	DW	040dH
	DW	0439H
	DW	040eH
	DW	040fH
	DW	0421H
	DW	0410H
	DW	0810H
	DW	0411H
	DW	044bH
	DW	043fH
	DW	0457H
	DW	0412H
	DW	0440H
	DW	0426H
	DW	0427H
	DW	042fH
	DW	043eH
	DW	083eH
	DW	044cH
	DW	043aH
	DW	0481H
	DW	044eH
	DW	0450H
	DW	0414H
	DW	0814H
	DW	0415H
	DW	0416H
	DW	0816H
	DW	0446H
	DW	046bH
	DW	086bH
	DW	0c6bH
	DW	0418H
	DW	0419H
	DW	0243bH
	DW	0103bH
	DW	0143bH
	DW	0c3bH
	DW	043bH
	DW	083bH
	DW	0203bH
	DW	0183bH
	DW	01c3bH
	DW	044fH
	DW	081aH
	DW	0181aH
	DW	0c1aH
	DW	01c1aH
	DW	041bH
	DW	0424H
	DW	040aH
	DW	080aH
	DW	0c0aH
	DW	0100aH
	DW	0140aH
	DW	0180aH
	DW	01c0aH
	DW	0200aH
	DW	0240aH
	DW	0280aH
	DW	02c0aH
	DW	0300aH
	DW	0340aH
	DW	0380aH
	DW	03c0aH
	DW	0400aH
	DW	0440aH
	DW	0480aH
	DW	04c0aH
	DW	0500aH
	DW	0441H
	DW	041dH
	DW	081dH
	DW	045aH
	DW	0449H
	DW	0444H
	DW	044aH
	DW	041eH
	DW	0432H
	DW	0422H
	DW	0420H
	DW	0443H
	DW	0843H
	DW	042aH
	DW	0452H
	DW	0434H
	DW	0435H
	ORG $+4
CreateResponseBase DQ FLAT:CreateResponseBaseCallback
?DefaultHwId@?1??CreateResponseV6@@9@9 DB 03aH		; `CreateResponseV6'::`2'::DefaultHwId
	DB	01cH
	DB	04H
	DB	096H
	DB	00H
	DB	0b6H
	DB	00H
	DB	076H
PUBLIC	DecryptResponseV6
PUBLIC	DecryptResponseV4
PUBLIC	CreateRequestV6
PUBLIC	CreateRequestV4
PUBLIC	CreateResponseV6
PUBLIC	CreateResponseV4
PUBLIC	get16RandomBytes
PUBLIC	randomPidInit
PUBLIC	InitializeClientLists
PUBLIC	CleanUpClientLists
PUBLIC	fileTimeToUnixTime
PUBLIC	getUnixTimeAsFileTime
PUBLIC	getReleaseDate
PUBLIC	getPlatformId
PUBLIC	getNextString
PUBLIC	getProductIndex
PUBLIC	sprintf
PUBLIC	_vsprintf_l
PUBLIC	_vsnprintf_l
PUBLIC	__local_stdio_printf_options
ClientLists DQ	01H DUP (?)
ZeroGuid DB	010H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptResponseV6 DD imagerel $LN35
	DD	imagerel $LN35+690
	DD	imagerel $unwind$DecryptResponseV6
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$VerifyResponseV6 DD imagerel VerifyResponseV6
	DD	imagerel VerifyResponseV6+229
	DD	imagerel $unwind$VerifyResponseV6
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptResponseV4 DD imagerel $LN8
	DD	imagerel $LN8+299
	DD	imagerel $unwind$DecryptResponseV4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateRequestV6 DD imagerel $LN10
	DD	imagerel $LN10+323
	DD	imagerel $unwind$CreateRequestV6
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateRequestV4 DD imagerel $LN10
	DD	imagerel $LN10+215
	DD	imagerel $unwind$CreateRequestV4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateResponseV6 DD imagerel $LN17
	DD	imagerel $LN17+413
	DD	imagerel $unwind$CreateResponseV6
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateV6Hmac DD imagerel CreateV6Hmac
	DD	imagerel CreateV6Hmac+148
	DD	imagerel $unwind$CreateV6Hmac
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateResponseV4 DD imagerel $LN5
	DD	imagerel $LN5+94
	DD	imagerel $unwind$CreateResponseV4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get16RandomBytes DD imagerel $LN11
	DD	imagerel $LN11+96
	DD	imagerel $unwind$get16RandomBytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateResponseBaseCallback DD imagerel CreateResponseBaseCallback
	DD	imagerel CreateResponseBaseCallback+991
	DD	imagerel $unwind$CreateResponseBaseCallback
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$logResponse DD imagerel logResponse
	DD	imagerel logResponse+127
	DD	imagerel $unwind$logResponse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getEpid DD imagerel getEpid
	DD	imagerel getEpid+172
	DD	imagerel $unwind$getEpid
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getEpidFromString DD imagerel getEpidFromString
	DD	imagerel getEpidFromString+34
	DD	imagerel $unwind$getEpidFromString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$logRequest DD imagerel logRequest
	DD	imagerel logRequest+233
	DD	imagerel $unwind$logRequest
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getProductIndexFromAllLists DD imagerel getProductIndexFromAllLists
	DD	imagerel getProductIndexFromAllLists+46
	DD	imagerel $unwind$getProductIndexFromAllLists
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$randomPidInit DD imagerel $LN24
	DD	imagerel $LN24+338
	DD	imagerel $unwind$randomPidInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$generateRandomPid DD imagerel generateRandomPid
	DD	imagerel generateRandomPid+939
	DD	imagerel $unwind$generateRandomPid
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getRandomServerType DD imagerel getRandomServerType
	DD	imagerel getRandomServerType+67
	DD	imagerel $unwind$getRandomServerType
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$itoc DD	imagerel itoc
	DD	imagerel itoc+94
	DD	imagerel $unwind$itoc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$InitializeClientLists DD imagerel $LN33
	DD	imagerel $LN33+294
	DD	imagerel $unwind$InitializeClientLists
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getUnixTimeAsFileTime DD imagerel $LN6
	DD	imagerel $LN6+46
	DD	imagerel $unwind$getUnixTimeAsFileTime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN8
	DD	imagerel $LN8+87
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN6
	DD	imagerel $LN6+87
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN4
	DD	imagerel $LN4+91
	DD	imagerel $unwind$_vsnprintf_l
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getUnixTimeAsFileTime DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$InitializeClientLists DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$itoc DD	020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getRandomServerType DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$generateRandomPid DD 0c1f01H
	DD	011741fH
	DD	010641fH
	DD	0e341fH
	DD	0f018721fH
	DD	0d014e016H
	DD	05010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$randomPidInit DD 081401H
	DD	0106414H
	DD	0f5414H
	DD	0e3414H
	DD	07010b214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getProductIndexFromAllLists DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$logRequest DD 035092101H
	DD	0137421H
	DD	011641dH
	DD	0103416H
	DD	0d206330bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getEpidFromString DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getEpid DD 040a01H
	DD	0e340aH
	DD	07006b20aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$logResponse DD 071201H
	DD	01f6412H
	DD	01e3412H
	DD	01c0112H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateResponseBaseCallback DD 0a1901H
	DD	0113419H
	DD	0f0157219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get16RandomBytes DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateResponseV4 DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateV6Hmac DD 040c01H
	DD	0b340cH
	DD	07008720cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateResponseV6 DD 0d1f01H
	DD	027641fH
	DD	026541fH
	DD	025341fH
	DD	01e011fH
	DD	0e016f018H
	DD	0c012d014H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateRequestV4 DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateRequestV6 DD 091801H
	DD	0237418H
	DD	0226418H
	DD	0213418H
	DD	01e0118H
	DD	0e011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptResponseV4 DD 0c1d01H
	DD	0b741dH
	DD	0a641dH
	DD	09541dH
	DD	08341dH
	DD	0f019321dH
	DD	0c015e017H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$VerifyResponseV6 DD 0a1901H
	DD	0b7419H
	DD	0a6419H
	DD	095419H
	DD	083419H
	DD	0e0155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptResponseV6 DD 0d1f01H
	DD	02d641fH
	DD	02c541fH
	DD	02a341fH
	DD	024011fH
	DD	0e016f018H
	DD	0c012d014H
	DD	07010H
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_Locale$dead$ = 88
_ArgList$ = 96
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	49 8b d8	 mov	 rbx, r8
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b f1	 mov	 rsi, rcx

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	4c 8b cb	 mov	 r9, rbx
  00020	4c 8b c7	 mov	 r8, rdi
  00023	48 8b d6	 mov	 rdx, rsi
  00026	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00029	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0002e	48 83 c9 01	 or	 rcx, 1
  00032	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00037	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;
; 1391 : }

  00043	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00048	83 c9 ff	 or	 ecx, -1
  0004b	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00050	85 c0		 test	 eax, eax
  00052	0f 48 c1	 cmovs	 eax, ecx
  00055	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$dead$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	49 8b d9	 mov	 rbx, r9
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b f1	 mov	 rsi, rcx

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx
  00022	4c 8b cf	 mov	 r9, rdi
  00025	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0002b	48 83 cb ff	 or	 rbx, -1
  0002f	4c 8b c3	 mov	 r8, rbx
  00032	48 8b d6	 mov	 rdx, rsi
  00035	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00038	48 83 c9 01	 or	 rcx, 1
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

  00042	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 1390 :     return _Result < 0 ? -1 : _Result;

  00047	85 c0		 test	 eax, eax
  00049	0f 48 c3	 cmovs	 eax, ebx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

  0004c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00051	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00055	5f		 pop	 rdi
  00056	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Buffer$ = 80
_Format$ = 88
sprintf	PROC						; COMDAT

; 1776 : {

$LN8:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  00007	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000b	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  0000f	53		 push	 rbx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00016	48 8b da	 mov	 rbx, rdx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  00019	48 8d 70 18	 lea	 rsi, QWORD PTR [rax+24]
  0001d	48 8b f9	 mov	 rdi, rcx

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00020	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00025	4c 8b cb	 mov	 r9, rbx
  00028	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  0002d	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00033	48 83 cb ff	 or	 rbx, -1
  00037	4c 8b c3	 mov	 r8, rbx
  0003a	48 8b d7	 mov	 rdx, rdi
  0003d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00040	48 83 c9 01	 or	 rcx, 1
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  0004a	85 c0		 test	 eax, eax
  0004c	0f 48 c3	 cmovs	 eax, ebx

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  0004f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00053	5f		 pop	 rdi
  00054	5e		 pop	 rsi
  00055	5b		 pop	 rbx
  00056	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\time.h
;	COMDAT gmtime
_TEXT	SEGMENT
_Time$ = 8
gmtime	PROC						; COMDAT

; 498  :             #pragma warning(push)
; 499  :             #pragma warning(disable: 4996)
; 500  :             return _gmtime64(_Time);

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__gmtime64
gmtime	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\time.h
;	COMDAT time
_TEXT	SEGMENT
_Time$ = 8
time	PROC						; COMDAT

; 535  :             return _time64(_Time);

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__time64
time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT getProductIndex
_TEXT	SEGMENT
guid$ = 8
list$ = 16
count$ = 24
name$ = 32
ePid$ = 40
getProductIndex PROC					; COMDAT

; 48   : {

  00000	66 90		 npad	 2
$LN18@getProduct:

; 49   : 	int i;
; 50   : 
; 51   : 	for (i = count - 1; i >= 0; i--)
; 52   : 	{
; 53   : 		if (IsEqualGUID(guid, &list[i].Guid))

  00002	41 83 e8 01	 sub	 r8d, 1
  00006	78 4d		 js	 SHORT $LN17@getProduct
  00008	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0000b	4d 63 d0	 movsxd	 r10, r8d
  0000e	49 c1 e2 05	 shl	 r10, 5
  00012	49 3b 04 12	 cmp	 rax, QWORD PTR [r10+rdx]
  00016	75 ea		 jne	 SHORT $LN18@getProduct
  00018	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  0001c	49 3b 44 12 08	 cmp	 rax, QWORD PTR [r10+rdx+8]
  00021	75 df		 jne	 SHORT $LN18@getProduct

; 54   : 		{
; 55   : 			if (name)

  00023	4d 85 c9	 test	 r9, r9
  00026	74 08		 je	 SHORT $LN6@getProduct

; 56   : 				*name = list[i].Name;

  00028	49 8b 4c 12 10	 mov	 rcx, QWORD PTR [r10+rdx+16]
  0002d	49 89 09	 mov	 QWORD PTR [r9], rcx
$LN6@getProduct:

; 57   : 			if (ePid)

  00030	48 8b 44 24 28	 mov	 rax, QWORD PTR ePid$[rsp]
  00035	48 85 c0	 test	 rax, rax
  00038	74 42		 je	 SHORT $LN9@getProduct

; 58   : 				*ePid = KmsData->CsvlkData[list[i].EPidIndex].EPid;

  0003a	41 0f b6 54 12
	1e		 movzx	 edx, BYTE PTR [r10+rdx+30]
  00040	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsData
  00047	48 c1 e2 05	 shl	 rdx, 5
  0004b	48 8b 54 0a 48	 mov	 rdx, QWORD PTR [rdx+rcx+72]
  00050	48 89 10	 mov	 QWORD PTR [rax], rdx

; 59   : 			return i;

  00053	eb 27		 jmp	 SHORT $LN9@getProduct
$LN17@getProduct:

; 60   : 		}
; 61   : 	}
; 62   : 
; 63   : 	if (name)

  00055	4d 85 c9	 test	 r9, r9
  00058	74 0a		 je	 SHORT $LN8@getProduct

; 64   : 		*name = (char *)"Unknown";

  0005a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07NBCGADJA@Unknown@
  00061	49 89 01	 mov	 QWORD PTR [r9], rax
$LN8@getProduct:

; 65   : 	if (ePid)

  00064	48 8b 54 24 28	 mov	 rdx, QWORD PTR ePid$[rsp]
  00069	48 85 d2	 test	 rdx, rdx
  0006c	74 0e		 je	 SHORT $LN9@getProduct

; 66   : 		*ePid = KmsData->CsvlkData->EPid;

  0006e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR KmsData
  00075	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  00079	48 89 0a	 mov	 QWORD PTR [rdx], rcx
$LN9@getProduct:

; 67   : 	return i;
; 68   : }

  0007c	41 8b c0	 mov	 eax, r8d
  0007f	c3		 ret	 0
getProductIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT getNextString
_TEXT	SEGMENT
s$ = 8
getNextString PROC					; COMDAT

; 73   : 	return s + strlen(s) + 1;

  00000	48 83 c8 ff	 or	 rax, -1
$LL3@getNextStr:
  00004	48 ff c0	 inc	 rax
  00007	80 3c 01 00	 cmp	 BYTE PTR [rcx+rax], 0
  0000b	75 f7		 jne	 SHORT $LL3@getNextStr
  0000d	48 ff c0	 inc	 rax
  00010	48 03 c1	 add	 rax, rcx

; 74   : }

  00013	c3		 ret	 0
getNextString ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT getPlatformId
_TEXT	SEGMENT
hostBuild$ = 8
getPlatformId PROC					; COMDAT

; 95   : 	int32_t i;
; 96   : 
; 97   : 	for (i = 0; i < KmsData->HostBuildCount; i++)

  00000	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR KmsData
  00007	33 c0		 xor	 eax, eax
  00009	49 63 50 18	 movsxd	 rdx, DWORD PTR [r8+24]
  0000d	41 39 40 18	 cmp	 DWORD PTR [r8+24], eax
  00011	7e 1e		 jle	 SHORT $LN12@getPlatfor

; 98   : 	{
; 99   : 		if (KmsData->HostBuildList[i].BuildNumber <= hostBuild)

  00013	4d 8b 58 38	 mov	 r11, QWORD PTR [r8+56]
  00017	44 8b d0	 mov	 r10d, eax
  0001a	4d 8d 4b 10	 lea	 r9, QWORD PTR [r11+16]
$LL4@getPlatfor:
  0001e	41 39 09	 cmp	 DWORD PTR [r9], ecx
  00021	7e 1b		 jle	 SHORT $LN8@getPlatfor

; 95   : 	int32_t i;
; 96   : 
; 97   : 	for (i = 0; i < KmsData->HostBuildCount; i++)

  00023	ff c0		 inc	 eax
  00025	49 ff c2	 inc	 r10
  00028	49 83 c1 20	 add	 r9, 32			; 00000020H
  0002c	4c 3b d2	 cmp	 r10, rdx
  0002f	7c ed		 jl	 SHORT $LL4@getPlatfor
$LN12@getPlatfor:

; 102  : 		}
; 103  : 	}
; 104  : 
; 105  : 	return KmsData->HostBuildList[KmsData->HostBuildCount - 1].PlatformId;

  00031	49 8b 40 38	 mov	 rax, QWORD PTR [r8+56]
  00035	48 c1 e2 05	 shl	 rdx, 5
  00039	8b 44 02 f4	 mov	 eax, DWORD PTR [rdx+rax-12]

; 106  : }

  0003d	c3		 ret	 0
$LN8@getPlatfor:

; 100  : 		{
; 101  : 			return KmsData->HostBuildList[i].PlatformId;

  0003e	48 98		 cdqe
  00040	48 c1 e0 05	 shl	 rax, 5
  00044	42 8b 44 18 14	 mov	 eax, DWORD PTR [rax+r11+20]

; 106  : }

  00049	c3		 ret	 0
getPlatformId ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT getReleaseDate
_TEXT	SEGMENT
hostBuild$ = 8
getReleaseDate PROC					; COMDAT

; 110  : 	int32_t i;
; 111  : 
; 112  : 	for (i = KmsData->HostBuildCount - 1; i >= 0; i--)

  00000	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR KmsData
  00007	41 8b 50 18	 mov	 edx, DWORD PTR [r8+24]
  0000b	83 ea 01	 sub	 edx, 1
  0000e	78 26		 js	 SHORT $LN3@getRelease

; 113  : 	{
; 114  : 		if (KmsData->HostBuildList[i].BuildNumber >= hostBuild)

  00010	4d 8b 58 38	 mov	 r11, QWORD PTR [r8+56]
  00014	4c 63 ca	 movsxd	 r9, edx
  00017	49 8b c1	 mov	 rax, r9
  0001a	48 c1 e0 05	 shl	 rax, 5
  0001e	4d 8d 53 10	 lea	 r10, QWORD PTR [r11+16]
  00022	4c 03 d0	 add	 r10, rax
$LL4@getRelease:
  00025	41 39 0a	 cmp	 DWORD PTR [r10], ecx
  00028	7d 15		 jge	 SHORT $LN8@getRelease

; 110  : 	int32_t i;
; 111  : 
; 112  : 	for (i = KmsData->HostBuildCount - 1; i >= 0; i--)

  0002a	ff ca		 dec	 edx
  0002c	49 83 ea 20	 sub	 r10, 32			; 00000020H
  00030	49 83 e9 01	 sub	 r9, 1
  00034	79 ef		 jns	 SHORT $LL4@getRelease
$LN3@getRelease:

; 117  : 		}
; 118  : 	}
; 119  : 
; 120  : 	return (time_t)KmsData->HostBuildList->ReleaseDate;

  00036	49 8b 40 38	 mov	 rax, QWORD PTR [r8+56]
  0003a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 121  : }

  0003e	c3		 ret	 0
$LN8@getRelease:

; 115  : 		{
; 116  : 			return (time_t)KmsData->HostBuildList[i].ReleaseDate;

  0003f	48 63 c2	 movsxd	 rax, edx
  00042	48 c1 e0 05	 shl	 rax, 5
  00046	4a 8b 44 18 08	 mov	 rax, QWORD PTR [rax+r11+8]

; 121  : }

  0004b	c3		 ret	 0
getReleaseDate ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\time.h
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT getUnixTimeAsFileTime
_TEXT	SEGMENT
ts$ = 48
getUnixTimeAsFileTime PROC				; COMDAT

; 155  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

  00009	33 c9		 xor	 ecx, ecx
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64
; File C:\Users\dev\source\repos\alpinevms\src\kms.c

; 159  : 	PUT_UA64LE(filetime, (unixtime + 11644473600LL) * 10000000LL);

  00011	48 b9 00 91 10
	b6 02 00 00 00	 mov	 rcx, 11644473600	; 00000002b6109100H
  0001b	48 03 c1	 add	 rax, rcx
  0001e	48 69 c0 80 96
	98 00		 imul	 rax, rax, 10000000	; 00989680H
  00025	48 89 03	 mov	 QWORD PTR [rbx], rax

; 160  : }

  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5b		 pop	 rbx
  0002d	c3		 ret	 0
getUnixTimeAsFileTime ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT fileTimeToUnixTime
_TEXT	SEGMENT
ts$ = 8
fileTimeToUnixTime PROC					; COMDAT

; 164  : 	return GET_UA64LE(ts) / 10000000LL - 11644473600LL;

  00000	48 b8 bd 42 7a
	e5 d5 94 bf d6	 mov	 rax, -2972493582642298179 ; d6bf94d5e57a42bdH
  0000a	48 f7 21	 mul	 QWORD PTR [rcx]
  0000d	48 b8 00 91 10
	b6 02 00 00 00	 mov	 rax, 11644473600	; 00000002b6109100H
  00017	48 c1 ea 17	 shr	 rdx, 23
  0001b	48 2b d0	 sub	 rdx, rax
  0001e	48 8b c2	 mov	 rax, rdx

; 165  : }

  00021	c3		 ret	 0
fileTimeToUnixTime ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT CleanUpClientLists
_TEXT	SEGMENT
CleanUpClientLists PROC					; COMDAT

; 197  : #ifndef USE_THREADS
; 198  : 	shmctl(shmid_clients, IPC_RMID, NULL);
; 199  : #endif // !USE_THREADS
; 200  : }

  00000	c2 00 00	 ret	 0
CleanUpClientLists ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT InitializeClientLists
_TEXT	SEGMENT
InitializeClientLists PROC				; COMDAT

; 203  : {

$LN33:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 234  : 	ClientLists = (PClientList_t)vlmcsd_malloc(sizeof(ClientList_t) * KmsData->AppItemCount);

  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR KmsData
  00020	48 63 48 0c	 movsxd	 rcx, DWORD PTR [rax+12]
  00024	48 69 c9 fc 29
	00 00		 imul	 rcx, rcx, 10748		; 000029fcH
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 366  : 	if (!buf) OutOfMemory();

  00031	48 85 c0	 test	 rax, rax
  00034	0f 84 e6 00 00
	00		 je	 $LN25@Initialize

; 365  : 	void* buf = malloc(len);

  0003a	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
; File C:\Users\dev\source\repos\alpinevms\src\kms.c

; 234  : 	ClientLists = (PClientList_t)vlmcsd_malloc(sizeof(ClientList_t) * KmsData->AppItemCount);

  0003f	48 89 05 00 00
	00 00		 mov	 QWORD PTR ClientLists, rax
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 366  : 	if (!buf) OutOfMemory();

  0004c	48 85 c0	 test	 rax, rax
  0004f	0f 84 cb 00 00
	00		 je	 $LN25@Initialize
; File C:\Users\dev\source\repos\alpinevms\src\kms.c

; 235  : 	mutex = (mutex_t *)vlmcsd_malloc(sizeof(mutex_t));

  00055	48 8b c8	 mov	 rcx, rax
  00058	48 89 05 00 00
	00 00		 mov	 QWORD PTR mutex, rax

; 236  : 
; 237  : #if !_WIN32 && !__CYGWIN__
; 238  : 	pthread_mutex_init(mutex, NULL);
; 239  : #else  //_WIN32 || __CYGWIN__
; 240  : 	InitializeCriticalSection(mutex);

  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection

; 241  : #endif //_WIN32 || __CYGWIN__
; 242  : 
; 243  : #endif // USE_THREADS
; 244  : 
; 245  : 	memset(ClientLists, 0, sizeof(ClientList_t) * KmsData->AppItemCount);

  00065	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR KmsData
  0006c	33 d2		 xor	 edx, edx
  0006e	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR ClientLists
  00075	48 8b cf	 mov	 rcx, rdi
  00078	48 63 43 0c	 movsxd	 rax, DWORD PTR [rbx+12]
  0007c	4c 69 c0 fc 29
	00 00		 imul	 r8, rax, 10748		; 000029fcH
  00083	e8 00 00 00 00	 call	 memset

; 246  : 
; 247  : 	if (!StartEmpty)

  00088	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR StartEmpty, 0
  0008f	75 74		 jne	 SHORT $LN3@Initialize

; 248  : 	{
; 249  : 		for (i = 0; i < KmsData->AppItemCount; i++)

  00091	40 32 f6	 xor	 sil, sil
  00094	83 7b 0c 00	 cmp	 DWORD PTR [rbx+12], 0
  00098	7e 6b		 jle	 SHORT $LN3@Initialize
$LL4@Initialize:

; 252  : 			ClientLists[i].CurrentCount = (maxCount >> 1) - 1;

  0009a	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0009e	48 0f be d6	 movsx	 rdx, sil
  000a2	4c 69 f2 fc 29
	00 00		 imul	 r14, rdx, 10748		; 000029fcH
  000a9	48 8b ca	 mov	 rcx, rdx
  000ac	48 c1 e1 05	 shl	 rcx, 5
  000b0	44 0f b6 44 01
	1b		 movzx	 r8d, BYTE PTR [rcx+rax+27]
  000b6	41 8b c0	 mov	 eax, r8d

; 253  : 			ClientLists[i].MaxCount = maxCount;

  000b9	45 89 84 3e f4
	29 00 00	 mov	 DWORD PTR [r14+rdi+10740], r8d
  000c1	d1 e8		 shr	 eax, 1
  000c3	ff c8		 dec	 eax
  000c5	41 89 84 3e f0
	29 00 00	 mov	 DWORD PTR [r14+rdi+10736], eax

; 254  : 
; 255  : 			for (j = 0; j < (maxCount >> 1) - 1; j++)

  000cd	85 c0		 test	 eax, eax
  000cf	7e 28		 jle	 SHORT $LN2@Initialize

; 250  : 		{
; 251  : 			const uint8_t maxCount = KmsData->AppItemList[i].NCountPolicy;

  000d1	33 db		 xor	 ebx, ebx
  000d3	8b e8		 mov	 ebp, eax
$LL7@Initialize:

; 256  : 			{
; 257  : 				get16RandomBytes(&ClientLists[i].Guid[j]);

  000d5	4a 8d 0c 33	 lea	 rcx, QWORD PTR [rbx+r14]
  000d9	48 03 cf	 add	 rcx, rdi
  000dc	e8 00 00 00 00	 call	 get16RandomBytes
  000e1	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR ClientLists
  000e8	48 8d 5b 10	 lea	 rbx, QWORD PTR [rbx+16]
  000ec	48 83 ed 01	 sub	 rbp, 1
  000f0	75 e3		 jne	 SHORT $LL7@Initialize
  000f2	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR KmsData
$LN2@Initialize:

; 248  : 	{
; 249  : 		for (i = 0; i < KmsData->AppItemCount; i++)

  000f9	40 fe c6	 inc	 sil
  000fc	40 0f be c6	 movsx	 eax, sil
  00100	3b 43 0c	 cmp	 eax, DWORD PTR [rbx+12]
  00103	7c 95		 jl	 SHORT $LL4@Initialize
$LN3@Initialize:

; 261  : }

  00105	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0010a	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0010f	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00114	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00119	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011d	41 5e		 pop	 r14
  0011f	c3		 ret	 0
$LN25@Initialize:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 366  : 	if (!buf) OutOfMemory();

  00120	e8 00 00 00 00	 call	 OutOfMemory
  00125	cc		 int	 3
$LN31@Initialize:
InitializeClientLists ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT itoc
_TEXT	SEGMENT
formatString$ = 48
c$ = 48
i$ = 56
digits$ = 64
itoc	PROC						; COMDAT

; 268  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 269  : 	char formatString[8];
; 270  : 	if (digits > 9)
; 271  : 		digits = 0;
; 272  : 	strcpy(formatString, "%");

  00006	b8 25 00 00 00	 mov	 eax, 37			; 00000025H
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	66 89 44 24 30	 mov	 WORD PTR formatString$[rsp], ax

; 273  : 
; 274  : 	if (digits)

  00013	45 84 c0	 test	 r8b, r8b
  00016	74 13		 je	 SHORT $LN3@itoc

; 275  : 	{
; 276  : 		formatString[1] = '0';
; 277  : 		formatString[2] = digits | 0x30;

  00018	41 80 c8 30	 or	 r8b, 48			; 00000030H
  0001c	c6 44 24 31 30	 mov	 BYTE PTR formatString$[rsp+1], 48 ; 00000030H
  00021	44 88 44 24 32	 mov	 BYTE PTR formatString$[rsp+2], r8b

; 278  : 		formatString[3] = 0;

  00026	c6 44 24 33 00	 mov	 BYTE PTR formatString$[rsp+3], 0
$LN3@itoc:

; 279  : 	}
; 280  : 
; 281  : 	strcat(formatString, "u");

  0002b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR formatString$[rsp]
  00030	48 ff c9	 dec	 rcx
$LL5@itoc:
  00033	48 ff c1	 inc	 rcx
  00036	80 39 00	 cmp	 BYTE PTR [rcx], 0
  00039	75 f8		 jne	 SHORT $LL5@itoc
  0003b	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_01OMGOGALD@u@

; 282  : 	sprintf(c, formatString, i);

  00042	44 8b c2	 mov	 r8d, edx
  00045	66 89 01	 mov	 WORD PTR [rcx], ax
  00048	48 8d 54 24 30	 lea	 rdx, QWORD PTR formatString$[rsp]
  0004d	48 8b cb	 mov	 rcx, rbx
  00050	e8 00 00 00 00	 call	 sprintf

; 283  : 	return c;

  00055	48 8b c3	 mov	 rax, rbx

; 284  : }

  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5b		 pop	 rbx
  0005d	c3		 ret	 0
itoc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT getRandomServerType
_TEXT	SEGMENT
getRandomServerType PROC				; COMDAT

; 287  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LL2@getRandomS:

; 288  : #if defined(USE_MSRPC) || defined(SIMPLE_RPC)
; 289  : 
; 290  : 	return rand() % KmsData->HostBuildCount;
; 291  : 
; 292  : #else  // !defined(USE_MSRPC) && !defined(SIMPLE_RPC)
; 293  : 	while (TRUE)
; 294  : 	{
; 295  : 		const uint32_t buildIndex = rand() % KmsData->HostBuildCount;

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  0000a	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR KmsData
  00011	99		 cdq
  00012	41 f7 78 18	 idiv	 DWORD PTR [r8+24]

; 296  : 
; 297  : 		if (!(KmsData->HostBuildList[buildIndex].Flags & UseNdr64) == !UseServerRpcNDR64)

  00016	49 8b 40 38	 mov	 rax, QWORD PTR [r8+56]
  0001a	8b ca		 mov	 ecx, edx
  0001c	48 c1 e1 05	 shl	 rcx, 5
  00020	44 8b 44 01 18	 mov	 r8d, DWORD PTR [rcx+rax+24]
  00025	33 c0		 xor	 eax, eax
  00027	41 f7 d0	 not	 r8d
  0002a	41 83 e0 01	 and	 r8d, 1
  0002e	38 05 00 00 00
	00		 cmp	 BYTE PTR UseServerRpcNDR64, al
  00034	0f 94 c0	 sete	 al
  00037	44 3b c0	 cmp	 r8d, eax
  0003a	75 c8		 jne	 SHORT $LL2@getRandomS

; 298  : 		{
; 299  : 			return (uint8_t)buildIndex;

  0003c	8a c2		 mov	 al, dl

; 300  : 		}
; 301  : 	}
; 302  : #endif // !defined(USE_MSRPC) && !defined(SIMPLE_RPC)
; 303  : }

  0003e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00042	c3		 ret	 0
getRandomServerType ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\time.h
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\time.h
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\time.h
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\time.h
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\time.h
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT generateRandomPid
_TEXT	SEGMENT
kmsTime$ = 32
numberBuffer$ = 40
index$ = 112
maxTime$ = 120
szPid$ = 120
lang$ = 128
hostBuild$ = 136
generateRandomPid PROC					; COMDAT

; 309  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	55		 push	 rbp
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 8b ec	 mov	 rbp, rsp
  0001b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0001f	48 63 d9	 movsxd	 rbx, ecx
  00022	45 8b f1	 mov	 r14d, r9d
  00025	45 0f b7 f8	 movzx	 r15d, r8w
  00029	48 8b f2	 mov	 rsi, rdx

; 310  : 	char numberBuffer[12];
; 311  : 
; 312  : 	if (!hostBuild)

  0002c	45 85 c9	 test	 r9d, r9d
  0002f	75 1d		 jne	 SHORT $LN2@generateRa

; 313  : 	{
; 314  : 		hostBuild = KmsData->HostBuildList[getRandomServerType()].BuildNumber;

  00031	e8 00 00 00 00	 call	 getRandomServerType
  00036	44 0f b6 d0	 movzx	 r10d, al
  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR KmsData
  00041	49 c1 e2 05	 shl	 r10, 5
  00045	4c 8b 48 38	 mov	 r9, QWORD PTR [rax+56]
  00049	47 8b 74 11 10	 mov	 r14d, DWORD PTR [r9+r10+16]
$LN2@generateRa:

; 315  : 	}
; 316  : 
; 317  : 	strcpy(szPid, itoc(numberBuffer, getPlatformId(hostBuild), 5));

  0004e	41 8b ce	 mov	 ecx, r14d
  00051	e8 00 00 00 00	 call	 getPlatformId
  00056	8b d0		 mov	 edx, eax
  00058	48 8d 4d e8	 lea	 rcx, QWORD PTR numberBuffer$[rbp-64]
  0005c	41 b0 05	 mov	 r8b, 5
  0005f	e8 00 00 00 00	 call	 itoc
  00064	48 8b d6	 mov	 rdx, rsi
  00067	bf 01 00 00 00	 mov	 edi, 1
  0006c	48 2b d0	 sub	 rdx, rax
$LL6@generateRa:
  0006f	8a 08		 mov	 cl, BYTE PTR [rax]
  00071	88 0c 02	 mov	 BYTE PTR [rdx+rax], cl
  00074	48 03 c7	 add	 rax, rdi
  00077	84 c9		 test	 cl, cl
  00079	75 f4		 jne	 SHORT $LL6@generateRa

; 318  : 	strcat(szPid, "-");

  0007b	48 8b ce	 mov	 rcx, rsi
  0007e	48 2b cf	 sub	 rcx, rdi
$LL35@generateRa:
  00081	48 03 cf	 add	 rcx, rdi
  00084	80 39 00	 cmp	 BYTE PTR [rcx], 0
  00087	75 f8		 jne	 SHORT $LL35@generateRa

; 319  : 
; 320  : 	// if (index > 3) index = 0;
; 321  : 
; 322  : 	PCsvlkData_t csvlkData = &KmsData->CsvlkData[index];

  00089	4c 8b 2d 00 00
	00 00		 mov	 r13, QWORD PTR KmsData
  00090	4c 8b e3	 mov	 r12, rbx
  00093	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_01JOAMLHOP@?9@

; 323  : 	strcat(szPid, itoc(numberBuffer, csvlkData->GroupId, 5));

  0009a	41 b0 05	 mov	 r8b, 5
  0009d	66 89 01	 mov	 WORD PTR [rcx], ax
  000a0	48 8d 4d e8	 lea	 rcx, QWORD PTR numberBuffer$[rbp-64]
  000a4	49 c1 e4 05	 shl	 r12, 5
  000a8	43 8b 54 2c 58	 mov	 edx, DWORD PTR [r12+r13+88]
  000ad	e8 00 00 00 00	 call	 itoc
  000b2	48 8b ce	 mov	 rcx, rsi
  000b5	4c 8b c0	 mov	 r8, rax
  000b8	48 2b cf	 sub	 rcx, rdi
$LL33@generateRa:
  000bb	48 03 cf	 add	 rcx, rdi
  000be	80 39 00	 cmp	 BYTE PTR [rcx], 0
  000c1	75 f8		 jne	 SHORT $LL33@generateRa
  000c3	33 d2		 xor	 edx, edx
$LL34@generateRa:
  000c5	41 8a 04 10	 mov	 al, BYTE PTR [r8+rdx]
  000c9	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  000cc	48 ff c2	 inc	 rdx
  000cf	84 c0		 test	 al, al
  000d1	75 f2		 jne	 SHORT $LL34@generateRa

; 324  : 	strcat(szPid, "-");

  000d3	48 8b ce	 mov	 rcx, rsi
  000d6	48 2b cf	 sub	 rcx, rdi
$LL32@generateRa:
  000d9	48 03 cf	 add	 rcx, rdi
  000dc	80 39 00	 cmp	 BYTE PTR [rcx], 0
  000df	75 f8		 jne	 SHORT $LL32@generateRa
  000e1	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_01JOAMLHOP@?9@
  000e8	66 89 01	 mov	 WORD PTR [rcx], ax

; 325  : 
; 326  : 	const int keyId = (rand32() % (csvlkData->MaxKeyId - csvlkData->MinKeyId)) + csvlkData->MinKeyId;

  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  000f1	8b d8		 mov	 ebx, eax
  000f3	c1 e3 0f	 shl	 ebx, 15
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  000fc	8b f8		 mov	 edi, eax
  000fe	0b fb		 or	 edi, ebx
  00100	c1 e7 02	 shl	 edi, 2
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00109	43 8b 4c 2c 60	 mov	 ecx, DWORD PTR [r12+r13+96]
  0010e	33 d2		 xor	 edx, edx
  00110	43 2b 4c 2c 5c	 sub	 ecx, DWORD PTR [r12+r13+92]
  00115	83 e0 03	 and	 eax, 3
  00118	0b c7		 or	 eax, edi

; 327  : 	strcat(szPid, itoc(numberBuffer, keyId / 1000000, 3));

  0011a	41 b0 03	 mov	 r8b, 3
  0011d	f7 f1		 div	 ecx
  0011f	b8 83 de 1b 43	 mov	 eax, 1125899907		; 431bde83H
  00124	48 8d 4d e8	 lea	 rcx, QWORD PTR numberBuffer$[rbp-64]
  00128	8b da		 mov	 ebx, edx
  0012a	43 03 5c 2c 5c	 add	 ebx, DWORD PTR [r12+r13+92]
  0012f	f7 eb		 imul	 ebx
  00131	8b fa		 mov	 edi, edx
  00133	c1 ff 12	 sar	 edi, 18
  00136	8b c7		 mov	 eax, edi
  00138	c1 e8 1f	 shr	 eax, 31
  0013b	03 f8		 add	 edi, eax
  0013d	8b d7		 mov	 edx, edi
  0013f	e8 00 00 00 00	 call	 itoc
  00144	48 8b d0	 mov	 rdx, rax
  00147	4c 8d 46 ff	 lea	 r8, QWORD PTR [rsi-1]
$LL30@generateRa:
  0014b	49 ff c0	 inc	 r8
  0014e	41 80 38 00	 cmp	 BYTE PTR [r8], 0
  00152	75 f7		 jne	 SHORT $LL30@generateRa
  00154	33 c9		 xor	 ecx, ecx
$LL31@generateRa:
  00156	8a 04 0a	 mov	 al, BYTE PTR [rdx+rcx]
  00159	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
  0015d	48 ff c1	 inc	 rcx
  00160	84 c0		 test	 al, al
  00162	75 f2		 jne	 SHORT $LL31@generateRa

; 328  : 	strcat(szPid, "-");

  00164	48 8d 4e ff	 lea	 rcx, QWORD PTR [rsi-1]
$LL29@generateRa:
  00168	48 ff c1	 inc	 rcx
  0016b	80 39 00	 cmp	 BYTE PTR [rcx], 0
  0016e	75 f8		 jne	 SHORT $LL29@generateRa
  00170	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_01JOAMLHOP@?9@

; 329  : 	strcat(szPid, itoc(numberBuffer, keyId % 1000000, 6));

  00177	41 b0 06	 mov	 r8b, 6
  0017a	66 89 01	 mov	 WORD PTR [rcx], ax
  0017d	48 8d 4d e8	 lea	 rcx, QWORD PTR numberBuffer$[rbp-64]
  00181	69 c7 40 42 0f
	00		 imul	 eax, edi, 1000000	; 000f4240H
  00187	2b d8		 sub	 ebx, eax
  00189	8b d3		 mov	 edx, ebx
  0018b	e8 00 00 00 00	 call	 itoc
  00190	48 8b ce	 mov	 rcx, rsi
  00193	bb 01 00 00 00	 mov	 ebx, 1
  00198	48 2b cb	 sub	 rcx, rbx
  0019b	4c 8b c0	 mov	 r8, rax
  0019e	33 ff		 xor	 edi, edi
$LL27@generateRa:
  001a0	48 03 cb	 add	 rcx, rbx
  001a3	40 38 39	 cmp	 BYTE PTR [rcx], dil
  001a6	75 f8		 jne	 SHORT $LL27@generateRa
  001a8	33 d2		 xor	 edx, edx
$LL28@generateRa:
  001aa	41 8a 04 10	 mov	 al, BYTE PTR [r8+rdx]
  001ae	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  001b1	48 ff c2	 inc	 rdx
  001b4	84 c0		 test	 al, al
  001b6	75 f2		 jne	 SHORT $LL28@generateRa

; 330  : 	strcat(szPid, "-03-");

  001b8	48 8b ce	 mov	 rcx, rsi
  001bb	48 2b cb	 sub	 rcx, rbx
$LL26@generateRa:
  001be	48 03 cb	 add	 rcx, rbx
  001c1	40 38 39	 cmp	 BYTE PTR [rcx], dil
  001c4	75 f8		 jne	 SHORT $LL26@generateRa
  001c6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_04PGKABKNA@?903?9@
  001cc	89 01		 mov	 DWORD PTR [rcx], eax
  001ce	8a 05 04 00 00
	00		 mov	 al, BYTE PTR ??_C@_04PGKABKNA@?903?9@+4
  001d4	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 331  : 
; 332  : 	if (lang < 1)

  001d7	66 44 3b fb	 cmp	 r15w, bx
  001db	7d 30		 jge	 SHORT $LN3@generateRa

; 333  : 		lang = LcidList[rand() % vlmcsd_countof(LcidList)];

  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  001e3	48 63 c8	 movsxd	 rcx, eax
  001e6	48 b8 75 64 cf
	40 54 3a b2 67	 mov	 rax, 7472098865300071541 ; 67b23a5440cf6475H
  001f0	48 f7 e1	 mul	 rcx
  001f3	48 c1 ea 06	 shr	 rdx, 6
  001f7	48 69 c2 9e 00
	00 00		 imul	 rax, rdx, 158		; 0000009eH
  001fe	48 2b c8	 sub	 rcx, rax
  00201	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:LcidList
  00208	44 0f b7 3c 48	 movzx	 r15d, WORD PTR [rax+rcx*2]
$LN3@generateRa:

; 334  : 	strcat(szPid, itoc(numberBuffer, lang, 0));

  0020d	41 0f bf d7	 movsx	 edx, r15w
  00211	48 8d 4d e8	 lea	 rcx, QWORD PTR numberBuffer$[rbp-64]
  00215	45 33 c0	 xor	 r8d, r8d
  00218	e8 00 00 00 00	 call	 itoc
  0021d	48 8b ce	 mov	 rcx, rsi
  00220	4c 8b c0	 mov	 r8, rax
  00223	48 2b cb	 sub	 rcx, rbx
$LL24@generateRa:
  00226	48 03 cb	 add	 rcx, rbx
  00229	40 38 39	 cmp	 BYTE PTR [rcx], dil
  0022c	75 f8		 jne	 SHORT $LL24@generateRa
  0022e	33 d2		 xor	 edx, edx
$LL25@generateRa:
  00230	41 8a 04 10	 mov	 al, BYTE PTR [r8+rdx]
  00234	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  00237	48 ff c2	 inc	 rdx
  0023a	84 c0		 test	 al, al
  0023c	75 f2		 jne	 SHORT $LL25@generateRa

; 335  : 	strcat(szPid, "-");

  0023e	48 8b ce	 mov	 rcx, rsi
  00241	48 2b cb	 sub	 rcx, rbx
$LL23@generateRa:
  00244	48 03 cb	 add	 rcx, rbx
  00247	40 38 39	 cmp	 BYTE PTR [rcx], dil
  0024a	75 f8		 jne	 SHORT $LL23@generateRa
  0024c	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_01JOAMLHOP@?9@

; 336  : 
; 337  : 	strcat(szPid, itoc(numberBuffer, hostBuild, 0));

  00253	45 33 c0	 xor	 r8d, r8d
  00256	66 89 01	 mov	 WORD PTR [rcx], ax
  00259	41 8b d6	 mov	 edx, r14d
  0025c	48 8d 4d e8	 lea	 rcx, QWORD PTR numberBuffer$[rbp-64]
  00260	e8 00 00 00 00	 call	 itoc
  00265	48 8b ce	 mov	 rcx, rsi
  00268	4c 8b c0	 mov	 r8, rax
  0026b	48 2b cb	 sub	 rcx, rbx
$LL21@generateRa:
  0026e	48 03 cb	 add	 rcx, rbx
  00271	40 38 39	 cmp	 BYTE PTR [rcx], dil
  00274	75 f8		 jne	 SHORT $LL21@generateRa
  00276	33 d2		 xor	 edx, edx
$LL22@generateRa:
  00278	41 8a 04 10	 mov	 al, BYTE PTR [r8+rdx]
  0027c	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  0027f	48 ff c2	 inc	 rdx
  00282	84 c0		 test	 al, al
  00284	75 f2		 jne	 SHORT $LL22@generateRa

; 338  : 	strcat(szPid, ".0000-");

  00286	48 8b ce	 mov	 rcx, rsi
  00289	48 2b cb	 sub	 rcx, rbx
$LL20@generateRa:
  0028c	48 03 cb	 add	 rcx, rbx
  0028f	40 38 39	 cmp	 BYTE PTR [rcx], dil
  00292	75 f8		 jne	 SHORT $LL20@generateRa
  00294	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_06KMCAJKLF@?40000?9@
  0029a	89 01		 mov	 DWORD PTR [rcx], eax
  0029c	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_06KMCAJKLF@?40000?9@+4
  002a3	66 89 41 04	 mov	 WORD PTR [rcx+4], ax
  002a7	8a 05 06 00 00
	00		 mov	 al, BYTE PTR ??_C@_06KMCAJKLF@?40000?9@+6
  002ad	88 41 06	 mov	 BYTE PTR [rcx+6], al

; 339  : 
; 340  : 	const time_t hostBuildReleaseDate = getReleaseDate(hostBuild);

  002b0	41 8b ce	 mov	 ecx, r14d
  002b3	e8 00 00 00 00	 call	 getReleaseDate

; 341  : 	const time_t minTime = csvlkData->ReleaseDate < hostBuildReleaseDate ? hostBuildReleaseDate : csvlkData->ReleaseDate;

  002b8	4b 8b 7c 2c 50	 mov	 rdi, QWORD PTR [r12+r13+80]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

  002bd	48 8d 4d 38	 lea	 rcx, QWORD PTR maxTime$[rbp-64]
; File C:\Users\dev\source\repos\alpinevms\src\kms.c

; 341  : 	const time_t minTime = csvlkData->ReleaseDate < hostBuildReleaseDate ? hostBuildReleaseDate : csvlkData->ReleaseDate;

  002c1	48 3b f8	 cmp	 rdi, rax
  002c4	48 0f 4c f8	 cmovl	 rdi, rax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

  002c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64
; File C:\Users\dev\source\repos\alpinevms\src\kms.c

; 350  : 	if (maxTime < (time_t)BUILD_TIME) // Just in case the system time is < 10/17/2013 1:00 pm

  002ce	48 8b 45 38	 mov	 rax, QWORD PTR maxTime$[rbp-64]
  002d2	b9 3b 19 ba 5b	 mov	 ecx, 1538922811		; 5bba193bH
  002d7	48 3b c1	 cmp	 rax, rcx
  002da	48 0f 4c c1	 cmovl	 rax, rcx
  002de	48 89 45 38	 mov	 QWORD PTR maxTime$[rbp-64], rax

; 353  : 	time_t kmsTime = (rand32() % (maxTime - minTime)) + minTime;

  002e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  002e8	8b d8		 mov	 ebx, eax
  002ea	c1 e3 0f	 shl	 ebx, 15
  002ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  002f3	0b d8		 or	 ebx, eax
  002f5	c1 e3 02	 shl	 ebx, 2
  002f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  002fe	48 8b 4d 38	 mov	 rcx, QWORD PTR maxTime$[rbp-64]
  00302	83 e0 03	 and	 eax, 3
  00305	48 0b c3	 or	 rax, rbx
  00308	48 2b cf	 sub	 rcx, rdi
  0030b	48 99		 cdq
  0030d	48 f7 f9	 idiv	 rcx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\time.h

; 500  :             return _gmtime64(_Time);

  00310	48 8d 4d e0	 lea	 rcx, QWORD PTR kmsTime$[rbp-64]
; File C:\Users\dev\source\repos\alpinevms\src\kms.c

; 353  : 	time_t kmsTime = (rand32() % (maxTime - minTime)) + minTime;

  00314	48 03 d7	 add	 rdx, rdi
  00317	48 89 55 e0	 mov	 QWORD PTR kmsTime$[rbp-64], rdx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\time.h

; 500  :             return _gmtime64(_Time);

  0031b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__gmtime64
; File C:\Users\dev\source\repos\alpinevms\src\kms.c

; 356  : 	strcat(szPid, itoc(numberBuffer, pidTime->tm_yday + 1, 3));

  00321	bf 01 00 00 00	 mov	 edi, 1
  00326	48 8d 4d e8	 lea	 rcx, QWORD PTR numberBuffer$[rbp-64]
  0032a	41 b0 03	 mov	 r8b, 3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\time.h

; 500  :             return _gmtime64(_Time);

  0032d	48 8b d8	 mov	 rbx, rax
; File C:\Users\dev\source\repos\alpinevms\src\kms.c

; 356  : 	strcat(szPid, itoc(numberBuffer, pidTime->tm_yday + 1, 3));

  00330	8b 50 1c	 mov	 edx, DWORD PTR [rax+28]
  00333	03 d7		 add	 edx, edi
  00335	e8 00 00 00 00	 call	 itoc
  0033a	48 8b d6	 mov	 rdx, rsi
  0033d	4c 8b c0	 mov	 r8, rax
  00340	48 2b d7	 sub	 rdx, rdi
$LL18@generateRa:
  00343	48 03 d7	 add	 rdx, rdi
  00346	80 3a 00	 cmp	 BYTE PTR [rdx], 0
  00349	75 f8		 jne	 SHORT $LL18@generateRa
  0034b	33 c9		 xor	 ecx, ecx
$LL19@generateRa:
  0034d	41 8a 04 08	 mov	 al, BYTE PTR [r8+rcx]
  00351	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00354	48 ff c1	 inc	 rcx
  00357	84 c0		 test	 al, al
  00359	75 f2		 jne	 SHORT $LL19@generateRa

; 357  : 	strcat(szPid, itoc(numberBuffer, pidTime->tm_year + 1900, 4));

  0035b	8b 53 14	 mov	 edx, DWORD PTR [rbx+20]
  0035e	48 8d 4d e8	 lea	 rcx, QWORD PTR numberBuffer$[rbp-64]
  00362	81 c2 6c 07 00
	00		 add	 edx, 1900		; 0000076cH
  00368	41 b0 04	 mov	 r8b, 4
  0036b	e8 00 00 00 00	 call	 itoc
  00370	48 8b d0	 mov	 rdx, rax
  00373	48 2b f7	 sub	 rsi, rdi
$LL16@generateRa:
  00376	48 03 f7	 add	 rsi, rdi
  00379	80 3e 00	 cmp	 BYTE PTR [rsi], 0
  0037c	75 f8		 jne	 SHORT $LL16@generateRa
  0037e	33 c9		 xor	 ecx, ecx
$LL17@generateRa:
  00380	8a 04 0a	 mov	 al, BYTE PTR [rdx+rcx]
  00383	88 04 0e	 mov	 BYTE PTR [rsi+rcx], al
  00386	48 ff c1	 inc	 rcx
  00389	84 c0		 test	 al, al
  0038b	75 f3		 jne	 SHORT $LL17@generateRa

; 358  : }

  0038d	4c 8d 5c 24 40	 lea	 r11, QWORD PTR [rsp+64]
  00392	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  00396	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  0039a	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  0039e	49 8b e3	 mov	 rsp, r11
  003a1	41 5f		 pop	 r15
  003a3	41 5e		 pop	 r14
  003a5	41 5d		 pop	 r13
  003a7	41 5c		 pop	 r12
  003a9	5d		 pop	 rbp
  003aa	c3		 ret	 0
generateRandomPid ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT randomPidInit
_TEXT	SEGMENT
Epid$1 = 32
randomPidInit PROC					; COMDAT

; 365  : {

$LN24:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 366  : 	uint32_t i;
; 367  : 
; 368  : 	const int16_t lang = Lcid ? Lcid : LcidList[rand() % vlmcsd_countof(LcidList)];

  00014	0f b7 35 00 00
	00 00		 movzx	 esi, WORD PTR Lcid
  0001b	33 ed		 xor	 ebp, ebp
  0001d	66 85 f6	 test	 si, si
  00020	75 2f		 jne	 SHORT $LN11@randomPidI
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00028	48 63 c8	 movsxd	 rcx, eax
  0002b	48 b8 75 64 cf
	40 54 3a b2 67	 mov	 rax, 7472098865300071541 ; 67b23a5440cf6475H
  00035	48 f7 e1	 mul	 rcx
  00038	48 c1 ea 06	 shr	 rdx, 6
  0003c	48 69 c2 9e 00
	00 00		 imul	 rax, rdx, 158		; 0000009eH
  00043	48 2b c8	 sub	 rcx, rax
  00046	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:LcidList
  0004d	0f b7 34 48	 movzx	 esi, WORD PTR [rax+rcx*2]
$LN11@randomPidI:

; 369  : 
; 370  : 	for (i = 0; i < KmsData->CsvlkCount; i++)

  00051	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR KmsData
  00058	8b fd		 mov	 edi, ebp
  0005a	40 38 6a 08	 cmp	 BYTE PTR [rdx+8], bpl
  0005e	0f 86 d2 00 00
	00		 jbe	 $LN21@randomPidI
  00064	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsResponseParameters
$LL4@randomPidI:

; 371  : 	{
; 372  : 		if (KmsResponseParameters[i].Epid)

  0006b	8b df		 mov	 ebx, edi
  0006d	48 c1 e3 05	 shl	 rbx, 5
  00071	48 39 2c 0b	 cmp	 QWORD PTR [rbx+rcx], rbp
  00075	0f 85 ad 00 00
	00		 jne	 $LN2@randomPidI

; 373  : 			continue;
; 374  : 
; 375  : 		char Epid[PID_BUFFER_SIZE];
; 376  : 
; 377  : 		if (!HostBuild)

  0007b	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR HostBuild
  00082	66 85 c0	 test	 ax, ax
  00085	75 5a		 jne	 SHORT $LN6@randomPidI

; 378  : 		{
; 379  : 			uint8_t index;
; 380  : 
; 381  : #if defined(USE_MSRPC) || defined(SIMPLE_RPC)
; 382  : 			index = getRandomServerType();
; 383  : #else  // !(defined(USE_MSRPC) || defined(SIMPLE_RPC))
; 384  : 			if (IsNDR64Defined)

  00087	40 38 2d 00 00
	00 00		 cmp	 BYTE PTR IsNDR64Defined, bpl
  0008e	74 10		 je	 SHORT $LN7@randomPidI

; 385  : 			{
; 386  : 				index = getRandomServerType();

  00090	e8 00 00 00 00	 call	 getRandomServerType

; 387  : 			}

  00095	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR KmsData
  0009c	8a d0		 mov	 dl, al
  0009e	eb 2a		 jmp	 SHORT $LN8@randomPidI
$LN7@randomPidI:

; 388  : 			else
; 389  : 			{
; 390  : 				index = (uint8_t)(rand() % KmsData->HostBuildCount);

  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  000a6	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR KmsData
  000ad	99		 cdq
  000ae	41 f7 78 18	 idiv	 DWORD PTR [r8+24]

; 391  : 				UseServerRpcNDR64 = !!(KmsData->HostBuildList[index].Flags & UseNdr64);

  000b2	49 8b 40 38	 mov	 rax, QWORD PTR [r8+56]
  000b6	0f b6 ca	 movzx	 ecx, dl
  000b9	48 c1 e1 05	 shl	 rcx, 5
  000bd	8a 4c 01 18	 mov	 cl, BYTE PTR [rcx+rax+24]
  000c1	80 e1 01	 and	 cl, 1
  000c4	88 0d 00 00 00
	00		 mov	 BYTE PTR UseServerRpcNDR64, cl
$LN8@randomPidI:

; 392  : 			}
; 393  : #endif // !(defined(USE_MSRPC) || defined(SIMPLE_RPC))
; 394  : 
; 395  : 			HostBuild = (uint16_t)KmsData->HostBuildList[index].BuildNumber;

  000ca	49 8b 40 38	 mov	 rax, QWORD PTR [r8+56]
  000ce	0f b6 ca	 movzx	 ecx, dl
  000d1	48 c1 e1 05	 shl	 rcx, 5
  000d5	0f b7 44 01 10	 movzx	 eax, WORD PTR [rcx+rax+16]
  000da	66 89 05 00 00
	00 00		 mov	 WORD PTR HostBuild, ax
$LN6@randomPidI:

; 396  : 		}
; 397  : 
; 398  : 		generateRandomPid(i, Epid, lang, HostBuild);

  000e1	44 0f b7 c8	 movzx	 r9d, ax
  000e5	48 8d 54 24 20	 lea	 rdx, QWORD PTR Epid$1[rsp]
  000ea	44 0f b7 c6	 movzx	 r8d, si
  000ee	8b cf		 mov	 ecx, edi
  000f0	e8 00 00 00 00	 call	 generateRandomPid
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 373  : 	char* dst = _strdup(src);

  000f5	48 8d 4c 24 20	 lea	 rcx, QWORD PTR Epid$1[rsp]
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup

; 378  : 	if (!dst) OutOfMemory();

  00100	48 85 c0	 test	 rax, rax
  00103	74 47		 je	 SHORT $LN17@randomPidI
; File C:\Users\dev\source\repos\alpinevms\src\kms.c

; 403  : 		KmsResponseParameters[i].IsRandom = TRUE;

  00105	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsResponseParameters
  0010c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR KmsData
  00113	48 89 04 0b	 mov	 QWORD PTR [rbx+rcx], rax
  00117	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@KDKADHPB@randomized?5at?5program?5start@
  0011e	48 89 44 0b 10	 mov	 QWORD PTR [rbx+rcx+16], rax
  00123	c6 44 0b 18 01	 mov	 BYTE PTR [rbx+rcx+24], 1
$LN2@randomPidI:

; 369  : 
; 370  : 	for (i = 0; i < KmsData->CsvlkCount; i++)

  00128	0f b6 42 08	 movzx	 eax, BYTE PTR [rdx+8]
  0012c	ff c7		 inc	 edi
  0012e	3b f8		 cmp	 edi, eax
  00130	0f 82 35 ff ff
	ff		 jb	 $LL4@randomPidI
$LN21@randomPidI:

; 406  : }

  00136	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  0013b	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  0013f	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  00143	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00147	49 8b e3	 mov	 rsp, r11
  0014a	5f		 pop	 rdi
  0014b	c3		 ret	 0
$LN17@randomPidI:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 378  : 	if (!dst) OutOfMemory();

  0014c	e8 00 00 00 00	 call	 OutOfMemory
  00151	cc		 int	 3
$LN22@randomPidI:
randomPidInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT getProductIndexFromAllLists
_TEXT	SEGMENT
guid$ = 64
productName$ = 72
getProductIndexFromAllLists PROC			; COMDAT

; 412  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 413  : 	return getProductIndex(guid, KmsData->AppItemList, KmsData->AppItemCount + KmsData->KmsItemCount + KmsData->SkuItemCount, productName, NULL);

  00004	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0000a	4c 8b ca	 mov	 r9, rdx
  0000d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR KmsData
  00014	44 8b 42 14	 mov	 r8d, DWORD PTR [rdx+20]
  00018	44 03 42 10	 add	 r8d, DWORD PTR [rdx+16]
  0001c	44 03 42 0c	 add	 r8d, DWORD PTR [rdx+12]
  00020	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00024	e8 00 00 00 00	 call	 getProductIndex

; 414  : }

  00029	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002d	c3		 ret	 0
getProductIndexFromAllLists ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT logRequest
_TEXT	SEGMENT
clientName$ = 0
baseRequest$ = 80
ipstr$ = 88
productName$ = 96
logRequest PROC						; COMDAT

; 420  : {

  00000	40 55		 push	 rbp
  00002	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00006	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]

; 421  : #ifndef NO_VERBOSE_LOG
; 422  : 	if (logverbose)

  0000b	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR logverbose, 0
  00012	48 89 5d 50	 mov	 QWORD PTR [rbp+80], rbx
  00016	48 8b d9	 mov	 rbx, rcx
  00019	48 89 75 58	 mov	 QWORD PTR [rbp+88], rsi
  0001d	48 89 7d 68	 mov	 QWORD PTR [rbp+104], rdi
  00021	48 8b fa	 mov	 rdi, rdx
  00024	74 1c		 je	 SHORT $LN2@logRequest

; 423  : 	{
; 424  : 		logger("<<< Incoming KMS request\n");

  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@PGELFKLD@?$DM?$DM?$DM?5Incoming?5KMS?5request?6@
  0002d	e8 00 00 00 00	 call	 logger

; 425  : 		logRequestVerbose(baseRequest, &logger, ipstr);

  00032	4c 8b c7	 mov	 r8, rdi
  00035	48 8b cb	 mov	 rcx, rbx
  00038	e8 00 00 00 00	 call	 logRequestVerbose

; 426  : 		return;

  0003d	e9 95 00 00 00	 jmp	 $LN1@logRequest
$LN2@logRequest:

; 427  : 	}
; 428  : #endif // NO_VERBOSE_LOG
; 429  : 
; 430  : 	char *productName;
; 431  : 	char clientName[64];
; 432  : 
; 433  : 	int32_t index = getProductIndexFromAllLists(&baseRequest->ActID, &productName);

  00042	48 8d 55 60	 lea	 rdx, QWORD PTR productName$[rbp]
  00046	48 83 c1 20	 add	 rcx, 32			; 00000020H
  0004a	e8 00 00 00 00	 call	 getProductIndexFromAllLists

; 434  : 	if (index < 0)

  0004f	85 c0		 test	 eax, eax
  00051	79 22		 jns	 SHORT $LN8@logRequest

; 435  : 		index = getProductIndexFromAllLists(&baseRequest->KMSID, &productName);

  00053	48 8d 4b 30	 lea	 rcx, QWORD PTR [rbx+48]
  00057	48 8d 55 60	 lea	 rdx, QWORD PTR productName$[rbp]
  0005b	e8 00 00 00 00	 call	 getProductIndexFromAllLists

; 436  : 	if (index < 0)

  00060	85 c0		 test	 eax, eax
  00062	79 11		 jns	 SHORT $LN8@logRequest

; 437  : 		index = getProductIndexFromAllLists(&baseRequest->AppID, &productName);

  00064	48 8d 4b 10	 lea	 rcx, QWORD PTR [rbx+16]
  00068	48 8d 55 60	 lea	 rdx, QWORD PTR productName$[rbp]
  0006c	e8 00 00 00 00	 call	 getProductIndexFromAllLists

; 438  : 
; 439  : 	if (index < 0 || !strcasecmp(productName, "Unknown"))

  00071	85 c0		 test	 eax, eax
  00073	78 18		 js	 SHORT $LN6@logRequest
$LN8@logRequest:
  00075	48 8b 7d 60	 mov	 rdi, QWORD PTR productName$[rbp]
  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07NBCGADJA@Unknown@
  00080	48 8b cf	 mov	 rcx, rdi
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00089	85 c0		 test	 eax, eax
  0008b	75 1a		 jne	 SHORT $LN5@logRequest
$LN6@logRequest:

; 440  : 	{
; 441  : 		productName = (char *)alloca(GUID_STRING_LENGTH + 1);

  0008d	8b 04 24	 mov	 eax, DWORD PTR [rsp]
  00090	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00094	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00099	8b 07		 mov	 eax, DWORD PTR [rdi]

; 442  : 		uuid2StringLE(&baseRequest->ActID, productName);

  0009b	48 8b d7	 mov	 rdx, rdi
  0009e	48 8d 4b 20	 lea	 rcx, QWORD PTR [rbx+32]
  000a2	e8 00 00 00 00	 call	 uuid2StringLE
$LN5@logRequest:

; 443  : 	}
; 444  : 
; 445  : 	ucs2_to_utf8(baseRequest->WorkstationName, clientName, 64, 64);

  000a7	48 8d 4b 6c	 lea	 rcx, QWORD PTR [rbx+108]
  000ab	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  000b1	48 8d 55 00	 lea	 rdx, QWORD PTR clientName$[rbp]
  000b5	e8 00 00 00 00	 call	 ucs2_to_utf8

; 446  : 	logger("KMS v%i.%i request from %s for %s\n", LE16(baseRequest->MajorVer), LE16(baseRequest->MinorVer), clientName, productName);

  000ba	44 0f b7 03	 movzx	 r8d, WORD PTR [rbx]
  000be	4c 8d 4d 00	 lea	 r9, QWORD PTR clientName$[rbp]
  000c2	0f b7 53 02	 movzx	 edx, WORD PTR [rbx+2]
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@NIMMPCGA@KMS?5v?$CFi?4?$CFi?5request?5from?5?$CFs?5for?5@
  000cd	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  000d2	e8 00 00 00 00	 call	 logger
$LN1@logRequest:

; 447  : }

  000d7	48 8b 5d 50	 mov	 rbx, QWORD PTR [rbp+80]
  000db	48 8b 75 58	 mov	 rsi, QWORD PTR [rbp+88]
  000df	48 8b 7d 68	 mov	 rdi, QWORD PTR [rbp+104]
  000e3	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000e7	5d		 pop	 rbp
  000e8	c3		 ret	 0
logRequest ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT getEpidFromString
_TEXT	SEGMENT
Response$ = 48
pid$ = 56
getEpidFromString PROC					; COMDAT

; 455  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 456  : 	const size_t length = utf8_to_ucs2(Response->KmsPID, pid, PID_BUFFER_SIZE, PID_BUFFER_SIZE * 3);

  00009	48 83 c1 08	 add	 rcx, 8
  0000d	e8 00 00 00 00	 call	 utf8_to_ucs2

; 457  : 	Response->PIDSize = LE32(((unsigned int)length + 1) << 1);

  00012	8d 14 45 02 00
	00 00		 lea	 edx, DWORD PTR [rax*2+2]
  00019	89 53 04	 mov	 DWORD PTR [rbx+4], edx

; 458  : }

  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5b		 pop	 rbx
  00021	c3		 ret	 0
getEpidFromString ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT getEpid
_TEXT	SEGMENT
ePid$1 = 32
baseResponse$ = 112
EpidSource$ = 120
index$ = 128
HwId$ = 136
defaultEPid$ = 144
getEpid	PROC						; COMDAT

; 464  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 465  : #if !defined(NO_RANDOM_EPID) || !defined(NO_CL_PIDS) || !defined(NO_INI_FILE)
; 466  : 	const char *pid;
; 467  : 	if (KmsResponseParameters[index].Epid == NULL)

  0000a	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR KmsResponseParameters
  00011	48 8b da	 mov	 rbx, rdx
  00014	49 63 c0	 movsxd	 rax, r8d
  00017	48 8b f9	 mov	 rdi, rcx
  0001a	48 8b d0	 mov	 rdx, rax
  0001d	48 c1 e2 05	 shl	 rdx, 5
  00021	4e 8b 14 1a	 mov	 r10, QWORD PTR [rdx+r11]
  00025	4d 85 d2	 test	 r10, r10
  00028	75 44		 jne	 SHORT $LN2@getEpid

; 468  : 	{
; 469  : #ifndef NO_RANDOM_EPID
; 470  : 		if (RandomizationLevel == 2)

  0002a	80 3d 00 00 00
	00 02		 cmp	 BYTE PTR RandomizationLevel, 2
  00031	75 2a		 jne	 SHORT $LN4@getEpid

; 471  : 		{
; 472  : 			char ePid[PID_BUFFER_SIZE];
; 473  : 			generateRandomPid(index, ePid, Lcid, HostBuild);

  00033	44 0f b7 0d 00
	00 00 00	 movzx	 r9d, WORD PTR HostBuild
  0003b	48 8d 54 24 20	 lea	 rdx, QWORD PTR ePid$1[rsp]
  00040	44 0f b7 05 00
	00 00 00	 movzx	 r8d, WORD PTR Lcid
  00048	8b c8		 mov	 ecx, eax
  0004a	e8 00 00 00 00	 call	 generateRandomPid

; 474  : 			pid = ePid;

  0004f	4c 8d 54 24 20	 lea	 r10, QWORD PTR ePid$1[rsp]

; 475  : 
; 476  : #ifndef NO_LOG
; 477  : 			*EpidSource = "randomized on every request";

  00054	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@JLIHBDJL@randomized?5on?5every?5request@

; 478  : #endif // NO_LOG
; 479  : 		}

  0005b	eb 2b		 jmp	 SHORT $LN3@getEpid
$LN4@getEpid:

; 480  : 		else
; 481  : #endif // NO_RANDOM_EPID
; 482  : 		{
; 483  : 			pid = defaultEPid;

  0005d	4c 8b 94 24 90
	00 00 00	 mov	 r10, QWORD PTR defaultEPid$[rsp]

; 484  : #ifndef NO_LOG
; 485  : 			*EpidSource = "vlmcsd default";

  00065	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0P@CACDFLGA@vlmcsd?5default@

; 486  : #endif // NO_LOG
; 487  : 		}
; 488  : 	}

  0006c	eb 1a		 jmp	 SHORT $LN3@getEpid
$LN2@getEpid:

; 489  : 	else
; 490  : 	{
; 491  : 		pid = KmsResponseParameters[index].Epid;
; 492  : 
; 493  : 		if (HwId && KmsResponseParameters[index].HwId != NULL)

  0006e	4d 85 c9	 test	 r9, r9
  00071	74 10		 je	 SHORT $LN6@getEpid
  00073	4a 8b 44 1a 08	 mov	 rax, QWORD PTR [rdx+r11+8]
  00078	48 85 c0	 test	 rax, rax
  0007b	74 06		 je	 SHORT $LN6@getEpid

; 494  : 			memcpy(HwId, KmsResponseParameters[index].HwId, sizeof(((RESPONSE_V6 *)0)->HwId));

  0007d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00080	49 89 01	 mov	 QWORD PTR [r9], rax
$LN6@getEpid:

; 495  : 
; 496  : #ifndef NO_LOG
; 497  : 		*EpidSource = KmsResponseParameters[index].EpidSource;

  00083	4a 8b 44 1a 10	 mov	 rax, QWORD PTR [rdx+r11+16]
$LN3@getEpid:

; 456  : 	const size_t length = utf8_to_ucs2(Response->KmsPID, pid, PID_BUFFER_SIZE, PID_BUFFER_SIZE * 3);

  00088	48 8d 4f 08	 lea	 rcx, QWORD PTR [rdi+8]
  0008c	48 89 03	 mov	 QWORD PTR [rbx], rax
  0008f	49 8b d2	 mov	 rdx, r10
  00092	e8 00 00 00 00	 call	 utf8_to_ucs2

; 498  : #endif // NO_LOG
; 499  : 	}
; 500  : 
; 501  : 	getEpidFromString(baseResponse, pid);
; 502  : 
; 503  : #else // defined(NO_RANDOM_EPID) && defined(NO_CL_PIDS) && !defined(NO_INI_FILE)
; 504  : 
; 505  : 	getEpidFromString(baseResponse, defaultEPid);
; 506  : 
; 507  : #ifndef NO_LOG
; 508  : 	*EpidSource = "vlmcsd default";
; 509  : #endif // NO_LOG
; 510  : 
; 511  : #endif // defined(NO_RANDOM_EPID) && defined(NO_CL_PIDS) && !defined(NO_INI_FILE)
; 512  : }

  00097	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]

; 457  : 	Response->PIDSize = LE32(((unsigned int)length + 1) << 1);

  0009c	8d 0c 45 02 00
	00 00		 lea	 ecx, DWORD PTR [rax*2+2]
  000a3	89 4f 04	 mov	 DWORD PTR [rdi+4], ecx

; 498  : #endif // NO_LOG
; 499  : 	}
; 500  : 
; 501  : 	getEpidFromString(baseResponse, pid);
; 502  : 
; 503  : #else // defined(NO_RANDOM_EPID) && defined(NO_CL_PIDS) && !defined(NO_INI_FILE)
; 504  : 
; 505  : 	getEpidFromString(baseResponse, defaultEPid);
; 506  : 
; 507  : #ifndef NO_LOG
; 508  : 	*EpidSource = "vlmcsd default";
; 509  : #endif // NO_LOG
; 510  : 
; 511  : #endif // defined(NO_RANDOM_EPID) && defined(NO_CL_PIDS) && !defined(NO_INI_FILE)
; 512  : }

  000a6	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
getEpid	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT logResponse
_TEXT	SEGMENT
utf8pid$ = 32
baseResponse$ = 240
hwId$ = 248
EpidSource$ = 256
logResponse PROC					; COMDAT

; 546  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b f9	 mov	 rdi, rcx

; 547  : 	char utf8pid[PID_BUFFER_SIZE * 3];
; 548  : 	ucs2_to_utf8(baseResponse->KmsPID, utf8pid, PID_BUFFER_SIZE, PID_BUFFER_SIZE * 3);

  00018	48 83 c1 08	 add	 rcx, 8
  0001c	48 8d 54 24 20	 lea	 rdx, QWORD PTR utf8pid$[rsp]
  00021	41 b9 c0 00 00
	00		 mov	 r9d, 192		; 000000c0H
  00027	49 8b d8	 mov	 rbx, r8
  0002a	e8 00 00 00 00	 call	 ucs2_to_utf8

; 549  : 
; 550  : #ifndef NO_VERBOSE_LOG
; 551  : 	if (!logverbose)

  0002f	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR logverbose, 0
  00036	48 8b d3	 mov	 rdx, rbx
  00039	75 13		 jne	 SHORT $LN2@logRespons

; 552  : 	{
; 553  : #endif // NO_VERBOSE_LOG
; 554  : 		logger("Sending ePID (%s): %s\n", EpidSource, utf8pid);

  0003b	4c 8d 44 24 20	 lea	 r8, QWORD PTR utf8pid$[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@ECOFGFLJ@Sending?5ePID?5?$CI?$CFs?$CJ?3?5?$CFs?6@
  00047	e8 00 00 00 00	 call	 logger

; 555  : #ifndef NO_VERBOSE_LOG
; 556  : 	}

  0004c	eb 1c		 jmp	 SHORT $LN3@logRespons
$LN2@logRespons:

; 557  : 	else
; 558  : 	{
; 559  : 		logger(">>> Sending response, ePID source = %s\n", EpidSource);

  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CI@NLELAFGA@?$DO?$DO?$DO?5Sending?5response?0?5ePID?5sour@
  00055	e8 00 00 00 00	 call	 logger

; 560  : 		logResponseVerbose(utf8pid, hwId, baseResponse, &logger);

  0005a	4c 8b c7	 mov	 r8, rdi
  0005d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR utf8pid$[rsp]
  00062	48 8b d6	 mov	 rdx, rsi
  00065	e8 00 00 00 00	 call	 logResponseVerbose
$LN3@logRespons:

; 561  : 	}
; 562  : #endif // NO_VERBOSE_LOG
; 563  : }

  0006a	4c 8d 9c 24 e0
	00 00 00	 lea	 r11, QWORD PTR [rsp+224]
  00072	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00076	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  0007a	49 8b e3	 mov	 rsp, r11
  0007d	5f		 pop	 rdi
  0007e	c3		 ret	 0
logResponse ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\time.h
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\time.h
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT CreateResponseBaseCallback
_TEXT	SEGMENT
EpidSource$ = 128
ePid$ = 128
baseRequest$ = 128
baseResponse$ = 136
hwId$ = 144
ipstr_unused$ = 152
CreateResponseBaseCallback PROC				; COMDAT

; 575  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 55		 push	 r13
  00011	41 56		 push	 r14
  00013	41 57		 push	 r15
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8b f2	 mov	 rsi, rdx
  0001c	4c 8b f1	 mov	 r14, rcx

; 576  : 	const char *EpidSource;
; 577  : #ifndef NO_LOG
; 578  : 	logRequest(baseRequest,ipstr_unused);

  0001f	49 8b d1	 mov	 rdx, r9
  00022	e8 00 00 00 00	 call	 logRequest

; 579  : #ifdef _PEDANTIC
; 580  : 	CheckRequest(baseRequest);
; 581  : #endif // _PEDANTIC
; 582  : #endif // NO_LOG
; 583  : 
; 584  : 	char *ePid;
; 585  : 	const DWORD minClients = LE32(baseRequest->N_Policy);

  00027	41 8b 46 50	 mov	 eax, DWORD PTR [r14+80]

; 586  : 	const DWORD required_clients = minClients < 1 ? 1 : minClients << 1;
; 587  : 
; 588  : 	const int32_t index = getProductIndex(&baseRequest->KMSID, KmsData->KmsItemList, KmsData->KmsItemCount, NULL, &ePid);

  0002b	49 8d 4e 30	 lea	 rcx, QWORD PTR [r14+48]
  0002f	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR KmsData
  00036	bb 01 00 00 00	 mov	 ebx, 1
  0003b	3b c3		 cmp	 eax, ebx
  0003d	8d 2c 00	 lea	 ebp, DWORD PTR [rax+rax]
  00040	45 8b 43 10	 mov	 r8d, DWORD PTR [r11+16]
  00044	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR ePid$[rsp]
  0004c	49 8b 53 28	 mov	 rdx, QWORD PTR [r11+40]
  00050	0f 42 eb	 cmovb	 ebp, ebx
  00053	45 33 c9	 xor	 r9d, r9d
  00056	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005b	e8 00 00 00 00	 call	 getProductIndex
  00060	4c 63 f8	 movsxd	 r15, eax

; 589  : 
; 590  : #ifndef NO_STRICT_MODES
; 591  : 
; 592  : 	if (required_clients > 2000)

  00063	81 fd d0 07 00
	00		 cmp	 ebp, 2000		; 000007d0H
  00069	76 16		 jbe	 SHORT $LN8@CreateResp

; 593  : 	{
; 594  : #ifndef NO_LOG
; 595  : 		logger("Rejecting request with more than 1000 minimum clients (0x8007000D)\n");

  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EE@GPFGCDIC@Rejecting?5request?5with?5more?5tha@
  00072	e8 00 00 00 00	 call	 logger

; 596  : #endif
; 597  : 
; 598  : 		return 0x8007000D;

  00077	b8 0d 00 07 80	 mov	 eax, -2147024883	; ffffffff8007000dH
  0007c	e9 46 03 00 00	 jmp	 $LN1@CreateResp
$LN8@CreateResp:

; 599  : 	}
; 600  : 
; 601  : 	if (CheckClientTime)

  00081	33 ff		 xor	 edi, edi
  00083	40 38 3d 00 00
	00 00		 cmp	 BYTE PTR CheckClientTime, dil
  0008a	74 62		 je	 SHORT $LN10@CreateResp

; 164  : 	return GET_UA64LE(ts) / 10000000LL - 11644473600LL;

  0008c	48 b8 bd 42 7a
	e5 d5 94 bf d6	 mov	 rax, -2972493582642298179 ; d6bf94d5e57a42bdH
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

  00096	33 c9		 xor	 ecx, ecx
; File C:\Users\dev\source\repos\alpinevms\src\kms.c

; 164  : 	return GET_UA64LE(ts) / 10000000LL - 11644473600LL;

  00098	49 f7 66 54	 mul	 QWORD PTR [r14+84]
  0009c	48 b8 00 91 10
	b6 02 00 00 00	 mov	 rax, 11644473600	; 00000002b6109100H
  000a6	48 8b da	 mov	 rbx, rdx
  000a9	48 c1 eb 17	 shr	 rbx, 23
  000ad	48 2b d8	 sub	 rbx, rax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64
; File C:\Users\dev\source\repos\alpinevms\src\kms.c

; 605  : 		if (llabs(requestTime - time(NULL)) > 60 * 60 * 4)

  000b6	48 2b d8	 sub	 rbx, rax
  000b9	48 8b c3	 mov	 rax, rbx
  000bc	48 99		 cdq
  000be	48 33 c2	 xor	 rax, rdx
  000c1	48 2b c2	 sub	 rax, rdx
  000c4	48 3d 40 38 00
	00		 cmp	 rax, 14400		; 00003840H
  000ca	7e 16		 jle	 SHORT $LN55@CreateResp

; 606  : 		{
; 607  : #ifndef NO_LOG
; 608  : 			logger("Client time differs more than 4 hours from system time (0xC004F06C)\n");

  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EF@NBMAOLBH@Client?5time?5differs?5more?5than?54@
  000d3	e8 00 00 00 00	 call	 logger

; 609  : #endif // !NO_LOG
; 610  : 
; 611  : 			return 0xC004F06C;

  000d8	b8 6c f0 04 c0	 mov	 eax, -1073418132	; ffffffffc004f06cH
  000dd	e9 e5 02 00 00	 jmp	 $LN1@CreateResp
$LN55@CreateResp:

; 605  : 		if (llabs(requestTime - time(NULL)) > 60 * 60 * 4)

  000e2	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR KmsData
  000e9	bb 01 00 00 00	 mov	 ebx, 1
$LN10@CreateResp:

; 612  : 		}
; 613  : 	}
; 614  : 
; 615  : 	if (WhitelistingLevel & 2)

  000ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR WhitelistingLevel
  000f4	f6 c2 02	 test	 dl, 2
  000f7	74 34		 je	 SHORT $LN12@CreateResp

; 616  : 	{
; 617  : 		if (index >= 0 && (KmsData->KmsItemList[index].IsPreview || KmsData->KmsItemList[index].IsRetail))

  000f9	45 85 ff	 test	 r15d, r15d
  000fc	78 2f		 js	 SHORT $LN12@CreateResp
  000fe	49 8b 4b 28	 mov	 rcx, QWORD PTR [r11+40]
  00102	49 8b c7	 mov	 rax, r15
  00105	48 c1 e0 05	 shl	 rax, 5
  00109	40 38 7c 08 1d	 cmp	 BYTE PTR [rax+rcx+29], dil
  0010e	75 07		 jne	 SHORT $LN13@CreateResp
  00110	40 38 7c 08 1c	 cmp	 BYTE PTR [rax+rcx+28], dil
  00115	74 16		 je	 SHORT $LN12@CreateResp
$LN13@CreateResp:

; 618  : 		{
; 619  : #ifndef NO_LOG
; 620  : 			logger("Refusing retail or beta product (0xC004F042)\n");

  00117	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@GEBKAAHB@Refusing?5retail?5or?5beta?5product@
$LN58@CreateResp:

; 740  : }

  0011e	e8 00 00 00 00	 call	 logger
  00123	b8 42 f0 04 c0	 mov	 eax, -1073418174	; ffffffffc004f042H
  00128	e9 9a 02 00 00	 jmp	 $LN1@CreateResp
$LN12@CreateResp:

; 621  : #endif // !NO_LOG
; 622  : 
; 623  : 			return 0xC004F042;
; 624  : 		}
; 625  : 	}
; 626  : 
; 627  : 	if ((WhitelistingLevel & 1) && index < 0)

  0012d	23 d3		 and	 edx, ebx
  0012f	45 85 ff	 test	 r15d, r15d
  00132	0f 89 92 00 00
	00		 jns	 $LN26@CreateResp
  00138	85 d2		 test	 edx, edx
  0013a	74 09		 je	 SHORT $LN14@CreateResp

; 628  : 	{
; 629  : #ifndef NO_LOG
; 630  : 		logger("Refusing unknown product (0xC004F042)\n");

  0013c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@OKECOFDM@Refusing?5unknown?5product?5?$CI0xC00@

; 631  : #endif // !NO_LOG
; 632  : 
; 633  : 		return 0xC004F042;

  00143	eb d9		 jmp	 SHORT $LN58@CreateResp
$LN14@CreateResp:

; 634  : 	}
; 635  : 
; 636  : #ifndef NO_CLIENT_LIST
; 637  : 	const int32_t appIndex = index < 0 ? 0 : KmsData->KmsItemList[index].AppIndex;

  00145	48 8b df	 mov	 rbx, rdi

; 638  : #endif // NO_CLIENT_LIST
; 639  : 
; 640  : #endif // !NO_STRICT_MODES
; 641  : 
; 642  : 	const int32_t ePidIndex = index < 0 ? 0 : KmsData->KmsItemList[index].EPidIndex;

  00148	44 8b ef	 mov	 r13d, edi
  0014b	4c 8b e7	 mov	 r12, rdi
$LN15@CreateResp:

; 652  : 	}
; 653  : 
; 654  : #ifndef NO_CLIENT_LIST
; 655  : 	if (MaintainClients)

  0014e	40 38 3d 00 00
	00 00		 cmp	 BYTE PTR MaintainClients, dil
  00155	0f 84 dd 01 00
	00		 je	 $LN16@CreateResp

; 656  : 	{
; 657  : 		lock_client_lists();

  0015b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR mutex
  00162	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 658  : 
; 659  : 		int_fast16_t i;
; 660  : 		int_fast8_t isKnownClient = FALSE;
; 661  : 
; 662  : 		if (required_clients > (DWORD)ClientLists[appIndex].MaxCount)

  00168	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR ClientLists
  0016f	4c 69 d3 fc 29
	00 00		 imul	 r10, rbx, 10748		; 000029fcH
  00176	43 8b 94 02 f4
	29 00 00	 mov	 edx, DWORD PTR [r10+r8+10740]
  0017e	3b ea		 cmp	 ebp, edx
  00180	76 0a		 jbe	 SHORT $LN18@CreateResp

; 663  : 			ClientLists[appIndex].MaxCount = required_clients;

  00182	43 89 ac 02 f4
	29 00 00	 mov	 DWORD PTR [r10+r8+10740], ebp
  0018a	8b d5		 mov	 edx, ebp
$LN18@CreateResp:

; 664  : 
; 665  : 		for (i = 0; i < ClientLists[appIndex].MaxCount; i++)

  0018c	44 8b cf	 mov	 r9d, edi
  0018f	41 bb 9f 02 00
	00		 mov	 r11d, 671		; 0000029fH
  00195	85 d2		 test	 edx, edx
  00197	0f 8e a9 00 00
	00		 jle	 $LN20@CreateResp
$LL4@CreateResp:

; 666  : 		{
; 667  : 			if (IsEqualGUID(&ClientLists[appIndex].Guid[i], &baseRequest->CMID))

  0019d	49 63 c9	 movsxd	 rcx, r9d
  001a0	48 c1 e1 04	 shl	 rcx, 4
  001a4	49 03 ca	 add	 rcx, r10
  001a7	4a 8b 04 01	 mov	 rax, QWORD PTR [rcx+r8]
  001ab	49 3b 46 40	 cmp	 rax, QWORD PTR [r14+64]
  001af	75 0b		 jne	 SHORT $LN52@CreateResp
  001b1	4a 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+r8+8]
  001b6	49 3b 46 48	 cmp	 rax, QWORD PTR [r14+72]
  001ba	74 70		 je	 SHORT $LN46@CreateResp
$LN52@CreateResp:

; 664  : 
; 665  : 		for (i = 0; i < ClientLists[appIndex].MaxCount; i++)

  001bc	41 ff c1	 inc	 r9d
  001bf	44 3b ca	 cmp	 r9d, edx
  001c2	0f 8d 85 00 00
	00		 jge	 $LN54@CreateResp
  001c8	eb d3		 jmp	 SHORT $LL4@CreateResp
$LN26@CreateResp:

; 634  : 	}
; 635  : 
; 636  : #ifndef NO_CLIENT_LIST
; 637  : 	const int32_t appIndex = index < 0 ? 0 : KmsData->KmsItemList[index].AppIndex;

  001ca	49 8b 43 28	 mov	 rax, QWORD PTR [r11+40]
  001ce	49 8b cf	 mov	 rcx, r15
  001d1	48 c1 e1 05	 shl	 rcx, 5
  001d5	4d 8b c7	 mov	 r8, r15

; 638  : #endif // NO_CLIENT_LIST
; 639  : 
; 640  : #endif // !NO_STRICT_MODES
; 641  : 
; 642  : 	const int32_t ePidIndex = index < 0 ? 0 : KmsData->KmsItemList[index].EPidIndex;

  001d8	49 c1 e0 05	 shl	 r8, 5
  001dc	0f b6 5c 01 18	 movzx	 ebx, BYTE PTR [rcx+rax+24]
  001e1	46 0f b6 6c 00
	1e		 movzx	 r13d, BYTE PTR [rax+r8+30]

; 643  : 
; 644  : #if !defined(NO_STRICT_MODES)
; 645  : 
; 646  : 	if ((WhitelistingLevel & 1) && index >= 0 && !IsEqualGUID(&KmsData->AppItemList[KmsData->KmsItemList[index].AppIndex].Guid, &baseRequest->AppID))

  001e7	44 8b e3	 mov	 r12d, ebx
  001ea	85 d2		 test	 edx, edx
  001ec	0f 84 5c ff ff
	ff		 je	 $LN15@CreateResp
  001f2	45 85 ff	 test	 r15d, r15d
  001f5	0f 88 53 ff ff
	ff		 js	 $LN15@CreateResp
  001fb	42 0f b6 4c 00
	18		 movzx	 ecx, BYTE PTR [rax+r8+24]
  00201	48 c1 e1 05	 shl	 rcx, 5
  00205	49 03 4b 20	 add	 rcx, QWORD PTR [r11+32]
  00209	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0020c	49 3b 46 10	 cmp	 rax, QWORD PTR [r14+16]
  00210	75 0e		 jne	 SHORT $LN53@CreateResp
  00212	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00216	49 3b 46 18	 cmp	 rax, QWORD PTR [r14+24]
  0021a	0f 84 2e ff ff
	ff		 je	 $LN15@CreateResp
$LN53@CreateResp:

; 647  : 	{
; 648  : #ifndef NO_LOG
; 649  : 		logger("Refusing product with incorrect Application ID (0xC004F042)\n");

  00220	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DN@KPFNIABO@Refusing?5product?5with?5incorrect@

; 650  : #endif // NO_LOG
; 651  : 		return 0xC004F042;

  00227	e9 f2 fe ff ff	 jmp	 $LN58@CreateResp
$LN46@CreateResp:

; 668  : 			{
; 669  : 				isKnownClient = TRUE;
; 670  : 				break;
; 671  : 			}
; 672  : 		}
; 673  : 
; 674  : 		if (isKnownClient)

  0022c	48 69 c3 fc 29
	00 00		 imul	 rax, rbx, 10748		; 000029fcH

; 675  : 		{
; 676  : 			baseResponse->Count = LE32(ClientLists[appIndex].CurrentCount);

  00233	42 8b 8c 00 f0
	29 00 00	 mov	 ecx, DWORD PTR [rax+r8+10736]
  0023b	89 8e a0 00 00
	00		 mov	 DWORD PTR [rsi+160], ecx

; 677  : 		}

  00241	e9 e3 00 00 00	 jmp	 $LN24@CreateResp
$LN20@CreateResp:

; 678  : 		else
; 679  : 		{
; 680  : 			for (i = 0; i < ClientLists[appIndex].MaxCount; i++)

  00246	49 8b dc	 mov	 rbx, r12
  00249	85 d2		 test	 edx, edx
  0024b	7e 7f		 jle	 SHORT $LN57@CreateResp
$LN54@CreateResp:
  0024d	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR ZeroGuid+8
  00254	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ZeroGuid
$LL50@CreateResp:

; 681  : 			{
; 682  : 				if (IsEqualGUID(ZeroGuid, &ClientLists[appIndex].Guid[i]))

  0025b	48 63 cf	 movsxd	 rcx, edi
  0025e	48 c1 e1 04	 shl	 rcx, 4
  00262	49 03 ca	 add	 rcx, r10
  00265	4e 3b 0c 01	 cmp	 r9, QWORD PTR [rcx+r8]
  00269	75 07		 jne	 SHORT $LN51@CreateResp
  0026b	4a 3b 44 01 08	 cmp	 rax, QWORD PTR [rcx+r8+8]
  00270	74 08		 je	 SHORT $LN39@CreateResp
$LN51@CreateResp:

; 678  : 		else
; 679  : 		{
; 680  : 			for (i = 0; i < ClientLists[appIndex].MaxCount; i++)

  00272	ff c7		 inc	 edi
  00274	3b fa		 cmp	 edi, edx
  00276	7d 54		 jge	 SHORT $LN57@CreateResp
  00278	eb e1		 jmp	 SHORT $LL50@CreateResp
$LN39@CreateResp:

; 683  : 				{
; 684  : 					if (ClientLists[appIndex].CurrentCount >= MAX_CLIENTS)

  0027a	48 69 d3 fc 29
	00 00		 imul	 rdx, rbx, 10748		; 000029fcH
  00281	42 8b 84 02 f0
	29 00 00	 mov	 eax, DWORD PTR [rdx+r8+10736]
  00289	41 3b c3	 cmp	 eax, r11d
  0028c	7c 23		 jl	 SHORT $LN23@CreateResp

; 685  : 					{
; 686  : #ifndef NO_LOG
; 687  : 						logger("Rejecting more than 671 clients (0xC004D104)\n");

  0028e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@CIIKPOBH@Rejecting?5more?5than?5671?5clients@
  00295	e8 00 00 00 00	 call	 logger

; 688  : #endif // !NO_LOG
; 689  : 
; 690  : 						unlock_client_lists();

  0029a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR mutex
  002a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 691  : 						return 0xC004D104;

  002a7	b8 04 d1 04 c0	 mov	 eax, -1073426172	; ffffffffc004d104H
  002ac	e9 16 01 00 00	 jmp	 $LN1@CreateResp
$LN23@CreateResp:

; 692  : 					}
; 693  : 
; 694  : 					baseResponse->Count = LE32(++ClientLists[appIndex].CurrentCount);

  002b1	ff c0		 inc	 eax
  002b3	42 89 84 02 f0
	29 00 00	 mov	 DWORD PTR [rdx+r8+10736], eax
  002bb	89 86 a0 00 00
	00		 mov	 DWORD PTR [rsi+160], eax

; 695  : 					memcpy(&ClientLists[appIndex].Guid[i], &baseRequest->CMID, sizeof(GUID));

  002c1	41 0f 10 46 40	 movups	 xmm0, XMMWORD PTR [r14+64]
  002c6	f3 42 0f 7f 04
	01		 movdqu	 XMMWORD PTR [rcx+r8], xmm0
$LN57@CreateResp:

; 696  : 					break;
; 697  : 				}
; 698  : 			}
; 699  : 
; 700  : 			if (i >= ClientLists[appIndex].MaxCount)

  002cc	4c 69 cb fc 29
	00 00		 imul	 r9, rbx, 10748		; 000029fcH
  002d3	43 3b bc 01 f4
	29 00 00	 cmp	 edi, DWORD PTR [r9+r8+10740]
  002db	7c 4c		 jl	 SHORT $LN24@CreateResp

; 701  : 			{
; 702  : 				memcpy(&ClientLists[appIndex].Guid[ClientLists[appIndex].CurrentPosition], &baseRequest->CMID, sizeof(GUID));

  002dd	4b 63 84 01 f8
	29 00 00	 movsxd	 rax, DWORD PTR [r9+r8+10744]
  002e5	41 0f 10 46 40	 movups	 xmm0, XMMWORD PTR [r14+64]
  002ea	48 c1 e0 04	 shl	 rax, 4
  002ee	49 03 c1	 add	 rax, r9
  002f1	f3 42 0f 7f 04
	00		 movdqu	 XMMWORD PTR [rax+r8], xmm0

; 703  : 				ClientLists[appIndex].CurrentPosition = (ClientLists[appIndex].CurrentPosition + 1) % (ClientLists[appIndex].MaxCount > MAX_CLIENTS ? MAX_CLIENTS : ClientLists[appIndex].MaxCount);

  002f7	43 8b 8c 01 f4
	29 00 00	 mov	 ecx, DWORD PTR [r9+r8+10740]
  002ff	41 3b cb	 cmp	 ecx, r11d
  00302	43 8b 84 01 f8
	29 00 00	 mov	 eax, DWORD PTR [r9+r8+10744]
  0030a	41 0f 4f cb	 cmovg	 ecx, r11d
  0030e	ff c0		 inc	 eax
  00310	99		 cdq
  00311	f7 f9		 idiv	 ecx

; 704  : 				baseResponse->Count = LE32(ClientLists[appIndex].CurrentCount);

  00313	43 8b 84 01 f0
	29 00 00	 mov	 eax, DWORD PTR [r9+r8+10736]
  0031b	43 89 94 01 f8
	29 00 00	 mov	 DWORD PTR [r9+r8+10744], edx
  00323	89 86 a0 00 00
	00		 mov	 DWORD PTR [rsi+160], eax
$LN24@CreateResp:

; 705  : 			}
; 706  : 		}
; 707  : 
; 708  : 		unlock_client_lists();

  00329	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR mutex
  00330	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 709  : 	}

  00336	eb 18		 jmp	 SHORT $LN17@CreateResp
$LN16@CreateResp:

; 710  : 	else
; 711  : #endif // !NO_CLIENT_LIST
; 712  : #endif // !defined(NO_STRICT_MODES)
; 713  : 	{
; 714  : 		const uint8_t minimum_answer_clients = (uint8_t)KmsData->CsvlkData[ePidIndex].MinActiveClients;

  00338	41 8b c5	 mov	 eax, r13d
  0033b	48 c1 e0 05	 shl	 rax, 5

; 715  : 		baseResponse->Count = LE32(required_clients > minimum_answer_clients ? required_clients : minimum_answer_clients);

  0033f	42 0f b6 4c 18
	64		 movzx	 ecx, BYTE PTR [rax+r11+100]
  00345	3b e9		 cmp	 ebp, ecx
  00347	0f 47 cd	 cmova	 ecx, ebp
  0034a	89 8e a0 00 00
	00		 mov	 DWORD PTR [rsi+160], ecx
$LN17@CreateResp:

; 716  : 		// if (LE32(baseRequest->N_Policy) > LE32(baseResponse->Count)) baseResponse->Count = LE32(LE32(baseRequest->N_Policy) << 1);
; 717  : 	}
; 718  : 
; 719  : 	getEpid(baseResponse, &EpidSource, ePidIndex, hwId, ePid);

  00350	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ePid$[rsp]
  00358	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR EpidSource$[rsp]
  00360	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR hwId$[rsp]
  00368	45 8b c5	 mov	 r8d, r13d
  0036b	48 8b ce	 mov	 rcx, rsi
  0036e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00373	e8 00 00 00 00	 call	 getEpid

; 720  : 
; 721  : 	baseResponse->Version = baseRequest->Version;

  00378	41 8b 06	 mov	 eax, DWORD PTR [r14]

; 722  : 
; 723  : 	memcpy(&baseResponse->CMID, &baseRequest->CMID, sizeof(GUID));
; 724  : 	memcpy(&baseResponse->ClientTime, &baseRequest->ClientTime, sizeof(FILETIME));
; 725  : 
; 726  : 	baseResponse->VLActivationInterval = LE32(VLActivationInterval);
; 727  : 	baseResponse->VLRenewalInterval = LE32(VLRenewalInterval);
; 728  : 
; 729  : #ifndef NO_LOG
; 730  : 	logResponse(baseResponse, hwId, EpidSource);

  0037b	48 8b ce	 mov	 rcx, rsi
  0037e	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR EpidSource$[rsp]
  00386	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR hwId$[rsp]
  0038e	89 06		 mov	 DWORD PTR [rsi], eax
  00390	41 0f 10 46 40	 movups	 xmm0, XMMWORD PTR [r14+64]
  00395	f3 0f 7f 86 88
	00 00 00	 movdqu	 XMMWORD PTR [rsi+136], xmm0
  0039d	49 8b 46 54	 mov	 rax, QWORD PTR [r14+84]
  003a1	48 89 86 98 00
	00 00		 mov	 QWORD PTR [rsi+152], rax
  003a8	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR VLActivationInterval
  003ae	89 86 a4 00 00
	00		 mov	 DWORD PTR [rsi+164], eax
  003b4	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR VLRenewalInterval
  003ba	89 86 a8 00 00
	00		 mov	 DWORD PTR [rsi+168], eax
  003c0	e8 00 00 00 00	 call	 logResponse

; 731  : #endif // NO_LOG
; 732  : #ifdef LOG_TO_MONGODB
; 733  : 	if ((strlen(mongoDbApiURL) > 0) && (strlen(mongoDbApiKey) > 0))
; 734  : 	{
; 735  : 		logger("We will log to MongoDB\n");
; 736  : 		logToMongoDB(baseRequest, baseResponse, mongoDbApiURL, mongoDbApiKey);
; 737  : 	}
; 738  : #endif
; 739  : 	return S_OK;

  003c5	33 c0		 xor	 eax, eax
$LN1@CreateResp:

; 740  : }

  003c7	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR [rsp+136]
  003cf	48 83 c4 40	 add	 rsp, 64			; 00000040H
  003d3	41 5f		 pop	 r15
  003d5	41 5e		 pop	 r14
  003d7	41 5d		 pop	 r13
  003d9	41 5c		 pop	 r12
  003db	5f		 pop	 rdi
  003dc	5e		 pop	 rsi
  003dd	5d		 pop	 rbp
  003de	c3		 ret	 0
CreateResponseBaseCallback ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT get16RandomBytes
_TEXT	SEGMENT
ptr$ = 48
get16RandomBytes PROC					; COMDAT

; 752  : {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00015	4c 8b f1	 mov	 r14, rcx
  00018	33 f6		 xor	 esi, esi
$LL4@get16Rando:

; 753  : 	int i;
; 754  : 	for (i = 0; i < 4; i++)
; 755  : 		((DWORD *)ptr)[i] = rand32();

  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00020	8b d8		 mov	 ebx, eax
  00022	c1 e3 0f	 shl	 ebx, 15
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  0002b	8b f8		 mov	 edi, eax
  0002d	0b fb		 or	 edi, ebx
  0002f	c1 e7 02	 shl	 edi, 2
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00038	83 e0 03	 and	 eax, 3
  0003b	0b c7		 or	 eax, edi
  0003d	41 89 04 b6	 mov	 DWORD PTR [r14+rsi*4], eax
  00041	48 ff c6	 inc	 rsi
  00044	48 83 fe 04	 cmp	 rsi, 4
  00048	7c d0		 jl	 SHORT $LL4@get16Rando

; 756  : }

  0004a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00054	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	41 5e		 pop	 r14
  0005f	c3		 ret	 0
get16RandomBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT CreateResponseV4
_TEXT	SEGMENT
request_v4$ = 48
responseBuffer$ = 56
ipString$ = 64
CreateResponseV4 PROC					; COMDAT

; 762  : {

$LN5:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 763  : 	RESPONSE_V4 *response = (RESPONSE_V4 *)responseBuffer;
; 764  : 
; 765  : 	HRESULT hResult;
; 766  : 	if (FAILED(hResult = CreateResponseBase(&request_v4->RequestBase, &response->ResponseBase, NULL, ipString)))

  0000a	4d 8b c8	 mov	 r9, r8
  0000d	48 8b fa	 mov	 rdi, rdx
  00010	45 33 c0	 xor	 r8d, r8d
  00013	e8 00 00 00 00	 call	 CreateResponseBaseCallback
  00018	85 c0		 test	 eax, eax
  0001a	79 04		 jns	 SHORT $LN2@CreateResp

; 767  : 		return hResult;

  0001c	48 98		 cdqe
  0001e	eb 33		 jmp	 SHORT $LN1@CreateResp
$LN2@CreateResp:

; 768  : 
; 769  : 	const DWORD pidSize = LE32(response->ResponseBase.PIDSize);
; 770  : 	BYTE *postEpidPtr = responseBuffer + V4_PRE_EPID_SIZE + pidSize;

  00020	8b 5f 04	 mov	 ebx, DWORD PTR [rdi+4]
  00023	48 8d 4f 08	 lea	 rcx, QWORD PTR [rdi+8]
  00027	48 03 cb	 add	 rcx, rbx

; 771  : 	memmove(postEpidPtr, &response->ResponseBase.CMID, V4_POST_EPID_SIZE);

  0002a	48 8d 97 88 00
	00 00		 lea	 rdx, QWORD PTR [rdi+136]
  00031	41 b8 24 00 00
	00		 mov	 r8d, 36			; 00000024H
  00037	e8 00 00 00 00	 call	 memmove

; 772  : 
; 773  : 	const size_t encryptSize = V4_PRE_EPID_SIZE + V4_POST_EPID_SIZE + pidSize;

  0003c	48 83 c3 2c	 add	 rbx, 44			; 0000002cH

; 774  : 	AesCmacV4(responseBuffer, encryptSize, responseBuffer + encryptSize);

  00040	48 8b cf	 mov	 rcx, rdi
  00043	48 8b d3	 mov	 rdx, rbx
  00046	4c 8d 04 3b	 lea	 r8, QWORD PTR [rbx+rdi]
  0004a	e8 00 00 00 00	 call	 AesCmacV4

; 775  : 
; 776  : 	return encryptSize + sizeof(response->MAC);

  0004f	48 8d 43 10	 lea	 rax, QWORD PTR [rbx+16]
$LN1@CreateResp:

; 777  : }

  00053	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
CreateResponseV4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT CreateV6Hmac
_TEXT	SEGMENT
hash$ = 32
encrypt_start$ = 80
encryptSize$ = 88
tolerance$ = 96
CreateV6Hmac PROC					; COMDAT

; 793  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00007	57		 push	 rdi
  00008	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000c	48 8b da	 mov	 rbx, rdx

; 794  : 	BYTE hash[32];
; 795  : 	const uint8_t halfHashSize = sizeof(hash) >> 1;
; 796  : 	BYTE *responseEnd = encrypt_start + encryptSize;
; 797  : 
; 798  : 	// This is the time from the response
; 799  : 	FILETIME *ft = (FILETIME *)(responseEnd - V6_POST_EPID_SIZE + sizeof(((RESPONSE *)0)->CMID));
; 800  : 
; 801  : 	// Generate a time slot that changes every 4.11 hours.
; 802  : 	// Request and response time must match +/- 1 slot.
; 803  : 	// When generating a response tolerance must be 0.
; 804  : 	// If verifying the hash, try tolerance -1, 0 and +1. One of them must match.
; 805  : 
; 806  : 	uint64_t timeSlot = LE64((GET_UA64LE(ft) / TIME_C1 * TIME_C2 + TIME_C3) + (tolerance * TIME_C1));

  0000f	4d 0f be c0	 movsx	 r8, r8b
  00013	33 d2		 xor	 edx, edx
  00015	49 b9 bd 89 68
	81 22 00 00 00	 mov	 r9, 148199999933	; 00000022816889bdH
  0001f	48 8b f9	 mov	 rdi, rcx
  00022	4d 0f af c1	 imul	 r8, r9
  00026	48 8b 44 19 94	 mov	 rax, QWORD PTR [rcx+rbx-108]
  0002b	48 b9 ed b5 ba
	8c 20 00 00 00	 mov	 rcx, 139799999981	; 000000208cbab5edH
  00035	49 f7 f1	 div	 r9

; 807  : 
; 808  : 	// The time slot is hashed with SHA256 so it is not so obvious that it is time
; 809  : 	Sha256((BYTE *)&timeSlot, sizeof(timeSlot), hash);

  00038	ba 08 00 00 00	 mov	 edx, 8
  0003d	48 0f af c1	 imul	 rax, rcx
  00041	48 b9 7a 47 28
	c6 5a cd 56 31	 mov	 rcx, 3555254745610864506 ; 3156cd5ac628477aH
  0004b	48 03 c8	 add	 rcx, rax
  0004e	49 03 c8	 add	 rcx, r8
  00051	4d 8d 43 d8	 lea	 r8, QWORD PTR [r11-40]
  00055	49 89 4b 08	 mov	 QWORD PTR [r11+8], rcx
  00059	49 8d 4b 08	 lea	 rcx, QWORD PTR [r11+8]
  0005d	e8 00 00 00 00	 call	 Sha256

; 810  : 
; 811  : 	// The last 16 bytes of the hashed time slot are the actual HMAC key
; 812  : 	if (!Sha256Hmac(

  00062	44 8d 43 f0	 lea	 r8d, DWORD PTR [rbx-16]
  00066	48 8b d7	 mov	 rdx, rdi
  00069	4c 8d 4c 24 20	 lea	 r9, QWORD PTR hash$[rsp]
  0006e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR hash$[rsp+16]
  00073	e8 00 00 00 00	 call	 Sha256Hmac
  00078	84 c0		 test	 al, al
  0007a	74 0d		 je	 SHORT $LN1@CreateV6Hm
$LN2@CreateV6Hm:

; 813  : 			hash + halfHashSize,									 // Use last 16 bytes of SHA256 as HMAC key
; 814  : 			encrypt_start,											 // hash only the encrypted part of the v6 response
; 815  : 			(DWORD)(encryptSize - sizeof(((RESPONSE_V6 *)0)->HMAC)), // encryptSize minus the HMAC itself
; 816  : 			hash													 // use same buffer for resulting hash where the key came from
; 817  : 			))
; 818  : 	{
; 819  : 		return FALSE;
; 820  : 	}
; 821  : 
; 822  : 	memcpy(responseEnd - sizeof(((RESPONSE_V6 *)0)->HMAC), hash + halfHashSize, halfHashSize);

  0007c	0f 10 44 24 30	 movups	 xmm0, XMMWORD PTR hash$[rsp+16]

; 823  : 	return TRUE;

  00081	b0 01		 mov	 al, 1
  00083	f3 0f 7f 44 1f
	f0		 movdqu	 XMMWORD PTR [rdi+rbx-16], xmm0
$LN1@CreateV6Hm:

; 824  : }

  00089	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0008e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00092	5f		 pop	 rdi
  00093	c3		 ret	 0
CreateV6Hmac ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Users\dev\source\repos\alpinevms\src\crypto.c
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT CreateResponseV6
_TEXT	SEGMENT
aesCtx$ = 32
encryptSize$ = 288
request_v6$ = 288
responseBuffer$ = 296
ipString$ = 304
CreateResponseV6 PROC					; COMDAT

; 830  : {

$LN17:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H

; 831  : 	// The response will be created in a fixed sized struct to
; 832  : 	// avoid unaligned access macros and packed structs on RISC systems
; 833  : 	// which largely increase code size.
; 834  : 	//
; 835  : 	// The fixed sized struct with 64 WCHARs for the ePID will be converted
; 836  : 	// to a variable sized struct later and requires unaligned access macros.
; 837  : 
; 838  : 	RESPONSE_V6 *response = (RESPONSE_V6 *)responseBuffer;
; 839  : 	RESPONSE *baseResponse = &response->ResponseBase;
; 840  : 
; 841  : #ifdef _DEBUG
; 842  : 	// ReSharper disable once CppDeclaratorNeverUsed
; 843  : 	RESPONSE_V6_DEBUG *xxx_unused = (RESPONSE_V6_DEBUG *)responseBuffer;
; 844  : #endif
; 845  : 
; 846  : 	static const BYTE DefaultHwId[8] = {HWID};
; 847  : 	const int_fast8_t v6 = LE16(request_v6->MajorVer) > 5;

  0001f	44 0f b7 79 02	 movzx	 r15d, WORD PTR [rcx+2]

; 848  : 	AesCtx aesCtx;
; 849  : 
; 850  : 	AesInitKey(&aesCtx, v6 ? AesKeyV6 : AesKeyV5, v6, AES_KEY_BYTES);

  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:AesKeyV6
  0002b	48 8b f2	 mov	 rsi, rdx
  0002e	66 41 83 ff 05	 cmp	 r15w, 5
  00033	4d 8b e8	 mov	 r13, r8
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:AesKeyV5
  0003d	48 8b f9	 mov	 rdi, rcx
  00040	bd 10 00 00 00	 mov	 ebp, 16
  00045	41 0f 97 c0	 seta	 r8b
  00049	48 8d 4c 24 20	 lea	 rcx, QWORD PTR aesCtx$[rsp]
  0004e	48 0f 47 d0	 cmova	 rdx, rax
  00052	44 8b cd	 mov	 r9d, ebp
  00055	e8 00 00 00 00	 call	 AesInitKey

; 851  : 	AesDecryptCbc(&aesCtx, NULL, request_v6->IV, V6_DECRYPT_SIZE);

  0005a	41 b9 00 01 00
	00		 mov	 r9d, 256		; 00000100H
  00060	4c 8d 47 04	 lea	 r8, QWORD PTR [rdi+4]
  00064	48 8d 4c 24 20	 lea	 rcx, QWORD PTR aesCtx$[rsp]
  00069	e8 00 00 00 00	 call	 AesDecryptCbc

; 852  : 
; 853  : 	// get random salt and SHA256 it
; 854  : 	get16RandomBytes(response->RandomXoredIVs);

  0006e	48 8d 9e c0 00
	00 00		 lea	 rbx, QWORD PTR [rsi+192]
  00075	48 8b cb	 mov	 rcx, rbx
  00078	e8 00 00 00 00	 call	 get16RandomBytes

; 855  : 	Sha256(response->RandomXoredIVs, sizeof(response->RandomXoredIVs), response->Hash);

  0007d	4c 8d 86 d0 00
	00 00		 lea	 r8, QWORD PTR [rsi+208]
  00084	8b d5		 mov	 edx, ebp
  00086	48 8b cb	 mov	 rcx, rbx
  00089	e8 00 00 00 00	 call	 Sha256
  0008e	48 8d 6e 04	 lea	 rbp, QWORD PTR [rsi+4]

; 856  : 
; 857  : 	if (v6) // V6 specific stuff

  00092	66 41 83 ff 05	 cmp	 r15w, 5
  00097	76 28		 jbe	 SHORT $LN2@CreateResp

; 858  : 	{
; 859  : 		// In v6 a random IV is generated
; 860  : 		response->Version = request_v6->Version;

  00099	8b 07		 mov	 eax, DWORD PTR [rdi]

; 861  : 		get16RandomBytes(response->IV);

  0009b	48 8b cd	 mov	 rcx, rbp
  0009e	89 06		 mov	 DWORD PTR [rsi], eax
  000a0	e8 00 00 00 00	 call	 get16RandomBytes

; 862  : 
; 863  : 		// pre-fill with default HwId (not required for v5)
; 864  : 		memcpy(response->HwId, DefaultHwId, sizeof(response->HwId));

  000a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?DefaultHwId@?1??CreateResponseV6@@9@9

; 865  : 
; 866  : 		// Just copy decrypted request IV (using Null IV) here. Note this is identical
; 867  : 		// to XORing non-decrypted request and response IVs
; 868  : 		memcpy(response->XoredIVs, request_v6->IV, sizeof(response->XoredIVs));

  000ac	0f 10 47 04	 movups	 xmm0, XMMWORD PTR [rdi+4]
  000b0	48 89 86 f0 00
	00 00		 mov	 QWORD PTR [rsi+240], rax
  000b7	f3 0f 7f 86 f8
	00 00 00	 movdqu	 XMMWORD PTR [rsi+248], xmm0

; 869  : 	}

  000bf	eb 0c		 jmp	 SHORT $LN3@CreateResp
$LN2@CreateResp:

; 870  : 	else // V5 specific stuff
; 871  : 	{
; 872  : 		// In v5 IVs of request and response must be identical (MS client checks this)
; 873  : 		// The following memcpy copies Version and IVs at once
; 874  : 		memcpy(response, request_v6, V6_UNENCRYPTED_SIZE);

  000c1	0f 10 07	 movups	 xmm0, XMMWORD PTR [rdi]
  000c4	8b 47 10	 mov	 eax, DWORD PTR [rdi+16]
  000c7	0f 11 06	 movups	 XMMWORD PTR [rsi], xmm0
  000ca	89 46 10	 mov	 DWORD PTR [rsi+16], eax
$LN3@CreateResp:

; 875  : 	}
; 876  : 
; 877  : 	// Xor Random bytes with decrypted request IV
; 878  : 	XorBlock(request_v6->IV, response->RandomXoredIVs);

  000cd	48 8b cf	 mov	 rcx, rdi
  000d0	ba 04 00 00 00	 mov	 edx, 4
  000d5	48 2b cb	 sub	 rcx, rbx
$LL10@CreateResp:
; File C:\Users\dev\source\repos\alpinevms\src\crypto.c

; 48   : 		((DWORD*)out)[i] ^= ((DWORD*)in)[i];

  000d8	8b 44 19 04	 mov	 eax, DWORD PTR [rcx+rbx+4]
  000dc	31 03		 xor	 DWORD PTR [rbx], eax
  000de	48 8d 5b 04	 lea	 rbx, QWORD PTR [rbx+4]
  000e2	48 83 ea 01	 sub	 rdx, 1
  000e6	75 f0		 jne	 SHORT $LL10@CreateResp
; File C:\Users\dev\source\repos\alpinevms\src\kms.c

; 882  : 	if (FAILED(hResult = CreateResponseBase(&request_v6->RequestBase, baseResponse, response->HwId, ipString)))

  000e8	4c 8d 86 f0 00
	00 00		 lea	 r8, QWORD PTR [rsi+240]
  000ef	4d 8b cd	 mov	 r9, r13
  000f2	48 8d 4f 14	 lea	 rcx, QWORD PTR [rdi+20]
  000f6	48 8d 56 14	 lea	 rdx, QWORD PTR [rsi+20]
  000fa	e8 00 00 00 00	 call	 CreateResponseBaseCallback
  000ff	85 c0		 test	 eax, eax
  00101	79 04		 jns	 SHORT $LN4@CreateResp

; 883  : 		return hResult;

  00103	48 98		 cdqe
  00105	eb 75		 jmp	 SHORT $LN1@CreateResp
$LN4@CreateResp:

; 884  : 
; 885  : 	// Convert the fixed sized struct into variable sized
; 886  : 	const DWORD pidSize = LE32(baseResponse->PIDSize);
; 887  : 	BYTE *postEpidPtr = responseBuffer + V6_PRE_EPID_SIZE + pidSize;

  00107	8b 5e 18	 mov	 ebx, DWORD PTR [rsi+24]
  0010a	48 8d 4e 1c	 lea	 rcx, QWORD PTR [rsi+28]

; 888  : 	const size_t post_epid_size = v6 ? V6_POST_EPID_SIZE : V5_POST_EPID_SIZE;

  0010e	bf 54 00 00 00	 mov	 edi, 84			; 00000054H

; 889  : 
; 890  : 	memmove(postEpidPtr, &baseResponse->CMID, post_epid_size);

  00113	48 8d 96 9c 00
	00 00		 lea	 rdx, QWORD PTR [rsi+156]
  0011a	66 41 83 ff 05	 cmp	 r15w, 5
  0011f	8d 47 28	 lea	 eax, QWORD PTR [rdi+40]
  00122	0f 47 f8	 cmova	 edi, eax
  00125	48 03 cb	 add	 rcx, rbx
  00128	44 8b c7	 mov	 r8d, edi
  0012b	e8 00 00 00 00	 call	 memmove

; 891  : 
; 892  : 	// number of bytes to encrypt
; 893  : 	size_t encryptSize =

  00130	48 8d 53 18	 lea	 rdx, QWORD PTR [rbx+24]
  00134	48 03 d7	 add	 rdx, rdi
  00137	48 89 94 24 20
	01 00 00	 mov	 QWORD PTR encryptSize$[rsp], rdx

; 894  : 		V6_PRE_EPID_SIZE - sizeof(response->Version) + pidSize + post_epid_size;
; 895  : 
; 896  : 	// AesDecryptBlock(&aesCtx, Response->IV);
; 897  : 	if (v6 && !CreateV6Hmac(response->IV, encryptSize, 0))

  0013f	66 41 83 ff 05	 cmp	 r15w, 5
  00144	76 13		 jbe	 SHORT $LN5@CreateResp
  00146	45 33 c0	 xor	 r8d, r8d
  00149	48 8b cd	 mov	 rcx, rbp
  0014c	e8 00 00 00 00	 call	 CreateV6Hmac
  00151	84 c0		 test	 al, al
  00153	75 04		 jne	 SHORT $LN5@CreateResp

; 898  : 		return 0;

  00155	33 c0		 xor	 eax, eax
  00157	eb 23		 jmp	 SHORT $LN1@CreateResp
$LN5@CreateResp:

; 899  : 
; 900  : 	// Padding auto handled by encryption func
; 901  : 	AesEncryptCbc(&aesCtx, NULL, response->IV, &encryptSize);

  00159	4c 8d 8c 24 20
	01 00 00	 lea	 r9, QWORD PTR encryptSize$[rsp]
  00161	4c 8b c5	 mov	 r8, rbp
  00164	33 d2		 xor	 edx, edx
  00166	48 8d 4c 24 20	 lea	 rcx, QWORD PTR aesCtx$[rsp]
  0016b	e8 00 00 00 00	 call	 AesEncryptCbc

; 902  : 
; 903  : 	return encryptSize + sizeof(response->Version);

  00170	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR encryptSize$[rsp]
  00178	48 83 c0 04	 add	 rax, 4
$LN1@CreateResp:

; 904  : }

  0017c	4c 8d 9c 24 f0
	00 00 00	 lea	 r11, QWORD PTR [rsp+240]
  00184	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  00188	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  0018c	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  00190	49 8b e3	 mov	 rsp, r11
  00193	41 5f		 pop	 r15
  00195	41 5e		 pop	 r14
  00197	41 5d		 pop	 r13
  00199	41 5c		 pop	 r12
  0019b	5f		 pop	 rdi
  0019c	c3		 ret	 0
CreateResponseV6 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT CreateRequestV4
_TEXT	SEGMENT
size$ = 48
requestBase$ = 56
CreateRequestV4 PROC					; COMDAT

; 908  : {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 909  : 	*size = sizeof(REQUEST_V4);

  0000a	b8 fc 00 00 00	 mov	 eax, 252		; 000000fcH
  0000f	48 8b da	 mov	 rbx, rdx
  00012	48 89 01	 mov	 QWORD PTR [rcx], rax
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  00015	8b c8		 mov	 ecx, eax
  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0001d	48 8b f8	 mov	 rdi, rax

; 366  : 	if (!buf) OutOfMemory();

  00020	48 85 c0	 test	 rax, rax
  00023	0f 84 a8 00 00
	00		 je	 $LN9@CreateRequ
; File C:\Users\dev\source\repos\alpinevms\src\kms.c

; 921  : 	AesCmacV4(request, sizeof(REQUEST), request_v4->MAC);

  00029	0f 10 03	 movups	 xmm0, XMMWORD PTR [rbx]
  0002c	4c 8d 87 ec 00
	00 00		 lea	 r8, QWORD PTR [rdi+236]
  00033	ba ec 00 00 00	 mov	 edx, 236		; 000000ecH
  00038	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0
  0003b	0f 10 4b 10	 movups	 xmm1, XMMWORD PTR [rbx+16]
  0003f	0f 11 48 10	 movups	 XMMWORD PTR [rax+16], xmm1
  00043	0f 10 43 20	 movups	 xmm0, XMMWORD PTR [rbx+32]
  00047	0f 11 40 20	 movups	 XMMWORD PTR [rax+32], xmm0
  0004b	0f 10 4b 30	 movups	 xmm1, XMMWORD PTR [rbx+48]
  0004f	0f 11 48 30	 movups	 XMMWORD PTR [rax+48], xmm1
  00053	0f 10 43 40	 movups	 xmm0, XMMWORD PTR [rbx+64]
  00057	0f 11 40 40	 movups	 XMMWORD PTR [rax+64], xmm0
  0005b	0f 10 4b 50	 movups	 xmm1, XMMWORD PTR [rbx+80]
  0005f	0f 11 48 50	 movups	 XMMWORD PTR [rax+80], xmm1
  00063	0f 10 43 60	 movups	 xmm0, XMMWORD PTR [rbx+96]
  00067	0f 11 40 60	 movups	 XMMWORD PTR [rax+96], xmm0
  0006b	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00070	0f 10 43 70	 movups	 xmm0, XMMWORD PTR [rbx+112]
  00074	48 03 d8	 add	 rbx, rax
  00077	48 8d 0c 38	 lea	 rcx, QWORD PTR [rax+rdi]
  0007b	0f 11 41 f0	 movups	 XMMWORD PTR [rcx-16], xmm0
  0007f	0f 10 0b	 movups	 xmm1, XMMWORD PTR [rbx]
  00082	0f 11 09	 movups	 XMMWORD PTR [rcx], xmm1
  00085	0f 10 43 10	 movups	 xmm0, XMMWORD PTR [rbx+16]
  00089	0f 11 41 10	 movups	 XMMWORD PTR [rcx+16], xmm0
  0008d	0f 10 4b 20	 movups	 xmm1, XMMWORD PTR [rbx+32]
  00091	0f 11 49 20	 movups	 XMMWORD PTR [rcx+32], xmm1
  00095	0f 10 43 30	 movups	 xmm0, XMMWORD PTR [rbx+48]
  00099	0f 11 41 30	 movups	 XMMWORD PTR [rcx+48], xmm0
  0009d	0f 10 4b 40	 movups	 xmm1, XMMWORD PTR [rbx+64]
  000a1	0f 11 49 40	 movups	 XMMWORD PTR [rcx+64], xmm1
  000a5	0f 10 43 50	 movups	 xmm0, XMMWORD PTR [rbx+80]
  000a9	0f 11 41 50	 movups	 XMMWORD PTR [rcx+80], xmm0
  000ad	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  000b1	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
  000b5	8b 43 68	 mov	 eax, DWORD PTR [rbx+104]
  000b8	89 41 68	 mov	 DWORD PTR [rcx+104], eax
  000bb	48 8b cf	 mov	 rcx, rdi
  000be	e8 00 00 00 00	 call	 AesCmacV4

; 925  : }

  000c3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c8	48 8b c7	 mov	 rax, rdi
  000cb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cf	5f		 pop	 rdi
  000d0	c3		 ret	 0
$LN9@CreateRequ:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 366  : 	if (!buf) OutOfMemory();

  000d1	e8 00 00 00 00	 call	 OutOfMemory
  000d6	cc		 int	 3
$LN7@CreateRequ:
CreateRequestV4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT CreateRequestV6
_TEXT	SEGMENT
ctx$ = 32
encryptSize$ = 256
size$ = 256
requestBase$ = 264
CreateRequestV6 PROC					; COMDAT

; 929  : {

$LN10:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 56		 push	 r14
  00011	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H

; 930  : 	*size = sizeof(REQUEST_V6);

  00018	b8 04 01 00 00	 mov	 eax, 260		; 00000104H
  0001d	48 8b f2	 mov	 rsi, rdx
  00020	48 89 01	 mov	 QWORD PTR [rcx], rax
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  00023	8b c8		 mov	 ecx, eax
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0002b	4c 8b f0	 mov	 r14, rax

; 366  : 	if (!buf) OutOfMemory();

  0002e	48 85 c0	 test	 rax, rax
  00031	0f 84 06 01 00
	00		 je	 $LN9@CreateRequ
; File C:\Users\dev\source\repos\alpinevms\src\kms.c

; 939  : 	get16RandomBytes(request->IV);

  00037	8b 06		 mov	 eax, DWORD PTR [rsi]
  00039	49 8d 4e 04	 lea	 rcx, QWORD PTR [r14+4]
  0003d	41 89 06	 mov	 DWORD PTR [r14], eax
  00040	e8 00 00 00 00	 call	 get16RandomBytes

; 940  : 
; 941  : 	// Set KMS Client Request Base
; 942  : 	memcpy(&request->RequestBase, requestBase, sizeof(REQUEST));

  00045	0f 10 06	 movups	 xmm0, XMMWORD PTR [rsi]
  00048	49 8d 5e 14	 lea	 rbx, QWORD PTR [r14+20]

; 943  : 
; 944  : 	// Encrypt KMS Client Request
; 945  : 	size_t encryptSize = sizeof(request->RequestBase);

  0004c	48 c7 84 24 00
	01 00 00 ec 00
	00 00		 mov	 QWORD PTR encryptSize$[rsp], 236 ; 000000ecH
  00058	b8 80 00 00 00	 mov	 eax, 128		; 00000080H

; 946  : 	AesCtx ctx;
; 947  : 	const int_fast8_t v6 = LE16(request->MajorVer) > 5;
; 948  : 	AesInitKey(&ctx, v6 ? AesKeyV6 : AesKeyV5, v6, 16);

  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:AesKeyV5
  00064	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
  00067	41 b9 10 00 00
	00		 mov	 r9d, 16
  0006d	0f 10 4e 10	 movups	 xmm1, XMMWORD PTR [rsi+16]
  00071	48 8d 0c 18	 lea	 rcx, QWORD PTR [rax+rbx]
  00075	0f 11 4b 10	 movups	 XMMWORD PTR [rbx+16], xmm1
  00079	0f 10 46 20	 movups	 xmm0, XMMWORD PTR [rsi+32]
  0007d	0f 11 43 20	 movups	 XMMWORD PTR [rbx+32], xmm0
  00081	0f 10 4e 30	 movups	 xmm1, XMMWORD PTR [rsi+48]
  00085	0f 11 4b 30	 movups	 XMMWORD PTR [rbx+48], xmm1
  00089	0f 10 46 40	 movups	 xmm0, XMMWORD PTR [rsi+64]
  0008d	0f 11 43 40	 movups	 XMMWORD PTR [rbx+64], xmm0
  00091	0f 10 4e 50	 movups	 xmm1, XMMWORD PTR [rsi+80]
  00095	0f 11 4b 50	 movups	 XMMWORD PTR [rbx+80], xmm1
  00099	0f 10 46 60	 movups	 xmm0, XMMWORD PTR [rsi+96]
  0009d	0f 11 43 60	 movups	 XMMWORD PTR [rbx+96], xmm0
  000a1	0f 10 46 70	 movups	 xmm0, XMMWORD PTR [rsi+112]
  000a5	48 03 f0	 add	 rsi, rax
  000a8	66 41 83 7e 02
	05		 cmp	 WORD PTR [r14+2], 5
  000ae	0f 11 41 f0	 movups	 XMMWORD PTR [rcx-16], xmm0
  000b2	41 0f 97 c0	 seta	 r8b
  000b6	0f 10 0e	 movups	 xmm1, XMMWORD PTR [rsi]
  000b9	0f 11 09	 movups	 XMMWORD PTR [rcx], xmm1
  000bc	0f 10 46 10	 movups	 xmm0, XMMWORD PTR [rsi+16]
  000c0	0f 11 41 10	 movups	 XMMWORD PTR [rcx+16], xmm0
  000c4	0f 10 4e 20	 movups	 xmm1, XMMWORD PTR [rsi+32]
  000c8	0f 11 49 20	 movups	 XMMWORD PTR [rcx+32], xmm1
  000cc	0f 10 46 30	 movups	 xmm0, XMMWORD PTR [rsi+48]
  000d0	0f 11 41 30	 movups	 XMMWORD PTR [rcx+48], xmm0
  000d4	0f 10 4e 40	 movups	 xmm1, XMMWORD PTR [rsi+64]
  000d8	0f 11 49 40	 movups	 XMMWORD PTR [rcx+64], xmm1
  000dc	0f 10 46 50	 movups	 xmm0, XMMWORD PTR [rsi+80]
  000e0	0f 11 41 50	 movups	 XMMWORD PTR [rcx+80], xmm0
  000e4	48 8b 46 60	 mov	 rax, QWORD PTR [rsi+96]
  000e8	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
  000ec	8b 46 68	 mov	 eax, DWORD PTR [rsi+104]
  000ef	89 41 68	 mov	 DWORD PTR [rcx+104], eax
  000f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:AesKeyV6
  000f9	48 0f 47 d0	 cmova	 rdx, rax
  000fd	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  00102	e8 00 00 00 00	 call	 AesInitKey

; 949  : 	AesEncryptCbc(&ctx, request->IV, (BYTE *)(&request->RequestBase), &encryptSize);

  00107	4c 8d 8c 24 00
	01 00 00	 lea	 r9, QWORD PTR encryptSize$[rsp]
  0010f	4c 8b c3	 mov	 r8, rbx
  00112	49 8d 56 04	 lea	 rdx, QWORD PTR [r14+4]
  00116	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  0011b	e8 00 00 00 00	 call	 AesEncryptCbc

; 953  : }

  00120	4c 8d 9c 24 f0
	00 00 00	 lea	 r11, QWORD PTR [rsp+240]
  00128	49 8b c6	 mov	 rax, r14
  0012b	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  0012f	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00133	49 8b 7b 28	 mov	 rdi, QWORD PTR [r11+40]
  00137	49 8b e3	 mov	 rsp, r11
  0013a	41 5e		 pop	 r14
  0013c	c3		 ret	 0
$LN9@CreateRequ:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 366  : 	if (!buf) OutOfMemory();

  0013d	e8 00 00 00 00	 call	 OutOfMemory
  00142	cc		 int	 3
$LN7@CreateRequ:
CreateRequestV6 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT checkPidLength
_TEXT	SEGMENT
responseBase$ = 8
checkPidLength PROC					; COMDAT

; 960  : 	unsigned int i;
; 961  : 
; 962  : 	if (LE32(responseBase->PIDSize) > (PID_BUFFER_SIZE << 1))

  00000	44 8b 41 04	 mov	 r8d, DWORD PTR [rcx+4]
  00004	41 81 f8 80 00
	00 00		 cmp	 r8d, 128		; 00000080H
  0000b	77 33		 ja	 SHORT $LN10@checkPidLe

; 963  : 		return FALSE;
; 964  : 	if (responseBase->KmsPID[(LE32(responseBase->PIDSize) >> 1) - 1])

  0000d	41 d1 e8	 shr	 r8d, 1
  00010	45 33 c9	 xor	 r9d, r9d
  00013	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  00017	66 44 39 4c 41
	08		 cmp	 WORD PTR [rcx+rax*2+8], r9w
  0001d	75 21		 jne	 SHORT $LN10@checkPidLe

; 965  : 		return FALSE;
; 966  : 
; 967  : 	for (i = 0; i < (LE32(responseBase->PIDSize) >> 1) - 2; i++)

  0001f	41 8b d1	 mov	 edx, r9d
  00022	41 83 c0 fe	 add	 r8d, -2			; fffffffeH
  00026	74 15		 je	 SHORT $LN3@checkPidLe
  00028	48 83 c1 08	 add	 rcx, 8
$LL4@checkPidLe:

; 968  : 	{
; 969  : 		if (!responseBase->KmsPID[i])

  0002c	66 44 39 09	 cmp	 WORD PTR [rcx], r9w
  00030	74 0e		 je	 SHORT $LN10@checkPidLe

; 965  : 		return FALSE;
; 966  : 
; 967  : 	for (i = 0; i < (LE32(responseBase->PIDSize) >> 1) - 2; i++)

  00032	ff c2		 inc	 edx
  00034	48 83 c1 02	 add	 rcx, 2
  00038	41 3b d0	 cmp	 edx, r8d
  0003b	72 ef		 jb	 SHORT $LL4@checkPidLe
$LN3@checkPidLe:

; 971  : 	}
; 972  : 
; 973  : 	return TRUE;

  0003d	b0 01		 mov	 al, 1

; 974  : }

  0003f	c3		 ret	 0
$LN10@checkPidLe:

; 970  : 			return FALSE;

  00040	32 c0		 xor	 al, al

; 974  : }

  00042	c3		 ret	 0
checkPidLength ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT DecryptResponseV4
_TEXT	SEGMENT
response_v4$ = 64
responseSize$ = 72
rawResponse$ = 80
rawRequest$ = 88
DecryptResponseV4 PROC					; COMDAT

; 980  : {

$LN8:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	41 56		 push	 r14
  00017	41 57		 push	 r15
  00019	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 981  : 	const int copySize =

  0001d	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00022	49 8b f0	 mov	 rsi, r8
  00025	41 39 40 04	 cmp	 DWORD PTR [r8+4], eax
  00029	8b ea		 mov	 ebp, edx

; 982  : 		V4_PRE_EPID_SIZE +
; 983  : 		(LE32(((RESPONSE_V4 *)rawResponse)->ResponseBase.PIDSize) <= PID_BUFFER_SIZE << 1 ? LE32(((RESPONSE_V4 *)rawResponse)->ResponseBase.PIDSize) : PID_BUFFER_SIZE << 1);
; 984  : 
; 985  : 	const int messageSize = copySize + V4_POST_EPID_SIZE;
; 986  : 
; 987  : 	memcpy(response_v4, rawResponse, copySize);

  0002b	48 8b d6	 mov	 rdx, rsi
  0002e	4d 8b f9	 mov	 r15, r9
  00031	41 0f 46 40 04	 cmovbe	 eax, DWORD PTR [r8+4]
  00036	4c 8b f1	 mov	 r14, rcx
  00039	8d 78 08	 lea	 edi, DWORD PTR [rax+8]
  0003c	48 63 df	 movsxd	 rbx, edi
  0003f	4c 8b c3	 mov	 r8, rbx
  00042	e8 00 00 00 00	 call	 memcpy

; 988  : 	memcpy(&response_v4->ResponseBase.CMID, rawResponse + copySize, responseSize - copySize);

  00047	8b c5		 mov	 eax, ebp
  00049	4d 8d a6 88 00
	00 00		 lea	 r12, QWORD PTR [r14+136]
  00050	2b c7		 sub	 eax, edi
  00052	48 8d 14 33	 lea	 rdx, QWORD PTR [rbx+rsi]
  00056	4c 63 c0	 movsxd	 r8, eax
  00059	49 8b cc	 mov	 rcx, r12
  0005c	e8 00 00 00 00	 call	 memcpy
  00061	8d 47 24	 lea	 eax, DWORD PTR [rdi+36]

; 989  : 
; 990  : 	// ensure PID is null terminated
; 991  : 	response_v4->ResponseBase.KmsPID[PID_BUFFER_SIZE - 1] = 0;

  00064	33 db		 xor	 ebx, ebx

; 992  : 
; 993  : 	uint8_t *mac = rawResponse + messageSize;

  00066	48 63 d0	 movsxd	 rdx, eax

; 994  : 	AesCmacV4(rawResponse, messageSize, mac);

  00069	48 8b ce	 mov	 rcx, rsi
  0006c	66 41 89 9e 86
	00 00 00	 mov	 WORD PTR [r14+134], bx
  00074	48 8d 3c 32	 lea	 rdi, QWORD PTR [rdx+rsi]
  00078	4c 8b c7	 mov	 r8, rdi
  0007b	e8 00 00 00 00	 call	 AesCmacV4

; 995  : 
; 996  : 	REQUEST_V4 *request_v4 = (REQUEST_V4 *)rawRequest;
; 997  : 	RESPONSE_RESULT result;
; 998  : 
; 999  : 	result.mask = (DWORD)~0;
; 1000 : 	result.PidLengthOK = checkPidLength((RESPONSE *)rawResponse);

  00080	48 8b ce	 mov	 rcx, rsi
  00083	e8 00 00 00 00	 call	 checkPidLength

; 1003 : 	result.TimeStampOK = !memcmp(&response_v4->ResponseBase.ClientTime, &request_v4->RequestBase.ClientTime, sizeof(FILETIME));
; 1004 : 	result.ClientMachineIDOK = !memcmp(&response_v4->ResponseBase.CMID, &request_v4->RequestBase.CMID, sizeof(GUID));

  00088	49 8b 14 24	 mov	 rdx, QWORD PTR [r12]
  0008c	83 e0 01	 and	 eax, 1
  0008f	c1 e0 05	 shl	 eax, 5
  00092	49 2b 57 40	 sub	 rdx, QWORD PTR [r15+64]
  00096	75 09		 jne	 SHORT $LN6@DecryptRes
  00098	49 8b 54 24 08	 mov	 rdx, QWORD PTR [r12+8]
  0009d	49 2b 57 48	 sub	 rdx, QWORD PTR [r15+72]
$LN6@DecryptRes:
  000a1	48 85 d2	 test	 rdx, rdx
  000a4	8b cb		 mov	 ecx, ebx
  000a6	ba dc 0f 00 00	 mov	 edx, 4060		; 00000fdcH
  000ab	0f 94 c1	 sete	 cl
  000ae	0b c1		 or	 eax, ecx
  000b0	41 8b 0f	 mov	 ecx, DWORD PTR [r15]
  000b3	41 39 0e	 cmp	 DWORD PTR [r14], ecx
  000b6	49 8b 8e 98 00
	00 00		 mov	 rcx, QWORD PTR [r14+152]
  000bd	44 8d 42 02	 lea	 r8d, QWORD PTR [rdx+2]
  000c1	41 0f 44 d0	 cmove	 edx, r8d
  000c5	0b c2		 or	 eax, edx
  000c7	8b d3		 mov	 edx, ebx
  000c9	03 c0		 add	 eax, eax
  000cb	49 3b 4f 54	 cmp	 rcx, QWORD PTR [r15+84]
  000cf	49 8b 8e ac 00
	00 00		 mov	 rcx, QWORD PTR [r14+172]
  000d6	0f 94 c2	 sete	 dl
  000d9	0b c2		 or	 eax, edx
  000db	03 c0		 add	 eax, eax
  000dd	48 2b 0f	 sub	 rcx, QWORD PTR [rdi]
  000e0	75 0b		 jne	 SHORT $LN5@DecryptRes

; 1001 : 	result.VersionOK = response_v4->ResponseBase.Version == request_v4->RequestBase.Version;
; 1002 : 	result.HashOK = !memcmp(&response_v4->MAC, mac, sizeof(response_v4->MAC));

  000e2	49 8b 8e b4 00
	00 00		 mov	 rcx, QWORD PTR [r14+180]
  000e9	48 2b 4f 08	 sub	 rcx, QWORD PTR [rdi+8]
$LN5@DecryptRes:

; 1005 : 	result.effectiveResponseSize = responseSize;
; 1006 : 	result.correctResponseSize = sizeof(RESPONSE_V4) - sizeof(response_v4->ResponseBase.KmsPID) + LE32(response_v4->ResponseBase.PIDSize);
; 1007 : 
; 1008 : 	return result;
; 1009 : }

  000ed	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000f2	48 85 c9	 test	 rcx, rcx
  000f5	41 8b 4e 04	 mov	 ecx, DWORD PTR [r14+4]
  000f9	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000fe	0f 94 c3	 sete	 bl
  00101	0b c3		 or	 eax, ebx
  00103	81 e5 ff 01 00
	00		 and	 ebp, 511		; 000001ffH
  00109	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0010e	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00111	c1 e1 17	 shl	 ecx, 23
  00114	c1 e5 0e	 shl	 ebp, 14
  00117	0b c1		 or	 eax, ecx
  00119	0b c5		 or	 eax, ebp
  0011b	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00120	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00124	41 5f		 pop	 r15
  00126	41 5e		 pop	 r14
  00128	41 5c		 pop	 r12
  0012a	c3		 ret	 0
DecryptResponseV4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT VerifyResponseV6
_TEXT	SEGMENT
OldHmac$ = 32
result$ = 64
response_v6$ = 72
request_v6$ = 80
rawResponse$ = 88
VerifyResponseV6 PROC					; COMDAT

; 1012 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1015 : 				   (
; 1016 : 					   response_v6->XoredIVs,
; 1017 : 					   request_v6->IV,
; 1018 : 					   sizeof(response_v6->XoredIVs));
; 1019 : 
; 1020 : 	result.IVnotSuspicious = !!memcmp // If IVs are identical, it is obviously an emulator

  00019	49 8b 40 04	 mov	 rax, QWORD PTR [r8+4]
  0001d	49 8b e9	 mov	 rbp, r9
  00020	4c 8b d2	 mov	 r10, rdx
  00023	48 2b 42 04	 sub	 rax, QWORD PTR [rdx+4]
  00027	75 08		 jne	 SHORT $LN14@VerifyResp
  00029	49 8b 40 0c	 mov	 rax, QWORD PTR [r8+12]
  0002d	48 2b 42 0c	 sub	 rax, QWORD PTR [rdx+12]
$LN14@VerifyResp:
  00031	48 8b 92 f8 00
	00 00		 mov	 rdx, QWORD PTR [rdx+248]
  00038	33 db		 xor	 ebx, ebx
  0003a	48 85 c0	 test	 rax, rax
  0003d	0f 95 c3	 setne	 bl
  00040	c1 e3 05	 shl	 ebx, 5
  00043	49 2b 50 04	 sub	 rdx, QWORD PTR [r8+4]
  00047	75 0b		 jne	 SHORT $LN13@VerifyResp

; 1013 : 	// Check IVs
; 1014 : 	result.IVsOK = !memcmp // In V6 the XoredIV is actually the request IV

  00049	49 8b 92 00 01
	00 00		 mov	 rdx, QWORD PTR [r10+256]
  00050	49 2b 50 0c	 sub	 rdx, QWORD PTR [r8+12]
$LN13@VerifyResp:

; 1021 : 							  (
; 1022 : 								  request_v6->IV,
; 1023 : 								  response_v6->IV,
; 1024 : 								  sizeof(request_v6->IV));
; 1025 : 
; 1026 : 	// Check Hmac
; 1027 : 	int_fast8_t tolerance;
; 1028 : 	BYTE OldHmac[sizeof(response_v6->HMAC)];
; 1029 : 
; 1030 : 	result.HmacSha256OK = FALSE;
; 1031 : 
; 1032 : 	memcpy // Save received HMAC to compare with calculated HMAC later

  00054	41 0f 10 82 08
	01 00 00	 movups	 xmm0, XMMWORD PTR [r10+264]
  0005c	33 c0		 xor	 eax, eax

; 1033 : 		(
; 1034 : 			OldHmac,
; 1035 : 			response_v6->HMAC,
; 1036 : 			sizeof(response_v6->HMAC));
; 1037 : 
; 1038 : 	// AesEncryptBlock(Ctx, Response_v6->IV); // CreateV6Hmac needs original IV as received over the network
; 1039 : 
; 1040 : 	for (tolerance = -1; tolerance < 2; tolerance++)

  0005e	40 b7 ff	 mov	 dil, -1
  00061	48 85 d2	 test	 rdx, rdx
  00064	f3 0f 7f 44 24
	20		 movdqu	 XMMWORD PTR OldHmac$[rsp], xmm0
  0006a	0f 94 c0	 sete	 al
  0006d	81 e1 af fd ff
	ff		 and	 ecx, -593		; fffffffffffffdafH
  00073	0b d8		 or	 ebx, eax
  00075	c1 e3 04	 shl	 ebx, 4
  00078	0b d9		 or	 ebx, ecx
$LL4@VerifyResp:

; 1041 : 	{
; 1042 : 		CreateV6Hmac(

  0007a	8b f3		 mov	 esi, ebx
  0007c	48 8d 4d 04	 lea	 rcx, QWORD PTR [rbp+4]
  00080	48 c1 ee 17	 shr	 rsi, 23
  00084	44 8a c7	 mov	 r8b, dil
  00087	48 8d 56 fc	 lea	 rdx, QWORD PTR [rsi-4]
  0008b	e8 00 00 00 00	 call	 CreateV6Hmac

; 1043 : 			rawResponse + sizeof(response_v6->Version),						   // Pointer to start of the encrypted part of the response
; 1044 : 			(size_t)result.correctResponseSize - sizeof(response_v6->Version), // size of the encrypted part
; 1045 : 			tolerance														   // tolerance -1, 0, or +1
; 1046 : 		);
; 1047 : 
; 1048 : 		result.HmacSha256OK = !memcmp // Compare both HMACs

  00090	48 8b 44 24 20	 mov	 rax, QWORD PTR OldHmac$[rsp]
  00095	48 2b 44 2e f0	 sub	 rax, QWORD PTR [rsi+rbp-16]
  0009a	75 0a		 jne	 SHORT $LN12@VerifyResp
  0009c	48 8b 44 24 28	 mov	 rax, QWORD PTR OldHmac$[rsp+8]
  000a1	48 2b 44 2e f8	 sub	 rax, QWORD PTR [rsi+rbp-8]
$LN12@VerifyResp:
  000a6	33 c9		 xor	 ecx, ecx
  000a8	48 85 c0	 test	 rax, rax
  000ab	8b c3		 mov	 eax, ebx
  000ad	0f 94 c1	 sete	 cl
  000b0	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  000b3	c1 e1 06	 shl	 ecx, 6
  000b6	8b d9		 mov	 ebx, ecx
  000b8	0b d8		 or	 ebx, eax

; 1049 : 							  (
; 1050 : 								  OldHmac,
; 1051 : 								  rawResponse + (size_t)result.correctResponseSize - sizeof(response_v6->HMAC),
; 1052 : 								  sizeof(OldHmac));
; 1053 : 
; 1054 : 		if (result.HmacSha256OK)

  000ba	f6 c3 40	 test	 bl, 64			; 00000040H
  000bd	75 09		 jne	 SHORT $LN8@VerifyResp

; 1033 : 		(
; 1034 : 			OldHmac,
; 1035 : 			response_v6->HMAC,
; 1036 : 			sizeof(response_v6->HMAC));
; 1037 : 
; 1038 : 	// AesEncryptBlock(Ctx, Response_v6->IV); // CreateV6Hmac needs original IV as received over the network
; 1039 : 
; 1040 : 	for (tolerance = -1; tolerance < 2; tolerance++)

  000bf	40 fe c7	 inc	 dil
  000c2	40 80 ff 02	 cmp	 dil, 2
  000c6	7c b2		 jl	 SHORT $LL4@VerifyResp
$LN8@VerifyResp:

; 1055 : 			break;
; 1056 : 	}
; 1057 : 
; 1058 : 	return result;
; 1059 : }

  000c8	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000cd	8b c3		 mov	 eax, ebx
  000cf	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d4	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000d9	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000de	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e2	41 5e		 pop	 r14
  000e4	c3		 ret	 0
VerifyResponseV6 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT VerifyResponseV5
_TEXT	SEGMENT
result$ = 8
request_v5$ = 16
response_v5$ = 24
VerifyResponseV5 PROC					; COMDAT

; 1063 : 	// Check IVs: in V5 (and only v5) request and response IVs must match
; 1064 : 	result.IVsOK = !memcmp(request_v5->IV, response_v5->IV, sizeof(request_v5->IV));

  00000	4c 8b 4a 04	 mov	 r9, QWORD PTR [rdx+4]
  00004	4d 2b 48 04	 sub	 r9, QWORD PTR [r8+4]
  00008	75 08		 jne	 SHORT $LN3@VerifyResp
  0000a	4c 8b 4a 0c	 mov	 r9, QWORD PTR [rdx+12]
  0000e	4d 2b 48 0c	 sub	 r9, QWORD PTR [r8+12]
$LN3@VerifyResp:
  00012	33 c0		 xor	 eax, eax
  00014	4d 85 c9	 test	 r9, r9
  00017	0f 94 c0	 sete	 al
  0001a	83 e1 ef	 and	 ecx, -17

; 1065 : 
; 1066 : 	// V5 has no Hmac, always set to TRUE
; 1067 : 	result.HmacSha256OK = TRUE;

  0001d	83 c8 04	 or	 eax, 4
  00020	c1 e0 04	 shl	 eax, 4
  00023	0b c1		 or	 eax, ecx

; 1068 : 
; 1069 : 	return result;
; 1070 : }

  00025	c3		 ret	 0
VerifyResponseV5 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Users\dev\source\repos\alpinevms\src\crypto.c
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
;	COMDAT DecryptResponseV6
_TEXT	SEGMENT
randomKey$ = 32
hashVerify$ = 48
ctx$ = 80
response_v6$ = 336
tv878 = 344
responseSize$ = 344
response$ = 352
rawRequest$ = 360
hwid$ = 368
DecryptResponseV6 PROC					; COMDAT

; 1077 : {

$LN35:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 81 ec 20 01
	00 00		 sub	 rsp, 288		; 00000120H

; 1078 : 	RESPONSE_RESULT result;
; 1079 : 	result.mask = (DWORD)~0; // Set all bits in the results mask to 1. Assume success first.
; 1080 : 	result.effectiveResponseSize = responseSize;
; 1081 : 
; 1082 : 	int copySize1 =
; 1083 : 		sizeof(response_v6->Version);
; 1084 : 
; 1085 : 	// Decrypt KMS Server Response (encrypted part starts after RequestIV)
; 1086 : 	responseSize -= copySize1;
; 1087 : 
; 1088 : 	AesCtx ctx;
; 1089 : 	const int_fast8_t v6 = LE16(((RESPONSE_V6 *)response)->MajorVer) > 5;

  0001f	45 0f b7 60 02	 movzx	 r12d, WORD PTR [r8+2]

; 1090 : 
; 1091 : 	AesInitKey(&ctx, v6 ? AesKeyV6 : AesKeyV5, v6, AES_KEY_BYTES);

  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:AesKeyV6
  0002b	8b fa		 mov	 edi, edx
  0002d	66 44 89 a4 24
	58 01 00 00	 mov	 WORD PTR tv878[rsp], r12w
  00036	8b da		 mov	 ebx, edx
  00038	c1 e7 0e	 shl	 edi, 14
  0003b	4d 8b f1	 mov	 r14, r9
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:AesKeyV5
  00045	4d 8b f8	 mov	 r15, r8
  00048	48 8b e9	 mov	 rbp, rcx
  0004b	81 cf ff 3f 80
	ff		 or	 edi, -8372225		; ff803fffH
  00051	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ctx$[rsp]
  00056	66 41 83 fc 05	 cmp	 r12w, 5
  0005b	41 b9 10 00 00
	00		 mov	 r9d, 16
  00061	41 0f 97 c0	 seta	 r8b
  00065	48 0f 47 d0	 cmova	 rdx, rax
  00069	e8 00 00 00 00	 call	 AesInitKey
  0006e	8d 43 fc	 lea	 eax, DWORD PTR [rbx-4]

; 1092 : 	AesDecryptCbc(&ctx, NULL, response + copySize1, responseSize);

  00071	4c 63 c8	 movsxd	 r9, eax
  00074	4d 8d 47 04	 lea	 r8, QWORD PTR [r15+4]
  00078	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ctx$[rsp]
  0007d	e8 00 00 00 00	 call	 AesDecryptCbc

; 1093 : 
; 1094 : 	// Check padding
; 1095 : 	BYTE *lastPadByte = response + (size_t)result.effectiveResponseSize - 1;

  00082	8b c7		 mov	 eax, edi
  00084	49 8d 57 ff	 lea	 rdx, QWORD PTR [r15-1]
  00088	48 c1 e8 0e	 shr	 rax, 14
  0008c	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00091	48 03 d0	 add	 rdx, rax

; 1096 : 
; 1097 : 	// Must be from 1 to 16
; 1098 : 	if (!*lastPadByte || *lastPadByte > AES_BLOCK_BYTES)

  00094	44 0f b6 02	 movzx	 r8d, BYTE PTR [rdx]
  00098	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  0009c	3c 0f		 cmp	 al, 15
  0009e	0f 87 e8 01 00
	00		 ja	 $LN6@DecryptRes

; 1102 : 	}
; 1103 : 
; 1104 : 	// Check if pad bytes are all the same
; 1105 : 	BYTE *padByte;
; 1106 : 	for (padByte = lastPadByte - *lastPadByte + 1; padByte < lastPadByte; padByte++)

  000a4	48 8b ca	 mov	 rcx, rdx
  000a7	49 2b c8	 sub	 rcx, r8
  000aa	eb 09		 jmp	 SHORT $LN33@DecryptRes
$LL4@DecryptRes:

; 1107 : 	{
; 1108 : 		if (*padByte != *lastPadByte)

  000ac	44 38 01	 cmp	 BYTE PTR [rcx], r8b
  000af	0f 85 d7 01 00
	00		 jne	 $LN6@DecryptRes
$LN33@DecryptRes:

; 1102 : 	}
; 1103 : 
; 1104 : 	// Check if pad bytes are all the same
; 1105 : 	BYTE *padByte;
; 1106 : 	for (padByte = lastPadByte - *lastPadByte + 1; padByte < lastPadByte; padByte++)

  000b5	48 ff c1	 inc	 rcx
  000b8	48 3b ca	 cmp	 rcx, rdx
  000bb	72 ef		 jb	 SHORT $LL4@DecryptRes

; 1109 : 		{
; 1110 : 			result.DecryptSuccess = FALSE;
; 1111 : 			return result;
; 1112 : 		}
; 1113 : 	}
; 1114 : 
; 1115 : 	// Add size of Version, KmsPIDLen and variable size PID
; 1116 : 	const DWORD pidSize = LE32(((RESPONSE_V6 *)response)->ResponseBase.PIDSize);
; 1117 : 
; 1118 : 	copySize1 +=

  000bd	b8 80 00 00 00	 mov	 eax, 128		; 00000080H

; 1119 : 		V6_UNENCRYPTED_SIZE +
; 1120 : 		sizeof(response_v6->ResponseBase.PIDSize) +
; 1121 : 		(pidSize <= PID_BUFFER_SIZE << 1 ? pidSize : PID_BUFFER_SIZE << 1);
; 1122 : 
; 1123 : 	// Copy part 1 of response up to variable sized PID
; 1124 : 	memcpy(response_v6, response, copySize1);

  000c2	49 8b d7	 mov	 rdx, r15
  000c5	41 39 47 18	 cmp	 DWORD PTR [r15+24], eax
  000c9	48 8b cd	 mov	 rcx, rbp
  000cc	41 0f 46 47 18	 cmovbe	 eax, DWORD PTR [r15+24]
  000d1	83 c0 1c	 add	 eax, 28
  000d4	48 63 d8	 movsxd	 rbx, eax
  000d7	4c 8b c3	 mov	 r8, rbx
  000da	e8 00 00 00 00	 call	 memcpy

; 1125 : 
; 1126 : 	// ensure PID is null terminated
; 1127 : 	response_v6->ResponseBase.KmsPID[PID_BUFFER_SIZE - 1] = 0;

  000df	33 f6		 xor	 esi, esi

; 1128 : 
; 1129 : 	// Copy part 2
; 1130 : 	const size_t copySize2 = v6 ? V6_POST_EPID_SIZE : V5_POST_EPID_SIZE;
; 1131 : 	memcpy(&response_v6->ResponseBase.CMID, response + copySize1, copySize2);

  000e1	4c 8d ad 9c 00
	00 00		 lea	 r13, QWORD PTR [rbp+156]
  000e8	66 41 83 fc 05	 cmp	 r12w, 5
  000ed	66 89 b5 9a 00
	00 00		 mov	 WORD PTR [rbp+154], si
  000f4	4a 8d 14 3b	 lea	 rdx, QWORD PTR [rbx+r15]
  000f8	49 8b cd	 mov	 rcx, r13
  000fb	8d 46 7c	 lea	 eax, QWORD PTR [rsi+124]
  000fe	44 8d 46 54	 lea	 r8d, QWORD PTR [rsi+84]
  00102	44 0f 47 c0	 cmova	 r8d, eax
  00106	e8 00 00 00 00	 call	 memcpy

; 1132 : 
; 1133 : 	// Decrypting the response is finished here. Now we check the results for validity
; 1134 : 	// A basic client doesn't need the stuff below this comment but we want to use vlmcs
; 1135 : 	// as a debug tool for KMS emulators.
; 1136 : 
; 1137 : 	REQUEST_V6 *request_v6 = (REQUEST_V6 *)rawRequest;
; 1138 : 	const DWORD decryptSize = sizeof(request_v6->IV) + sizeof(request_v6->RequestBase) + sizeof(request_v6->Pad);
; 1139 : 
; 1140 : 	AesDecryptCbc(&ctx, NULL, request_v6->IV, decryptSize);

  0010b	4d 8d 66 04	 lea	 r12, QWORD PTR [r14+4]
  0010f	41 b9 00 01 00
	00		 mov	 r9d, 256		; 00000100H
  00115	4d 8b c4	 mov	 r8, r12
  00118	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ctx$[rsp]
  0011d	e8 00 00 00 00	 call	 AesDecryptCbc

; 1141 : 
; 1142 : 	// Check that all version information is the same
; 1143 : 	result.VersionOK =

  00122	41 8b 06	 mov	 eax, DWORD PTR [r14]
  00125	3b 45 14	 cmp	 eax, DWORD PTR [rbp+20]
  00128	75 0f		 jne	 SHORT $LN11@DecryptRes
  0012a	3b 45 00	 cmp	 eax, DWORD PTR [rbp]
  0012d	75 0a		 jne	 SHORT $LN11@DecryptRes
  0012f	44 8d 56 02	 lea	 r10d, QWORD PTR [rsi+2]
  00133	41 3b 46 14	 cmp	 eax, DWORD PTR [r14+20]
  00137	74 03		 je	 SHORT $LN12@DecryptRes
$LN11@DecryptRes:
  00139	44 8b d6	 mov	 r10d, esi
$LN12@DecryptRes:

; 1144 : 		request_v6->Version == response_v6->ResponseBase.Version &&
; 1145 : 		request_v6->Version == response_v6->Version &&
; 1146 : 		request_v6->Version == request_v6->RequestBase.Version;
; 1147 : 
; 1148 : 	// Check Base Request
; 1149 : 	result.PidLengthOK = checkPidLength(&((RESPONSE_V6 *)response)->ResponseBase);

  0013c	49 8d 4f 14	 lea	 rcx, QWORD PTR [r15+20]
  00140	e8 00 00 00 00	 call	 checkPidLength

; 1150 : 	result.TimeStampOK = !memcmp(&response_v6->ResponseBase.ClientTime, &request_v6->RequestBase.ClientTime, sizeof(FILETIME));
; 1151 : 	result.ClientMachineIDOK = IsEqualGUID(&response_v6->ResponseBase.CMID, &request_v6->RequestBase.CMID);

  00145	49 8b 4d 00	 mov	 rcx, QWORD PTR [r13]
  00149	8a d8		 mov	 bl, al
  0014b	83 e3 01	 and	 ebx, 1
  0014e	c1 e3 05	 shl	 ebx, 5
  00151	49 2b 4e 54	 sub	 rcx, QWORD PTR [r14+84]
  00155	75 08		 jne	 SHORT $LN31@DecryptRes
  00157	49 8b 4d 08	 mov	 rcx, QWORD PTR [r13+8]
  0015b	49 2b 4e 5c	 sub	 rcx, QWORD PTR [r14+92]
$LN31@DecryptRes:

; 1152 : 
; 1153 : 	// Rebuild Random Key and Sha256 Hash
; 1154 : 	BYTE hashVerify[sizeof(response_v6->Hash)];
; 1155 : 	BYTE randomKey[sizeof(response_v6->RandomXoredIVs)];
; 1156 : 
; 1157 : 	memcpy(randomKey, request_v6->IV, sizeof(randomKey));

  0015f	41 0f 10 04 24	 movups	 xmm0, XMMWORD PTR [r12]
  00164	48 85 c9	 test	 rcx, rcx
  00167	8b c6		 mov	 eax, esi
  00169	8b ce		 mov	 ecx, esi
  0016b	4c 8b cd	 mov	 r9, rbp
  0016e	0f 94 c0	 sete	 al
  00171	41 b8 04 00 00
	00		 mov	 r8d, 4
  00177	0b d8		 or	 ebx, eax
  00179	48 8b 85 ac 00
	00 00		 mov	 rax, QWORD PTR [rbp+172]
  00180	41 0b da	 or	 ebx, r10d
  00183	03 db		 add	 ebx, ebx
  00185	49 3b 46 68	 cmp	 rax, QWORD PTR [r14+104]
  00189	48 8d 44 24 20	 lea	 rax, QWORD PTR randomKey$[rsp]
  0018e	f3 0f 7f 44 24
	20		 movdqu	 XMMWORD PTR randomKey$[rsp], xmm0
  00194	0f 94 c1	 sete	 cl
  00197	81 e7 71 ff ff
	ff		 and	 edi, -143		; ffffffffffffff71H
  0019d	0b d9		 or	 ebx, ecx
  0019f	48 8d 4c 24 20	 lea	 rcx, QWORD PTR randomKey$[rsp]
  001a4	03 db		 add	 ebx, ebx
  001a6	0b df		 or	 ebx, edi
  001a8	4c 2b c8	 sub	 r9, rax
$LL16@DecryptRes:
; File C:\Users\dev\source\repos\alpinevms\src\crypto.c

; 48   : 		((DWORD*)out)[i] ^= ((DWORD*)in)[i];

  001ab	41 8b 84 09 c0
	00 00 00	 mov	 eax, DWORD PTR [r9+rcx+192]
  001b3	31 01		 xor	 DWORD PTR [rcx], eax
  001b5	48 8d 49 04	 lea	 rcx, QWORD PTR [rcx+4]
  001b9	49 83 e8 01	 sub	 r8, 1
  001bd	75 ec		 jne	 SHORT $LL16@DecryptRes
; File C:\Users\dev\source\repos\alpinevms\src\kms.c

; 1159 : 	Sha256(randomKey, sizeof(randomKey), hashVerify);

  001bf	4c 8d 44 24 30	 lea	 r8, QWORD PTR hashVerify$[rsp]
  001c4	ba 10 00 00 00	 mov	 edx, 16
  001c9	48 8d 4c 24 20	 lea	 rcx, QWORD PTR randomKey$[rsp]
  001ce	e8 00 00 00 00	 call	 Sha256

; 1160 : 
; 1161 : 	result.HashOK = !memcmp(response_v6->Hash, hashVerify, sizeof(hashVerify));

  001d3	48 8d 8d d0 00
	00 00		 lea	 rcx, QWORD PTR [rbp+208]
  001da	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  001e0	48 8d 54 24 30	 lea	 rdx, QWORD PTR hashVerify$[rsp]
  001e5	e8 00 00 00 00	 call	 memcmp
  001ea	8b c8		 mov	 ecx, eax

; 1162 : 
; 1163 : 	// size before encryption (padding not included)
; 1164 : 	result.correctResponseSize =

  001ec	ba f0 00 00 00	 mov	 edx, 240		; 000000f0H
  001f1	85 c9		 test	 ecx, ecx
  001f3	8b c6		 mov	 eax, esi
  001f5	0f 94 c0	 sete	 al
  001f8	66 83 bc 24 58
	01 00 00 05	 cmp	 WORD PTR tv878[rsp], 5
  00201	8d 4a 28	 lea	 ecx, QWORD PTR [rdx+40]
  00204	0f 47 d1	 cmova	 edx, ecx
  00207	81 e3 fe ff 7f
	00		 and	 ebx, 8388606		; 007ffffeH
  0020d	83 c2 80	 add	 edx, -128		; ffffff80H
  00210	03 55 18	 add	 edx, DWORD PTR [rbp+24]
  00213	c1 e2 17	 shl	 edx, 23
  00216	0b c2		 or	 eax, edx
  00218	0b c3		 or	 eax, ebx

; 1165 : 		(v6 ? sizeof(RESPONSE_V6) : sizeof(RESPONSE_V5)) - sizeof(response_v6->ResponseBase.KmsPID) + LE32(response_v6->ResponseBase.PIDSize);
; 1166 : 
; 1167 : 	// Version specific stuff
; 1168 : 	if (v6)

  0021a	66 83 bc 24 58
	01 00 00 05	 cmp	 WORD PTR tv878[rsp], 5
  00223	76 26		 jbe	 SHORT $LN8@DecryptRes

; 1169 : 	{
; 1170 : 		// Copy the HwId
; 1171 : 		memcpy(hwid, response_v6->HwId, sizeof(response_v6->HwId));

  00225	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR hwid$[rsp]

; 1172 : 
; 1173 : 		// Verify the V6 specific part of the response
; 1174 : 		result = VerifyResponseV6(result, response_v6, request_v6, response);

  0022d	4d 8b cf	 mov	 r9, r15
  00230	48 8b 95 f0 00
	00 00		 mov	 rdx, QWORD PTR [rbp+240]
  00237	4d 8b c6	 mov	 r8, r14
  0023a	48 89 11	 mov	 QWORD PTR [rcx], rdx
  0023d	48 8b d5	 mov	 rdx, rbp
  00240	8b c8		 mov	 ecx, eax
  00242	e8 00 00 00 00	 call	 VerifyResponseV6
  00247	8b f0		 mov	 esi, eax

; 1175 : 	}

  00249	eb 25		 jmp	 SHORT $LN9@DecryptRes
$LN8@DecryptRes:

; 1064 : 	result.IVsOK = !memcmp(request_v5->IV, response_v5->IV, sizeof(request_v5->IV));

  0024b	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
  0024f	48 2b 4d 04	 sub	 rcx, QWORD PTR [rbp+4]
  00253	75 09		 jne	 SHORT $LN30@DecryptRes
  00255	49 8b 4c 24 08	 mov	 rcx, QWORD PTR [r12+8]
  0025a	48 2b 4d 0c	 sub	 rcx, QWORD PTR [rbp+12]
$LN30@DecryptRes:
  0025e	48 85 c9	 test	 rcx, rcx
  00261	40 0f 94 c6	 sete	 sil
  00265	83 e0 ef	 and	 eax, -17

; 1065 : 
; 1066 : 	// V5 has no Hmac, always set to TRUE
; 1067 : 	result.HmacSha256OK = TRUE;

  00268	83 ce 04	 or	 esi, 4
  0026b	c1 e6 04	 shl	 esi, 4
  0026e	0b f0		 or	 esi, eax
$LN9@DecryptRes:

; 1176 : 	else // V5
; 1177 : 	{
; 1178 : 		// Verify the V5 specific part of the response
; 1179 : 		result = VerifyResponseV5(result, request_v6, (RESPONSE_V5 *)response_v6);
; 1180 : 	}
; 1181 : 
; 1182 : 	// padded size after encryption
; 1183 : 	result.correctResponseSize += (~(result.correctResponseSize - sizeof(response_v6->ResponseBase.Version)) & 0xf) + 1;

  00270	8b c6		 mov	 eax, esi
  00272	b9 03 00 00 00	 mov	 ecx, 3
  00277	c1 e8 17	 shr	 eax, 23
  0027a	2b c8		 sub	 ecx, eax
  0027c	83 e1 0f	 and	 ecx, 15
  0027f	c1 e1 17	 shl	 ecx, 23
  00282	8d 81 00 00 80
	00		 lea	 eax, DWORD PTR [rcx+8388608]
  00288	03 c6		 add	 eax, esi

; 1184 : 
; 1185 : 	return result;

  0028a	eb 05		 jmp	 SHORT $LN1@DecryptRes
$LN6@DecryptRes:

; 1099 : 	{
; 1100 : 		result.DecryptSuccess = FALSE;

  0028c	83 e7 df	 and	 edi, -33		; ffffffffffffffdfH

; 1101 : 		return result;

  0028f	8b c7		 mov	 eax, edi
$LN1@DecryptRes:

; 1186 : }

  00291	4c 8d 9c 24 20
	01 00 00	 lea	 r11, QWORD PTR [rsp+288]
  00299	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  0029d	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  002a1	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  002a5	49 8b e3	 mov	 rsp, r11
  002a8	41 5f		 pop	 r15
  002aa	41 5e		 pop	 r14
  002ac	41 5d		 pop	 r13
  002ae	41 5c		 pop	 r12
  002b0	5f		 pop	 rdi
  002b1	c3		 ret	 0
DecryptResponseV6 ENDP
_TEXT	ENDS
END
