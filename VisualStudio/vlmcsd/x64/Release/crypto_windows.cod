; Listing generated by Microsoft (R) Optimizing Compiler Version 19.32.31332.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	__imp_CryptDestroyKey:PROC
EXTRN	__imp_CryptAcquireContextW:PROC
EXTRN	__imp_CryptCreateHash:PROC
EXTRN	__imp_CryptHashData:PROC
EXTRN	__imp_CryptSetHashParam:PROC
EXTRN	__imp_CryptDestroyHash:PROC
EXTRN	__imp_CryptImportKey:PROC
EXTRN	__imp_CryptGetHashParam:PROC
PUBLIC	Sha256Hmac
PUBLIC	Sha256
hRsaAesProvider DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Sha256Hmac DD imagerel $LN8
	DD	imagerel $LN8+338
	DD	imagerel $unwind$Sha256Hmac
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Sha256 DD imagerel $LN7
	DD	imagerel $LN7+180
	DD	imagerel $unwind$Sha256
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcquireCryptContext DD imagerel AcquireCryptContext
	DD	imagerel AcquireCryptContext+55
	DD	imagerel $unwind$AcquireCryptContext
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcquireCryptContext DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Sha256 DD 061001H
	DD	0b6410H
	DD	0a3410H
	DD	0700c7210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Sha256Hmac DD 091a01H
	DD	018641aH
	DD	017341aH
	DD	012011aH
	DD	0700ce00eH
	DD	0500bH
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\crypto_windows.c
;	COMDAT AcquireCryptContext
_TEXT	SEGMENT
AcquireCryptContext PROC				; COMDAT

; 39   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 40   : 	if (!hRsaAesProvider)

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR hRsaAesProvider, 0
  0000c	75 22		 jne	 SHORT $LN2@AcquireCry

; 41   : 	{
; 42   : 		return (int_fast8_t)CryptAcquireContextW

  0000e	41 b9 18 00 00
	00		 mov	 r9d, 24
  00014	c7 44 24 20 00
	00 00 f0	 mov	 DWORD PTR [rsp+32], -268435456 ; f0000000H
  0001c	45 33 c0	 xor	 r8d, r8d
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hRsaAesProvider
  00026	33 d2		 xor	 edx, edx
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptAcquireContextW
  0002e	eb 02		 jmp	 SHORT $LN1@AcquireCry
$LN2@AcquireCry:

; 43   : 		(
; 44   : 			&hRsaAesProvider,		// Provider handle
; 45   : 			NULL,					// No key container name
; 46   : 			NULL,					// Default provider
; 47   : 			PROV_RSA_AES,			// Provides SHA and AES
; 48   : 			CRYPT_VERIFYCONTEXT		// We don't need access to persistent keys
; 49   : 		);
; 50   : 	}
; 51   : 
; 52   : 	return TRUE;

  00030	b0 01		 mov	 al, 1
$LN1@AcquireCry:

; 53   : }

  00032	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00036	c3		 ret	 0
AcquireCryptContext ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\crypto_windows.c
;	COMDAT Sha256
_TEXT	SEGMENT
hHash$ = 48
data$ = 80
DataSize$ = 88
hash$ = 96
HashSize$ = 104
Sha256	PROC						; COMDAT

; 57   : {

$LN7:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 58   : 	HCRYPTHASH hHash = 0;

  00010	48 83 60 e8 00	 and	 QWORD PTR [rax-24], 0
  00015	49 8b d8	 mov	 rbx, r8
  00018	8b fa		 mov	 edi, edx

; 59   : 	DWORD HashSize = 32;

  0001a	c7 40 20 20 00
	00 00		 mov	 DWORD PTR [rax+32], 32	; 00000020H
  00021	48 8b f1	 mov	 rsi, rcx

; 60   : 
; 61   : 	int_fast8_t success =

  00024	e8 00 00 00 00	 call	 AcquireCryptContext
  00029	84 c0		 test	 al, al
  0002b	74 63		 je	 SHORT $LN4@Sha256
  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hRsaAesProvider
  00034	48 8d 44 24 30	 lea	 rax, QWORD PTR hHash$[rsp]
  00039	45 33 c9	 xor	 r9d, r9d
  0003c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00041	45 33 c0	 xor	 r8d, r8d
  00044	ba 0c 80 00 00	 mov	 edx, 32780		; 0000800cH
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptCreateHash
  0004f	85 c0		 test	 eax, eax
  00051	74 3d		 je	 SHORT $LN4@Sha256
  00053	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hHash$[rsp]
  00058	45 33 c9	 xor	 r9d, r9d
  0005b	44 8b c7	 mov	 r8d, edi
  0005e	48 8b d6	 mov	 rdx, rsi
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptHashData
  00067	85 c0		 test	 eax, eax
  00069	74 25		 je	 SHORT $LN4@Sha256
  0006b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hHash$[rsp]
  00070	4c 8d 4c 24 68	 lea	 r9, QWORD PTR HashSize$[rsp]
  00075	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  0007a	4c 8b c3	 mov	 r8, rbx
  0007d	ba 02 00 00 00	 mov	 edx, 2
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptGetHashParam
  00088	85 c0		 test	 eax, eax
  0008a	74 04		 je	 SHORT $LN4@Sha256
  0008c	b3 01		 mov	 bl, 1
  0008e	eb 02		 jmp	 SHORT $LN5@Sha256
$LN4@Sha256:
  00090	32 db		 xor	 bl, bl
$LN5@Sha256:

; 62   : 		AcquireCryptContext() &&
; 63   : 
; 64   : 		CryptCreateHash
; 65   : 		(
; 66   : 			hRsaAesProvider,// Provider handle
; 67   : 			CALG_SHA_256,	// Algorithm
; 68   : 			NULLHANDLE,		// SHA256 requires no key
; 69   : 			NULLFLAGS,		// Use default flags
; 70   : 			&hHash			// Handle for hashing
; 71   : 		) &&
; 72   : 
; 73   : 		CryptHashData
; 74   : 		(
; 75   : 			hHash,			// Handle
; 76   : 			data,			// data to hash
; 77   : 			DataSize,		// size of data
; 78   : 			NULLFLAGS		// Use default flags
; 79   : 		) &&
; 80   : 
; 81   : 		CryptGetHashParam
; 82   : 		(
; 83   : 			hHash,			// Handle
; 84   : 			HP_HASHVAL,		// what you actually want to get (the resulting hash)
; 85   : 			hash,			// data to retrieve
; 86   : 			&HashSize,		// size of data
; 87   : 			NULLFLAGS		// currently reserved (as of this writing)
; 88   : 		);
; 89   : 
; 90   : 	if (hHash) CryptDestroyHash(hHash);

  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hHash$[rsp]
  00097	48 85 c9	 test	 rcx, rcx
  0009a	74 06		 je	 SHORT $LN2@Sha256
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptDestroyHash
$LN2@Sha256:

; 91   : 
; 92   : 	return success;
; 93   : }

  000a2	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  000a7	8a c3		 mov	 al, bl
  000a9	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000ae	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000b2	5f		 pop	 rdi
  000b3	c3		 ret	 0
Sha256	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\crypto_windows.c
;	COMDAT Sha256Hmac
_TEXT	SEGMENT
hHmacHash$ = 48
hKey$ = 56
hmackeyblob$ = 64
HmacInfo$ = 96
dwHmacSize$ = 176
key$ = 176
data$ = 184
len$ = 192
hmac$ = 200
Sha256Hmac PROC						; COMDAT

; 97   : {

$LN8:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	41 56		 push	 r14
  0000e	48 8d 6c 24 b9	 lea	 rbp, QWORD PTR [rsp-71]
  00013	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001a	0f 57 c0	 xorps	 xmm0, xmm0

; 98   : #	ifndef USE_THREADS // In fork() mode thread-safety is not required
; 99   : 	static
; 100  : #	endif
; 101  : 	HMAC_KEYBLOB hmackeyblob = {

  0001d	c7 45 f7 08 02
	00 00		 mov	 DWORD PTR hmackeyblob$[rbp-73], 520 ; 00000208H

; 102  : 		// Type, Version, Algorithm
; 103  : 		{ PLAINTEXTKEYBLOB, CUR_BLOB_VERSION, 0, CALG_RC2 },
; 104  : 		// Key length
; 105  : 		16
; 106  : 	};
; 107  : 
; 108  : 	HCRYPTKEY hKey = NULLHANDLE;
; 109  : 	HCRYPTHASH hHmacHash = NULLHANDLE;
; 110  : 	HMAC_INFO HmacInfo = { 0 };

  00024	0f 11 45 17	 movups	 XMMWORD PTR HmacInfo$[rbp-73], xmm0
  00028	45 33 f6	 xor	 r14d, r14d
  0002b	33 c0		 xor	 eax, eax
  0002d	0f 11 45 27	 movups	 XMMWORD PTR HmacInfo$[rbp-57], xmm0
  00031	49 8b d9	 mov	 rbx, r9
  00034	41 8b f8	 mov	 edi, r8d

; 111  : 	DWORD dwHmacSize = 32;
; 112  : 
; 113  : 	HmacInfo.HashAlgid = CALG_SHA_256;
; 114  : 	memcpy(hmackeyblob.KeyData, key, sizeof(hmackeyblob.KeyData));

  00037	0f 10 01	 movups	 xmm0, XMMWORD PTR [rcx]
  0003a	48 8b f2	 mov	 rsi, rdx
  0003d	c7 45 fb 02 66
	00 00		 mov	 DWORD PTR hmackeyblob$[rbp-69], 26114 ; 00006602H
  00044	c7 45 ff 10 00
	00 00		 mov	 DWORD PTR hmackeyblob$[rbp-65], 16
  0004b	f3 0f 7f 45 03	 movdqu	 XMMWORD PTR hmackeyblob$[rbp-61], xmm0
  00050	4c 89 75 ef	 mov	 QWORD PTR hKey$[rbp-73], r14
  00054	4c 89 75 e7	 mov	 QWORD PTR hHmacHash$[rbp-73], r14
  00058	48 89 45 37	 mov	 QWORD PTR HmacInfo$[rbp-41], rax
  0005c	c7 45 67 20 00
	00 00		 mov	 DWORD PTR dwHmacSize$[rbp-73], 32 ; 00000020H
  00063	c7 45 17 0c 80
	00 00		 mov	 DWORD PTR HmacInfo$[rbp-73], 32780 ; 0000800cH

; 115  : 
; 116  : 	BOOL success =

  0006a	e8 00 00 00 00	 call	 AcquireCryptContext
  0006f	84 c0		 test	 al, al
  00071	0f 84 a0 00 00
	00		 je	 $LN5@Sha256Hmac
  00077	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hRsaAesProvider
  0007e	48 8d 45 ef	 lea	 rax, QWORD PTR hKey$[rbp-73]
  00082	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00087	45 8d 46 1c	 lea	 r8d, QWORD PTR [r14+28]
  0008b	45 33 c9	 xor	 r9d, r9d
  0008e	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  00093	48 8d 55 f7	 lea	 rdx, QWORD PTR hmackeyblob$[rbp-73]
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptImportKey
  0009d	85 c0		 test	 eax, eax
  0009f	74 76		 je	 SHORT $LN5@Sha256Hmac
  000a1	4c 8b 45 ef	 mov	 r8, QWORD PTR hKey$[rbp-73]
  000a5	48 8d 45 e7	 lea	 rax, QWORD PTR hHmacHash$[rbp-73]
  000a9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hRsaAesProvider
  000b0	45 33 c9	 xor	 r9d, r9d
  000b3	ba 09 80 00 00	 mov	 edx, 32777		; 00008009H
  000b8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptCreateHash
  000c3	85 c0		 test	 eax, eax
  000c5	74 50		 je	 SHORT $LN5@Sha256Hmac
  000c7	48 8b 4d e7	 mov	 rcx, QWORD PTR hHmacHash$[rbp-73]
  000cb	4c 8d 45 17	 lea	 r8, QWORD PTR HmacInfo$[rbp-73]
  000cf	45 33 c9	 xor	 r9d, r9d
  000d2	41 8d 56 05	 lea	 edx, QWORD PTR [r14+5]
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptSetHashParam
  000dc	85 c0		 test	 eax, eax
  000de	74 37		 je	 SHORT $LN5@Sha256Hmac
  000e0	48 8b 4d e7	 mov	 rcx, QWORD PTR hHmacHash$[rbp-73]
  000e4	45 33 c9	 xor	 r9d, r9d
  000e7	44 8b c7	 mov	 r8d, edi
  000ea	48 8b d6	 mov	 rdx, rsi
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptHashData
  000f3	85 c0		 test	 eax, eax
  000f5	74 20		 je	 SHORT $LN5@Sha256Hmac
  000f7	48 8b 4d e7	 mov	 rcx, QWORD PTR hHmacHash$[rbp-73]
  000fb	4c 8d 4d 67	 lea	 r9, QWORD PTR dwHmacSize$[rbp-73]
  000ff	4c 8b c3	 mov	 r8, rbx
  00102	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  00107	41 8d 56 02	 lea	 edx, QWORD PTR [r14+2]
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptGetHashParam
  00111	b3 01		 mov	 bl, 1
  00113	85 c0		 test	 eax, eax
  00115	75 03		 jne	 SHORT $LN6@Sha256Hmac
$LN5@Sha256Hmac:
  00117	41 8a de	 mov	 bl, r14b
$LN6@Sha256Hmac:

; 117  : 		AcquireCryptContext() &&
; 118  : 
; 119  : 		CryptImportKey
; 120  : 		(
; 121  : 			hRsaAesProvider,        // provider handle
; 122  : 			(PBYTE)&hmackeyblob,    // the actual key MS blob format
; 123  : 			sizeof(HMAC_KEYBLOB),   // size of the entire blob
; 124  : 			NULLHANDLE,             // password/key for the key store (none required here)
; 125  : 			NULLFLAGS,              // default flags
; 126  : 			&hKey                   // key handle to retrieve (must be kept until you finish hashing)
; 127  : 		) &&
; 128  : 
; 129  : 		CryptCreateHash
; 130  : 		(
; 131  : 			hRsaAesProvider,        // provider handle
; 132  : 			CALG_HMAC,              // the actual key MS blob format
; 133  : 			hKey,                   // size of the entire blob
; 134  : 			NULLFLAGS,              // password/key for the key store (none required here)
; 135  : 			&hHmacHash              // default flags
; 136  : 		) &&                        // key handle to retrieve (must be kept until you finish hashing)
; 137  : 
; 138  : 		CryptSetHashParam
; 139  : 		(
; 140  : 			hHmacHash,              // hash handle
; 141  : 			HP_HMAC_INFO,           // parameter you want to set
; 142  : 			(PBYTE)&HmacInfo,       // the HMAC parameters (SHA256 with default ipad and opad)
; 143  : 			NULLFLAGS               // flags are reserved up to Windows 8.1
; 144  : 		) &&
; 145  : 
; 146  : 		CryptHashData
; 147  : 		(
; 148  : 			hHmacHash,              // hash handle
; 149  : 			data,                   // Pointer to data you want to hash
; 150  : 			len,                    // data length
; 151  : 			NULLFLAGS               // default flags
; 152  : 		) &&
; 153  : 
; 154  : 		CryptGetHashParam
; 155  : 		(
; 156  : 			hHmacHash,              // hash handle
; 157  : 			HP_HASHVAL,             // what you actually want to get (the resulting HMAC)
; 158  : 			hmac,                   // data to retrieve
; 159  : 			&dwHmacSize,            // size of data
; 160  : 			NULLFLAGS               // currently reserved (as of this writing)
; 161  : 		);
; 162  : 
; 163  : 	if (hKey) CryptDestroyKey(hKey);

  0011a	48 8b 4d ef	 mov	 rcx, QWORD PTR hKey$[rbp-73]
  0011e	48 85 c9	 test	 rcx, rcx
  00121	74 06		 je	 SHORT $LN2@Sha256Hmac
  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptDestroyKey
$LN2@Sha256Hmac:

; 164  : 	if (hHmacHash) CryptDestroyHash(hHmacHash);

  00129	48 8b 4d e7	 mov	 rcx, QWORD PTR hHmacHash$[rbp-73]
  0012d	48 85 c9	 test	 rcx, rcx
  00130	74 06		 je	 SHORT $LN3@Sha256Hmac
  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptDestroyHash
$LN3@Sha256Hmac:

; 165  : 
; 166  : 	return (int_fast8_t)success;
; 167  : }

  00138	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  00140	8a c3		 mov	 al, bl
  00142	49 8b 5b 28	 mov	 rbx, QWORD PTR [r11+40]
  00146	49 8b 73 30	 mov	 rsi, QWORD PTR [r11+48]
  0014a	49 8b e3	 mov	 rsp, r11
  0014d	41 5e		 pop	 r14
  0014f	5f		 pop	 rdi
  00150	5d		 pop	 rbp
  00151	c3		 ret	 0
Sha256Hmac ENDP
_TEXT	ENDS
END
