; Listing generated by Microsoft (R) Optimizing Compiler Version 19.32.31332.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_05CCMOGDN@?$CFs?3?$CFs@			; `string'
PUBLIC	??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs@		; `string'
PUBLIC	??_C@_0BB@NNGIJDIP@Warning?3?5?$CFs?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BL@MAEBPPDA@Connecting?5to?5?$CFs?5?$CI?$CFs?$CJ?5?4?4?4?5@ ; `string'
PUBLIC	??_C@_0BG@GMGEJMIK@Connecting?5to?5?$CFs?5?4?4?4?5@ ; `string'
PUBLIC	??_C@_0M@DODJIFLM@successful?6@			; `string'
PUBLIC	??_C@_09OGKCMDDI@Timed?5out@			; `string'
PUBLIC	??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@		; `string'
PUBLIC	??_C@_0CP@HEAGFLOL@FATAL?3?5Could?5not?5get?5network?5ad@ ; `string'
PUBLIC	??_C@_0DL@MGEENDOJ@WARNING?3?5Could?5not?5get?5IP?5addre@ ; `string'
PUBLIC	??_C@_0BH@CLCPPOBA@Warning?3?5?$CFs?5error?4?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BB@LMJPNEIG@Listening?5on?5?$CFs?6@	; `string'
PUBLIC	??_C@_08LMOPGBBD@accepted@			; `string'
PUBLIC	??_C@_06IKJOPBFO@closed@			; `string'
PUBLIC	??_C@_0BH@BBMMHHHK@?$CFs?5connection?5?$CFs?3?5?$CFs?4?6@ ; `string'
PUBLIC	??_C@_0CI@MHIGHDIH@Client?5with?5public?5IP?5address?5r@ ; `string'
PUBLIC	??_C@_0L@DGCMIMNM@Fatal?3?5?$CFs?6@		; `string'
EXTRN	__imp_CreateThread:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	__imp_getaddrinfo:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp_WaitForSingleObject:PROC
EXTRN	__imp_GetAdaptersAddresses:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_ReleaseSemaphore:PROC
EXTRN	__imp_freeaddrinfo:PROC
EXTRN	__imp_getnameinfo:PROC
;	COMDAT ??_C@_0L@DGCMIMNM@Fatal?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0L@DGCMIMNM@Fatal?3?5?$CFs?6@ DB 'Fatal: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MHIGHDIH@Client?5with?5public?5IP?5address?5r@
CONST	SEGMENT
??_C@_0CI@MHIGHDIH@Client?5with?5public?5IP?5address?5r@ DB 'Client with '
	DB	'public IP address rejected', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BBMMHHHK@?$CFs?5connection?5?$CFs?3?5?$CFs?4?6@
CONST	SEGMENT
??_C@_0BH@BBMMHHHK@?$CFs?5connection?5?$CFs?3?5?$CFs?4?6@ DB '%s connecti'
	DB	'on %s: %s.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKJOPBFO@closed@
CONST	SEGMENT
??_C@_06IKJOPBFO@closed@ DB 'closed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LMOPGBBD@accepted@
CONST	SEGMENT
??_C@_08LMOPGBBD@accepted@ DB 'accepted', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LMJPNEIG@Listening?5on?5?$CFs?6@
CONST	SEGMENT
??_C@_0BB@LMJPNEIG@Listening?5on?5?$CFs?6@ DB 'Listening on %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CLCPPOBA@Warning?3?5?$CFs?5error?4?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@CLCPPOBA@Warning?3?5?$CFs?5error?4?5?$CFs?6@ DB 'Warning: %s er'
	DB	'ror. %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@MGEENDOJ@WARNING?3?5Could?5not?5get?5IP?5addre@
CONST	SEGMENT
??_C@_0DL@MGEENDOJ@WARNING?3?5Could?5not?5get?5IP?5addre@ DB 'WARNING: Co'
	DB	'uld not get IP address from interface list: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HEAGFLOL@FATAL?3?5Could?5not?5get?5network?5ad@
CONST	SEGMENT
??_C@_0CP@HEAGFLOL@FATAL?3?5Could?5not?5get?5network?5ad@ DB 'FATAL: Coul'
	DB	'd not get network address list: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@
CONST	SEGMENT
??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@ DB '%s: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OGKCMDDI@Timed?5out@
CONST	SEGMENT
??_C@_09OGKCMDDI@Timed?5out@ DB 'Timed out', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DODJIFLM@successful?6@
CONST	SEGMENT
??_C@_0M@DODJIFLM@successful?6@ DB 'successful', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMGEJMIK@Connecting?5to?5?$CFs?5?4?4?4?5@
CONST	SEGMENT
??_C@_0BG@GMGEJMIK@Connecting?5to?5?$CFs?5?4?4?4?5@ DB 'Connecting to %s '
	DB	'... ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MAEBPPDA@Connecting?5to?5?$CFs?5?$CI?$CFs?$CJ?5?4?4?4?5@
CONST	SEGMENT
??_C@_0BL@MAEBPPDA@Connecting?5to?5?$CFs?5?$CI?$CFs?$CJ?5?4?4?4?5@ DB 'Co'
	DB	'nnecting to %s (%s) ... ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NNGIJDIP@Warning?3?5?$CFs?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BB@NNGIJDIP@Warning?3?5?$CFs?3?5?$CFs?6@ DB 'Warning: %s: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs@
CONST	SEGMENT
??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs@ DB '[%s]:%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCMOGDN@?$CFs?3?$CFs@
CONST	SEGMENT
??_C@_05CCMOGDN@?$CFs?3?$CFs@ DB '%s:%s', 00H		; `string'
	ORG $+2
?fIP@?1??serveClient@@9@9 DQ FLAT:??_C@_0BH@BBMMHHHK@?$CFs?5connection?5?$CFs?3?5?$CFs?4?6@ ; `serveClient'::`2'::fIP
?cClosed@?1??serveClient@@9@9 DQ FLAT:??_C@_06IKJOPBFO@closed@ ; `serveClient'::`2'::cClosed
?fIPv6@?1??ip2str@@9@9 DQ FLAT:??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs@ ; `ip2str'::`2'::fIPv6
?fIPv4@?1??ip2str@@9@9 DQ FLAT:??_C@_05CCMOGDN@?$CFs?3?$CFs@ ; `ip2str'::`2'::fIPv4
?cAccepted@?1??serveClient@@9@9 DQ FLAT:??_C@_08LMOPGBBD@accepted@ ; `serveClient'::`2'::cAccepted
PUBLIC	runServer
PUBLIC	serveClientAsync
PUBLIC	closeAllListeningSockets
PUBLIC	checkProtocolStack
PUBLIC	addListeningSocket
PUBLIC	getPrivateIPAddresses
PUBLIC	connectToAddress
PUBLIC	isDisconnected
PUBLIC	sendrecv
PUBLIC	_snprintf
PUBLIC	_vsnprintf
PUBLIC	printf
PUBLIC	_vfprintf_l
PUBLIC	gai_strerrorA
;	COMDAT pdata
pdata	SEGMENT
$pdata$runServer DD imagerel $LN25
	DD	imagerel $LN25+160
	DD	imagerel $unwind$runServer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$serveClientAsync DD imagerel $LN10
	DD	imagerel $LN10+61
	DD	imagerel $unwind$serveClientAsync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$serveClientAsyncWinThreads DD imagerel serveClientAsyncWinThreads
	DD	imagerel serveClientAsyncWinThreads+102
	DD	imagerel $unwind$serveClientAsyncWinThreads
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$serveClientThreadProc DD imagerel serveClientThreadProc
	DD	imagerel serveClientThreadProc+42
	DD	imagerel $unwind$serveClientThreadProc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wait_sem DD imagerel wait_sem
	DD	imagerel wait_sem+46
	DD	imagerel $unwind$wait_sem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$post_sem DD imagerel post_sem
	DD	imagerel post_sem+50
	DD	imagerel $unwind$post_sem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$serveClient DD imagerel serveClient
	DD	imagerel serveClient+331
	DD	imagerel $unwind$serveClient
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$closeAllListeningSockets DD imagerel $LN11
	DD	imagerel $LN11+64
	DD	imagerel $unwind$closeAllListeningSockets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$network_accept_any DD imagerel network_accept_any
	DD	imagerel network_accept_any+251
	DD	imagerel $unwind$network_accept_any
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$checkProtocolStack DD imagerel $LN4
	DD	imagerel $LN4+44
	DD	imagerel $unwind$checkProtocolStack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addListeningSocket DD imagerel $LN17
	DD	imagerel $LN17+150
	DD	imagerel $unwind$addListeningSocket
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$listenOnAddress DD imagerel listenOnAddress
	DD	imagerel listenOnAddress+309
	DD	imagerel $unwind$listenOnAddress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getPrivateIPAddresses DD imagerel $LN63
	DD	imagerel $LN63+549
	DD	imagerel $unwind$getPrivateIPAddresses
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$allowSocketReuse DD imagerel allowSocketReuse
	DD	imagerel allowSocketReuse+49
	DD	imagerel $unwind$allowSocketReuse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$connectToAddress DD imagerel $LN20
	DD	imagerel $LN20+423
	DD	imagerel $unwind$connectToAddress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$isDisconnected DD imagerel $LN16
	DD	imagerel $LN16+131
	DD	imagerel $unwind$isDisconnected
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setBlockingEnabled DD imagerel setBlockingEnabled
	DD	imagerel setBlockingEnabled+51
	DD	imagerel $unwind$setBlockingEnabled
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getSocketList DD imagerel getSocketList
	DD	imagerel getSocketList+289
	DD	imagerel $unwind$getSocketList
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ip2str DD imagerel ip2str
	DD	imagerel ip2str+161
	DD	imagerel $unwind$ip2str
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sendrecv DD imagerel $LN13
	DD	imagerel $LN13+131
	DD	imagerel $unwind$sendrecv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_snprintf DD imagerel $LN8
	DD	imagerel $LN8+87
	DD	imagerel $unwind$_snprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf DD imagerel $LN6
	DD	imagerel $LN6+99
	DD	imagerel $unwind$_vsnprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN6
	DD	imagerel $LN6+83
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gai_strerrorA DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$gai_strerrorA
;	COMDAT xdata
xdata	SEGMENT
$unwind$gai_strerrorA DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 041a01H
	DD	07016521aH
	DD	030146015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_snprintf DD 051201H
	DD	0700e6212H
	DD	0500c600dH
	DD	0300bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sendrecv DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ip2str DD 071301H
	DD	0156413H
	DD	0143413H
	DD	0120113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getSocketList DD 0450b2401H
	DD	0167424H
	DD	015641dH
	DD	0143416H
	DD	0f20d4312H
	DD	0e004f006H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setBlockingEnabled DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$isDisconnected DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$connectToAddress DD 091501H
	DD	01d5415H
	DD	01c3415H
	DD	0180115H
	DD	0700ce00eH
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$allowSocketReuse DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getPrivateIPAddresses DD 081201H
	DD	0e3412H
	DD	0f00e7212H
	DD	0700ae00cH
	DD	050086009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listenOnAddress DD 060f01H
	DD	012640fH
	DD	011340fH
	DD	0700bd20fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addListeningSocket DD 060f01H
	DD	08640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$checkProtocolStack DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$network_accept_any DD 050d01H
	DD	04a340dH
	DD	048010dH
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$closeAllListeningSockets DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$serveClient DD 071401H
	DD	0223414H
	DD	01e0114H
	DD	060077008H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$post_sem DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wait_sem DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$serveClientThreadProc DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$serveClientAsyncWinThreads DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$serveClientAsync DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$runServer DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft SDKs\Windows\v7.1A\include\ws2tcpip.h
;	COMDAT gai_strerrorA
_TEXT	SEGMENT
ecode$ = 80
gai_strerrorA PROC					; COMDAT

; 604  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 605  :     DWORD dwMsgLen;
; 606  :     static char buff[GAI_STRERROR_BUFFER_SIZE + 1];
; 607  : 
; 608  :     dwMsgLen = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM

  00006	48 83 64 24 30
	00		 and	 QWORD PTR [rsp+48], 0
  0000c	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:?buff@?1??gai_strerrorA@@9@9 ; `gai_strerrorA'::`2'::buff
  00013	41 b9 00 04 00
	00		 mov	 r9d, 1024		; 00000400H
  00019	44 8b c1	 mov	 r8d, ecx
  0001c	44 89 4c 24 28	 mov	 DWORD PTR [rsp+40], r9d
  00021	33 d2		 xor	 edx, edx
  00023	b9 ff 12 00 00	 mov	 ecx, 4863		; 000012ffH
  00028	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatMessageA

; 609  :                              |FORMAT_MESSAGE_IGNORE_INSERTS
; 610  :                              |FORMAT_MESSAGE_MAX_WIDTH_MASK,
; 611  :                               NULL,
; 612  :                               ecode,
; 613  :                               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
; 614  :                               (LPSTR)buff,
; 615  :                               GAI_STRERROR_BUFFER_SIZE,
; 616  :                               NULL);
; 617  : 
; 618  :     return buff;

  00033	48 8b c3	 mov	 rax, rbx

; 619  : }

  00036	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
gai_strerrorA ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$dead$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	49 8b d9	 mov	 rbx, r9
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b f1	 mov	 rsi, rcx

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	45 33 c9	 xor	 r9d, r9d
  00020	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00025	4c 8b c7	 mov	 r8, rdi
  00028	48 8b d6	 mov	 rdx, rsi
  0002b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

  00034	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00039	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0003e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 950  : {

$LN6:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00007	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  0000b	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000f	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  00013	53		 push	 rbx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001a	48 8b f9	 mov	 rdi, rcx

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

  0001d	48 8d 70 10	 lea	 rsi, QWORD PTR [rax+16]

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00021	b9 01 00 00 00	 mov	 ecx, 1
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002c	48 8b d8	 mov	 rbx, rax

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0002f	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00034	45 33 c9	 xor	 r9d, r9d
  00037	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0003c	4c 8b c7	 mov	 r8, rdi
  0003f	48 8b d3	 mov	 rdx, rbx
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 955  :     __crt_va_end(_ArgList);
; 956  :     return _Result;
; 957  : }

  0004b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004f	5f		 pop	 rdi
  00050	5e		 pop	 rsi
  00051	5b		 pop	 rbx
  00052	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_ArgList$ = 88
_vsnprintf PROC						; COMDAT

; 1405 : {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	49 8b d9	 mov	 rbx, r9
  00017	49 8b f8	 mov	 rdi, r8
  0001a	48 8b f2	 mov	 rsi, rdx
  0001d	48 8b e9	 mov	 rbp, rcx

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00020	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00025	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx
  0002a	4c 8b cf	 mov	 r9, rdi
  0002d	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00033	4c 8b c6	 mov	 r8, rsi
  00036	48 8b d5	 mov	 rdx, rbp
  00039	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003c	48 83 c9 01	 or	 rcx, 1
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf

; 1406 :     #pragma warning(push)
; 1407 :     #pragma warning(disable: 4996) // Deprecation
; 1408 :     return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1409 :     #pragma warning(pop)
; 1410 : }

  00046	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1390 :     return _Result < 0 ? -1 : _Result;

  0004b	83 c9 ff	 or	 ecx, -1

; 1406 :     #pragma warning(push)
; 1407 :     #pragma warning(disable: 4996) // Deprecation
; 1408 :     return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1409 :     #pragma warning(pop)
; 1410 : }

  0004e	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]

; 1390 :     return _Result < 0 ? -1 : _Result;

  00053	85 c0		 test	 eax, eax

; 1406 :     #pragma warning(push)
; 1407 :     #pragma warning(disable: 4996) // Deprecation
; 1408 :     return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1409 :     #pragma warning(pop)
; 1410 : }

  00055	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 1390 :     return _Result < 0 ? -1 : _Result;

  0005a	0f 48 c1	 cmovs	 eax, ecx

; 1406 :     #pragma warning(push)
; 1407 :     #pragma warning(disable: 4996) // Deprecation
; 1408 :     return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1409 :     #pragma warning(pop)
; 1410 : }

  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5f		 pop	 rdi
  00062	c3		 ret	 0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
_Buffer$ = 96
_BufferCount$ = 104
_Format$ = 112
_snprintf PROC						; COMDAT

; 1960 : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00012	49 8b f0	 mov	 rsi, r8

; 1961 :     int _Result;
; 1962 :     va_list _ArgList;
; 1963 :     __crt_va_start(_ArgList, _Format);

  00015	48 8d 6c 24 78	 lea	 rbp, QWORD PTR _Format$[rsp+8]
  0001a	48 8b da	 mov	 rbx, rdx
  0001d	48 8b f9	 mov	 rdi, rcx

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00020	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00025	48 89 6c 24 28	 mov	 QWORD PTR [rsp+40], rbp
  0002a	4c 8b ce	 mov	 r9, rsi
  0002d	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00033	4c 8b c3	 mov	 r8, rbx
  00036	48 8b d7	 mov	 rdx, rdi
  00039	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003c	48 83 c9 01	 or	 rcx, 1
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00046	83 c9 ff	 or	 ecx, -1
  00049	85 c0		 test	 eax, eax
  0004b	0f 48 c1	 cmovs	 eax, ecx

; 1964 : #pragma warning(suppress:28719)    // __WARNING_BANNED_API_USAGE
; 1965 :     _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1966 :     __crt_va_end(_ArgList);
; 1967 :     return _Result;
; 1968 : }

  0004e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00052	5f		 pop	 rdi
  00053	5e		 pop	 rsi
  00054	5d		 pop	 rbp
  00055	5b		 pop	 rbx
  00056	c3		 ret	 0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT sendrecv
_TEXT	SEGMENT
sock$ = 48
data$ = 56
len$ = 64
do_send$ = 72
sendrecv PROC						; COMDAT

; 60   : {

$LN13:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 61   : 	int n;
; 62   : 	sendrecv_t f = do_send

  00019	48 8b 2d 00 00
	00 00		 mov	 rbp, QWORD PTR __imp_recv
  00020	45 84 c9	 test	 r9b, r9b
  00023	41 8b d8	 mov	 ebx, r8d
  00026	48 8b f2	 mov	 rsi, rdx
  00029	48 0f 45 2d 00
	00 00 00	 cmovne	 rbp, QWORD PTR __imp_send
  00031	4c 8b f1	 mov	 r14, rcx
$LL4@sendrecv:

; 63   : 					   ? (sendrecv_t)send
; 64   : 					   : (sendrecv_t)recv;
; 65   : 
; 66   : 	do
; 67   : 	{
; 68   : 		n = f(sock, data, len, 0);

  00034	45 33 c9	 xor	 r9d, r9d
  00037	44 8b c3	 mov	 r8d, ebx
  0003a	48 8b d6	 mov	 rdx, rsi
  0003d	49 8b ce	 mov	 rcx, r14
  00040	ff d5		 call	 rbp
  00042	48 63 f8	 movsxd	 rdi, eax

; 69   : 	} while (
; 70   : 		(n < 0 && socket_errno == SOCKET_EINTR) || (n > 0 && (data += n, (len -= n) > 0)));

  00045	85 c0		 test	 eax, eax
  00047	79 0d		 jns	 SHORT $LN5@sendrecv
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0004f	3d 14 27 00 00	 cmp	 eax, 10004		; 00002714H
  00054	74 de		 je	 SHORT $LL4@sendrecv
$LN5@sendrecv:
  00056	85 ff		 test	 edi, edi
  00058	7e 09		 jle	 SHORT $LN6@sendrecv
  0005a	48 03 f7	 add	 rsi, rdi
  0005d	2b df		 sub	 ebx, edi
  0005f	85 db		 test	 ebx, ebx
  00061	7f d1		 jg	 SHORT $LL4@sendrecv
$LN6@sendrecv:

; 71   : 
; 72   : 	return !len;
; 73   : }

  00063	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00068	85 db		 test	 ebx, ebx
  0006a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006f	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00074	0f 94 c0	 sete	 al
  00077	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	41 5e		 pop	 r14
  00082	c3		 ret	 0
sendrecv ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT ip2str
_TEXT	SEGMENT
portNumber$ = 64
ipAddress$ = 80
result$ = 160
resultLength$ = 168
socketAddress$ = 176
socketLength$ = 184
ip2str	PROC						; COMDAT

; 76   : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  00007	49 89 73 10	 mov	 QWORD PTR [r11+16], rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00013	48 8b f1	 mov	 rsi, rcx

; 77   : 	static const char *const fIPv4 = "%s:%s";
; 78   : 	static const char *const fIPv6 = "[%s]:%s";
; 79   : 	char ipAddress[64], portNumber[8];
; 80   : 
; 81   : 	if (getnameinfo(

  00016	c7 44 24 30 0a
	00 00 00	 mov	 DWORD PTR [rsp+48], 10
  0001e	49 8d 4b a8	 lea	 rcx, QWORD PTR [r11-88]
  00022	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR [rsp+40], 8
  0002a	41 8b c1	 mov	 eax, r9d
  0002d	49 89 4b 88	 mov	 QWORD PTR [r11-120], rcx
  00031	49 8b f8	 mov	 rdi, r8
  00034	48 8b da	 mov	 rbx, rdx
  00037	48 8b cf	 mov	 rcx, rdi
  0003a	4d 8d 43 b8	 lea	 r8, QWORD PTR [r11-72]
  0003e	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00044	8b d0		 mov	 edx, eax
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getnameinfo
  0004c	85 c0		 test	 eax, eax
  0004e	75 3a		 jne	 SHORT $LN5@ip2str

; 82   : 			socketAddress,
; 83   : 			socketLength,
; 84   : 			ipAddress,
; 85   : 			sizeof(ipAddress),
; 86   : 			portNumber,
; 87   : 			sizeof(portNumber),
; 88   : 			NI_NUMERICHOST | NI_NUMERICSERV))
; 89   : 	{
; 90   : 		return FALSE;
; 91   : 	}
; 92   : 
; 93   : 	if ((unsigned int)vlmcsd_snprintf(result, resultLength, socketAddress->sa_family == AF_INET6 ? fIPv6 : fIPv4, ipAddress, portNumber) > resultLength)

  00050	66 83 3f 17	 cmp	 WORD PTR [rdi], 23
  00054	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs@
  0005b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05CCMOGDN@?$CFs?3?$CFs@
  00062	48 8b d3	 mov	 rdx, rbx
  00065	4c 0f 44 c0	 cmove	 r8, rax
  00069	4c 8d 4c 24 50	 lea	 r9, QWORD PTR ipAddress$[rsp]
  0006e	48 8d 44 24 40	 lea	 rax, QWORD PTR portNumber$[rsp]
  00073	48 8b ce	 mov	 rcx, rsi
  00076	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007b	e8 00 00 00 00	 call	 _snprintf
  00080	8b c0		 mov	 eax, eax
  00082	48 3b c3	 cmp	 rax, rbx
  00085	0f 96 c0	 setbe	 al
  00088	eb 02		 jmp	 SHORT $LN1@ip2str
$LN5@ip2str:

; 94   : 		return FALSE;

  0008a	32 c0		 xor	 al, al
$LN1@ip2str:

; 95   : 	return TRUE;
; 96   : }

  0008c	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  00094	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00098	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  0009c	49 8b e3	 mov	 rsp, r11
  0009f	5f		 pop	 rdi
  000a0	c3		 ret	 0
ip2str	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
; File C:\Program Files (x86)\Microsoft SDKs\Windows\v7.1A\include\ws2tcpip.h
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT getSocketList
_TEXT	SEGMENT
szPort$ = 0
szHost$ = 8
hints$ = 16
saList$ = 96
addr$ = 104
flags$ = 112
AddressFamily$ = 120
getSocketList PROC					; COMDAT

; 99   : {

  00000	40 55		 push	 rbp
  00002	41 56		 push	 r14
  00004	41 57		 push	 r15
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  00012	48 89 5d 60	 mov	 QWORD PTR [rbp+96], rbx
  00016	45 8b f0	 mov	 r14d, r8d
  00019	48 89 75 68	 mov	 QWORD PTR [rbp+104], rsi
  0001d	4c 8b f9	 mov	 r15, rcx
  00020	48 89 7d 70	 mov	 QWORD PTR [rbp+112], rdi
  00024	41 8b f1	 mov	 esi, r9d
  00027	48 8b fa	 mov	 rdi, rdx

; 100  : 	int status;
; 101  : 	char *szHost, *szPort;
; 102  : 	const size_t len = strlen(addr) + 1;

  0002a	49 83 c8 ff	 or	 r8, -1
$LL8@getSocketL:
  0002e	49 ff c0	 inc	 r8
  00031	42 80 3c 02 00	 cmp	 BYTE PTR [rdx+r8], 0
  00036	75 f6		 jne	 SHORT $LL8@getSocketL
  00038	49 ff c0	 inc	 r8

; 103  : 
; 104  : 	// Don't alloca too much
; 105  : 	if (len > 264)

  0003b	49 81 f8 08 01
	00 00		 cmp	 r8, 264			; 00000108H
  00042	76 07		 jbe	 SHORT $LN2@getSocketL
$LN9@getSocketL:

; 129  : }

  00044	32 c0		 xor	 al, al
  00046	e9 c0 00 00 00	 jmp	 $LN1@getSocketL
$LN2@getSocketL:

; 106  : 		return FALSE;
; 107  : 
; 108  : 	char *addrcopy = (char *)alloca(len);

  0004b	49 8d 40 0f	 lea	 rax, QWORD PTR [r8+15]
  0004f	49 3b c0	 cmp	 rax, r8
  00052	77 0a		 ja	 SHORT $LN7@getSocketL
  00054	48 b8 f0 ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846960 ; 0ffffffffffffff0H
$LN7@getSocketL:
  0005e	48 83 e0 f0	 and	 rax, -16
  00062	e8 00 00 00 00	 call	 __chkstk
  00067	48 2b e0	 sub	 rsp, rax
  0006a	48 8d 5c 24 40	 lea	 rbx, QWORD PTR [rsp+64]

; 109  : 	memcpy(addrcopy, addr, len);

  0006f	48 8b cb	 mov	 rcx, rbx
  00072	e8 00 00 00 00	 call	 memcpy

; 110  : 
; 111  : 	parseAddress(addrcopy, &szHost, &szPort);

  00077	4c 8d 45 00	 lea	 r8, QWORD PTR szPort$[rbp]
  0007b	48 8b cb	 mov	 rcx, rbx
  0007e	48 8d 55 08	 lea	 rdx, QWORD PTR szHost$[rbp]
  00082	e8 00 00 00 00	 call	 parseAddress

; 112  : 
; 113  : 	struct addrinfo hints;
; 114  : 
; 115  : 	memset(&hints, 0, sizeof(struct addrinfo));
; 116  : 
; 117  : 	hints.ai_family = AddressFamily;
; 118  : 	hints.ai_socktype = SOCK_STREAM;
; 119  : 	hints.ai_protocol = IPPROTO_TCP;
; 120  : 	hints.ai_flags = flags;
; 121  : 
; 122  : 	if ((status = getaddrinfo(szHost, szPort, &hints, saList)))

  00087	48 8b 55 00	 mov	 rdx, QWORD PTR szPort$[rbp]
  0008b	4c 8d 45 10	 lea	 r8, QWORD PTR hints$[rbp]
  0008f	48 8b 4d 08	 mov	 rcx, QWORD PTR szHost$[rbp]
  00093	0f 57 c0	 xorps	 xmm0, xmm0
  00096	0f 57 c9	 xorps	 xmm1, xmm1
  00099	89 75 14	 mov	 DWORD PTR hints$[rbp+4], esi
  0009c	4d 8b cf	 mov	 r9, r15
  0009f	c7 45 18 01 00
	00 00		 mov	 DWORD PTR hints$[rbp+8], 1
  000a6	f3 0f 7f 45 20	 movdqu	 XMMWORD PTR hints$[rbp+16], xmm0
  000ab	c7 45 1c 06 00
	00 00		 mov	 DWORD PTR hints$[rbp+12], 6
  000b2	f3 0f 7f 4d 30	 movdqu	 XMMWORD PTR hints$[rbp+32], xmm1
  000b7	44 89 75 10	 mov	 DWORD PTR hints$[rbp], r14d
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getaddrinfo
  000c1	85 c0		 test	 eax, eax
  000c3	74 44		 je	 SHORT $LN3@getSocketL
; File C:\Program Files (x86)\Microsoft SDKs\Windows\v7.1A\include\ws2tcpip.h

; 608  :     dwMsgLen = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM

  000c5	48 83 64 24 30
	00		 and	 QWORD PTR [rsp+48], 0
  000cb	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:?buff@?1??gai_strerrorA@@9@9 ; `gai_strerrorA'::`2'::buff
  000d2	41 b9 00 04 00
	00		 mov	 r9d, 1024		; 00000400H
  000d8	44 8b c0	 mov	 r8d, eax
  000db	44 89 4c 24 28	 mov	 DWORD PTR [rsp+40], r9d
  000e0	33 d2		 xor	 edx, edx
  000e2	b9 ff 12 00 00	 mov	 ecx, 4863		; 000012ffH
  000e7	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatMessageA
; File C:\Users\dev\source\repos\alpinevms\src\network.c

; 124  : 		printerrorf("Warning: %s: %s\n", addr, gai_strerror(status));

  000f2	4c 8b c3	 mov	 r8, rbx
  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@NNGIJDIP@Warning?3?5?$CFs?3?5?$CFs?6@
  000fc	48 8b d7	 mov	 rdx, rdi
  000ff	e8 00 00 00 00	 call	 printerrorf

; 125  : 		return FALSE;

  00104	e9 3b ff ff ff	 jmp	 $LN9@getSocketL
$LN3@getSocketL:

; 126  : 	}
; 127  : 
; 128  : 	return TRUE;

  00109	b0 01		 mov	 al, 1
$LN1@getSocketL:

; 129  : }

  0010b	48 8b 5d 60	 mov	 rbx, QWORD PTR [rbp+96]
  0010f	48 8b 75 68	 mov	 rsi, QWORD PTR [rbp+104]
  00113	48 8b 7d 70	 mov	 rdi, QWORD PTR [rbp+112]
  00117	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0011b	41 5f		 pop	 r15
  0011d	41 5e		 pop	 r14
  0011f	5d		 pop	 rbp
  00120	c3		 ret	 0
getSocketList ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT setBlockingEnabled
_TEXT	SEGMENT
mode$ = 48
fd$ = 48
blocking$ = 56
setBlockingEnabled PROC					; COMDAT

; 132  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 133  : 	if (fd == INVALID_SOCKET)

  00004	48 83 f9 ff	 cmp	 rcx, -1
  00008	75 04		 jne	 SHORT $LN2@setBlockin

; 134  : 		return FALSE;

  0000a	32 c0		 xor	 al, al
  0000c	eb 20		 jmp	 SHORT $LN1@setBlockin
$LN2@setBlockin:

; 135  : 
; 136  : #ifdef _WIN32
; 137  : 
; 138  : 	unsigned long mode = blocking ? 0 : 1;

  0000e	33 c0		 xor	 eax, eax

; 139  : 	return (ioctlsocket(fd, FIONBIO, &mode) == 0) ? TRUE : FALSE;

  00010	4c 8d 44 24 30	 lea	 r8, QWORD PTR mode$[rsp]
  00015	84 d2		 test	 dl, dl
  00017	ba 7e 66 04 80	 mov	 edx, -2147195266	; ffffffff8004667eH
  0001c	0f 94 c0	 sete	 al
  0001f	89 44 24 30	 mov	 DWORD PTR mode$[rsp], eax
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ioctlsocket
  00029	85 c0		 test	 eax, eax
  0002b	0f 94 c0	 sete	 al
$LN1@setBlockin:

; 140  : 
; 141  : #else // POSIX
; 142  : 
; 143  : 	int flags = fcntl(fd, F_GETFL, 0);
; 144  : 
; 145  : 	if (flags < 0)
; 146  : 		return FALSE;
; 147  : 
; 148  : 	flags = blocking ? (flags & ~O_NONBLOCK) : (flags | O_NONBLOCK);
; 149  : 	return (fcntl(fd, F_SETFL, flags) == 0) ? TRUE : FALSE;
; 150  : 
; 151  : #endif // POSIX
; 152  : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
setBlockingEnabled ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT isDisconnected
_TEXT	SEGMENT
buffer$ = 48
s$ = 48
mode$1 = 56
mode$2 = 56
isDisconnected PROC					; COMDAT

; 155  : {

$LN16:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 133  : 	if (fd == INVALID_SOCKET)

  0000d	48 83 f9 ff	 cmp	 rcx, -1
  00011	74 63		 je	 SHORT $LN14@isDisconne

; 139  : 	return (ioctlsocket(fd, FIONBIO, &mode) == 0) ? TRUE : FALSE;

  00013	4c 8d 44 24 38	 lea	 r8, QWORD PTR mode$2[rsp]
  00018	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR mode$2[rsp], 1
  00020	ba 7e 66 04 80	 mov	 edx, -2147195266	; ffffffff8004667eH
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ioctlsocket
  0002b	85 c0		 test	 eax, eax
  0002d	0f 94 c0	 sete	 al

; 156  : 	char buffer[1];
; 157  : 
; 158  : 	if (!setBlockingEnabled(s, FALSE))

  00030	84 c0		 test	 al, al
  00032	74 42		 je	 SHORT $LN14@isDisconne

; 159  : 		return TRUE;
; 160  : 
; 161  : 	const int n = recv(s, buffer, 1, MSG_PEEK);

  00034	41 b9 02 00 00
	00		 mov	 r9d, 2
  0003a	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	45 8d 41 ff	 lea	 r8d, QWORD PTR [r9-1]
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv

; 138  : 	unsigned long mode = blocking ? 0 : 1;

  0004c	83 64 24 38 00	 and	 DWORD PTR mode$1[rsp], 0

; 139  : 	return (ioctlsocket(fd, FIONBIO, &mode) == 0) ? TRUE : FALSE;

  00051	4c 8d 44 24 38	 lea	 r8, QWORD PTR mode$1[rsp]
  00056	ba 7e 66 04 80	 mov	 edx, -2147195266	; ffffffff8004667eH
  0005b	48 8b cb	 mov	 rcx, rbx

; 159  : 		return TRUE;
; 160  : 
; 161  : 	const int n = recv(s, buffer, 1, MSG_PEEK);

  0005e	8b f8		 mov	 edi, eax

; 139  : 	return (ioctlsocket(fd, FIONBIO, &mode) == 0) ? TRUE : FALSE;

  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ioctlsocket
  00066	85 c0		 test	 eax, eax
  00068	0f 94 c0	 sete	 al

; 162  : 
; 163  : 	if (!setBlockingEnabled(s, TRUE))

  0006b	84 c0		 test	 al, al
  0006d	74 07		 je	 SHORT $LN14@isDisconne

; 164  : 		return TRUE;
; 165  : 	if (n == 0)

  0006f	85 ff		 test	 edi, edi
  00071	0f 94 c0	 sete	 al
  00074	eb 02		 jmp	 SHORT $LN1@isDisconne
$LN14@isDisconne:

; 166  : 		return TRUE;

  00076	b0 01		 mov	 al, 1
$LN1@isDisconne:

; 167  : 
; 168  : 	return FALSE;
; 169  : }

  00078	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0007d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00081	5f		 pop	 rdi
  00082	c3		 ret	 0
isDisconnected ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT isPrivateIPAddress
_TEXT	SEGMENT
addr$ = 8
length$ = 16
isPrivateIPAddress PROC					; COMDAT

; 174  : {

  00000	4c 8b c2	 mov	 r8, rdx

; 175  : 	union v6addr
; 176  : 	{
; 177  : 		uint8_t bytes[16];
; 178  : 		uint16_t words[8];
; 179  : 		uint32_t dwords[4];
; 180  : 		uint64_t qwords[2];
; 181  : 	};
; 182  : 
; 183  : 	if (addr == NULL)

  00003	48 85 c9	 test	 rcx, rcx
  00006	0f 84 9a 00 00
	00		 je	 $LN14@isPrivateI

; 184  : 		return FALSE;
; 185  : 
; 186  : 	switch (addr->sa_family)

  0000c	66 83 39 02	 cmp	 WORD PTR [rcx], 2
  00010	74 45		 je	 SHORT $LN9@isPrivateI
  00012	66 83 39 17	 cmp	 WORD PTR [rcx], 23
  00016	0f 85 8a 00 00
	00		 jne	 $LN14@isPrivateI

; 187  : 	{
; 188  : 	case AF_INET6:
; 189  : 	{
; 190  : 		union v6addr *ipv6addr = (union v6addr *)&((struct sockaddr_in6 *)addr)->sin6_addr;
; 191  : 
; 192  : 		if (
; 193  : 			(ipv6addr->qwords[0] != 0 || BE64(ipv6addr->qwords[1]) != 1) && // ::1 IPv6 localhost

  0001c	48 83 79 08 00	 cmp	 QWORD PTR [rcx+8], 0
  00021	75 0d		 jne	 SHORT $LN7@isPrivateI
  00023	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00027	48 0f c8	 bswap	 rax
  0002a	48 83 f8 01	 cmp	 rax, 1
  0002e	74 1a		 je	 SHORT $LN6@isPrivateI
$LN7@isPrivateI:
  00030	0f b7 41 08	 movzx	 eax, WORD PTR [rcx+8]
  00034	b9 00 e0 00 00	 mov	 ecx, 57344		; 0000e000H
  00039	66 c1 c8 08	 ror	 ax, 8
  0003d	66 23 c1	 and	 ax, cx
  00040	b9 00 20 00 00	 mov	 ecx, 8192		; 00002000H
  00045	66 3b c1	 cmp	 ax, cx
  00048	74 5c		 je	 SHORT $LN14@isPrivateI
$LN6@isPrivateI:

; 194  : 			(BE16(ipv6addr->words[0]) & 0xe000) == 0x2000					// !2000::/3
; 195  : 		)
; 196  : 		{
; 197  : 			return FALSE;
; 198  : 		}
; 199  : 
; 200  : 		if (length)

  0004a	4d 85 c0	 test	 r8, r8
  0004d	74 54		 je	 SHORT $LN11@isPrivateI

; 201  : 			*length = sizeof(struct sockaddr_in6);

  0004f	c7 02 1c 00 00
	00		 mov	 DWORD PTR [rdx], 28

; 202  : 		break;

  00055	eb 4c		 jmp	 SHORT $LN11@isPrivateI
$LN9@isPrivateI:

; 203  : 	}
; 204  : 
; 205  : 	case AF_INET:
; 206  : 	{
; 207  : 		const uint32_t ipv4addr = BE32(((struct sockaddr_in *)addr)->sin_addr.s_addr);

  00057	8b 51 04	 mov	 edx, DWORD PTR [rcx+4]
  0005a	0f ca		 bswap	 edx

; 208  : 
; 209  : 		if (
; 210  : 			(ipv4addr & 0xff000000) != 0x7f000000 && // 127.x.x.x localhost
; 211  : 			(ipv4addr & 0xffff0000) != 0xc0a80000 && // 192.168.x.x private routeable
; 212  : 			(ipv4addr & 0xffff0000) != 0xa9fe0000 && // 169.254.x.x link local
; 213  : 			(ipv4addr & 0xff000000) != 0x0a000000 && // 10.x.x.x private routeable

  0005c	8b ca		 mov	 ecx, edx
  0005e	81 e1 00 00 00
	ff		 and	 ecx, -16777216		; ff000000H
  00064	81 f9 00 00 00
	7f		 cmp	 ecx, 2130706432		; 7f000000H
  0006a	74 2b		 je	 SHORT $LN10@isPrivateI
  0006c	8b c2		 mov	 eax, edx
  0006e	25 00 00 ff ff	 and	 eax, -65536		; ffff0000H
  00073	3d 00 00 a8 c0	 cmp	 eax, -1062731776	; c0a80000H
  00078	74 1d		 je	 SHORT $LN10@isPrivateI
  0007a	3d 00 00 fe a9	 cmp	 eax, -1442971648	; a9fe0000H
  0007f	74 16		 je	 SHORT $LN10@isPrivateI
  00081	81 f9 00 00 00
	0a		 cmp	 ecx, 167772160		; 0a000000H
  00087	74 0e		 je	 SHORT $LN10@isPrivateI
  00089	81 e2 00 00 f0
	ff		 and	 edx, -1048576		; fff00000H
  0008f	81 fa 00 00 10
	ac		 cmp	 edx, -1408237568	; ac100000H
  00095	75 0f		 jne	 SHORT $LN14@isPrivateI
$LN10@isPrivateI:

; 218  : 		}
; 219  : 
; 220  : 		if (length)

  00097	4d 85 c0	 test	 r8, r8
  0009a	74 07		 je	 SHORT $LN11@isPrivateI

; 221  : 			*length = sizeof(struct sockaddr_in);

  0009c	41 c7 00 10 00
	00 00		 mov	 DWORD PTR [r8], 16
$LN11@isPrivateI:

; 222  : 		break;
; 223  : 	}
; 224  : 
; 225  : 	default:
; 226  : 		return FALSE;
; 227  : 	}
; 228  : 
; 229  : 	return TRUE;

  000a3	b0 01		 mov	 al, 1

; 230  : }

  000a5	c3		 ret	 0
$LN14@isPrivateI:

; 214  : 			(ipv4addr & 0xfff00000) != 0xac100000	 // 172.16-31.x.x private routeable
; 215  : 		)
; 216  : 		{
; 217  : 			return FALSE;

  000a6	32 c0		 xor	 al, al

; 230  : }

  000a8	c3		 ret	 0
isPrivateIPAddress ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT connectToAddress
_TEXT	SEGMENT
saList$ = 48
szAddr$ = 64
addr$ = 224
AddressFamily$ = 232
showHostName$ = 240
to$1 = 248
connectToAddress PROC					; COMDAT

; 236  : {

$LN20:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 56		 push	 r14
  0000e	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H

; 237  : 	struct addrinfo *saList, *sa;
; 238  : 	SOCKET s = INVALID_SOCKET;
; 239  : 	char szAddr[128];
; 240  : 
; 241  : 	if (!getSocketList(&saList, addr, 0, AddressFamily))

  00015	44 8b ca	 mov	 r9d, edx
  00018	41 8a e8	 mov	 bpl, r8b
  0001b	48 8b d1	 mov	 rdx, rcx
  0001e	48 8b f1	 mov	 rsi, rcx
  00021	49 83 ce ff	 or	 r14, -1
  00025	48 8d 4c 24 30	 lea	 rcx, QWORD PTR saList$[rsp]
  0002a	45 33 c0	 xor	 r8d, r8d
  0002d	49 8b fe	 mov	 rdi, r14
  00030	e8 00 00 00 00	 call	 getSocketList
  00035	84 c0		 test	 al, al
  00037	75 08		 jne	 SHORT $LN5@connectToA

; 242  : 		return INVALID_SOCKET;

  00039	49 8b c6	 mov	 rax, r14
  0003c	e9 4e 01 00 00	 jmp	 $LN1@connectToA
$LN5@connectToA:

; 243  : 
; 244  : 	for (sa = saList; sa; sa = sa->ai_next)

  00041	48 8b 5c 24 30	 mov	 rbx, QWORD PTR saList$[rsp]
  00046	e9 1f 01 00 00	 jmp	 $LN18@connectToA
$LL4@connectToA:

; 245  : 	{
; 246  : 		// struct sockaddr_in* addr4 = (struct sockaddr_in*)sa->ai_addr;
; 247  : 		// struct sockaddr_in6* addr6 = (struct sockaddr_in6*)sa->ai_addr;
; 248  : 
; 249  : 		if (ip2str(szAddr, sizeof(szAddr), sa->ai_addr, (socklen_t)sa->ai_addrlen))

  0004b	44 8b 4b 10	 mov	 r9d, DWORD PTR [rbx+16]
  0004f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR szAddr$[rsp]
  00054	4c 8b 43 20	 mov	 r8, QWORD PTR [rbx+32]
  00058	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0005d	e8 00 00 00 00	 call	 ip2str
  00062	84 c0		 test	 al, al
  00064	74 40		 je	 SHORT $LN6@connectToA

; 250  : 		{
; 251  : 			showHostName ? printf("Connecting to %s (%s) ... ", addr, szAddr) : printf("Connecting to %s ... ", szAddr);

  00066	40 84 ed	 test	 bpl, bpl
  00069	74 16		 je	 SHORT $LN9@connectToA
  0006b	4c 8d 44 24 40	 lea	 r8, QWORD PTR szAddr$[rsp]
  00070	48 8b d6	 mov	 rdx, rsi
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@MAEBPPDA@Connecting?5to?5?$CFs?5?$CI?$CFs?$CJ?5?4?4?4?5@
  0007a	e8 00 00 00 00	 call	 printf
  0007f	eb 11		 jmp	 SHORT $LN10@connectToA
$LN9@connectToA:
  00081	48 8d 54 24 40	 lea	 rdx, QWORD PTR szAddr$[rsp]
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@GMGEJMIK@Connecting?5to?5?$CFs?5?4?4?4?5@
  0008d	e8 00 00 00 00	 call	 printf
$LN10@connectToA:

; 252  : 			fflush(stdout);

  00092	b9 01 00 00 00	 mov	 ecx, 1
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0009d	48 8b c8	 mov	 rcx, rax
  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush
$LN6@connectToA:

; 253  : 		}
; 254  : 
; 255  : 		s = socket(sa->ai_family, SOCK_STREAM, IPPROTO_TCP);

  000a6	8b 4b 04	 mov	 ecx, DWORD PTR [rbx+4]
  000a9	ba 01 00 00 00	 mov	 edx, 1
  000ae	44 8d 42 05	 lea	 r8d, QWORD PTR [rdx+5]
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket

; 256  : 
; 257  : #if !defined(NO_TIMEOUT) && !__minix__
; 258  : #ifndef _WIN32 // Standard Posix timeout structure
; 259  : 
; 260  : 		struct timeval to;
; 261  : 		to.tv_sec = 10;
; 262  : 		to.tv_usec = 0;
; 263  : 
; 264  : #else // Windows requires a DWORD with milliseconds
; 265  : 
; 266  : 		DWORD to = 10000;
; 267  : 
; 268  : #endif // _WIN32
; 269  : 
; 270  : 		setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (sockopt_t)&to, sizeof(to));

  000b8	4c 8d 8c 24 f8
	00 00 00	 lea	 r9, QWORD PTR to$1[rsp]
  000c0	c7 84 24 f8 00
	00 00 10 27 00
	00		 mov	 DWORD PTR to$1[rsp], 10000 ; 00002710H
  000cb	48 8b c8	 mov	 rcx, rax
  000ce	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d6	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  000db	41 b8 06 10 00
	00		 mov	 r8d, 4102		; 00001006H
  000e1	48 8b f8	 mov	 rdi, rax
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt

; 271  : 		setsockopt(s, SOL_SOCKET, SO_SNDTIMEO, (sockopt_t)&to, sizeof(to));

  000ea	4c 8d 8c 24 f8
	00 00 00	 lea	 r9, QWORD PTR to$1[rsp]
  000f2	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000fa	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  000ff	41 b8 05 10 00
	00		 mov	 r8d, 4101		; 00001005H
  00105	48 8b cf	 mov	 rcx, rdi
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt

; 272  : #endif // !defined(NO_TIMEOUT) && !__minix__
; 273  : 
; 274  : 		if (!connect(s, sa->ai_addr, (int)sa->ai_addrlen))

  0010e	44 8b 43 10	 mov	 r8d, DWORD PTR [rbx+16]
  00112	48 8b cf	 mov	 rcx, rdi
  00115	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_connect
  0011f	85 c0		 test	 eax, eax
  00121	74 52		 je	 SHORT $LN14@connectToA

; 277  : 			break;
; 278  : 		}
; 279  : 
; 280  : 		printerrorf("%s: %s\n", szAddr, socket_errno == SOCKET_EINPROGRESS ? "Timed out" : vlmcsd_strerror(socket_errno));

  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00129	3d 34 27 00 00	 cmp	 eax, 10036		; 00002734H
  0012e	75 09		 jne	 SHORT $LN11@connectToA
  00130	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_09OGKCMDDI@Timed?5out@
  00137	eb 0d		 jmp	 SHORT $LN12@connectToA
$LN11@connectToA:
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0013f	8b c8		 mov	 ecx, eax
  00141	e8 00 00 00 00	 call	 win_strerror
$LN12@connectToA:
  00146	4c 8b c0	 mov	 r8, rax
  00149	48 8d 54 24 40	 lea	 rdx, QWORD PTR szAddr$[rsp]
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@
  00155	e8 00 00 00 00	 call	 printerrorf

; 281  : 
; 282  : 		socketclose(s);

  0015a	48 8b cf	 mov	 rcx, rdi
  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
  00163	48 8b 5b 28	 mov	 rbx, QWORD PTR [rbx+40]

; 283  : 		s = INVALID_SOCKET;

  00167	49 8b fe	 mov	 rdi, r14
$LN18@connectToA:

; 243  : 
; 244  : 	for (sa = saList; sa; sa = sa->ai_next)

  0016a	48 85 db	 test	 rbx, rbx
  0016d	0f 85 d8 fe ff
	ff		 jne	 $LL4@connectToA

; 272  : #endif // !defined(NO_TIMEOUT) && !__minix__
; 273  : 
; 274  : 		if (!connect(s, sa->ai_addr, (int)sa->ai_addrlen))

  00173	eb 0c		 jmp	 SHORT $LN3@connectToA
$LN14@connectToA:

; 275  : 		{
; 276  : 			printf("successful\n");

  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@DODJIFLM@successful?6@
  0017c	e8 00 00 00 00	 call	 printf
$LN3@connectToA:

; 284  : 	}
; 285  : 
; 286  : 	freeaddrinfo(saList);

  00181	48 8b 4c 24 30	 mov	 rcx, QWORD PTR saList$[rsp]
  00186	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_freeaddrinfo

; 287  : 	return s;

  0018c	48 8b c7	 mov	 rax, rdi
$LN1@connectToA:

; 288  : }

  0018f	4c 8d 9c 24 c0
	00 00 00	 lea	 r11, QWORD PTR [rsp+192]
  00197	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  0019b	49 8b 6b 28	 mov	 rbp, QWORD PTR [r11+40]
  0019f	49 8b e3	 mov	 rsp, r11
  001a2	41 5e		 pop	 r14
  001a4	5f		 pop	 rdi
  001a5	5e		 pop	 rsi
  001a6	c3		 ret	 0
connectToAddress ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT allowSocketReuse
_TEXT	SEGMENT
s$ = 64
socketOption$ = 72
allowSocketReuse PROC					; COMDAT

; 298  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 299  : #if !__CYGWIN__
; 300  : 
; 301  : 	BOOL socketOption = TRUE;
; 302  : 
; 303  : #if !_WIN32
; 304  : #define VLMCSD_SOCKET_OPTION SO_REUSEADDR
; 305  : #else // _WIN32
; 306  : #define VLMCSD_SOCKET_OPTION SO_EXCLUSIVEADDRUSE
; 307  : #endif // _WIN32
; 308  : 
; 309  : 	if (setsockopt(s, SOL_SOCKET, VLMCSD_SOCKET_OPTION, (sockopt_t)&socketOption, sizeof(socketOption)))

  00004	4c 8d 4c 24 48	 lea	 r9, QWORD PTR socketOption$[rsp]
  00009	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR socketOption$[rsp], 1
  00011	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00016	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0001e	41 b8 fb ff ff
	ff		 mov	 r8d, -5
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt

; 310  : 	{
; 311  : #ifdef _PEDANTIC
; 312  : 		printerrorf("Warning: Socket option SO_REUSEADDR unsupported: %s\n", vlmcsd_strerror(socket_errno));
; 313  : #endif // _PEDANTIC
; 314  : 	}
; 315  : 
; 316  : #undef VLMCSD_SOCKET_OPTION
; 317  : #endif // !__CYGWIN__
; 318  : 
; 319  : 	return 0;

  0002a	32 c0		 xor	 al, al

; 320  : }

  0002c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00030	c3		 ret	 0
allowSocketReuse ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\network.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\network.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\network.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\network.c
; File C:\Program Files (x86)\Microsoft SDKs\Windows\v7.1A\include\ws2tcpip.h
; File C:\Users\dev\source\repos\alpinevms\src\network.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT getPrivateIPAddresses
_TEXT	SEGMENT
numAddresses$ = 112
ipAddresses$ = 120
outBufLen$ = 128
length$1 = 136
length$2 = 136
getPrivateIPAddresses PROC				; COMDAT

; 379  : {

$LN63:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	55		 push	 rbp
  00008	56		 push	 rsi
  00009	57		 push	 rdi
  0000a	41 56		 push	 r14
  0000c	41 57		 push	 r15
  0000e	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00012	48 8b f1	 mov	 rsi, rcx
  00015	4c 8b fa	 mov	 r15, rdx

; 380  : #if _WIN32
; 381  : 
; 382  : 	PIP_ADAPTER_ADDRESSES firstAdapter, currentAdapter;
; 383  : 
; 384  : 	DWORD dwRetVal;
; 385  : 	ULONG outBufLen = 16384;

  00018	b9 00 40 00 00	 mov	 ecx, 16384		; 00004000H
  0001d	89 48 18	 mov	 DWORD PTR [rax+24], ecx
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00026	48 8b d8	 mov	 rbx, rax

; 366  : 	if (!buf) OutOfMemory();

  00029	48 85 c0	 test	 rax, rax
  0002c	0f 84 ed 01 00
	00		 je	 $LN41@getPrivate
; File C:\Users\dev\source\repos\alpinevms\src\network.c

; 390  : 	if ((dwRetVal = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, firstAdapter, &outBufLen)) == ERROR_BUFFER_OVERFLOW)

  00032	45 33 c0	 xor	 r8d, r8d
  00035	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR outBufLen$[rsp]
  0003d	4c 8b cb	 mov	 r9, rbx
  00040	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00045	33 c9		 xor	 ecx, ecx
  00047	41 8d 68 2e	 lea	 ebp, QWORD PTR [r8+46]
  0004b	8b d5		 mov	 edx, ebp
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetAdaptersAddresses
  00053	8b f8		 mov	 edi, eax
  00055	83 f8 6f	 cmp	 eax, 111		; 0000006fH
  00058	75 41		 jne	 SHORT $LN14@getPrivate

; 391  : 	{
; 392  : 		free(firstAdapter);

  0005a	48 8b cb	 mov	 rcx, rbx
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 393  : 		firstAdapter = (PIP_ADAPTER_ADDRESSES)vlmcsd_malloc(outBufLen);

  00063	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR outBufLen$[rsp]
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00070	48 8b d8	 mov	 rbx, rax

; 366  : 	if (!buf) OutOfMemory();

  00073	48 85 c0	 test	 rax, rax
  00076	0f 84 a3 01 00
	00		 je	 $LN41@getPrivate
; File C:\Users\dev\source\repos\alpinevms\src\network.c

; 394  : 		dwRetVal = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, firstAdapter, &outBufLen);

  0007c	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR outBufLen$[rsp]
  00084	4c 8b cb	 mov	 r9, rbx
  00087	45 33 c0	 xor	 r8d, r8d
  0008a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008f	8b d5		 mov	 edx, ebp
  00091	33 c9		 xor	 ecx, ecx
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetAdaptersAddresses
  00099	8b f8		 mov	 edi, eax
$LN14@getPrivate:

; 395  : 	}
; 396  : 
; 397  : 	if (dwRetVal != NO_ERROR)

  0009b	85 ff		 test	 edi, edi
  0009d	74 1f		 je	 SHORT $LN15@getPrivate

; 398  : 	{
; 399  : 		printerrorf("FATAL: Could not get network address list: %s\n", vlmcsd_strerror(dwRetVal));

  0009f	8b cf		 mov	 ecx, edi
  000a1	e8 00 00 00 00	 call	 win_strerror
  000a6	48 8b d0	 mov	 rdx, rax
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CP@HEAGFLOL@FATAL?3?5Could?5not?5get?5network?5ad@
  000b0	e8 00 00 00 00	 call	 printerrorf

; 400  : 		exit(dwRetVal);

  000b5	8b cf		 mov	 ecx, edi
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  000bd	cc		 int	 3
$LN15@getPrivate:

; 401  : 	}
; 402  : 
; 403  : 	for (currentAdapter = firstAdapter, *numAddresses = 0; currentAdapter != NULL; currentAdapter = currentAdapter->Next)

  000be	83 26 00	 and	 DWORD PTR [rsi], 0
  000c1	4c 8b cb	 mov	 r9, rbx
  000c4	48 85 db	 test	 rbx, rbx
  000c7	74 36		 je	 SHORT $LN3@getPrivate
$LL4@getPrivate:

; 404  : 	{
; 405  : 		PIP_ADAPTER_UNICAST_ADDRESS currentAddress;
; 406  : 		int length;
; 407  : 
; 408  : 		if (currentAdapter->OperStatus != IfOperStatusUp)

  000c9	41 83 79 68 01	 cmp	 DWORD PTR [r9+104], 1
  000ce	75 26		 jne	 SHORT $LN2@getPrivate

; 409  : 			continue;
; 410  : 
; 411  : 		for (currentAddress = currentAdapter->FirstUnicastAddress; currentAddress != NULL; currentAddress = currentAddress->Next)

  000d0	4d 8b 51 18	 mov	 r10, QWORD PTR [r9+24]
  000d4	eb 1b		 jmp	 SHORT $LN60@getPrivate
$LL7@getPrivate:

; 412  : 		{
; 413  : 			if (isPrivateIPAddress(currentAddress->Address.lpSockaddr, &length))

  000d6	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  000da	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR length$2[rsp]
  000e2	e8 00 00 00 00	 call	 isPrivateIPAddress
  000e7	84 c0		 test	 al, al
  000e9	74 02		 je	 SHORT $LN5@getPrivate

; 414  : 				(*numAddresses)++;

  000eb	ff 06		 inc	 DWORD PTR [rsi]
$LN5@getPrivate:

; 409  : 			continue;
; 410  : 
; 411  : 		for (currentAddress = currentAdapter->FirstUnicastAddress; currentAddress != NULL; currentAddress = currentAddress->Next)

  000ed	4d 8b 52 08	 mov	 r10, QWORD PTR [r10+8]
$LN60@getPrivate:
  000f1	4d 85 d2	 test	 r10, r10
  000f4	75 e0		 jne	 SHORT $LL7@getPrivate
$LN2@getPrivate:

; 401  : 	}
; 402  : 
; 403  : 	for (currentAdapter = firstAdapter, *numAddresses = 0; currentAdapter != NULL; currentAdapter = currentAdapter->Next)

  000f6	4d 8b 49 08	 mov	 r9, QWORD PTR [r9+8]
  000fa	4d 85 c9	 test	 r9, r9
  000fd	75 ca		 jne	 SHORT $LL4@getPrivate
$LN3@getPrivate:

; 415  : 		}
; 416  : 	}
; 417  : 
; 418  : 	*ipAddresses = (char **)vlmcsd_malloc(*numAddresses * sizeof(char *));

  000ff	48 63 0e	 movsxd	 rcx, DWORD PTR [rsi]
  00102	48 c1 e1 03	 shl	 rcx, 3
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 366  : 	if (!buf) OutOfMemory();

  0010c	48 85 c0	 test	 rax, rax
  0010f	0f 84 0a 01 00
	00		 je	 $LN41@getPrivate
; File C:\Users\dev\source\repos\alpinevms\src\network.c

; 420  : 	for (currentAdapter = firstAdapter, *numAddresses = 0; currentAdapter != NULL; currentAdapter = currentAdapter->Next)

  00115	83 26 00	 and	 DWORD PTR [rsi], 0
  00118	48 8b eb	 mov	 rbp, rbx
  0011b	49 89 07	 mov	 QWORD PTR [r15], rax
  0011e	48 85 db	 test	 rbx, rbx
  00121	0f 84 de 00 00
	00		 je	 $LN9@getPrivate
$LL10@getPrivate:

; 421  : 	{
; 422  : 		PIP_ADAPTER_UNICAST_ADDRESS currentAddress;
; 423  : 		int length;
; 424  : 
; 425  : 		if (currentAdapter->OperStatus != IfOperStatusUp)

  00127	83 7d 68 01	 cmp	 DWORD PTR [rbp+104], 1
  0012b	0f 85 c7 00 00
	00		 jne	 $LN8@getPrivate

; 426  : 			continue;
; 427  : 
; 428  : 		for (currentAddress = currentAdapter->FirstUnicastAddress; currentAddress != NULL; currentAddress = currentAddress->Next)

  00131	48 8b 7d 18	 mov	 rdi, QWORD PTR [rbp+24]
  00135	e9 b5 00 00 00	 jmp	 $LN61@getPrivate
$LL13@getPrivate:

; 429  : 		{
; 430  : 			if (!isPrivateIPAddress(currentAddress->Address.lpSockaddr, &length))

  0013a	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  0013e	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR length$1[rsp]
  00146	e8 00 00 00 00	 call	 isPrivateIPAddress
  0014b	84 c0		 test	 al, al
  0014d	0f 84 98 00 00
	00		 je	 $LN11@getPrivate
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  00153	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00158	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0015e	4c 8b f0	 mov	 r14, rax

; 366  : 	if (!buf) OutOfMemory();

  00161	48 85 c0	 test	 rax, rax
  00164	0f 84 b5 00 00
	00		 je	 $LN41@getPrivate
; File C:\Users\dev\source\repos\alpinevms\src\network.c

; 434  : 			const int error = getnameinfo(currentAddress->Address.lpSockaddr, currentAddress->Address.iSockaddrLength, ipAddress, 64, NULL, 0, NI_NUMERICHOST);

  0016a	8b 57 18	 mov	 edx, DWORD PTR [rdi+24]
  0016d	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00173	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00177	4c 8b c0	 mov	 r8, rax
  0017a	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR [rsp+48], 2
  00182	83 64 24 28 00	 and	 DWORD PTR [rsp+40], 0
  00187	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getnameinfo

; 435  : 
; 436  : 			if (error)

  00193	85 c0		 test	 eax, eax
  00195	74 45		 je	 SHORT $LN20@getPrivate
; File C:\Program Files (x86)\Microsoft SDKs\Windows\v7.1A\include\ws2tcpip.h

; 608  :     dwMsgLen = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM

  00197	48 83 64 24 30
	00		 and	 QWORD PTR [rsp+48], 0
  0019d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?buff@?1??gai_strerrorA@@9@9 ; `gai_strerrorA'::`2'::buff
  001a4	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  001a9	44 8b c0	 mov	 r8d, eax
  001ac	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  001b0	44 8b c9	 mov	 r9d, ecx
  001b3	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001b8	b9 ff 12 00 00	 mov	 ecx, 4863		; 000012ffH
  001bd	33 d2		 xor	 edx, edx
  001bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatMessageA
; File C:\Users\dev\source\repos\alpinevms\src\network.c

; 438  : 				printerrorf("WARNING: Could not get IP address from interface list: %s\n", gai_strerror(error));

  001c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?buff@?1??gai_strerrorA@@9@9 ; `gai_strerrorA'::`2'::buff
  001cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DL@MGEENDOJ@WARNING?3?5Could?5not?5get?5IP?5addre@
  001d3	e8 00 00 00 00	 call	 printerrorf

; 439  : 				*ipAddress = 0;

  001d8	41 c6 06 00	 mov	 BYTE PTR [r14], 0
$LN20@getPrivate:

; 440  : 			}
; 441  : 
; 442  : 			(*ipAddresses)[(*numAddresses)++] = ipAddress;

  001dc	48 63 16	 movsxd	 rdx, DWORD PTR [rsi]
  001df	49 8b 07	 mov	 rax, QWORD PTR [r15]
  001e2	4c 89 34 d0	 mov	 QWORD PTR [rax+rdx*8], r14
  001e6	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  001e9	89 06		 mov	 DWORD PTR [rsi], eax
$LN11@getPrivate:

; 426  : 			continue;
; 427  : 
; 428  : 		for (currentAddress = currentAdapter->FirstUnicastAddress; currentAddress != NULL; currentAddress = currentAddress->Next)

  001eb	48 8b 7f 08	 mov	 rdi, QWORD PTR [rdi+8]
$LN61@getPrivate:
  001ef	48 85 ff	 test	 rdi, rdi
  001f2	0f 85 42 ff ff
	ff		 jne	 $LL13@getPrivate
$LN8@getPrivate:

; 420  : 	for (currentAdapter = firstAdapter, *numAddresses = 0; currentAdapter != NULL; currentAdapter = currentAdapter->Next)

  001f8	48 8b 6d 08	 mov	 rbp, QWORD PTR [rbp+8]
  001fc	48 85 ed	 test	 rbp, rbp
  001ff	0f 85 22 ff ff
	ff		 jne	 $LL10@getPrivate
$LN9@getPrivate:

; 443  : 		}
; 444  : 	}
; 445  : 
; 446  : 	free(firstAdapter);

  00205	48 8b cb	 mov	 rcx, rbx
  00208	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 515  : }

  0020e	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00213	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00217	41 5f		 pop	 r15
  00219	41 5e		 pop	 r14
  0021b	5f		 pop	 rdi
  0021c	5e		 pop	 rsi
  0021d	5d		 pop	 rbp
  0021e	c3		 ret	 0
$LN41@getPrivate:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 366  : 	if (!buf) OutOfMemory();

  0021f	e8 00 00 00 00	 call	 OutOfMemory
  00224	cc		 int	 3
$LN59@getPrivate:
getPrivateIPAddresses ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT listenOnAddress
_TEXT	SEGMENT
ipstr$ = 48
socketOption$ = 128
ai$ = 128
s$ = 136
listenOnAddress PROC					; COMDAT

; 521  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 522  : 	int error;
; 523  : 	char ipstr[64];
; 524  : 
; 525  : 	ip2str(ipstr, sizeof(ipstr), ai->ai_addr, (socklen_t)ai->ai_addrlen);

  0000f	44 8b 49 10	 mov	 r9d, DWORD PTR [rcx+16]
  00013	48 8b f2	 mov	 rsi, rdx
  00016	4c 8b 41 20	 mov	 r8, QWORD PTR [rcx+32]
  0001a	48 8b f9	 mov	 rdi, rcx
  0001d	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00022	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ipstr$[rsp]
  00027	e8 00 00 00 00	 call	 ip2str

; 526  : 
; 527  : 	//*s = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
; 528  : 	*s = socket(ai->ai_family, SOCK_STREAM, IPPROTO_TCP);

  0002c	8b 4f 04	 mov	 ecx, DWORD PTR [rdi+4]
  0002f	bb 01 00 00 00	 mov	 ebx, 1
  00034	8b d3		 mov	 edx, ebx
  00036	44 8d 43 05	 lea	 r8d, QWORD PTR [rbx+5]
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket
  00040	48 89 06	 mov	 QWORD PTR [rsi], rax

; 529  : 
; 530  : 	if (*s == INVALID_SOCKET)

  00043	48 83 f8 ff	 cmp	 rax, -1
  00047	75 39		 jne	 SHORT $LN2@listenOnAd

; 531  : 	{
; 532  : 		error = socket_errno;

  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError

; 533  : 		printerrorf("Warning: %s error. %s\n", ai->ai_family == AF_INET6 ? cIPv6 : cIPv4, vlmcsd_strerror(error));

  0004f	8b c8		 mov	 ecx, eax
  00051	8b d8		 mov	 ebx, eax
  00053	e8 00 00 00 00	 call	 win_strerror
  00058	83 7f 04 17	 cmp	 DWORD PTR [rdi+4], 23
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04EMGFNKGN@IPv4@
  00063	4c 8b c0	 mov	 r8, rax
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@CLCPPOBA@Warning?3?5?$CFs?5error?4?5?$CFs?6@
  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04HOFDLIOP@IPv6@
  00074	48 0f 44 d0	 cmove	 rdx, rax
  00078	e8 00 00 00 00	 call	 printerrorf

; 534  : 		return error;

  0007d	e9 9f 00 00 00	 jmp	 $LN7@listenOnAd
$LN2@listenOnAd:

; 535  : 	}
; 536  : 
; 537  : #if !defined(_WIN32) && !defined(NO_SIGHUP)
; 538  : 
; 539  : 	int flags = fcntl(*s, F_GETFD, 0);
; 540  : 
; 541  : 	if (flags != -1)
; 542  : 	{
; 543  : 		flags |= FD_CLOEXEC;
; 544  : 		fcntl(*s, F_SETFD, flags);
; 545  : 	}
; 546  : #ifdef _PEDANTIC
; 547  : 	else
; 548  : 	{
; 549  : 		printerrorf("Warning: Could not set FD_CLOEXEC flag on %s: %s\n", ipstr, vlmcsd_strerror(errno));
; 550  : 	}
; 551  : #endif // _PEDANTIC
; 552  : 
; 553  : #endif // !defined(_WIN32) && !defined(NO_SIGHUP)
; 554  : 
; 555  : 	BOOL socketOption = TRUE;
; 556  : 
; 557  : #ifdef IPV6_V6ONLY
; 558  : 	if (ai->ai_family == AF_INET6 && setsockopt(*s, IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_t)&socketOption, sizeof(socketOption)))

  00082	83 7f 04 17	 cmp	 DWORD PTR [rdi+4], 23
  00086	89 9c 24 80 00
	00 00		 mov	 DWORD PTR socketOption$[rsp], ebx
  0008d	75 22		 jne	 SHORT $LN3@listenOnAd
  0008f	ba 29 00 00 00	 mov	 edx, 41			; 00000029H
  00094	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0009c	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR socketOption$[rsp]
  000a4	48 8b c8	 mov	 rcx, rax
  000a7	44 8d 42 f2	 lea	 r8d, QWORD PTR [rdx-14]
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt
$LN3@listenOnAd:

; 559  : 	{
; 560  : #ifdef _PEDANTIC
; 561  : #if defined(_WIN32) || defined(__CYGWIN__)
; 562  : 		//		if (IsWindowsVistaOrGreater()) //Doesn't work with older version of MingW32-w64 toolchain
; 563  : 		if ((GetVersion() & 0xff) > 5)
; 564  : 		{
; 565  : #endif // _WIN32
; 566  : 			printerrorf("Warning: %s does not support socket option IPV6_V6ONLY: %s\n", ipstr, vlmcsd_strerror(socket_errno));
; 567  : #if defined(_WIN32) || defined(__CYGWIN__)
; 568  : 		}
; 569  : #endif // _WIN32
; 570  : #endif // _PEDANTIC
; 571  : 	}
; 572  : #endif
; 573  : 
; 574  : 	allowSocketReuse(*s);

  000b1	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  000b4	e8 00 00 00 00	 call	 allowSocketReuse

; 575  : 
; 576  : #if HAVE_FREEBIND
; 577  : #if (defined(IP_NONLOCALOK) || __FreeBSD_kernel__ || __FreeBSD__) && !defined(IPV6_BINDANY)
; 578  : #define IPV6_BINDANY 64
; 579  : #endif					 // (defined(IP_NONLOCALOK) || __FreeBSD_kernel__ || __FreeBSD__) && !defined(IPV6_BINDANY)
; 580  : 
; 581  : 	if (freebind)
; 582  : 	{
; 583  : #if defined(IP_FREEBIND) // Linux
; 584  : 		if (setsockopt(*s, IPPROTO_IP, IP_FREEBIND, (sockopt_t)&socketOption, sizeof(socketOption)))
; 585  : 		{
; 586  : 			printerrorf("Warning: Cannot use FREEBIND on %s: %s\n", ipstr, vlmcsd_strerror(socket_errno));
; 587  : 		}
; 588  : #endif					 // defined(IP_FREEBIND)
; 589  : 
; 590  : #if defined(IP_BINDANY) // FreeBSD IPv4
; 591  : 		if (ai->ai_family == AF_INET && setsockopt(*s, IPPROTO_IP, IP_BINDANY, (sockopt_t)&socketOption, sizeof(socketOption)))
; 592  : 		{
; 593  : 			printerrorf("Warning: Cannot use BINDANY on %s: %s\n", ipstr, vlmcsd_strerror(socket_errno));
; 594  : 		}
; 595  : #endif					// defined(IP_BINDANY)
; 596  : 
; 597  : #if defined(IPV6_BINDANY) // FreeBSD IPv6
; 598  : 		if (ai->ai_family == AF_INET6 && setsockopt(*s, IPPROTO_IP, IPV6_BINDANY, (sockopt_t)&socketOption, sizeof(socketOption)))
; 599  : 		{
; 600  : #ifdef _PEDANTIC		  // FreeBSD defines the symbol but doesn't have BINDANY in IPv6 (Kame stack doesn't have it)
; 601  : 			printerrorf("Warning: Cannot use BINDANY on %s: %s\n", ipstr, vlmcsd_strerror(socket_errno));
; 602  : #endif
; 603  : 		}
; 604  : #endif // defined(IPV6_BINDANY)
; 605  : 
; 606  : #if defined(IP_NONLOCALOK) && !defined(IP_BINDANY) // FreeBSD with GNU userspace IPv4
; 607  : 		if (ai->ai_family == AF_INET && setsockopt(*s, IPPROTO_IP, IP_NONLOCALOK, (sockopt_t)&socketOption, sizeof(socketOption)))
; 608  : 		{
; 609  : 			printerrorf("Warning: Cannot use BINDANY on %s: %s\n", ipstr, vlmcsd_strerror(socket_errno));
; 610  : 		}
; 611  : #endif											   // defined(IP_NONLOCALOK) && !defined(IP_BINDANY)
; 612  : 	}
; 613  : 
; 614  : #endif // HAVE_FREEBIND
; 615  : 
; 616  : 	if (bind(*s, ai->ai_addr, (int)ai->ai_addrlen) || listen(*s, SOMAXCONN))

  000b9	44 8b 47 10	 mov	 r8d, DWORD PTR [rdi+16]
  000bd	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]
  000c1	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  000c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_bind
  000ca	85 c0		 test	 eax, eax
  000cc	75 27		 jne	 SHORT $LN5@listenOnAd
  000ce	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  000d1	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_listen
  000dc	85 c0		 test	 eax, eax
  000de	75 15		 jne	 SHORT $LN5@listenOnAd

; 621  : 		return error;
; 622  : 	}
; 623  : 
; 624  : #ifndef NO_LOG
; 625  : 	logger("Listening on %s\n", ipstr);

  000e0	48 8d 54 24 30	 lea	 rdx, QWORD PTR ipstr$[rsp]
  000e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@LMJPNEIG@Listening?5on?5?$CFs?6@
  000ec	e8 00 00 00 00	 call	 logger

; 626  : #endif
; 627  : 
; 628  : 	return 0;

  000f1	33 c0		 xor	 eax, eax
  000f3	eb 2e		 jmp	 SHORT $LN1@listenOnAd
$LN5@listenOnAd:

; 617  : 	{
; 618  : 		error = socket_errno;

  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError

; 619  : 		printerrorf("Warning: %s: %s\n", ipstr, vlmcsd_strerror(error));

  000fb	8b c8		 mov	 ecx, eax
  000fd	8b d8		 mov	 ebx, eax
  000ff	e8 00 00 00 00	 call	 win_strerror
  00104	4c 8b c0	 mov	 r8, rax
  00107	48 8d 54 24 30	 lea	 rdx, QWORD PTR ipstr$[rsp]
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@NNGIJDIP@Warning?3?5?$CFs?3?5?$CFs?6@
  00113	e8 00 00 00 00	 call	 printerrorf

; 620  : 		socketclose(*s);

  00118	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  0011b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
$LN7@listenOnAd:

; 629  : }

  00121	8b c3		 mov	 eax, ebx
$LN1@listenOnAd:
  00123	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  00128	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  0012c	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00130	49 8b e3	 mov	 rsp, r11
  00133	5f		 pop	 rdi
  00134	c3		 ret	 0
listenOnAddress ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT addListeningSocket
_TEXT	SEGMENT
addr$ = 48
aiList$ = 56
addListeningSocket PROC					; COMDAT

; 634  : {

$LN17:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 635  : 	struct addrinfo *aiList, *ai;
; 636  : 	int result = FALSE;
; 637  : 	SOCKET *s = SocketList + numsockets;

  0000f	48 63 15 00 00
	00 00		 movsxd	 rdx, DWORD PTR numsockets
  00016	33 ff		 xor	 edi, edi
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR SocketList

; 638  : 
; 639  : 	if (getSocketList(&aiList, addr, AI_PASSIVE | AI_NUMERICHOST, AF_UNSPEC))

  0001f	45 33 c9	 xor	 r9d, r9d
  00022	44 8d 47 05	 lea	 r8d, QWORD PTR [rdi+5]
  00026	48 8d 34 d0	 lea	 rsi, QWORD PTR [rax+rdx*8]
  0002a	48 8b d1	 mov	 rdx, rcx
  0002d	48 8d 4c 24 38	 lea	 rcx, QWORD PTR aiList$[rsp]
  00032	e8 00 00 00 00	 call	 getSocketList
  00037	84 c0		 test	 al, al
  00039	74 49		 je	 SHORT $LN5@addListeni

; 640  : 	{
; 641  : 		for (ai = aiList; ai; ai = ai->ai_next)

  0003b	48 8b 5c 24 38	 mov	 rbx, QWORD PTR aiList$[rsp]
  00040	48 85 db	 test	 rbx, rbx
  00043	74 36		 je	 SHORT $LN11@addListeni
$LL4@addListeni:

; 642  : 		{
; 643  : 			// struct sockaddr_in* addr4 = (struct sockaddr_in*)sa->ai_addr;
; 644  : 			// struct sockaddr_in6* addr6 = (struct sockaddr_in6*)sa->ai_addr;
; 645  : 
; 646  : 			if (numsockets >= FD_SETSIZE)

  00045	83 3d 00 00 00
	00 40		 cmp	 DWORD PTR numsockets, 64 ; 00000040H
  0004c	7d 28		 jge	 SHORT $LN15@addListeni

; 647  : 			{
; 648  : #ifdef _PEDANTIC // Do not report this error in normal builds to keep file size low
; 649  : 				printerrorf("Warning: Cannot listen on %s. Your OS only supports %u listening sockets in an FD_SET.\n", addr, FD_SETSIZE);
; 650  : #endif
; 651  : 				break;
; 652  : 			}
; 653  : 
; 654  : 			if (!listenOnAddress(ai, s))

  0004e	48 8b d6	 mov	 rdx, rsi
  00051	48 8b cb	 mov	 rcx, rbx
  00054	e8 00 00 00 00	 call	 listenOnAddress
  00059	85 c0		 test	 eax, eax
  0005b	75 0b		 jne	 SHORT $LN7@addListeni

; 655  : 			{
; 656  : 				numsockets++;

  0005d	ff 05 00 00 00
	00		 inc	 DWORD PTR numsockets

; 657  : 				result = TRUE;

  00063	8d 78 01	 lea	 edi, QWORD PTR [rax+1]

; 658  : 			}

  00066	eb 05		 jmp	 SHORT $LN2@addListeni
$LN7@addListeni:

; 659  : 			else
; 660  : 			{
; 661  : 				exitOnWarningLevel(1);

  00068	e8 00 00 00 00	 call	 exitOnWarningLevel
$LN2@addListeni:

; 640  : 	{
; 641  : 		for (ai = aiList; ai; ai = ai->ai_next)

  0006d	48 8b 5b 28	 mov	 rbx, QWORD PTR [rbx+40]
  00071	48 85 db	 test	 rbx, rbx
  00074	75 cf		 jne	 SHORT $LL4@addListeni
$LN15@addListeni:

; 642  : 		{
; 643  : 			// struct sockaddr_in* addr4 = (struct sockaddr_in*)sa->ai_addr;
; 644  : 			// struct sockaddr_in6* addr6 = (struct sockaddr_in6*)sa->ai_addr;
; 645  : 
; 646  : 			if (numsockets >= FD_SETSIZE)

  00076	48 8b 5c 24 38	 mov	 rbx, QWORD PTR aiList$[rsp]
$LN11@addListeni:

; 662  : 			}
; 663  : 		}
; 664  : 
; 665  : 		freeaddrinfo(aiList);

  0007b	48 8b cb	 mov	 rcx, rbx
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_freeaddrinfo
$LN5@addListeni:

; 666  : 	}
; 667  : 	return result;
; 668  : }

  00084	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00089	8b c7		 mov	 eax, edi
  0008b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00090	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00094	5f		 pop	 rdi
  00095	c3		 ret	 0
addListeningSocket ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT checkProtocolStack
_TEXT	SEGMENT
addressfamily$ = 48
checkProtocolStack PROC					; COMDAT

; 672  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 673  : 	SOCKET s; // = INVALID_SOCKET;
; 674  : 
; 675  : 	s = socket(addressfamily, SOCK_STREAM, 0);

  00006	45 33 c0	 xor	 r8d, r8d
  00009	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket

; 676  : 	const int_fast8_t success = (s != INVALID_SOCKET);
; 677  : 
; 678  : 	socketclose(s);

  00013	48 8b c8	 mov	 rcx, rax
  00016	48 8b d8	 mov	 rbx, rax
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
  0001f	48 83 fb ff	 cmp	 rbx, -1
  00023	0f 95 c0	 setne	 al

; 679  : 	return success;
; 680  : }

  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
checkProtocolStack ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT network_accept_any
_TEXT	SEGMENT
ListeningSocketsList$ = 48
network_accept_any PROC					; COMDAT

; 684  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 81 ec 40 02
	00 00		 sub	 rsp, 576		; 00000240H

; 685  : 	fd_set ListeningSocketsList;
; 686  : 	SOCKET maxSocket, sock;
; 687  : 	int i;
; 688  : 	int status;
; 689  : 
; 690  : 	FD_ZERO(&ListeningSocketsList);
; 691  : 	maxSocket = 0;
; 692  : 
; 693  : 	for (i = 0; i < numsockets; i++)

  0000d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numsockets
  00013	33 c9		 xor	 ecx, ecx
  00015	45 33 c0	 xor	 r8d, r8d
  00018	89 4c 24 30	 mov	 DWORD PTR ListeningSocketsList$[rsp], ecx
  0001c	85 c0		 test	 eax, eax
  0001e	7e 52		 jle	 SHORT $LN3@network_ac
  00020	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR SocketList
  00027	44 8b d8	 mov	 r11d, eax
$LL4@network_ac:

; 694  : 	{
; 695  : 		FD_SET(SocketList[i], &ListeningSocketsList);

  0002a	33 d2		 xor	 edx, edx
  0002c	85 c9		 test	 ecx, ecx
  0002e	74 10		 je	 SHORT $LN26@network_ac
  00030	4d 8b 11	 mov	 r10, QWORD PTR [r9]
$LL10@network_ac:
  00033	4c 39 54 d4 38	 cmp	 QWORD PTR ListeningSocketsList$[rsp+rdx*8+8], r10
  00038	74 06		 je	 SHORT $LN26@network_ac
  0003a	ff c2		 inc	 edx
  0003c	3b d1		 cmp	 edx, ecx
  0003e	72 f3		 jb	 SHORT $LL10@network_ac
$LN26@network_ac:
  00040	3b d1		 cmp	 edx, ecx
  00042	75 17		 jne	 SHORT $LN5@network_ac
  00044	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00047	73 12		 jae	 SHORT $LN5@network_ac
  00049	49 8b 01	 mov	 rax, QWORD PTR [r9]
  0004c	48 89 44 d4 38	 mov	 QWORD PTR ListeningSocketsList$[rsp+rdx*8+8], rax
  00051	8b 4c 24 30	 mov	 ecx, DWORD PTR ListeningSocketsList$[rsp]
  00055	ff c1		 inc	 ecx
  00057	89 4c 24 30	 mov	 DWORD PTR ListeningSocketsList$[rsp], ecx
$LN5@network_ac:

; 696  : 		if (SocketList[i] > maxSocket)

  0005b	49 8b 01	 mov	 rax, QWORD PTR [r9]
  0005e	49 3b c0	 cmp	 rax, r8
  00061	49 0f 46 c0	 cmovbe	 rax, r8
  00065	49 83 c1 08	 add	 r9, 8
  00069	4c 8b c0	 mov	 r8, rax
  0006c	49 83 eb 01	 sub	 r11, 1
  00070	75 b8		 jne	 SHORT $LL4@network_ac
$LN3@network_ac:

; 697  : 			maxSocket = SocketList[i];
; 698  : 	}
; 699  : 
; 700  : 	status = select((int)maxSocket + 1, &ListeningSocketsList, NULL, NULL, NULL);

  00072	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00078	41 8d 48 01	 lea	 ecx, DWORD PTR [r8+1]
  0007c	45 33 c0	 xor	 r8d, r8d
  0007f	48 8d 54 24 30	 lea	 rdx, QWORD PTR ListeningSocketsList$[rsp]
  00084	45 33 c9	 xor	 r9d, r9d
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_select

; 701  : 
; 702  : 	if (status < 0)

  0008d	85 c0		 test	 eax, eax
  0008f	78 34		 js	 SHORT $LN37@network_ac

; 703  : 		return INVALID_SOCKET;
; 704  : 
; 705  : 	sock = INVALID_SOCKET;
; 706  : 
; 707  : 	for (i = 0; i < numsockets; i++)

  00091	33 db		 xor	 ebx, ebx
  00093	39 1d 00 00 00
	00		 cmp	 DWORD PTR numsockets, ebx
  00099	7e 2a		 jle	 SHORT $LN37@network_ac
  0009b	33 ff		 xor	 edi, edi
$LL13@network_ac:

; 708  : 	{
; 709  : 		if (FD_ISSET(SocketList[i], &ListeningSocketsList))

  0009d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR SocketList
  000a4	48 8d 54 24 30	 lea	 rdx, QWORD PTR ListeningSocketsList$[rsp]
  000a9	48 8b 0c 0f	 mov	 rcx, QWORD PTR [rdi+rcx]
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___WSAFDIsSet
  000b3	85 c0		 test	 eax, eax
  000b5	75 23		 jne	 SHORT $LN27@network_ac

; 703  : 		return INVALID_SOCKET;
; 704  : 
; 705  : 	sock = INVALID_SOCKET;
; 706  : 
; 707  : 	for (i = 0; i < numsockets; i++)

  000b7	ff c3		 inc	 ebx
  000b9	48 83 c7 08	 add	 rdi, 8
  000bd	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR numsockets
  000c3	7c d8		 jl	 SHORT $LL13@network_ac
$LN37@network_ac:

; 717  : 		return INVALID_SOCKET;

  000c5	48 83 c8 ff	 or	 rax, -1
$LN21@network_ac:

; 723  : #endif
; 724  : }

  000c9	48 8b 9c 24 50
	02 00 00	 mov	 rbx, QWORD PTR [rsp+592]
  000d1	48 81 c4 40 02
	00 00		 add	 rsp, 576		; 00000240H
  000d8	5f		 pop	 rdi
  000d9	c3		 ret	 0
$LN27@network_ac:

; 710  : 		{
; 711  : 			sock = SocketList[i];

  000da	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR SocketList
  000e1	48 63 cb	 movsxd	 rcx, ebx
  000e4	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]

; 712  : 			break;
; 713  : 		}
; 714  : 	}
; 715  : 
; 716  : 	if (sock == INVALID_SOCKET)

  000e8	48 83 f9 ff	 cmp	 rcx, -1
  000ec	74 d7		 je	 SHORT $LN37@network_ac

; 718  : 	else
; 719  : #ifndef _WIN32
; 720  : 		return _pp_accept(sock, NULL, NULL);
; 721  : #else
; 722  : 		return accept(sock, NULL, NULL);

  000ee	45 33 c0	 xor	 r8d, r8d
  000f1	33 d2		 xor	 edx, edx
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_accept
  000f9	eb ce		 jmp	 SHORT $LN21@network_ac
network_accept_any ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT closeAllListeningSockets
_TEXT	SEGMENT
closeAllListeningSockets PROC				; COMDAT

; 728  : {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 729  : #ifdef SIMPLE_SOCKETS
; 730  : 
; 731  : 	socketclose(s_server);
; 732  : 
; 733  : #else // !SIMPLE_SOCKETS
; 734  : 
; 735  : 	int i;
; 736  : 
; 737  : 	for (i = 0; i < numsockets; i++)

  0000a	33 db		 xor	 ebx, ebx
  0000c	39 1d 00 00 00
	00		 cmp	 DWORD PTR numsockets, ebx
  00012	7e 21		 jle	 SHORT $LN3@closeAllLi
  00014	8b fb		 mov	 edi, ebx
$LL4@closeAllLi:

; 738  : 	{
; 739  : 		socketclose(SocketList[i]);

  00016	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR SocketList
  0001d	48 8b 0c 0f	 mov	 rcx, QWORD PTR [rdi+rcx]
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
  00027	ff c3		 inc	 ebx
  00029	48 8d 7f 08	 lea	 rdi, QWORD PTR [rdi+8]
  0002d	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR numsockets
  00033	7c e1		 jl	 SHORT $LL4@closeAllLi
$LN3@closeAllLi:

; 740  : 	}
; 741  : 
; 742  : #endif // !SIMPLE_SOCKETS
; 743  : }

  00035	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5f		 pop	 rdi
  0003f	c3		 ret	 0
closeAllListeningSockets ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT serveClient
_TEXT	SEGMENT
ipstr$ = 48
addr$ = 112
s_client$ = 272
RpcAssocGroup$ = 280
to$ = 288
len$ = 296
serveClient PROC					; COMDAT

; 747  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 8d 6c 24 b9	 lea	 rbp, QWORD PTR [rsp-71]
  0000d	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H

; 748  : #if !defined(NO_TIMEOUT) && !__minix__
; 749  : 
; 750  : #ifndef _WIN32 // Standard Posix timeout structure
; 751  : 
; 752  : 	struct timeval to;
; 753  : 	to.tv_sec = ServerTimeout;
; 754  : 	to.tv_usec = 0;
; 755  : 
; 756  : #else // Windows requires a DWORD with milliseconds
; 757  : 
; 758  : 	DWORD to = ServerTimeout * 1000;

  00014	69 05 00 00 00
	00 e8 03 00 00	 imul	 eax, DWORD PTR ServerTimeout, 1000 ; 000003e8H

; 759  : 
; 760  : #endif // _WIN32
; 761  : 
; 762  : #if !defined(NO_LOG) && defined(_PEDANTIC)
; 763  : 
; 764  : 	const int result =
; 765  : 		setsockopt(s_client, SOL_SOCKET, SO_RCVTIMEO, (sockopt_t)&to, sizeof(to)) ||
; 766  : 		setsockopt(s_client, SOL_SOCKET, SO_SNDTIMEO, (sockopt_t)&to, sizeof(to));
; 767  : 
; 768  : 	if (result)
; 769  : 		logger("Warning: Set timeout failed: %s\n", vlmcsd_strerror(socket_errno));
; 770  : 
; 771  : #else // !(!defined(NO_LOG) && defined(_PEDANTIC))
; 772  : 
; 773  : 	setsockopt(s_client, SOL_SOCKET, SO_RCVTIMEO, (sockopt_t)&to, sizeof(to));

  0001e	4c 8d 4d 77	 lea	 r9, QWORD PTR to$[rbp-169]
  00022	8b f2		 mov	 esi, edx
  00024	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0002c	bb ff ff 00 00	 mov	 ebx, 65535		; 0000ffffH
  00031	41 b8 06 10 00
	00		 mov	 r8d, 4102		; 00001006H
  00037	8b d3		 mov	 edx, ebx
  00039	48 8b f9	 mov	 rdi, rcx
  0003c	89 45 77	 mov	 DWORD PTR to$[rbp-169], eax
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt

; 774  : 	setsockopt(s_client, SOL_SOCKET, SO_SNDTIMEO, (sockopt_t)&to, sizeof(to));

  00045	4c 8d 4d 77	 lea	 r9, QWORD PTR to$[rbp-169]
  00049	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00051	41 b8 05 10 00
	00		 mov	 r8d, 4101		; 00001005H
  00057	8b d3		 mov	 edx, ebx
  00059	48 8b cf	 mov	 rcx, rdi
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt

; 775  : 
; 776  : #endif // !(!defined(NO_LOG) && defined(_PEDANTIC))
; 777  : 
; 778  : #endif // !defined(NO_TIMEOUT) && !__minix__
; 779  : 
; 780  : 	char ipstr[64];
; 781  : 	socklen_t len;
; 782  : 	struct sockaddr_storage addr;
; 783  : 
; 784  : 	len = sizeof(addr);
; 785  : #ifndef _WIN32
; 786  : 	if (_pp_getpeername(s_client, (struct sockaddr *)&addr, &len) ||
; 787  : 		!ip2str(ipstr, sizeof(ipstr), (struct sockaddr *)&addr, len))
; 788  : #else
; 789  : 	if (getpeername(s_client, (struct sockaddr *)&addr, &len) ||

  00062	4c 8d 45 7f	 lea	 r8, QWORD PTR len$[rbp-169]
  00066	c7 45 7f 80 00
	00 00		 mov	 DWORD PTR len$[rbp-169], 128 ; 00000080H
  0006d	48 8d 55 c7	 lea	 rdx, QWORD PTR addr$[rbp-169]
  00071	48 8b cf	 mov	 rcx, rdi
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpeername
  0007a	85 c0		 test	 eax, eax
  0007c	0f 85 ad 00 00
	00		 jne	 $LN3@serveClien
  00082	44 8b 4d 7f	 mov	 r9d, DWORD PTR len$[rbp-169]
  00086	4c 8d 45 c7	 lea	 r8, QWORD PTR addr$[rbp-169]
  0008a	8d 50 40	 lea	 edx, QWORD PTR [rax+64]
  0008d	48 8d 4d 87	 lea	 rcx, QWORD PTR ipstr$[rbp-169]
  00091	e8 00 00 00 00	 call	 ip2str
  00096	84 c0		 test	 al, al
  00098	0f 84 91 00 00
	00		 je	 $LN3@serveClien

; 797  : 		return;
; 798  : 	}
; 799  : 
; 800  : #ifndef NO_LOG
; 801  : 	const char *const connection_type = addr.ss_family == AF_INET6 ? cIPv6 : cIPv4;

  0009e	66 83 7d c7 17	 cmp	 WORD PTR addr$[rbp-169], 23
  000a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04HOFDLIOP@IPv6@
  000aa	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:??_C@_04EMGFNKGN@IPv4@
  000b1	48 0f 44 d8	 cmove	 rbx, rax

; 802  : 	static const char *const cAccepted = "accepted";
; 803  : 	static const char *const cClosed = "closed";
; 804  : 	static const char *const fIP = "%s connection %s: %s.\n";
; 805  : 	if (logverbose > 3)

  000b5	80 3d 00 00 00
	00 03		 cmp	 BYTE PTR logverbose, 3
  000bc	7e 1a		 jle	 SHORT $LN4@serveClien

; 806  : 	{
; 807  : 		logger(fIP, connection_type, cAccepted, ipstr);

  000be	4c 8d 4d 87	 lea	 r9, QWORD PTR ipstr$[rbp-169]
  000c2	48 8b d3	 mov	 rdx, rbx
  000c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08LMOPGBBD@accepted@
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@BBMMHHHK@?$CFs?5connection?5?$CFs?3?5?$CFs?4?6@
  000d3	e8 00 00 00 00	 call	 logger
$LN4@serveClien:

; 808  : 	}
; 809  : #endif // NO_LOG
; 810  : 
; 811  : #if !defined(NO_PRIVATE_IP_DETECT)
; 812  : 
; 813  : 	if (!(PublicIPProtectionLevel & 2) || isPrivateIPAddress((struct sockaddr *)&addr, NULL))

  000d8	f6 05 00 00 00
	00 02		 test	 BYTE PTR PublicIPProtectionLevel, 2
  000df	74 1d		 je	 SHORT $LN7@serveClien
  000e1	33 d2		 xor	 edx, edx
  000e3	48 8d 4d c7	 lea	 rcx, QWORD PTR addr$[rbp-169]
  000e7	e8 00 00 00 00	 call	 isPrivateIPAddress
  000ec	84 c0		 test	 al, al
  000ee	75 0e		 jne	 SHORT $LN7@serveClien

; 816  : 	}
; 817  : #ifndef NO_LOG
; 818  : 	else
; 819  : 	{
; 820  : 		logger("Client with public IP address rejected\n");

  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CI@MHIGHDIH@Client?5with?5public?5IP?5address?5r@
  000f7	e8 00 00 00 00	 call	 logger
  000fc	eb 0e		 jmp	 SHORT $LN6@serveClien
$LN7@serveClien:

; 814  : 	{
; 815  : 		rpcServer(s_client, RpcAssocGroup, ipstr);

  000fe	4c 8d 45 87	 lea	 r8, QWORD PTR ipstr$[rbp-169]
  00102	8b d6		 mov	 edx, esi
  00104	48 8b cf	 mov	 rcx, rdi
  00107	e8 00 00 00 00	 call	 rpcServer
$LN6@serveClien:

; 821  : 	}
; 822  : #endif // NO_LOG
; 823  : 
; 824  : #else // defined(NO_PRIVATE_IP_DETECT)
; 825  : 
; 826  : 	rpcServer(s_client, RpcAssocGroup, ipstr);
; 827  : 
; 828  : #endif // defined(NO_PRIVATE_IP_DETECT)
; 829  : 
; 830  : #ifndef NO_LOG
; 831  : 	if (logverbose > 3)

  0010c	80 3d 00 00 00
	00 03		 cmp	 BYTE PTR logverbose, 3
  00113	7e 1a		 jle	 SHORT $LN3@serveClien

; 832  : 	{
; 833  : 		logger(fIP, connection_type, cClosed, ipstr);

  00115	4c 8d 4d 87	 lea	 r9, QWORD PTR ipstr$[rbp-169]
  00119	48 8b d3	 mov	 rdx, rbx
  0011c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06IKJOPBFO@closed@
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@BBMMHHHK@?$CFs?5connection?5?$CFs?3?5?$CFs?4?6@
  0012a	e8 00 00 00 00	 call	 logger
$LN3@serveClien:

; 790  : 		!ip2str(ipstr, sizeof(ipstr), (struct sockaddr *)&addr, len))
; 791  : #endif
; 792  : 	{
; 793  : #if !defined(NO_LOG) && defined(_PEDANTIC)
; 794  : 		logger("Fatal: Cannot determine client's IP address: %s\n", vlmcsd_strerror(errno));
; 795  : #endif // !defined(NO_LOG) && defined(_PEDANTIC)
; 796  : 		socketclose(s_client);

  0012f	48 8b cf	 mov	 rcx, rdi
  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket

; 834  : 	}
; 835  : #endif // NO_LOG
; 836  : 
; 837  : 	socketclose(s_client);
; 838  : }

  00138	48 8b 9c 24 10
	01 00 00	 mov	 rbx, QWORD PTR [rsp+272]
  00140	48 81 c4 f0 00
	00 00		 add	 rsp, 240		; 000000f0H
  00147	5f		 pop	 rdi
  00148	5e		 pop	 rsi
  00149	5d		 pop	 rbp
  0014a	c3		 ret	 0
serveClient ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT post_sem
_TEXT	SEGMENT
post_sem PROC						; COMDAT

; 842  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 843  : #if !defined(NO_LIMIT) && !__minix__
; 844  : 	if (!InetdMode && MaxTasks != SEM_VALUE_MAX)

  00004	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  0000b	75 20		 jne	 SHORT $LN2@post_sem
  0000d	81 3d 00 00 00
	00 ff ff ff 7f	 cmp	 DWORD PTR MaxTasks, 2147483647 ; 7fffffffH
  00017	74 14		 je	 SHORT $LN2@post_sem

; 845  : 	{
; 846  : 		semaphore_post(MaxTaskSemaphore);

  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR MaxTaskSemaphore
  00020	45 33 c0	 xor	 r8d, r8d
  00023	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseSemaphore
$LN2@post_sem:

; 847  : 	}
; 848  : #endif // !defined(NO_LIMIT) && !__minix__
; 849  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
post_sem ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT wait_sem
_TEXT	SEGMENT
wait_sem PROC						; COMDAT

; 852  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 853  : #if !defined(NO_LIMIT) && !__minix__
; 854  : 	if (!InetdMode && MaxTasks != SEM_VALUE_MAX)

  00004	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  0000b	75 1c		 jne	 SHORT $LN2@wait_sem
  0000d	81 3d 00 00 00
	00 ff ff ff 7f	 cmp	 DWORD PTR MaxTasks, 2147483647 ; 7fffffffH
  00017	74 10		 je	 SHORT $LN2@wait_sem

; 855  : 	{
; 856  : 		semaphore_wait(MaxTaskSemaphore);

  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR MaxTaskSemaphore
  00020	83 ca ff	 or	 edx, -1			; ffffffffH
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
$LN2@wait_sem:

; 857  : 	}
; 858  : #endif // !defined(NO_LIMIT) && !__minix__
; 859  : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
wait_sem ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT serveClientThreadProc
_TEXT	SEGMENT
clData$ = 48
serveClientThreadProc PROC				; COMDAT

; 869  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 870  : 	serveClient(clData->socket, clData->RpcAssocGroup);

  00006	8b 51 08	 mov	 edx, DWORD PTR [rcx+8]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000f	e8 00 00 00 00	 call	 serveClient

; 871  : 	free(clData);

  00014	48 8b cb	 mov	 rcx, rbx
  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 872  : 	post_sem();

  0001d	e8 00 00 00 00	 call	 post_sem

; 873  : 
; 874  : 	return 0;

  00022	33 c0		 xor	 eax, eax

; 875  : }

  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5b		 pop	 rbx
  00029	c3		 ret	 0
serveClientThreadProc ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT serveClientAsyncWinThreads
_TEXT	SEGMENT
thr_CLData$ = 64
serveClientAsyncWinThreads PROC				; COMDAT

; 883  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 884  : 	wait_sem();

  00009	e8 00 00 00 00	 call	 wait_sem

; 885  : 
; 886  : 	HANDLE h = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)serveClientThreadProc, thr_CLData, 0, NULL);

  0000e	48 83 64 24 28
	00		 and	 QWORD PTR [rsp+40], 0
  00014	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:serveClientThreadProc
  0001b	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  00020	4c 8b cb	 mov	 r9, rbx
  00023	33 d2		 xor	 edx, edx
  00025	33 c9		 xor	 ecx, ecx
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateThread

; 887  : 
; 888  : 	if (h)

  0002d	48 85 c0	 test	 rax, rax
  00030	74 11		 je	 SHORT $LN2@serveClien

; 889  : 	{
; 890  : 		CloseHandle(h);

  00032	48 8b c8	 mov	 rcx, rax
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 891  : 		return NO_ERROR;

  0003b	33 c0		 xor	 eax, eax

; 899  : 	}
; 900  : }

  0003d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00041	5b		 pop	 rbx
  00042	c3		 ret	 0
$LN2@serveClien:

; 892  : 	}
; 893  : 	else
; 894  : 	{
; 895  : 		socketclose(thr_CLData->socket);

  00043	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket

; 896  : 		free(thr_CLData);

  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 897  : 		post_sem();

  00055	e8 00 00 00 00	 call	 post_sem

; 899  : 	}
; 900  : }

  0005a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005e	5b		 pop	 rbx

; 898  : 		return GetLastError();

  0005f	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_GetLastError
serveClientAsyncWinThreads ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\network.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT serveClientAsync
_TEXT	SEGMENT
s_client$ = 48
RpcAssocGroup$ = 56
serveClientAsync PROC					; COMDAT

; 987  : {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	8b da		 mov	 ebx, edx
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  0000f	b9 10 00 00 00	 mov	 ecx, 16
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 366  : 	if (!buf) OutOfMemory();

  0001a	48 85 c0	 test	 rax, rax
  0001d	74 18		 je	 SHORT $LN9@serveClien
; File C:\Users\dev\source\repos\alpinevms\src\network.c

; 995  : 	thr_CLData->socket = s_client;

  0001f	48 8b c8	 mov	 rcx, rax
  00022	48 89 38	 mov	 QWORD PTR [rax], rdi

; 996  : 	thr_CLData->RpcAssocGroup = RpcAssocGroup;

  00025	89 58 08	 mov	 DWORD PTR [rax+8], ebx

; 1009 : }

  00028	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5f		 pop	 rdi

; 997  : 
; 998  : #if defined(_WIN32) || defined(__CYGWIN__) // Windows threads
; 999  : 
; 1000 : 	return serveClientAsyncWinThreads(thr_CLData);

  00032	e9 00 00 00 00	 jmp	 serveClientAsyncWinThreads
$LN9@serveClien:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 366  : 	if (!buf) OutOfMemory();

  00037	e8 00 00 00 00	 call	 OutOfMemory
  0003c	cc		 int	 3
$LN7@serveClien:
serveClientAsync ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\network.c
;	COMDAT runServer
_TEXT	SEGMENT
runServer PROC						; COMDAT

; 1014 : {

$LN25:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1015 : 	DWORD RpcAssocGroup = rand32();

  0000a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00010	8b d8		 mov	 ebx, eax
  00012	c1 e3 0f	 shl	 ebx, 15
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  0001b	8b f8		 mov	 edi, eax
  0001d	0b fb		 or	 edi, ebx
  0001f	c1 e7 02	 shl	 edi, 2
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00028	8b d8		 mov	 ebx, eax
  0002a	83 e3 03	 and	 ebx, 3
  0002d	0b df		 or	 ebx, edi

; 1016 : 
; 1017 : 	// If compiled for inetd-only mode just serve the stdin socket
; 1018 : #ifdef NO_SOCKETS
; 1019 : 	serveClient(STDIN_FILENO, RpcAssocGroup);
; 1020 : 	return 0;
; 1021 : #else
; 1022 : 	// In inetd mode just handle the stdin socket
; 1023 : 	if (InetdMode)

  0002f	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  00036	74 0d		 je	 SHORT $LL2@runServer

; 1024 : 	{
; 1025 : 		serveClient(STDIN_FILENO, RpcAssocGroup);

  00038	8b d3		 mov	 edx, ebx
  0003a	33 c9		 xor	 ecx, ecx
  0003c	e8 00 00 00 00	 call	 serveClient
$LN23@runServer:

; 1071 : #endif // NO_SOCKETS
; 1072 : }

  00041	33 c0		 xor	 eax, eax
  00043	eb 42		 jmp	 SHORT $LN3@runServer
$LL2@runServer:

; 1026 : 		return 0;
; 1027 : 	}
; 1028 : 
; 1029 : 	for (;;)
; 1030 : 	{
; 1031 : 		int error;
; 1032 : 		SOCKET s_client;
; 1033 : 
; 1034 : #ifdef SIMPLE_SOCKETS
; 1035 : 		if ((s_client = accept(s_server, NULL, NULL)) == INVALID_SOCKET)
; 1036 : #else  // Standalone mode fully featured sockets
; 1037 : 		if ((s_client = network_accept_any()) == INVALID_SOCKET)

  00045	e8 00 00 00 00	 call	 network_accept_any
  0004a	48 83 f8 ff	 cmp	 rax, -1
  0004e	75 42		 jne	 SHORT $LN6@runServer

; 1038 : #endif // Standalone mode fully featured sockets
; 1039 : 		{
; 1040 : 			error = socket_errno;

  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00056	8b f8		 mov	 edi, eax

; 1041 : 			if (error == SOCKET_EINTR || error == SOCKET_ECONNABORTED)

  00058	3d 14 27 00 00	 cmp	 eax, 10004		; 00002714H
  0005d	74 e6		 je	 SHORT $LL2@runServer
  0005f	3d 45 27 00 00	 cmp	 eax, 10053		; 00002745H
  00064	74 df		 je	 SHORT $LL2@runServer

; 1042 : 				continue;
; 1043 : 
; 1044 : #ifdef _NTSERVICE
; 1045 : 			if (ServiceShutdown)

  00066	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ServiceShutdown, 0
  0006d	75 d2		 jne	 SHORT $LN23@runServer

; 1046 : 				return 0;
; 1047 : #endif
; 1048 : 
; 1049 : #ifndef NO_LOG
; 1050 : 			logger("Fatal: %s\n", vlmcsd_strerror(error));

  0006f	8b c8		 mov	 ecx, eax
  00071	e8 00 00 00 00	 call	 win_strerror
  00076	48 8b d0	 mov	 rdx, rax
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DGCMIMNM@Fatal?3?5?$CFs?6@
  00080	e8 00 00 00 00	 call	 logger

; 1051 : #endif
; 1052 : 
; 1053 : 			return error;

  00085	8b c7		 mov	 eax, edi
$LN3@runServer:

; 1071 : #endif // NO_SOCKETS
; 1072 : }

  00087	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00090	5f		 pop	 rdi
  00091	c3		 ret	 0
$LN6@runServer:

; 1054 : 		}
; 1055 : 
; 1056 : 		RpcAssocGroup++;

  00092	ff c3		 inc	 ebx

; 1057 : 
; 1058 : #if !defined(NO_LOG) && defined(_PEDANTIC)
; 1059 : 		if ((error = serveClientAsync(s_client, RpcAssocGroup)))
; 1060 : 		{
; 1061 : #ifdef USE_THREADS
; 1062 : 			logger("Warning: Could not create client thread: %s\n", vlmcsd_strerror(error));
; 1063 : #else  // !USE_THREADS
; 1064 : 			logger("Warning: Could not fork client: %s\n", vlmcsd_strerror(error));
; 1065 : #endif // !USE_THREADS
; 1066 : 		}
; 1067 : #else  // NO_LOG || !_PEDANTIC
; 1068 : 		serveClientAsync(s_client, RpcAssocGroup);

  00094	48 8b c8	 mov	 rcx, rax
  00097	8b d3		 mov	 edx, ebx
  00099	e8 00 00 00 00	 call	 serveClientAsync

; 1069 : #endif // NO_LOG || !_PEDANTIC
; 1070 : 	}

  0009e	eb a5		 jmp	 SHORT $LL2@runServer
runServer ENDP
_TEXT	ENDS
END
