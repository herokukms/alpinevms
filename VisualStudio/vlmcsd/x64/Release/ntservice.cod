; Listing generated by Microsoft (R) Optimizing Compiler Version 19.32.31332.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_06INAKJJAK@vlmcsd@			; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC@				; `string'
PUBLIC	??_C@_0BN@JDPANHLH@Cannot?5install?5service?5?$CI?$CFd?$CJ?6@ ; `string'
PUBLIC	??_C@_02DEDJNJGL@?9s@				; `string'
PUBLIC	??_C@_02MFNBDIMN@?9W@				; `string'
PUBLIC	??_C@_02PHOHFKEP@?9U@				; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_0BN@FIOFKNLG@Service?5removal?5failed?5?$CI?$CFd?$CJ?6@ ; `string'
PUBLIC	??_C@_02PKOHADJL@?1l@				; `string'
PUBLIC	??_C@_0BK@PHAGCFFB@NT?5AUTHORITY?2LocalService@	; `string'
PUBLIC	??_C@_02MINBGBBJ@?1n@				; `string'
PUBLIC	??_C@_0BM@PDMNECKP@NT?5AUTHORITY?2NetworkService@ ; `string'
PUBLIC	??_C@_02CEGDFPFP@?4?2@				; `string'
PUBLIC	??_C@_06BPNJJJFL@tcpip?$AA@			; `string'
PUBLIC	??_C@_0BG@JPMCODEK@Key?5Management?5Server@	; `string'
PUBLIC	??_C@_0BL@LFBNDFIB@CreateService?5failed?5?$CI?$CFu?$CJ?6@ ; `string'
PUBLIC	??_C@_0CA@OFMAEDKI@Service?5installed?5successfully?6@ ; `string'
PUBLIC	??_C@_0BO@LEBOOPBL@Restarting?5vlmcsd?5service?5?$DN?$DO?5@ ; `string'
PUBLIC	??_C@_08GKHOLFG@Success?6@			; `string'
PUBLIC	??_C@_0BL@MMELEJAD@Not?5ready?5within?5a?5second?6@ ; `string'
PUBLIC	??_C@_06HPIHNGNL@Error?6@			; `string'
PUBLIC	??_C@_09JBCKIECM@Error?5?$CFu?6@		; `string'
PUBLIC	??_C@_0BL@KECMPHCB@Error?5removing?5service?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CB@KAHEFAHB@Service?5?$CFs?5removed?5successfully@ ; `string'
PUBLIC	??_C@_0BM@GDAJEGHF@Service?5?$CFs?5does?5not?5exist?4?6@ ; `string'
PUBLIC	NTServiceDispatchTable
EXTRN	__imp_CreateServiceA:PROC
EXTRN	__imp_QueryServiceStatus:PROC
EXTRN	__imp_CloseServiceHandle:PROC
EXTRN	__imp_SetServiceStatus:PROC
EXTRN	__imp_RegisterServiceCtrlHandlerA:PROC
EXTRN	__imp_OpenSCManagerA:PROC
EXTRN	__imp_DeleteService:PROC
EXTRN	__imp_ControlService:PROC
EXTRN	__imp_StartServiceA:PROC
EXTRN	__imp_OpenServiceA:PROC
COMM	gSvcStatus:BYTE:01cH
COMM	gSvcStatusHandle:QWORD
_DATA	ENDS
;	COMDAT ??_C@_0BM@GDAJEGHF@Service?5?$CFs?5does?5not?5exist?4?6@
CONST	SEGMENT
??_C@_0BM@GDAJEGHF@Service?5?$CFs?5does?5not?5exist?4?6@ DB 'Service %s d'
	DB	'oes not exist.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KAHEFAHB@Service?5?$CFs?5removed?5successfully@
CONST	SEGMENT
??_C@_0CB@KAHEFAHB@Service?5?$CFs?5removed?5successfully@ DB 'Service %s '
	DB	'removed successfully', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KECMPHCB@Error?5removing?5service?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@KECMPHCB@Error?5removing?5service?5?$CFs?6@ DB 'Error removing '
	DB	'service %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09JBCKIECM@Error?5?$CFu?6@
CONST	SEGMENT
??_C@_09JBCKIECM@Error?5?$CFu?6@ DB 'Error %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HPIHNGNL@Error?6@
CONST	SEGMENT
??_C@_06HPIHNGNL@Error?6@ DB 'Error', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MMELEJAD@Not?5ready?5within?5a?5second?6@
CONST	SEGMENT
??_C@_0BL@MMELEJAD@Not?5ready?5within?5a?5second?6@ DB 'Not ready within '
	DB	'a second', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08GKHOLFG@Success?6@
CONST	SEGMENT
??_C@_08GKHOLFG@Success?6@ DB 'Success', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LEBOOPBL@Restarting?5vlmcsd?5service?5?$DN?$DO?5@
CONST	SEGMENT
??_C@_0BO@LEBOOPBL@Restarting?5vlmcsd?5service?5?$DN?$DO?5@ DB 'Restartin'
	DB	'g vlmcsd service => ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OFMAEDKI@Service?5installed?5successfully?6@
CONST	SEGMENT
??_C@_0CA@OFMAEDKI@Service?5installed?5successfully?6@ DB 'Service instal'
	DB	'led successfully', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LFBNDFIB@CreateService?5failed?5?$CI?$CFu?$CJ?6@
CONST	SEGMENT
??_C@_0BL@LFBNDFIB@CreateService?5failed?5?$CI?$CFu?$CJ?6@ DB 'CreateServ'
	DB	'ice failed (%u)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JPMCODEK@Key?5Management?5Server@
CONST	SEGMENT
??_C@_0BG@JPMCODEK@Key?5Management?5Server@ DB 'Key Management Server', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BPNJJJFL@tcpip?$AA@
CONST	SEGMENT
??_C@_06BPNJJJFL@tcpip?$AA@ DB 'tcpip', 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02CEGDFPFP@?4?2@
CONST	SEGMENT
??_C@_02CEGDFPFP@?4?2@ DB '.\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PDMNECKP@NT?5AUTHORITY?2NetworkService@
CONST	SEGMENT
??_C@_0BM@PDMNECKP@NT?5AUTHORITY?2NetworkService@ DB 'NT AUTHORITY\Networ'
	DB	'kService', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02MINBGBBJ@?1n@
CONST	SEGMENT
??_C@_02MINBGBBJ@?1n@ DB '/n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PHAGCFFB@NT?5AUTHORITY?2LocalService@
CONST	SEGMENT
??_C@_0BK@PHAGCFFB@NT?5AUTHORITY?2LocalService@ DB 'NT AUTHORITY\LocalSer'
	DB	'vice', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_02PKOHADJL@?1l@
CONST	SEGMENT
??_C@_02PKOHADJL@?1l@ DB '/l', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FIOFKNLG@Service?5removal?5failed?5?$CI?$CFd?$CJ?6@
CONST	SEGMENT
??_C@_0BN@FIOFKNLG@Service?5removal?5failed?5?$CI?$CFd?$CJ?6@ DB 'Service'
	DB	' removal failed (%d)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PHOHFKEP@?9U@
CONST	SEGMENT
??_C@_02PHOHFKEP@?9U@ DB '-U', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MFNBDIMN@?9W@
CONST	SEGMENT
??_C@_02MFNBDIMN@?9W@ DB '-W', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DEDJNJGL@?9s@
CONST	SEGMENT
??_C@_02DEDJNJGL@?9s@ DB '-s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JDPANHLH@Cannot?5install?5service?5?$CI?$CFd?$CJ?6@
CONST	SEGMENT
??_C@_0BN@JDPANHLH@Cannot?5install?5service?5?$CI?$CFd?$CJ?6@ DB 'Cannot '
	DB	'install service (%d)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06INAKJJAK@vlmcsd@
CONST	SEGMENT
??_C@_06INAKJJAK@vlmcsd@ DB 'vlmcsd', 00H		; `string'
NTServiceDispatchTable DQ FLAT:??_C@_06INAKJJAK@vlmcsd@
	DQ	FLAT:ServiceMain
	DQ	0000000000000000H
	DQ	0000000000000000H
PUBLIC	NtServiceInstallation
PUBLIC	ReportServiceStatus
PUBLIC	ServiceCtrlHandler
PUBLIC	RtlSecureZeroMemory
;	COMDAT pdata
pdata	SEGMENT
$pdata$NtServiceInstallation DD imagerel $LN14
	DD	imagerel $LN14+130
	DD	imagerel $unwind$NtServiceInstallation
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ServiceInstaller DD imagerel ServiceInstaller
	DD	imagerel ServiceInstaller+1047
	DD	imagerel $unwind$ServiceInstaller
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$OpenAndRemoveService DD imagerel OpenAndRemoveService
	DD	imagerel OpenAndRemoveService+290
	DD	imagerel $unwind$OpenAndRemoveService
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ServiceMain DD imagerel ServiceMain
	DD	imagerel ServiceMain+81
	DD	imagerel $unwind$ServiceMain
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ServiceCtrlHandler DD imagerel $LN9
	DD	imagerel $LN9+44
	DD	imagerel $unwind$ServiceCtrlHandler
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RtlSecureZeroMemory DD imagerel $LN4
	DD	imagerel $LN4+27
	DD	imagerel $unwind$RtlSecureZeroMemory
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlSecureZeroMemory DD 020501H
	DD	017405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ServiceCtrlHandler DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ServiceMain DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OpenAndRemoveService DD 0250b2101H
	DD	0de421H
	DD	0c741dH
	DD	0b6416H
	DD	0a340fH
	DD	07206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ServiceInstaller DD 0b1f01H
	DD	03c341fH
	DD	034011fH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$NtServiceInstallation DD 010401H
	DD	04204H
?dwCheckPoint@?1??ReportServiceStatus@@9@9 DD 01H	; `ReportServiceStatus'::`2'::dwCheckPoint
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft SDKs\Windows\v7.1A\include\winnt.h
;	COMDAT RtlSecureZeroMemory
_TEXT	SEGMENT
ptr$ = 8
cnt$ = 16
RtlSecureZeroMemory PROC				; COMDAT

; 13069: {

$LN4:
  00000	48 89 7c 24 08	 mov	 QWORD PTR [rsp+8], rdi
  00005	4c 8b c1	 mov	 r8, rcx

; 13070:     volatile char *vptr = (volatile char *)ptr;
; 13071: 
; 13072: #if defined(_M_AMD64)
; 13073: 
; 13074:         __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  00008	48 8b f9	 mov	 rdi, rcx
  0000b	33 c0		 xor	 eax, eax
  0000d	48 8b ca	 mov	 rcx, rdx
  00010	f3 aa		 rep stosb

; 13075: 
; 13076: #else
; 13077: 
; 13078:     while (cnt) {
; 13079:         *vptr = 0;
; 13080:         vptr++;
; 13081:         cnt--;
; 13082:     }
; 13083: 
; 13084: #endif
; 13085: 
; 13086:     return ptr;
; 13087: }

  00012	48 8b 7c 24 08	 mov	 rdi, QWORD PTR [rsp+8]
  00017	49 8b c0	 mov	 rax, r8
  0001a	c3		 ret	 0
RtlSecureZeroMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\ntservice.c
;	COMDAT ServiceCtrlHandler
_TEXT	SEGMENT
dwCtrl$ = 48
ServiceCtrlHandler PROC					; COMDAT

; 18   : {

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 19   : 	// Handle the requested control code.
; 20   : 	switch (dwCtrl)

  00004	83 e9 01	 sub	 ecx, 1
  00007	74 05		 je	 SHORT $LN4@ServiceCtr
  00009	83 f9 04	 cmp	 ecx, 4
  0000c	75 19		 jne	 SHORT $LN6@ServiceCtr
$LN4@ServiceCtr:

; 21   : 	{
; 22   : 	case SERVICE_CONTROL_STOP:
; 23   : 	case SERVICE_CONTROL_SHUTDOWN:
; 24   : 
; 25   : 		ServiceShutdown = TRUE;
; 26   : 		ReportServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, 0);

  0000e	33 d2		 xor	 edx, edx
  00010	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ServiceShutdown, 1
  00017	45 33 c0	 xor	 r8d, r8d
  0001a	8d 4a 03	 lea	 ecx, QWORD PTR [rdx+3]
  0001d	e8 00 00 00 00	 call	 ReportServiceStatus

; 27   : 
; 28   : 		// Remove PID file and free ressources
; 29   : 		cleanup();

  00022	e8 00 00 00 00	 call	 cleanup
$LN6@ServiceCtr:

; 30   : #			if __CYGWIN__ || defined(USE_MSRPC)
; 31   : 		ReportServiceStatus(SERVICE_STOPPED, NO_ERROR, 0);
; 32   : #			endif // __CYGWIN__
; 33   : 
; 34   : 	default:
; 35   : 		break;
; 36   : 	}
; 37   : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
ServiceCtrlHandler ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\ntservice.c
;	COMDAT ServiceMain
_TEXT	SEGMENT
argc_unused$ = 48
argv_unused$ = 56
ServiceMain PROC					; COMDAT

; 40   : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 41   : 	// Register the handler function for the service
; 42   : 
; 43   : 	if (!((gSvcStatusHandle = RegisterServiceCtrlHandler(NT_SERVICE_NAME, ServiceCtrlHandler))))

  00004	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ServiceCtrlHandler
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06INAKJJAK@vlmcsd@
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegisterServiceCtrlHandlerA
  00018	48 89 05 00 00
	00 00		 mov	 QWORD PTR gSvcStatusHandle, rax
  0001f	48 85 c0	 test	 rax, rax
  00022	74 28		 je	 SHORT $LN1@ServiceMai

; 44   : 	{
; 45   : 		return;
; 46   : 	}
; 47   : 
; 48   : 	// These SERVICE_STATUS members remain as set here
; 49   : 
; 50   : 	gSvcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
; 51   : 	gSvcStatus.dwServiceSpecificExitCode = 0;

  00024	83 25 10 00 00
	00 00		 and	 DWORD PTR gSvcStatus+16, 0
  0002b	c7 05 00 00 00
	00 10 00 00 00	 mov	 DWORD PTR gSvcStatus, 16

; 52   : 
; 53   : 	// Run the actual program
; 54   : 	ReportServiceStatus(SERVICE_STOPPED, newmain(), 3000);

  00035	e8 00 00 00 00	 call	 newmain
  0003a	8b d0		 mov	 edx, eax
  0003c	b9 01 00 00 00	 mov	 ecx, 1
  00041	41 b8 b8 0b 00
	00		 mov	 r8d, 3000		; 00000bb8H
  00047	e8 00 00 00 00	 call	 ReportServiceStatus
$LN1@ServiceMai:

; 55   : }

  0004c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00050	c3		 ret	 0
ServiceMain ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\ntservice.c
;	COMDAT ReportServiceStatus
_TEXT	SEGMENT
dwCurrentState$ = 8
dwWin32ExitCode$ = 16
dwWaitHint$ = 24
ReportServiceStatus PROC				; COMDAT

; 70   : 	static DWORD dwCheckPoint = 1;
; 71   : 
; 72   : 	// Fill in the SERVICE_STATUS structure.
; 73   : 
; 74   : 	gSvcStatus.dwCurrentState = dwCurrentState;

  00000	89 0d 04 00 00
	00		 mov	 DWORD PTR gSvcStatus+4, ecx

; 75   : 	gSvcStatus.dwWin32ExitCode = dwWin32ExitCode;

  00006	89 15 0c 00 00
	00		 mov	 DWORD PTR gSvcStatus+12, edx

; 76   : 	gSvcStatus.dwWaitHint = dwWaitHint;

  0000c	44 89 05 18 00
	00 00		 mov	 DWORD PTR gSvcStatus+24, r8d

; 77   : 
; 78   : 	if (dwCurrentState == SERVICE_START_PENDING)
; 79   : 		gSvcStatus.dwControlsAccepted = 0;
; 80   : 	else
; 81   : 		gSvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

  00013	c7 05 08 00 00
	00 01 00 00 00	 mov	 DWORD PTR gSvcStatus+8, 1

; 82   : 
; 83   : 	if ((dwCurrentState == SERVICE_RUNNING) ||

  0001d	83 f9 04	 cmp	 ecx, 4
  00020	74 1b		 je	 SHORT $LN6@ReportServ
  00022	83 f9 01	 cmp	 ecx, 1
  00025	74 16		 je	 SHORT $LN6@ReportServ

; 86   : 	else
; 87   : 		gSvcStatus.dwCheckPoint = dwCheckPoint++;

  00027	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?dwCheckPoint@?1??ReportServiceStatus@@9@9
  0002d	89 05 14 00 00
	00		 mov	 DWORD PTR gSvcStatus+20, eax
  00033	ff c0		 inc	 eax
  00035	89 05 00 00 00
	00		 mov	 DWORD PTR ?dwCheckPoint@?1??ReportServiceStatus@@9@9, eax
  0003b	eb 07		 jmp	 SHORT $LN5@ReportServ
$LN6@ReportServ:

; 84   : 		(dwCurrentState == SERVICE_STOPPED))
; 85   : 		gSvcStatus.dwCheckPoint = 0;

  0003d	83 25 14 00 00
	00 00		 and	 DWORD PTR gSvcStatus+20, 0
$LN5@ReportServ:

; 88   : 
; 89   : 	// Report the status of the service to the SCM.
; 90   : 	SetServiceStatus(gSvcStatusHandle, &gSvcStatus);

  00044	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gSvcStatusHandle
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gSvcStatus
  00052	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_SetServiceStatus
ReportServiceStatus ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\ntservice.c
;	COMDAT OpenAndRemoveService
_TEXT	SEGMENT
status$ = 0
dwPreviousState$ = 48
schSCManager$ = 56
OpenAndRemoveService PROC				; COMDAT

; 126  : {

  00000	40 55		 push	 rbp
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 89 5d 30	 mov	 QWORD PTR [rbp+48], rbx
  0000f	48 8b d9	 mov	 rbx, rcx
  00012	48 89 75 38	 mov	 QWORD PTR [rbp+56], rsi
  00016	48 8b f2	 mov	 rsi, rdx
  00019	48 89 7d 40	 mov	 QWORD PTR [rbp+64], rdi
  0001d	4c 89 75 48	 mov	 QWORD PTR [rbp+72], r14

; 127  : 	SERVICE_STATUS status;
; 128  : 	uint_fast8_t i;
; 129  : 	SC_HANDLE installedService;
; 130  : 	uint_fast8_t result = 1;
; 131  : 	BOOL closeManager = FALSE;

  00021	45 33 f6	 xor	 r14d, r14d

; 132  : 
; 133  : 	// Allow NULL for both Arguments
; 134  : 	if (!dwPreviousState) dwPreviousState = (DWORD*)alloca(sizeof(*dwPreviousState));

  00024	41 8d 46 10	 lea	 eax, QWORD PTR [r14+16]
  00028	48 85 c9	 test	 rcx, rcx
  0002b	75 0d		 jne	 SHORT $LN5@OpenAndRem
  0002d	8b 0c 24	 mov	 ecx, DWORD PTR [rsp]
  00030	48 2b e0	 sub	 rsp, rax
  00033	48 8d 5c 24 20	 lea	 rbx, QWORD PTR [rsp+32]
  00038	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN5@OpenAndRem:

; 135  : 	if (!schSCManager)

  0003a	48 85 d2	 test	 rdx, rdx
  0003d	75 11		 jne	 SHORT $LN6@OpenAndRem

; 136  : 	{
; 137  : 		schSCManager = (SC_HANDLE*)alloca(sizeof(*schSCManager));

  0003f	8b 0c 24	 mov	 ecx, DWORD PTR [rsp]
  00042	48 2b e0	 sub	 rsp, rax
  00045	48 8d 74 24 20	 lea	 rsi, QWORD PTR [rsp+32]
  0004a	8b 06		 mov	 eax, DWORD PTR [rsi]

; 138  : 		closeManager = TRUE;

  0004c	44 8d 72 01	 lea	 r14d, QWORD PTR [rdx+1]
$LN6@OpenAndRem:

; 139  : 	}
; 140  : 
; 141  : 	*schSCManager = OpenSCManager(

  00050	33 d2		 xor	 edx, edx
  00052	33 c9		 xor	 ecx, ecx
  00054	41 b8 3f 00 0f
	00		 mov	 r8d, 983103		; 000f003fH
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OpenSCManagerA
  00060	48 89 06	 mov	 QWORD PTR [rsi], rax

; 142  : 		NULL,                    // local computer
; 143  : 		NULL,                    // ServicesActive database
; 144  : 		SC_MANAGER_ALL_ACCESS);  // full access rights
; 145  : 
; 146  : 	if (!*schSCManager) return 0;

  00063	48 85 c0	 test	 rax, rax
  00066	0f 84 a0 00 00
	00		 je	 $LN1@OpenAndRem
$LN7@OpenAndRem:

; 147  : 
; 148  : 	if (!((installedService = OpenService(*schSCManager, NT_SERVICE_NAME, SERVICE_ALL_ACCESS))))

  0006c	41 b8 ff 01 0f
	00		 mov	 r8d, 983551		; 000f01ffH
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06INAKJJAK@vlmcsd@
  00079	48 8b c8	 mov	 rcx, rax
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OpenServiceA
  00082	48 8b f8	 mov	 rdi, rax
  00085	48 85 c0	 test	 rax, rax
  00088	75 04		 jne	 SHORT $LN8@OpenAndRem

; 149  : 	{
; 150  : 		result = 2;

  0008a	b3 02		 mov	 bl, 2

; 151  : 	}

  0008c	eb 6e		 jmp	 SHORT $LN9@OpenAndRem
$LN8@OpenAndRem:

; 152  : 	else
; 153  : 	{
; 154  : 		*dwPreviousState = SERVICE_STOPPED;
; 155  : 		if (QueryServiceStatus(installedService, &status)) *dwPreviousState = status.dwCurrentState;

  0008e	48 8d 55 00	 lea	 rdx, QWORD PTR status$[rbp]
  00092	c7 03 01 00 00
	00		 mov	 DWORD PTR [rbx], 1
  00098	48 8b cf	 mov	 rcx, rdi
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryServiceStatus
  000a1	85 c0		 test	 eax, eax
  000a3	74 05		 je	 SHORT $LN10@OpenAndRem
  000a5	8b 45 04	 mov	 eax, DWORD PTR status$[rbp+4]
  000a8	89 03		 mov	 DWORD PTR [rbx], eax
$LN10@OpenAndRem:

; 156  : 
; 157  : 		ControlService(installedService, SERVICE_CONTROL_STOP, &status);

  000aa	4c 8d 45 00	 lea	 r8, QWORD PTR status$[rbp]
  000ae	ba 01 00 00 00	 mov	 edx, 1
  000b3	48 8b cf	 mov	 rcx, rdi
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ControlService

; 158  : 
; 159  : 		for (i = 0; i < 10; i++)

  000bc	32 db		 xor	 bl, bl
$LL4@OpenAndRem:

; 160  : 		{
; 161  : 			QueryServiceStatus(installedService, &status);

  000be	48 8d 55 00	 lea	 rdx, QWORD PTR status$[rbp]
  000c2	48 8b cf	 mov	 rcx, rdi
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryServiceStatus

; 162  : 			// Give it 100 ms after it reported SERVICE_STOPPED. Subsequent CreateService will fail otherwise
; 163  : 			Sleep(100);

  000cb	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep

; 164  : 			if (status.dwCurrentState == SERVICE_STOPPED) break;

  000d6	83 7d 04 01	 cmp	 DWORD PTR status$[rbp+4], 1
  000da	74 07		 je	 SHORT $LN16@OpenAndRem

; 158  : 
; 159  : 		for (i = 0; i < 10; i++)

  000dc	fe c3		 inc	 bl
  000de	80 fb 0a	 cmp	 bl, 10
  000e1	72 db		 jb	 SHORT $LL4@OpenAndRem
$LN16@OpenAndRem:

; 165  : 		}
; 166  : 
; 167  : 		if (!DeleteService(installedService)) result = 0;

  000e3	48 8b cf	 mov	 rcx, rdi
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteService
  000ec	f7 d8		 neg	 eax

; 168  : 		CloseServiceHandle(installedService);

  000ee	48 8b cf	 mov	 rcx, rdi
  000f1	1a db		 sbb	 bl, bl
  000f3	80 e3 01	 and	 bl, 1
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseServiceHandle
$LN9@OpenAndRem:

; 169  : 	}
; 170  : 
; 171  : 	if (closeManager) CloseServiceHandle(*schSCManager);

  000fc	45 85 f6	 test	 r14d, r14d
  000ff	74 09		 je	 SHORT $LN13@OpenAndRem
  00101	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseServiceHandle
$LN13@OpenAndRem:

; 172  : 	return result;

  0010a	8a c3		 mov	 al, bl
$LN1@OpenAndRem:

; 173  : }

  0010c	48 8b 5d 30	 mov	 rbx, QWORD PTR [rbp+48]
  00110	48 8b 75 38	 mov	 rsi, QWORD PTR [rbp+56]
  00114	48 8b 7d 40	 mov	 rdi, QWORD PTR [rbp+64]
  00118	4c 8b 75 48	 mov	 r14, QWORD PTR [rbp+72]
  0011c	48 8d 65 20	 lea	 rsp, QWORD PTR [rbp+32]
  00120	5d		 pop	 rbp
  00121	c3		 ret	 0
OpenAndRemoveService ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\ntservice.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\ntservice.c
; File C:\Program Files (x86)\Microsoft SDKs\Windows\v7.1A\include\winnt.h
; File C:\Users\dev\source\repos\alpinevms\src\ntservice.c
; File C:\Program Files (x86)\Microsoft SDKs\Windows\v7.1A\include\winnt.h
; File C:\Users\dev\source\repos\alpinevms\src\ntservice.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\ntservice.c
;	COMDAT ServiceInstaller
_TEXT	SEGMENT
status$ = 112
szPath$ = 144
ServiceUser$ = 480
ServicePassword$ = 488
dwPreviousState$ = 496
schSCManager$ = 504
ServiceInstaller PROC					; COMDAT

; 176  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 8d ac 24 60
	ff ff ff	 lea	 rbp, QWORD PTR [rsp-160]
  00018	48 81 ec a0 01
	00 00		 sub	 rsp, 416		; 000001a0H
  0001f	4c 8b e2	 mov	 r12, rdx
  00022	4c 8b f1	 mov	 r14, rcx

; 177  : 	SC_HANDLE schSCManager;
; 178  : 	SC_HANDLE schService;
; 179  : 	char szPath[MAX_PATH] = "\"";

  00025	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  0002a	48 8d 4d 92	 lea	 rcx, QWORD PTR szPath$[rbp-254]
  0002e	33 d2		 xor	 edx, edx
  00030	66 89 45 90	 mov	 WORD PTR szPath$[rbp-256], ax
  00034	41 b8 02 01 00
	00		 mov	 r8d, 258		; 00000102H
  0003a	e8 00 00 00 00	 call	 memset

; 180  : 
; 181  : 	if (!GetModuleFileName(NULL, szPath + sizeof(char), MAX_PATH - 1))

  0003f	41 b8 03 01 00
	00		 mov	 r8d, 259		; 00000103H
  00045	48 8d 55 91	 lea	 rdx, QWORD PTR szPath$[rbp-255]
  00049	33 c9		 xor	 ecx, ecx
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleFileNameA
  00051	45 33 ed	 xor	 r13d, r13d
  00054	85 c0		 test	 eax, eax
  00056	75 19		 jne	 SHORT $LN8@ServiceIns

; 182  : 	{
; 183  : 		errorout("Cannot install service (%d)\n", (uint32_t)GetLastError());

  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@JDPANHLH@Cannot?5install?5service?5?$CI?$CFd?$CJ?6@
$LN69@ServiceIns:

; 303  : }

  00065	8b d0		 mov	 edx, eax
  00067	e8 00 00 00 00	 call	 errorout
  0006c	e9 85 03 00 00	 jmp	 $LN1@ServiceIns
$LN8@ServiceIns:

; 184  : 		return;
; 185  : 	}
; 186  : 
; 187  : 	strcat(szPath, "\"");

  00071	48 8d 4d 90	 lea	 rcx, QWORD PTR szPath$[rbp-256]
  00075	41 bf 01 00 00
	00		 mov	 r15d, 1
  0007b	49 2b cf	 sub	 rcx, r15
$LL61@ServiceIns:
  0007e	49 03 cf	 add	 rcx, r15
  00081	44 38 29	 cmp	 BYTE PTR [rcx], r13b
  00084	75 f8		 jne	 SHORT $LL61@ServiceIns

; 188  : 
; 189  : 	int i;
; 190  : 	for (i = 1; i < global_argc; i++)

  00086	44 39 3d 00 00
	00 00		 cmp	 DWORD PTR global_argc, r15d
  0008d	41 8b df	 mov	 ebx, r15d
  00090	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_01BJJEKLCA@?$CC@
  00097	66 89 01	 mov	 WORD PTR [rcx], ax
  0009a	0f 8e 12 01 00
	00		 jle	 $LN3@ServiceIns
  000a0	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR global_argv
  000a7	bf 08 00 00 00	 mov	 edi, 8
  000ac	40 b6 2d	 mov	 sil, 45			; 0000002dH
$LL4@ServiceIns:

; 191  : 	{
; 192  : 		// Strip unneccessary parameters, especially the password
; 193  : 		if (!strcmp(global_argv[i], "-s")) continue;

  000af	4a 8b 04 0f	 mov	 rax, QWORD PTR [rdi+r9]
  000b3	40 38 30	 cmp	 BYTE PTR [rax], sil
  000b6	75 3e		 jne	 SHORT $LN58@ServiceIns
  000b8	80 78 01 73	 cmp	 BYTE PTR [rax+1], 115	; 00000073H
  000bc	75 0a		 jne	 SHORT $LN60@ServiceIns
  000be	44 38 68 02	 cmp	 BYTE PTR [rax+2], r13b
  000c2	0f 84 d7 00 00
	00		 je	 $LN2@ServiceIns
$LN60@ServiceIns:

; 194  : 
; 195  : 		if (!strcmp(global_argv[i], "-W") ||

  000c8	40 38 30	 cmp	 BYTE PTR [rax], sil
  000cb	75 29		 jne	 SHORT $LN58@ServiceIns
  000cd	80 78 01 57	 cmp	 BYTE PTR [rax+1], 87	; 00000057H
  000d1	75 06		 jne	 SHORT $LN59@ServiceIns
  000d3	44 38 68 02	 cmp	 BYTE PTR [rax+2], r13b
  000d7	74 11		 je	 SHORT $LN11@ServiceIns
$LN59@ServiceIns:
  000d9	40 38 30	 cmp	 BYTE PTR [rax], sil
  000dc	75 18		 jne	 SHORT $LN58@ServiceIns
  000de	80 78 01 55	 cmp	 BYTE PTR [rax+1], 85	; 00000055H
  000e2	75 12		 jne	 SHORT $LN58@ServiceIns
  000e4	44 38 68 02	 cmp	 BYTE PTR [rax+2], r13b
  000e8	75 0c		 jne	 SHORT $LN58@ServiceIns
$LN11@ServiceIns:

; 196  : 			!strcmp(global_argv[i], "-U"))
; 197  : 		{
; 198  : 			i++;

  000ea	41 03 df	 add	 ebx, r15d
  000ed	48 83 c7 08	 add	 rdi, 8
  000f1	e9 a9 00 00 00	 jmp	 $LN2@ServiceIns
$LN58@ServiceIns:

; 199  : 			continue;
; 200  : 		}
; 201  : 
; 202  : 		strcat(szPath, " ");

  000f6	48 8d 4d 90	 lea	 rcx, QWORD PTR szPath$[rbp-256]
  000fa	49 2b cf	 sub	 rcx, r15
$LL57@ServiceIns:
  000fd	49 03 cf	 add	 rcx, r15
  00100	44 38 29	 cmp	 BYTE PTR [rcx], r13b
  00103	75 f8		 jne	 SHORT $LL57@ServiceIns
  00105	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_01CLKCMJKC@?5@

; 203  : 
; 204  : 		if (strchr(global_argv[i], ' '))

  0010c	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00111	66 89 01	 mov	 WORD PTR [rcx], ax
  00114	4a 8b 0c 0f	 mov	 rcx, QWORD PTR [rdi+r9]
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  0011e	48 8d 4d 90	 lea	 rcx, QWORD PTR szPath$[rbp-256]
  00122	49 2b cf	 sub	 rcx, r15
  00125	48 85 c0	 test	 rax, rax
  00128	74 52		 je	 SHORT $LL51@ServiceIns
$LL56@ServiceIns:

; 205  : 		{
; 206  : 			strcat(szPath, "\"");

  0012a	49 03 cf	 add	 rcx, r15
  0012d	44 38 29	 cmp	 BYTE PTR [rcx], r13b
  00130	75 f8		 jne	 SHORT $LL56@ServiceIns
  00132	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_01BJJEKLCA@?$CC@

; 207  : 			strcat(szPath, global_argv[i]);

  00139	48 8d 55 90	 lea	 rdx, QWORD PTR szPath$[rbp-256]
  0013d	66 89 01	 mov	 WORD PTR [rcx], ax
  00140	49 2b d7	 sub	 rdx, r15
$LL54@ServiceIns:
  00143	49 03 d7	 add	 rdx, r15
  00146	44 38 2a	 cmp	 BYTE PTR [rdx], r13b
  00149	75 f8		 jne	 SHORT $LL54@ServiceIns
  0014b	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR global_argv
  00152	45 33 c0	 xor	 r8d, r8d
  00155	4e 8b 14 0f	 mov	 r10, QWORD PTR [rdi+r9]
$LL55@ServiceIns:
  00159	43 8a 0c 02	 mov	 cl, BYTE PTR [r10+r8]
  0015d	42 88 0c 02	 mov	 BYTE PTR [rdx+r8], cl
  00161	49 ff c0	 inc	 r8
  00164	84 c9		 test	 cl, cl
  00166	75 f1		 jne	 SHORT $LL55@ServiceIns

; 208  : 			strcat(szPath, "\"");

  00168	48 8d 4d 90	 lea	 rcx, QWORD PTR szPath$[rbp-256]
  0016c	49 2b cf	 sub	 rcx, r15
$LL53@ServiceIns:
  0016f	49 03 cf	 add	 rcx, r15
  00172	44 38 29	 cmp	 BYTE PTR [rcx], r13b
  00175	75 f8		 jne	 SHORT $LL53@ServiceIns
  00177	66 89 01	 mov	 WORD PTR [rcx], ax

; 209  : 		}

  0017a	eb 23		 jmp	 SHORT $LN2@ServiceIns
$LL51@ServiceIns:

; 210  : 		else
; 211  : 			strcat(szPath, global_argv[i]);

  0017c	49 03 cf	 add	 rcx, r15
  0017f	44 38 29	 cmp	 BYTE PTR [rcx], r13b
  00182	75 f8		 jne	 SHORT $LL51@ServiceIns
  00184	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR global_argv
  0018b	33 d2		 xor	 edx, edx
  0018d	4e 8b 04 0f	 mov	 r8, QWORD PTR [rdi+r9]
$LL52@ServiceIns:
  00191	41 8a 04 10	 mov	 al, BYTE PTR [r8+rdx]
  00195	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  00198	48 ff c2	 inc	 rdx
  0019b	84 c0		 test	 al, al
  0019d	75 f2		 jne	 SHORT $LL52@ServiceIns
$LN2@ServiceIns:

; 188  : 
; 189  : 	int i;
; 190  : 	for (i = 1; i < global_argc; i++)

  0019f	41 03 df	 add	 ebx, r15d
  001a2	48 83 c7 08	 add	 rdi, 8
  001a6	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR global_argc
  001ac	0f 8c fd fe ff
	ff		 jl	 $LL4@ServiceIns
$LN3@ServiceIns:

; 212  : 	}
; 213  : 
; 214  : 	// Get a handle to the SCM database.
; 215  : 
; 216  : 	SERVICE_STATUS status;
; 217  : 	DWORD dwPreviousState;
; 218  : 
; 219  : 	if (!OpenAndRemoveService(&dwPreviousState, &schSCManager))

  001b2	48 8d 95 f8 00
	00 00		 lea	 rdx, QWORD PTR schSCManager$[rbp-256]
  001b9	48 8d 8d f0 00
	00 00		 lea	 rcx, QWORD PTR dwPreviousState$[rbp-256]
  001c0	e8 00 00 00 00	 call	 OpenAndRemoveService
  001c5	84 c0		 test	 al, al
  001c7	75 12		 jne	 SHORT $LN14@ServiceIns

; 220  : 	{
; 221  : 		errorout("Service removal failed (%d)\n", (uint32_t)GetLastError());

  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  001cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@FIOFKNLG@Service?5removal?5failed?5?$CI?$CFd?$CJ?6@

; 222  : 		return;

  001d6	e9 8a fe ff ff	 jmp	 $LN69@ServiceIns
$LN14@ServiceIns:

; 223  : 	}
; 224  : 
; 225  : 	char *tempUser = NULL;
; 226  : 
; 227  : 	if (ServiceUser)

  001db	48 83 ce ff	 or	 rsi, -1
  001df	49 8b dd	 mov	 rbx, r13
  001e2	4d 85 f6	 test	 r14, r14
  001e5	0f 84 a1 00 00
	00		 je	 $LN18@ServiceIns

; 228  : 	{
; 229  : 		// Shortcuts for some well known users
; 230  : 		if (!strcasecmp(ServiceUser, "/l")) ServiceUser = "NT AUTHORITY\\LocalService";

  001eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02PKOHADJL@?1l@
  001f2	49 8b ce	 mov	 rcx, r14
  001f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  001fb	85 c0		 test	 eax, eax
  001fd	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0BK@PHAGCFFB@NT?5AUTHORITY?2LocalService@

; 231  : 		if (!strcasecmp(ServiceUser, "/n")) ServiceUser = "NT AUTHORITY\\NetworkService";

  00204	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MINBGBBJ@?1n@
  0020b	49 0f 45 fe	 cmovne	 rdi, r14
  0020f	48 8b cf	 mov	 rcx, rdi
  00212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00218	85 c0		 test	 eax, eax
  0021a	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:??_C@_0BM@PDMNECKP@NT?5AUTHORITY?2NetworkService@

; 232  : 
; 233  : 		// Allow Local Users without .\ , e.g. "johndoe" instead of ".\johndoe"
; 234  : 		if (!strchr(ServiceUser, '\\'))

  00221	8d 56 5d	 lea	 edx, QWORD PTR [rsi+93]
  00224	4c 0f 45 f7	 cmovne	 r14, rdi
  00228	49 8b ce	 mov	 rcx, r14
  0022b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  00231	48 85 c0	 test	 rax, rax
  00234	75 56		 jne	 SHORT $LN18@ServiceIns

; 235  : 		{
; 236  : 			tempUser = (char*)vlmcsd_malloc(strlen(ServiceUser) + 3);

  00236	48 8b ce	 mov	 rcx, rsi
$LL50@ServiceIns:
  00239	48 ff c1	 inc	 rcx
  0023c	45 38 2c 0e	 cmp	 BYTE PTR [r14+rcx], r13b
  00240	75 f7		 jne	 SHORT $LL50@ServiceIns
  00242	48 83 c1 03	 add	 rcx, 3
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  00246	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0024c	48 8b d8	 mov	 rbx, rax

; 366  : 	if (!buf) OutOfMemory();

  0024f	48 85 c0	 test	 rax, rax
  00252	0f 84 b9 01 00
	00		 je	 $LN71@ServiceIns
; File C:\Users\dev\source\repos\alpinevms\src\ntservice.c

; 238  : 			strcat(tempUser, ServiceUser);

  00258	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_02CEGDFPFP@?4?2@
  0025f	48 8b cb	 mov	 rcx, rbx
  00262	66 89 03	 mov	 WORD PTR [rbx], ax
  00265	49 2b cf	 sub	 rcx, r15
  00268	8a 05 02 00 00
	00		 mov	 al, BYTE PTR ??_C@_02CEGDFPFP@?4?2@+2
  0026e	88 43 02	 mov	 BYTE PTR [rbx+2], al
$LL48@ServiceIns:
  00271	49 03 cf	 add	 rcx, r15
  00274	44 38 29	 cmp	 BYTE PTR [rcx], r13b
  00277	75 f8		 jne	 SHORT $LL48@ServiceIns
  00279	33 d2		 xor	 edx, edx
$LL49@ServiceIns:
  0027b	41 8a 04 16	 mov	 al, BYTE PTR [r14+rdx]
  0027f	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  00282	48 ff c2	 inc	 rdx
  00285	84 c0		 test	 al, al
  00287	75 f2		 jne	 SHORT $LL49@ServiceIns

; 239  : 			ServiceUser = tempUser;

  00289	4c 8b f3	 mov	 r14, rbx
$LN18@ServiceIns:

; 240  : 		}
; 241  : 	}
; 242  : 
; 243  : 	schService = CreateService(

  0028c	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  00291	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06BPNJJJFL@tcpip?$AA@
  00298	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14
  0029d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BG@JPMCODEK@Key?5Management?5Server@
  002a4	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  002a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06INAKJJAK@vlmcsd@
  002b0	4c 89 6c 24 48	 mov	 QWORD PTR [rsp+72], r13
  002b5	48 8d 45 90	 lea	 rax, QWORD PTR szPath$[rbp-256]
  002b9	4c 89 6c 24 40	 mov	 QWORD PTR [rsp+64], r13
  002be	41 b9 ff 01 0f
	00		 mov	 r9d, 983551		; 000f01ffH
  002c4	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  002c9	44 89 7c 24 30	 mov	 DWORD PTR [rsp+48], r15d
  002ce	4c 8b bd f8 00
	00 00		 mov	 r15, QWORD PTR schSCManager$[rbp-256]
  002d5	49 8b cf	 mov	 rcx, r15
  002d8	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR [rsp+40], 2
  002e0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateServiceA
  002ee	4c 8b f0	 mov	 r14, rax
$LL47@ServiceIns:

; 262  : 	SecureZeroMemory((char*)ServicePassword, strlen(ServicePassword));

  002f1	48 ff c6	 inc	 rsi
  002f4	45 38 2c 34	 cmp	 BYTE PTR [r12+rsi], r13b
  002f8	75 f7		 jne	 SHORT $LL47@ServiceIns
; File C:\Program Files (x86)\Microsoft SDKs\Windows\v7.1A\include\winnt.h

; 13074:         __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  002fa	33 c0		 xor	 eax, eax
; File C:\Users\dev\source\repos\alpinevms\src\ntservice.c

; 262  : 	SecureZeroMemory((char*)ServicePassword, strlen(ServicePassword));

  002fc	48 8b ce	 mov	 rcx, rsi
; File C:\Program Files (x86)\Microsoft SDKs\Windows\v7.1A\include\winnt.h

; 13074:         __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  002ff	49 8b fc	 mov	 rdi, r12
  00302	f3 aa		 rep stosb
; File C:\Users\dev\source\repos\alpinevms\src\ntservice.c

; 264  : 	if (tempUser) free(tempUser);

  00304	48 85 db	 test	 rbx, rbx
  00307	74 09		 je	 SHORT $LN19@ServiceIns
  00309	48 8b cb	 mov	 rcx, rbx
  0030c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN19@ServiceIns:

; 265  : 
; 266  : 	if (schService == NULL)

  00312	4d 85 f6	 test	 r14, r14
  00315	75 19		 jne	 SHORT $LN20@ServiceIns

; 267  : 	{
; 268  : 		errorout("CreateService failed (%u)\n", (uint32_t)GetLastError());

  00317	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0031d	8b d0		 mov	 edx, eax
  0031f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@LFBNDFIB@CreateService?5failed?5?$CI?$CFu?$CJ?6@
  00326	e8 00 00 00 00	 call	 errorout

; 269  : 		CloseServiceHandle(schSCManager);
; 270  : 		return;

  0032b	e9 bd 00 00 00	 jmp	 $LN66@ServiceIns
$LN20@ServiceIns:

; 271  : 	}
; 272  : 	else
; 273  : 	{
; 274  : 		errorout("Service installed successfully\n");

  00330	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@OFMAEDKI@Service?5installed?5successfully?6@
  00337	e8 00 00 00 00	 call	 errorout

; 275  : 
; 276  : 		if (dwPreviousState == SERVICE_RUNNING)

  0033c	83 bd f0 00 00
	00 04		 cmp	 DWORD PTR dwPreviousState$[rbp-256], 4
  00343	0f 85 9b 00 00
	00		 jne	 $LN24@ServiceIns

; 277  : 		{
; 278  : 			printf("Restarting " NT_SERVICE_NAME " service => ");

  00349	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@LEBOOPBL@Restarting?5vlmcsd?5service?5?$DN?$DO?5@
  00350	e8 00 00 00 00	 call	 printf

; 279  : 			status.dwCurrentState = SERVICE_STOPPED;
; 280  : 
; 281  : 			if (StartService(schService, 0, NULL))

  00355	45 33 c0	 xor	 r8d, r8d
  00358	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR status$[rsp+4], 1
  00360	33 d2		 xor	 edx, edx
  00362	49 8b ce	 mov	 rcx, r14
  00365	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_StartServiceA
  0036b	85 c0		 test	 eax, eax
  0036d	74 61		 je	 SHORT $LN23@ServiceIns

; 282  : 			{
; 283  : 				for (i = 0; i < 10; i++)

  0036f	41 8b fd	 mov	 edi, r13d
$LL7@ServiceIns:

; 284  : 				{
; 285  : 					if (!QueryServiceStatus(schService, &status) || status.dwCurrentState != SERVICE_START_PENDING) break;

  00372	48 8d 54 24 70	 lea	 rdx, QWORD PTR status$[rsp]
  00377	49 8b ce	 mov	 rcx, r14
  0037a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryServiceStatus
  00380	85 c0		 test	 eax, eax
  00382	74 19		 je	 SHORT $LN62@ServiceIns
  00384	8b 44 24 74	 mov	 eax, DWORD PTR status$[rsp+4]
  00388	83 f8 02	 cmp	 eax, 2
  0038b	75 14		 jne	 SHORT $LN40@ServiceIns

; 286  : 					Sleep(100);

  0038d	8d 48 62	 lea	 ecx, QWORD PTR [rax+98]
  00390	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep
  00396	ff c7		 inc	 edi
  00398	83 ff 0a	 cmp	 edi, 10
  0039b	7c d5		 jl	 SHORT $LL7@ServiceIns
$LN62@ServiceIns:

; 284  : 				{
; 285  : 					if (!QueryServiceStatus(schService, &status) || status.dwCurrentState != SERVICE_START_PENDING) break;

  0039d	8b 44 24 74	 mov	 eax, DWORD PTR status$[rsp+4]
$LN40@ServiceIns:

; 287  : 				}
; 288  : 
; 289  : 				if (status.dwCurrentState == SERVICE_RUNNING)

  003a1	83 f8 04	 cmp	 eax, 4
  003a4	75 09		 jne	 SHORT $LN27@ServiceIns

; 290  : 					printf("Success\n");

  003a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GKHOLFG@Success?6@
  003ad	eb 0c		 jmp	 SHORT $LN67@ServiceIns
$LN27@ServiceIns:

; 291  : 				else if (status.dwCurrentState == SERVICE_START_PENDING)

  003af	83 f8 02	 cmp	 eax, 2
  003b2	75 0e		 jne	 SHORT $LN29@ServiceIns

; 292  : 					printf("Not ready within a second\n");

  003b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@MMELEJAD@Not?5ready?5within?5a?5second?6@
$LN67@ServiceIns:

; 298  : 		}
; 299  : 	}
; 300  : 
; 301  : 	CloseServiceHandle(schService);

  003bb	e8 00 00 00 00	 call	 printf
  003c0	eb 22		 jmp	 SHORT $LN24@ServiceIns
$LN29@ServiceIns:

; 293  : 				else
; 294  : 					errorout("Error\n");

  003c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06HPIHNGNL@Error?6@
  003c9	e8 00 00 00 00	 call	 errorout

; 295  : 			}

  003ce	eb 14		 jmp	 SHORT $LN24@ServiceIns
$LN23@ServiceIns:

; 296  : 			else
; 297  : 				errorout("Error %u\n", (uint32_t)GetLastError());

  003d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  003d6	8b d0		 mov	 edx, eax
  003d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09JBCKIECM@Error?5?$CFu?6@
  003df	e8 00 00 00 00	 call	 errorout
$LN24@ServiceIns:

; 298  : 		}
; 299  : 	}
; 300  : 
; 301  : 	CloseServiceHandle(schService);

  003e4	49 8b ce	 mov	 rcx, r14
  003e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseServiceHandle
$LN66@ServiceIns:

; 303  : }

  003ed	49 8b cf	 mov	 rcx, r15
  003f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseServiceHandle
$LN1@ServiceIns:
  003f6	48 8b 9c 24 e0
	01 00 00	 mov	 rbx, QWORD PTR [rsp+480]
  003fe	48 81 c4 a0 01
	00 00		 add	 rsp, 416		; 000001a0H
  00405	41 5f		 pop	 r15
  00407	41 5e		 pop	 r14
  00409	41 5d		 pop	 r13
  0040b	41 5c		 pop	 r12
  0040d	5f		 pop	 rdi
  0040e	5e		 pop	 rsi
  0040f	5d		 pop	 rbp
  00410	c3		 ret	 0
$LN71@ServiceIns:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 366  : 	if (!buf) OutOfMemory();

  00411	e8 00 00 00 00	 call	 OutOfMemory
  00416	cc		 int	 3
$LN63@ServiceIns:
ServiceInstaller ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\ntservice.c
;	COMDAT NtServiceInstallation
_TEXT	SEGMENT
installService$dead$ = 48
ServiceUser$dead$ = 56
ServicePassword$dead$ = 64
NtServiceInstallation PROC				; COMDAT

; 306  : {

$LN14:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 307  : 	if (IsNTService) return 0;

  00004	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR IsNTService, 0
  0000b	75 1d		 jne	 SHORT $LN6@NtServiceI

; 308  : 
; 309  : 	if (installService == 1) // Install

  0000d	8a 05 00 00 00
	00		 mov	 al, BYTE PTR installService
  00013	3c 01		 cmp	 al, 1
  00015	75 1a		 jne	 SHORT $LN5@NtServiceI

; 310  : 	{
; 311  : 		ServiceInstaller(ServiceUser, ServicePassword);

  00017	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ServicePassword
  0001e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ServiceUser
  00025	e8 00 00 00 00	 call	 ServiceInstaller
$LN6@NtServiceI:

; 328  : 		}
; 329  : 	}
; 330  : 
; 331  : 	// Do nothing
; 332  : 
; 333  : 	return(0);
; 334  : }

  0002a	33 c0		 xor	 eax, eax
$LN1@NtServiceI:
  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
$LN5@NtServiceI:

; 312  : 		return(0);
; 313  : 	}
; 314  : 
; 315  : 	if (installService == 2) // Remove

  00031	3c 02		 cmp	 al, 2
  00033	75 f5		 jne	 SHORT $LN6@NtServiceI

; 316  : 	{
; 317  : 		switch (OpenAndRemoveService(NULL, NULL))

  00035	33 d2		 xor	 edx, edx
  00037	33 c9		 xor	 ecx, ecx
  00039	e8 00 00 00 00	 call	 OpenAndRemoveService
  0003e	0f b6 d0	 movzx	 edx, al
  00041	84 c0		 test	 al, al
  00043	74 23		 je	 SHORT $LN7@NtServiceI
  00045	83 fa 01	 cmp	 edx, 1
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06INAKJJAK@vlmcsd@
  0004f	74 09		 je	 SHORT $LN8@NtServiceI

; 325  : 		default:
; 326  : 			errorout("Service %s does not exist.\n", NT_SERVICE_NAME);

  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@GDAJEGHF@Service?5?$CFs?5does?5not?5exist?4?6@

; 327  : 			return(!0);

  00058	eb 1c		 jmp	 SHORT $LN12@NtServiceI
$LN8@NtServiceI:

; 321  : 			return(!0);
; 322  : 		case 1:
; 323  : 			printf("Service %s removed successfully\n", NT_SERVICE_NAME);

  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@KAHEFAHB@Service?5?$CFs?5removed?5successfully@
  00061	e8 00 00 00 00	 call	 printf

; 324  : 			return(0);

  00066	eb c2		 jmp	 SHORT $LN6@NtServiceI
$LN7@NtServiceI:

; 318  : 		{
; 319  : 		case 0:
; 320  : 			errorout("Error removing service %s\n", NT_SERVICE_NAME);

  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06INAKJJAK@vlmcsd@
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@KECMPHCB@Error?5removing?5service?5?$CFs?6@
$LN12@NtServiceI:

; 328  : 		}
; 329  : 	}
; 330  : 
; 331  : 	// Do nothing
; 332  : 
; 333  : 	return(0);
; 334  : }

  00076	e8 00 00 00 00	 call	 errorout
  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	eb aa		 jmp	 SHORT $LN1@NtServiceI
NtServiceInstallation ENDP
_TEXT	ENDS
END
