; Listing generated by Microsoft (R) Optimizing Compiler Version 19.32.31332.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0EJ@OGPMLMGM@a?3N?3B?3m?3t?3A?3R?3u?3g?3L?3p?3i?3H?3P?3X?3Y@ ; `string'
PUBLIC	??_C@_09BIFGJFAC@ExitLevel@			; `string'
PUBLIC	??_C@_03DCJLDMKG@VPN@				; `string'
PUBLIC	??_C@_07IIAKFIOC@KmsData@			; `string'
PUBLIC	??_C@_0BC@IJCDKLCC@WhiteListingLevel@		; `string'
PUBLIC	??_C@_0BA@PHKIMFI@CheckClientTime@		; `string'
PUBLIC	??_C@_0L@MPMBKNGK@StartEmpty@			; `string'
PUBLIC	??_C@_0BA@PFAJBMD@MaintainClients@		; `string'
PUBLIC	??_C@_0BD@BOJJAJAF@RandomizationLevel@		; `string'
PUBLIC	??_C@_04MGCBHGDH@LCID@				; `string'
PUBLIC	??_C@_09FNOKBMFF@HostBuild@			; `string'
PUBLIC	??_C@_04HOKNCALA@Port@				; `string'
PUBLIC	??_C@_06CBIOIDCI@Listen@			; `string'
PUBLIC	??_C@_0L@CJHAKJAH@MaxWorkers@			; `string'
PUBLIC	??_C@_0BC@JIAPHOFH@ConnectionTimeout@		; `string'
PUBLIC	??_C@_0BN@MMGPMACK@DisconnectClientsImmediately@ ; `string'
PUBLIC	??_C@_08LIILCCDA@UseNDR64@			; `string'
PUBLIC	??_C@_07HOBDIJEO@UseBTFN@			; `string'
PUBLIC	??_C@_07ECHLBDEG@PIDFile@			; `string'
PUBLIC	??_C@_0P@DLGBEDLC@LogDateAndTime@		; `string'
PUBLIC	??_C@_07EEDKEMBM@LogFile@			; `string'
PUBLIC	??_C@_0L@JCGDMJPB@LogVerbose@			; `string'
PUBLIC	??_C@_0BD@NEDPHNH@ActivationInterval@		; `string'
PUBLIC	??_C@_0BA@MJJIHAAL@RenewalInterval@		; `string'
PUBLIC	??_C@_0BI@DFILPCOB@PublicIPProtectionLevel@	; `string'
PUBLIC	??_C@_0IEE@BNCCDJLA@vlmcsd?5?$CFs?6?6Usage?3?6?5?5?5?$CFs?5?$FL?5optio@ ; `string'
PUBLIC	??_C@_0BF@DDLEHNLP@Incorrect?5time?5span?4@	; `string'
PUBLIC	??_C@_0DE@FKNLKBBJ@Fatal?3?5No?5valid?5time?5span?5speci@ ; `string'
PUBLIC	??_C@_0DB@GHHCGCFM@Argument?5must?5be?5true?1on?1yes?11?5@ ; `string'
PUBLIC	??_C@_0CC@DKAMOLDO@Must?5be?5integer?5between?5?$CFu?5and?5@ ; `string'
PUBLIC	??_C@_0BM@OKFKNBIN@?8?$DN?8?5required?5after?5keyword?4@ ; `string'
PUBLIC	??_C@_0BM@MPPMKLEJ@missing?5argument?5after?5?8?$DN?8?4@ ; `string'
PUBLIC	??_C@_0BB@MJCPHOFN@Unknown?5keyword?4@		; `string'
PUBLIC	??_C@_0BF@GAGAHLAN@Cannot?5listen?5on?5?$CFs?4@	; `string'
PUBLIC	??_C@_01KDCPPGHE@r@				; `string'
PUBLIC	??_C@_0BP@LIEMBDLF@Warning?3?5?$CFs?5line?5?$CFu?3?5?$CC?$CFs?$CC?4?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BC@DOBMPJAF@Read?5ini?5file?5?$CFs?6@	; `string'
PUBLIC	??_C@_0DO@FOGLIAKA@Warning?3?5Could?5not?5register?5Win@ ; `string'
PUBLIC	??_C@_0BC@OKDFGCCJ@vlmcsd?5?$CFs?5?$CFi?9bit?6@	; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_02GMHACPFF@?$CFu@				; `string'
PUBLIC	??_C@_0CK@KCAHIBIN@Warning?3?5Cannot?5write?5pid?5file?5@ ; `string'
PUBLIC	??_C@_0BI@LGLPDEEC@vlmcsd?5?$CFs?5was?5shutdown?6@ ; `string'
PUBLIC	??_C@_0CJ@LKGGDOJH@Warning?3?5Could?5not?5create?5semap@ ; `string'
PUBLIC	??_C@_0BM@GJMMPBLN@Warning?3?5Can?8t?5read?5?$CFs?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_02MOLJINC@?3?3@				; `string'
PUBLIC	??_C@_07OHKHACFK@0?40?40?40@			; `string'
PUBLIC	??_C@_0CI@NMNKDLLC@Fatal?3?5Could?5not?5listen?5on?5any?5@ ; `string'
PUBLIC	??_C@_0DK@DEOGKNEK@Fatal?3?5Could?5not?5initialize?5Win@ ; `string'
PUBLIC	??_C@_0N@BACOLJMI@command?5line@		; `string'
PUBLIC	??_C@_07CIFAGBMG@unknown@			; `string'
PUBLIC	??_C@_06NLFCANPD@random@			; `string'
PUBLIC	??_C@_05OFLEIIDM@fixed@				; `string'
PUBLIC	??_C@_0CF@MNAHGPHJ@Using?5CSVLK?5?$CFs?5?$CI?$CFs?$CJ?5with?5?$CFs?5ePI@ ; `string'
PUBLIC	??_C@_0CA@NLOBOCBL@vlmcsd?5?$CFs?5started?5successfully?6@ ; `string'
PUBLIC	??_C@_0N@CKBEMNGB@0?40?40?40?38000@		; `string'
PUBLIC	??_C@_09JDMNIDNN@http?3?1?1?$CFs@		; `string'
PUBLIC	??_C@_0BJ@LGLGONCN@Starting?5Mongoose?5on?5?$CFs?6@ ; `string'
PUBLIC	IniFileErrorBuffer
PUBLIC	tapArgument
EXTRN	__imp_CreateSemaphoreA:PROC
EXTRN	__imp_isspace:PROC
EXTRN	__imp_StartServiceCtrlDispatcherA:PROC
EXTRN	__imp_GetCurrentProcessId:PROC
EXTRN	pthread_create:PROC
EXTRN	__imp_DeleteFileA:PROC
EXTRN	__imp_fgets:PROC
EXTRN	__imp_CommandLineToArgvW:PROC
EXTRN	pthread_join:PROC
EXTRN	__imp_ferror:PROC
EXTRN	__imp_GetCommandLineW:PROC
EXTRN	__imp_SetConsoleCtrlHandler:PROC
	ALIGN	8

IniFileErrorBuffer DQ 01H DUP (?)
tapArgument DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BJ@LGLGONCN@Starting?5Mongoose?5on?5?$CFs?6@
CONST	SEGMENT
??_C@_0BJ@LGLGONCN@Starting?5Mongoose?5on?5?$CFs?6@ DB 'Starting Mongoose'
	DB	' on %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09JDMNIDNN@http?3?1?1?$CFs@
CONST	SEGMENT
??_C@_09JDMNIDNN@http?3?1?1?$CFs@ DB 'http://%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CKBEMNGB@0?40?40?40?38000@
CONST	SEGMENT
??_C@_0N@CKBEMNGB@0?40?40?40?38000@ DB '0.0.0.0:8000', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NLOBOCBL@vlmcsd?5?$CFs?5started?5successfully?6@
CONST	SEGMENT
??_C@_0CA@NLOBOCBL@vlmcsd?5?$CFs?5started?5successfully?6@ DB 'vlmcsd %s '
	DB	'started successfully', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MNAHGPHJ@Using?5CSVLK?5?$CFs?5?$CI?$CFs?$CJ?5with?5?$CFs?5ePI@
CONST	SEGMENT
??_C@_0CF@MNAHGPHJ@Using?5CSVLK?5?$CFs?5?$CI?$CFs?$CJ?5with?5?$CFs?5ePI@ DB 'U'
	DB	'sing CSVLK %s (%s) with %s ePID %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OFLEIIDM@fixed@
CONST	SEGMENT
??_C@_05OFLEIIDM@fixed@ DB 'fixed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NLFCANPD@random@
CONST	SEGMENT
??_C@_06NLFCANPD@random@ DB 'random', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIFAGBMG@unknown@
CONST	SEGMENT
??_C@_07CIFAGBMG@unknown@ DB 'unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BACOLJMI@command?5line@
CONST	SEGMENT
??_C@_0N@BACOLJMI@command?5line@ DB 'command line', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@DEOGKNEK@Fatal?3?5Could?5not?5initialize?5Win@
CONST	SEGMENT
??_C@_0DK@DEOGKNEK@Fatal?3?5Could?5not?5initialize?5Win@ DB 'Fatal: Could'
	DB	' not initialize Windows sockets (Error: %d).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NMNKDLLC@Fatal?3?5Could?5not?5listen?5on?5any?5@
CONST	SEGMENT
??_C@_0CI@NMNKDLLC@Fatal?3?5Could?5not?5listen?5on?5any?5@ DB 'Fatal: Cou'
	DB	'ld not listen on any socket.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OHKHACFK@0?40?40?40@
CONST	SEGMENT
??_C@_07OHKHACFK@0?40?40?40@ DB '0.0.0.0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02MOLJINC@?3?3@
CONST	SEGMENT
??_C@_02MOLJINC@?3?3@ DB '::', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GJMMPBLN@Warning?3?5Can?8t?5read?5?$CFs?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BM@GJMMPBLN@Warning?3?5Can?8t?5read?5?$CFs?3?5?$CFs?6@ DB 'Warning'
	DB	': Can''t read %s: %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@LKGGDOJH@Warning?3?5Could?5not?5create?5semap@
CONST	SEGMENT
??_C@_0CJ@LKGGDOJH@Warning?3?5Could?5not?5create?5semap@ DB 'Warning: Cou'
	DB	'ld not create semaphore: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LGLPDEEC@vlmcsd?5?$CFs?5was?5shutdown?6@
CONST	SEGMENT
??_C@_0BI@LGLPDEEC@vlmcsd?5?$CFs?5was?5shutdown?6@ DB 'vlmcsd %s was shut'
	DB	'down', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KCAHIBIN@Warning?3?5Cannot?5write?5pid?5file?5@
CONST	SEGMENT
??_C@_0CK@KCAHIBIN@Warning?3?5Cannot?5write?5pid?5file?5@ DB 'Warning: Ca'
	DB	'nnot write pid file ''%s''. %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMHACPFF@?$CFu@
CONST	SEGMENT
??_C@_02GMHACPFF@?$CFu@ DB '%u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OKDFGCCJ@vlmcsd?5?$CFs?5?$CFi?9bit?6@
CONST	SEGMENT
??_C@_0BC@OKDFGCCJ@vlmcsd?5?$CFs?5?$CFi?9bit?6@ DB 'vlmcsd %s %i-bit', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@FOGLIAKA@Warning?3?5Could?5not?5register?5Win@
CONST	SEGMENT
??_C@_0DO@FOGLIAKA@Warning?3?5Could?5not?5register?5Win@ DB 'Warning: Cou'
	DB	'ld not register Windows signal handler: Error %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DOBMPJAF@Read?5ini?5file?5?$CFs?6@
CONST	SEGMENT
??_C@_0BC@DOBMPJAF@Read?5ini?5file?5?$CFs?6@ DB 'Read ini file %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LIEMBDLF@Warning?3?5?$CFs?5line?5?$CFu?3?5?$CC?$CFs?$CC?4?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@LIEMBDLF@Warning?3?5?$CFs?5line?5?$CFu?3?5?$CC?$CFs?$CC?4?5?$CFs?6@ DB 'W'
	DB	'arning: %s line %u: "%s". %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r@
CONST	SEGMENT
??_C@_01KDCPPGHE@r@ DB 'r', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GAGAHLAN@Cannot?5listen?5on?5?$CFs?4@
CONST	SEGMENT
??_C@_0BF@GAGAHLAN@Cannot?5listen?5on?5?$CFs?4@ DB 'Cannot listen on %s.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MJCPHOFN@Unknown?5keyword?4@
CONST	SEGMENT
??_C@_0BB@MJCPHOFN@Unknown?5keyword?4@ DB 'Unknown keyword.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MPPMKLEJ@missing?5argument?5after?5?8?$DN?8?4@
CONST	SEGMENT
??_C@_0BM@MPPMKLEJ@missing?5argument?5after?5?8?$DN?8?4@ DB 'missing argu'
	DB	'ment after ''=''.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OKFKNBIN@?8?$DN?8?5required?5after?5keyword?4@
CONST	SEGMENT
??_C@_0BM@OKFKNBIN@?8?$DN?8?5required?5after?5keyword?4@ DB '''='' requir'
	DB	'ed after keyword.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DKAMOLDO@Must?5be?5integer?5between?5?$CFu?5and?5@
CONST	SEGMENT
??_C@_0CC@DKAMOLDO@Must?5be?5integer?5between?5?$CFu?5and?5@ DB 'Must be '
	DB	'integer between %u and %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GHHCGCFM@Argument?5must?5be?5true?1on?1yes?11?5@
CONST	SEGMENT
??_C@_0DB@GHHCGCFM@Argument?5must?5be?5true?1on?1yes?11?5@ DB 'Argument m'
	DB	'ust be true/on/yes/1 or false/off/no/0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FKNLKBBJ@Fatal?3?5No?5valid?5time?5span?5speci@
CONST	SEGMENT
??_C@_0DE@FKNLKBBJ@Fatal?3?5No?5valid?5time?5span?5speci@ DB 'Fatal: No v'
	DB	'alid time span specified in option -%c.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DDLEHNLP@Incorrect?5time?5span?4@
CONST	SEGMENT
??_C@_0BF@DDLEHNLP@Incorrect?5time?5span?4@ DB 'Incorrect time span.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IEE@BNCCDJLA@vlmcsd?5?$CFs?6?6Usage?3?6?5?5?5?$CFs?5?$FL?5optio@
CONST	SEGMENT
??_C@_0IEE@BNCCDJLA@vlmcsd?5?$CFs?6?6Usage?3?6?5?5?5?$CFs?5?$FL?5optio@ DB 'v'
	DB	'lmcsd %s', 0aH, 0aH, 'Usage:', 0aH, '   %s [ options ]', 0aH, 0aH
	DB	'Where:', 0aH, '  -a <csvlk>=<epid>', 09H, 'use <epid> for <cs'
	DB	'vlk>', 0aH, '  -r 0|1|2', 09H, 09H, 'set ePID randomization l'
	DB	'evel (default 1)', 0aH, '  -C <LCID>', 09H, 09H, 'use fixed <'
	DB	'LCID> in random ePIDs', 0aH, '  -H <build>', 09H, 09H, 'use f'
	DB	'ixed <build> number in random ePIDs', 0aH, '  -w <address>:<p'
	DB	'ort>', 09H, 'start web server on <address>:<port> (default to'
	DB	' 0.0.0.0:8000)', 0aH, '  -o 0|1|2|3', 09H, 09H, 'set protecti'
	DB	'on level against clients with public IP addresses (default 0)'
	DB	0aH, '  -O <v>[=<a>][/<c>]', 09H, 'use VPN adapter <v> with IP'
	DB	'v4 address <a> and CIDR <c>', 0aH, '  -x <level>', 09H, 09H, 'e'
	DB	'xit if warning <level> reached (default 0)', 0aH, '  -L <addr'
	DB	'ess>[:<port>]', 09H, 'listen on IP address <address> with opt'
	DB	'ional <port>', 0aH, '  -P <port>', 09H, 09H, 'set TCP port <p'
	DB	'ort> for subsequent -L statements (default 1688)', 0aH, '  -m'
	DB	' <clients>', 09H, 09H, 'Handle max. <clients> simultaneously '
	DB	'(default no limit)', 0aH, '  -s', 09H, 09H, 09H, 'install vlm'
	DB	'csd as an NT service. Ignores -e', 0aH, '  -S', 09H, 09H, 09H
	DB	'remove vlmcsd service. Ignores all other options', 0aH, '  -U'
	DB	' <username>', 09H, 09H, 'run NT service as <username>. Must b'
	DB	'e used with -s', 0aH, '  -W <password>', 09H, 09H, 'optional '
	DB	'<password> for -U. Must be used with -s', 0aH, '  -e', 09H, 09H
	DB	09H, 'log to stdout', 0aH, '  -D', 09H, 09H, 09H, 'does nothin'
	DB	'g. Provided for compatibility with POSIX versions only', 0aH, ' '
	DB	' -K 0|1|2|3', 09H, 09H, 'set white-listing level for KMS IDs '
	DB	'(default -K0)', 0aH, '  -c0, -c1', 09H, 09H, 'disable/enable '
	DB	'client time checking (default -c0)', 0aH, '  -M0, -M1', 09H, 09H
	DB	'disable/enable maintaining clients (default -M0)', 0aH, '  -E'
	DB	'0, -E1', 09H, 09H, 'disable/enable start with empty client li'
	DB	'st (default -E0, ignored if -M0)', 0aH, '  -t <seconds>', 09H
	DB	09H, 'disconnect clients after <seconds> of inactivity (defaul'
	DB	't 30)', 0aH, '  -d', 09H, 09H, 09H, 'disconnect clients after'
	DB	' each request', 0aH, '  -k', 09H, 09H, 09H, 'don''t disconnec'
	DB	't clients after each request (default)', 0aH, '  -N0, -N1', 09H
	DB	09H, 'disable/enable NDR64', 0aH, '  -B0, -B1', 09H, 09H, 'dis'
	DB	'able/enable bind time feature negotiation', 0aH, '  -p <file>'
	DB	09H, 09H, 'write pid to <file>', 0aH, '  -i <file>', 09H, 09H, 'u'
	DB	'se config file <file>', 0aH, '  -j <file>', 09H, 09H, 'use KM'
	DB	'S data file <file>', 0aH, '  -R <interval>', 09H, 09H, 'renew'
	DB	' activation every <interval> (default 1w)', 0aH, '  -A <inter'
	DB	'val>', 09H, 09H, 'retry activation every <interval> (default '
	DB	'2h)', 0aH, '  -l <file>', 09H, 09H, 'log to <file>', 0aH, '  '
	DB	'-T0, -T1', 09H, 09H, 'disable/enable logging with time and da'
	DB	'te (default -T1)', 0aH, '  -v', 09H, 09H, 09H, 'log verbose ('
	DB	'multiple v for more verbosity)', 0aH, '  -q', 09H, 09H, 09H, 'd'
	DB	'on''t log verbose (default)', 0aH, '  -V', 09H, 09H, 09H, 'di'
	DB	'splay version information and exit', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DFILPCOB@PublicIPProtectionLevel@
CONST	SEGMENT
??_C@_0BI@DFILPCOB@PublicIPProtectionLevel@ DB 'PublicIPProtectionLevel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MJJIHAAL@RenewalInterval@
CONST	SEGMENT
??_C@_0BA@MJJIHAAL@RenewalInterval@ DB 'RenewalInterval', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NEDPHNH@ActivationInterval@
CONST	SEGMENT
??_C@_0BD@NEDPHNH@ActivationInterval@ DB 'ActivationInterval', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JCGDMJPB@LogVerbose@
CONST	SEGMENT
??_C@_0L@JCGDMJPB@LogVerbose@ DB 'LogVerbose', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07EEDKEMBM@LogFile@
CONST	SEGMENT
??_C@_07EEDKEMBM@LogFile@ DB 'LogFile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DLGBEDLC@LogDateAndTime@
CONST	SEGMENT
??_C@_0P@DLGBEDLC@LogDateAndTime@ DB 'LogDateAndTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07ECHLBDEG@PIDFile@
CONST	SEGMENT
??_C@_07ECHLBDEG@PIDFile@ DB 'PIDFile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HOBDIJEO@UseBTFN@
CONST	SEGMENT
??_C@_07HOBDIJEO@UseBTFN@ DB 'UseBTFN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LIILCCDA@UseNDR64@
CONST	SEGMENT
??_C@_08LIILCCDA@UseNDR64@ DB 'UseNDR64', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MMGPMACK@DisconnectClientsImmediately@
CONST	SEGMENT
??_C@_0BN@MMGPMACK@DisconnectClientsImmediately@ DB 'DisconnectClientsImm'
	DB	'ediately', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JIAPHOFH@ConnectionTimeout@
CONST	SEGMENT
??_C@_0BC@JIAPHOFH@ConnectionTimeout@ DB 'ConnectionTimeout', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CJHAKJAH@MaxWorkers@
CONST	SEGMENT
??_C@_0L@CJHAKJAH@MaxWorkers@ DB 'MaxWorkers', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CBIOIDCI@Listen@
CONST	SEGMENT
??_C@_06CBIOIDCI@Listen@ DB 'Listen', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HOKNCALA@Port@
CONST	SEGMENT
??_C@_04HOKNCALA@Port@ DB 'Port', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09FNOKBMFF@HostBuild@
CONST	SEGMENT
??_C@_09FNOKBMFF@HostBuild@ DB 'HostBuild', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MGCBHGDH@LCID@
CONST	SEGMENT
??_C@_04MGCBHGDH@LCID@ DB 'LCID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BOJJAJAF@RandomizationLevel@
CONST	SEGMENT
??_C@_0BD@BOJJAJAF@RandomizationLevel@ DB 'RandomizationLevel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PFAJBMD@MaintainClients@
CONST	SEGMENT
??_C@_0BA@PFAJBMD@MaintainClients@ DB 'MaintainClients', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MPMBKNGK@StartEmpty@
CONST	SEGMENT
??_C@_0L@MPMBKNGK@StartEmpty@ DB 'StartEmpty', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PHKIMFI@CheckClientTime@
CONST	SEGMENT
??_C@_0BA@PHKIMFI@CheckClientTime@ DB 'CheckClientTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IJCDKLCC@WhiteListingLevel@
CONST	SEGMENT
??_C@_0BC@IJCDKLCC@WhiteListingLevel@ DB 'WhiteListingLevel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IIAKFIOC@KmsData@
CONST	SEGMENT
??_C@_07IIAKFIOC@KmsData@ DB 'KmsData', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DCJLDMKG@VPN@
CONST	SEGMENT
??_C@_03DCJLDMKG@VPN@ DB 'VPN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09BIFGJFAC@ExitLevel@
CONST	SEGMENT
??_C@_09BIFGJFAC@ExitLevel@ DB 'ExitLevel', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@OGPMLMGM@a?3N?3B?3m?3t?3A?3R?3u?3g?3L?3p?3i?3H?3P?3X?3Y@
CONST	SEGMENT
??_C@_0EJ@OGPMLMGM@a?3N?3B?3m?3t?3A?3R?3u?3g?3L?3p?3i?3H?3P?3X?3Y@ DB 'a:'
	DB	'N:B:m:t:A:R:u:g:L:p:i:H:P:X:Y:l:r:U:W:C:c:F:O:o:x:T:K:E:M:j:S'
	DB	'seDdVvqkZ', 00H				; `string'
optstring DQ	FLAT:??_C@_0EJ@OGPMLMGM@a?3N?3B?3m?3t?3A?3R?3u?3g?3L?3p?3i?3H?3P?3X?3Y@
CONST	ENDS
PUBLIC	WinStartUp
PUBLIC	main
PUBLIC	setupListeningSockets
PUBLIC	newmain
PUBLIC	cleanup
	ALIGN	8

fn_pid	DQ	01H DUP (?)
ServiceUser DQ	01H DUP (?)
maxsockets DB	01H DUP (?)
	ALIGN	8

fn_ini	DQ	01H DUP (?)
installService DB 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$WinStartUp DD imagerel $LN11
	DD	imagerel $LN11+210
	DD	imagerel $unwind$WinStartUp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN5
	DD	imagerel $LN5+78
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setupListeningSockets DD imagerel $LN40
	DD	imagerel $LN40+463
	DD	imagerel $unwind$setupListeningSockets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$allocateSemaphore DD imagerel allocateSemaphore
	DD	imagerel allocateSemaphore+96
	DD	imagerel $unwind$allocateSemaphore
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$writePidFile DD imagerel writePidFile
	DD	imagerel writePidFile+129
	DD	imagerel $unwind$writePidFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$parseGeneralArguments DD imagerel parseGeneralArguments
	DD	imagerel parseGeneralArguments+1246
	DD	imagerel $unwind$parseGeneralArguments
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$daemonizeAndSetSignalAction DD imagerel daemonizeAndSetSignalAction
	DD	imagerel daemonizeAndSetSignalAction+53
	DD	imagerel $unwind$daemonizeAndSetSignalAction
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$terminationHandler DD imagerel terminationHandler
	DD	imagerel terminationHandler+49
	DD	imagerel $unwind$terminationHandler
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$readIniFile DD imagerel readIniFile
	DD	imagerel readIniFile+449
	DD	imagerel $unwind$readIniFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setupListeningSocketsFromIniFile DD imagerel setupListeningSocketsFromIniFile
	DD	imagerel setupListeningSocketsFromIniFile+125
	DD	imagerel $unwind$setupListeningSocketsFromIniFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$handleIniFileParameter DD imagerel handleIniFileParameter
	DD	imagerel handleIniFileParameter+157
	DD	imagerel $unwind$handleIniFileParameter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$handleIniFileEpidParameter DD imagerel handleIniFileEpidParameter
	DD	imagerel handleIniFileEpidParameter+222
	DD	imagerel $unwind$handleIniFileEpidParameter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetCsvlkIndexFromName DD imagerel GetCsvlkIndexFromName
	DD	imagerel GetCsvlkIndexFromName+125
	DD	imagerel $unwind$GetCsvlkIndexFromName
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getIniFileArgument DD imagerel getIniFileArgument
	DD	imagerel getIniFileArgument+125
	DD	imagerel $unwind$getIniFileArgument
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setIniFileParameter DD imagerel setIniFileParameter
	DD	imagerel setIniFileParameter+829
	DD	imagerel $unwind$setIniFileParameter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getIniFileArgumentInt8 DD imagerel getIniFileArgumentInt8
	DD	imagerel getIniFileArgumentInt8+107
	DD	imagerel $unwind$getIniFileArgumentInt8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getIniFileArgumentInt DD imagerel getIniFileArgumentInt
	DD	imagerel getIniFileArgumentInt+125
	DD	imagerel $unwind$getIniFileArgumentInt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setEpidFromIniFileLine DD imagerel setEpidFromIniFileLine
	DD	imagerel setEpidFromIniFileLine+224
	DD	imagerel $unwind$setEpidFromIniFileLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setHwIdFromIniFileLine DD imagerel setHwIdFromIniFileLine
	DD	imagerel setHwIdFromIniFileLine+138
	DD	imagerel $unwind$setHwIdFromIniFileLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$iniFileLineNextWord DD imagerel iniFileLineNextWord
	DD	imagerel iniFileLineNextWord+45
	DD	imagerel $unwind$iniFileLineNextWord
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getTimeSpanFromCommandLine DD imagerel getTimeSpanFromCommandLine
	DD	imagerel getTimeSpanFromCommandLine+71
	DD	imagerel $unwind$getTimeSpanFromCommandLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getTimeSpanFromIniFile DD imagerel getTimeSpanFromIniFile
	DD	imagerel getTimeSpanFromIniFile+64
	DD	imagerel $unwind$getTimeSpanFromIniFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$usage DD	imagerel usage
	DD	imagerel usage+45
	DD	imagerel $unwind$usage
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newmain DD imagerel $LN80
	DD	imagerel $LN80+1107
	DD	imagerel $unwind$newmain
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cleanup DD imagerel $LN7
	DD	imagerel $LN7+60
	DD	imagerel $unwind$cleanup
;	COMDAT xdata
xdata	SEGMENT
$unwind$cleanup DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newmain DD 091701H
	DD	0536417H
	DD	0525417H
	DD	0513417H
	DD	04e0117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$usage DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getTimeSpanFromIniFile DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getTimeSpanFromCommandLine DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iniFileLineNextWord DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setHwIdFromIniFileLine DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setEpidFromIniFileLine DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getIniFileArgumentInt DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getIniFileArgumentInt8 DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setIniFileParameter DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getIniFileArgument DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetCsvlkIndexFromName DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$handleIniFileEpidParameter DD 0a1c01H
	DD	0b641cH
	DD	0a541cH
	DD	09341cH
	DD	0f018321cH
	DD	07014e016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$handleIniFileParameter DD 081901H
	DD	097419H
	DD	086419H
	DD	073419H
	DD	0f0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setupListeningSocketsFromIniFile DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$readIniFile DD 091701H
	DD	02b6417H
	DD	02a5417H
	DD	0283417H
	DD	0260117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$terminationHandler DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$daemonizeAndSetSignalAction DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parseGeneralArguments DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$writePidFile DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$allocateSemaphore DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setupListeningSockets DD 081301H
	DD	0b5413H
	DD	0a3413H
	DD	0e00f3213H
	DD	0600c700dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WinStartUp DD 081201H
	DD	0e5412H
	DD	0d3412H
	DD	0e00e7212H
	DD	0600b700cH
ServicePassword DQ FLAT:??_C@_00CNPNBAHC@@
IniFileParameterList DQ FLAT:??_C@_09BIFGJFAC@ExitLevel@
	DB	01eH
	ORG $+7
	DQ	FLAT:??_C@_03DCJLDMKG@VPN@
	DB	01dH
	ORG $+7
	DQ	FLAT:??_C@_07IIAKFIOC@KmsData@
	DB	01cH
	ORG $+7
	DQ	FLAT:??_C@_0BC@IJCDKLCC@WhiteListingLevel@
	DB	018H
	ORG $+7
	DQ	FLAT:??_C@_0BA@PHKIMFI@CheckClientTime@
	DB	019H
	ORG $+7
	DQ	FLAT:??_C@_0L@MPMBKNGK@StartEmpty@
	DB	01bH
	ORG $+7
	DQ	FLAT:??_C@_0BA@PFAJBMD@MaintainClients@
	DB	01aH
	ORG $+7
	DQ	FLAT:??_C@_0BD@BOJJAJAF@RandomizationLevel@
	DB	01H
	ORG $+7
	DQ	FLAT:??_C@_04MGCBHGDH@LCID@
	DB	02H
	ORG $+7
	DQ	FLAT:??_C@_09FNOKBMFF@HostBuild@
	DB	014H
	ORG $+7
	DQ	FLAT:??_C@_04HOKNCALA@Port@
	DB	0eH
	ORG $+7
	DQ	FLAT:??_C@_06CBIOIDCI@Listen@
	DB	03H
	ORG $+7
	DQ	FLAT:??_C@_0L@CJHAKJAH@MaxWorkers@
	DB	04H
	ORG $+7
	DQ	FLAT:??_C@_0BC@JIAPHOFH@ConnectionTimeout@
	DB	05H
	ORG $+7
	DQ	FLAT:??_C@_0BN@MMGPMACK@DisconnectClientsImmediately@
	DB	0bH
	ORG $+7
	DQ	FLAT:??_C@_08LIILCCDA@UseNDR64@
	DB	0fH
	ORG $+7
	DQ	FLAT:??_C@_07HOBDIJEO@UseBTFN@
	DB	010H
	ORG $+7
	DQ	FLAT:??_C@_07ECHLBDEG@PIDFile@
	DB	06H
	ORG $+7
	DQ	FLAT:??_C@_0P@DLGBEDLC@LogDateAndTime@
	DB	013H
	ORG $+7
	DQ	FLAT:??_C@_07EEDKEMBM@LogFile@
	DB	07H
	ORG $+7
	DQ	FLAT:??_C@_0L@JCGDMJPB@LogVerbose@
	DB	08H
	ORG $+7
	DQ	FLAT:??_C@_0BD@NEDPHNH@ActivationInterval@
	DB	09H
	ORG $+7
	DQ	FLAT:??_C@_0BA@MJJIHAAL@RenewalInterval@
	DB	0aH
	ORG $+7
	DQ	FLAT:??_C@_0BI@DFILPCOB@PublicIPProtectionLevel@
	DB	012H
	ORG $+7
IniFileErrorMessage DQ FLAT:??_C@_00CNPNBAHC@@
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT cleanup
_TEXT	SEGMENT
cleanup	PROC						; COMDAT

; 1538 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1539 : 	if (!InetdMode)

  00004	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  0000b	75 2a		 jne	 SHORT $LN2@cleanup

; 1540 : 	{
; 1541 : #ifndef NO_CLIENT_LIST
; 1542 : 		if (MaintainClients)
; 1543 : 			CleanUpClientLists();
; 1544 : #endif // !NO_CLIENT_LIST
; 1545 : 
; 1546 : #ifndef NO_PID_FILE
; 1547 : 		if (fn_pid)

  0000d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fn_pid
  00014	48 85 c9	 test	 rcx, rcx
  00017	74 06		 je	 SHORT $LN4@cleanup

; 1548 : 			vlmcsd_unlink(fn_pid);

  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteFileA
$LN4@cleanup:

; 1549 : #endif // NO_PID_FILE
; 1550 : 		closeAllListeningSockets();

  0001f	e8 00 00 00 00	 call	 closeAllListeningSockets

; 1551 : 
; 1552 : #if !defined(NO_LIMIT) && !defined(NO_SOCKETS) && !defined(_WIN32) && !__minix__
; 1553 : 		sem_unlink("/vlmcsd");
; 1554 : #if !defined(USE_THREADS) && !defined(CYGWIN)
; 1555 : 		if (shmid >= 0)
; 1556 : 		{
; 1557 : 			if (MaxTaskSemaphore != (sem_t *)-1)
; 1558 : 				shmdt(MaxTaskSemaphore);
; 1559 : 			shmctl(shmid, IPC_RMID, NULL);
; 1560 : 		}
; 1561 : #endif // !defined(USE_THREADS) && !defined(CYGWIN)
; 1562 : #endif // !defined(NO_LIMIT) && !defined(NO_SOCKETS) && !defined(_WIN32) && !__minix__
; 1563 : 
; 1564 : #ifndef NO_LOG
; 1565 : 		logger("vlmcsd %s was shutdown\n", Version);

  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@LMFFFEAG@?B?$KJ?5Microsoft?5may?52023@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@LGLPDEEC@vlmcsd?5?$CFs?5was?5shutdown?6@
  00032	e8 00 00 00 00	 call	 logger
$LN2@cleanup:

; 1566 : #endif // NO_LOG
; 1567 : 	}
; 1568 : }

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
cleanup	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT newmain
_TEXT	SEGMENT
thread$ = 48
$T1 = 64
mgr$ = 80
wsadata$ = 208
newmain	PROC						; COMDAT

; 1777 : {

$LN80:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 70 02
	00 00		 sub	 rsp, 624		; 00000270H

; 1778 : 	// Initialize thread synchronization objects for Windows and Cygwin
; 1779 : #ifdef USE_THREADS
; 1780 : 
; 1781 : #ifndef NO_LOG
; 1782 : // Initialize the Critical Section for proper logging
; 1783 : #if _WIN32 || __CYGWIN__
; 1784 : 	InitializeCriticalSection(&logmutex);

  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logmutex
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection

; 1785 : #endif // _WIN32 || __CYGWIN__
; 1786 : #endif // NO_LOG
; 1787 : 
; 1788 : #endif // USE_THREADS
; 1789 : 
; 1790 : #ifdef _WIN32
; 1791 : 
; 1792 : #ifndef USE_MSRPC
; 1793 : 	WSADATA wsadata;
; 1794 : 	{
; 1795 : 		// Windows Sockets must be initialized
; 1796 : 		int error;
; 1797 : 		if ((error = WSAStartup(0x0202, &wsadata)))

  00024	b9 02 02 00 00	 mov	 ecx, 514		; 00000202H
  00029	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR wsadata$[rsp]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAStartup
  00037	33 ed		 xor	 ebp, ebp
  00039	8b d8		 mov	 ebx, eax
  0003b	85 c0		 test	 eax, eax
  0003d	74 13		 je	 SHORT $LN10@newmain

; 1798 : 		{
; 1799 : 			printerrorf("Fatal: Could not initialize Windows sockets (Error: %d).\n", error);

  0003f	8b d0		 mov	 edx, eax
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DK@DEOGKNEK@Fatal?3?5Could?5not?5initialize?5Win@
  00048	e8 00 00 00 00	 call	 printerrorf

; 1800 : 			return error;

  0004d	e9 da 03 00 00	 jmp	 $LN31@newmain
$LN10@newmain:

; 1801 : 		}
; 1802 : 	}
; 1803 : #endif // USE_MSRPC
; 1804 : 
; 1805 : 	// Windows can never daemonize
; 1806 : 	// nodaemon = 1;
; 1807 : 
; 1808 : #else // __CYGWIN__
; 1809 : 
; 1810 : 	// Do not daemonize if we are a Windows service
; 1811 : #ifdef _NTSERVICE
; 1812 : 	if (IsNTService)
; 1813 : 		nodaemon = 1;
; 1814 : #endif
; 1815 : 
; 1816 : #endif // _WIN32 / __CYGWIN__
; 1817 : 
; 1818 : 	parseGeneralArguments(); // Does not return if an error occurs

  00052	e8 00 00 00 00	 call	 parseGeneralArguments

; 1819 : 
; 1820 : #if !defined(_WIN32) && !defined(NO_SOCKETS) && !defined(USE_MSRPC)
; 1821 : 
; 1822 : 	struct stat statbuf;
; 1823 : 	fstat(STDIN_FILENO, &statbuf);
; 1824 : 
; 1825 : 	if (S_ISSOCK(statbuf.st_mode))
; 1826 : 	{
; 1827 : 		InetdMode = 1;
; 1828 : #ifndef NO_CLIENT_LIST
; 1829 : 		MaintainClients = FALSE;
; 1830 : #endif // !NO_CLIENT_LIST
; 1831 : 		nodaemon = 1;
; 1832 : #ifndef SIMPLE_SOCKETS
; 1833 : 		maxsockets = 0;
; 1834 : #endif // !SIMPLE_SOCKETS
; 1835 : #ifndef NO_LOG
; 1836 : 		logstdout = 0;
; 1837 : #endif // !NO_LOG
; 1838 : 	}
; 1839 : 
; 1840 : #endif // !defined(_WIN32) && !defined(NO_SOCKETS) && !defined(USE_MSRPC)
; 1841 : 
; 1842 : #ifndef NO_INI_FILE
; 1843 : 
; 1844 : 	if (fn_ini && !readIniFile(INI_FILE_PASS_1))

  00057	48 39 2d 00 00
	00 00		 cmp	 QWORD PTR fn_ini, rbp
  0005e	74 2f		 je	 SHORT $LN11@newmain
  00060	b1 01		 mov	 cl, 1
  00062	e8 00 00 00 00	 call	 readIniFile
  00067	85 c0		 test	 eax, eax
  00069	75 24		 jne	 SHORT $LN11@newmain

; 1845 : 	{
; 1846 : #ifdef INI_FILE
; 1847 : 		if (strcmp(fn_ini, INI_FILE))
; 1848 : #endif // INI_FILE
; 1849 : 			printerrorf("Warning: Can't read %s: %s\n", fn_ini, strerror(errno));

  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00071	8b 08		 mov	 ecx, DWORD PTR [rax]
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00079	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR fn_ini
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@GJMMPBLN@Warning?3?5Can?8t?5read?5?$CFs?3?5?$CFs?6@
  00087	4c 8b c0	 mov	 r8, rax
  0008a	e8 00 00 00 00	 call	 printerrorf
$LN11@newmain:

; 1850 : 	}
; 1851 : 
; 1852 : #endif // NO_INI_FILE
; 1853 : 
; 1854 : 	loadKmsData();

  0008f	e8 00 00 00 00	 call	 loadKmsData

; 1855 : 
; 1856 : #if !defined(USE_MSRPC) && !defined(SIMPLE_RPC)
; 1857 : 
; 1858 : 	if (
; 1859 : 		!IsNDR64Defined)

  00094	40 38 2d 00 00
	00 00		 cmp	 BYTE PTR IsNDR64Defined, bpl
  0009b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsData
  000a2	75 2f		 jne	 SHORT $LN13@newmain

; 1860 : 	{
; 1861 : 		UseServerRpcNDR64 = !!(KmsData->Flags & KMS_OPTIONS_USENDR64);

  000a4	8a 41 09	 mov	 al, BYTE PTR [rcx+9]
  000a7	24 01		 and	 al, 1
  000a9	88 05 00 00 00
	00		 mov	 BYTE PTR UseServerRpcNDR64, al

; 1862 : #ifndef NO_RANDOM_EPID
; 1863 : 		if (HostBuild && RandomizationLevel)

  000af	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR HostBuild
  000b6	66 85 c0	 test	 ax, ax
  000b9	74 18		 je	 SHORT $LN13@newmain
  000bb	40 38 2d 00 00
	00 00		 cmp	 BYTE PTR RandomizationLevel, bpl
  000c2	74 0f		 je	 SHORT $LN13@newmain

; 1864 : 		{
; 1865 : 			UseServerRpcNDR64 = HostBuild > 7601;

  000c4	ba b1 1d 00 00	 mov	 edx, 7601		; 00001db1H
  000c9	66 3b c2	 cmp	 ax, dx
  000cc	0f 97 05 00 00
	00 00		 seta	 BYTE PTR UseServerRpcNDR64
$LN13@newmain:

; 1866 : 		}
; 1867 : #endif
; 1868 : 	}
; 1869 : #endif // !defined(USE_MSRPC) && !defined(SIMPLE_RPC)
; 1870 : 
; 1871 : #if !defined(NO_RANDOM_EPID) || !defined(NO_CL_PIDS) || !defined(NO_INI_FILE)
; 1872 : 	KmsResponseParameters = (KmsResponseParam_t *)vlmcsd_malloc(sizeof(KmsResponseParam_t) * KmsData->CsvlkCount);

  000d3	0f b6 49 08	 movzx	 ecx, BYTE PTR [rcx+8]
  000d7	48 c1 e1 05	 shl	 rcx, 5
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000e1	48 8b c8	 mov	 rcx, rax

; 366  : 	if (!buf) OutOfMemory();

  000e4	48 85 c0	 test	 rax, rax
  000e7	0f 84 5a 03 00
	00		 je	 $LN78@newmain
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c

; 1873 : 	memset(KmsResponseParameters, 0, sizeof(KmsResponseParam_t) * KmsData->CsvlkCount);

  000ed	48 89 05 00 00
	00 00		 mov	 QWORD PTR KmsResponseParameters, rax
  000f4	33 d2		 xor	 edx, edx
  000f6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR KmsData
  000fd	44 0f b6 40 08	 movzx	 r8d, BYTE PTR [rax+8]
  00102	49 c1 e0 05	 shl	 r8, 5
  00106	e8 00 00 00 00	 call	 memset

; 1874 : #endif // !defined(NO_RANDOM_EPID) || !defined(NO_CL_PIDS) || !defined(NO_INI_FILE)
; 1875 : 
; 1876 : #ifndef NO_CL_PIDS
; 1877 : 	optReset();

  0010b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR optind, 1
$LN15@newmain:

; 1878 : 	int o;
; 1879 : 
; 1880 : 	for (opterr = 0; (o = getopt(global_argc, (char *const *)global_argv, (const char *)optstring)) > 0;)
; 1881 : 		switch (o)

  00115	e8 00 00 00 00	 call	 getopt
  0011a	85 c0		 test	 eax, eax
  0011c	7e 24		 jle	 SHORT $LN65@newmain
  0011e	83 f8 61	 cmp	 eax, 97			; 00000061H
  00121	75 f2		 jne	 SHORT $LN15@newmain

; 1882 : 		{
; 1883 : 		case 'a':
; 1884 : 			if (!handleIniFileEpidParameter(optarg, FALSE, "command line"))

  00123	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR optarg
  0012a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@BACOLJMI@command?5line@
  00131	33 d2		 xor	 edx, edx
  00133	e8 00 00 00 00	 call	 handleIniFileEpidParameter
  00138	85 c0		 test	 eax, eax
  0013a	0f 84 0d 03 00
	00		 je	 $LN79@newmain
  00140	eb d3		 jmp	 SHORT $LN15@newmain
$LN65@newmain:

; 1887 : 			}
; 1888 : 
; 1889 : 			break;
; 1890 : 
; 1891 : 		default:
; 1892 : 			break;
; 1893 : 		}
; 1894 : 
; 1895 : #endif // NO_CL_PIDS
; 1896 : 
; 1897 : #ifndef NO_INI_FILE
; 1898 : 
; 1899 : 	if (fn_ini && !readIniFile(INI_FILE_PASS_2))

  00142	48 39 2d 00 00
	00 00		 cmp	 QWORD PTR fn_ini, rbp
  00149	74 2f		 je	 SHORT $LN17@newmain
  0014b	b1 02		 mov	 cl, 2
  0014d	e8 00 00 00 00	 call	 readIniFile
  00152	85 c0		 test	 eax, eax
  00154	75 24		 jne	 SHORT $LN17@newmain

; 1900 : 	{
; 1901 : #ifdef INI_FILE
; 1902 : 		if (strcmp(fn_ini, INI_FILE))
; 1903 : #endif // INI_FILE
; 1904 : 			printerrorf("Warning: Can't read %s: %s\n", fn_ini, strerror(errno));

  00156	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0015c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00164	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR fn_ini
  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@GJMMPBLN@Warning?3?5Can?8t?5read?5?$CFs?3?5?$CFs?6@
  00172	4c 8b c0	 mov	 r8, rax
  00175	e8 00 00 00 00	 call	 printerrorf
$LN17@newmain:

; 1905 : 	}
; 1906 : 
; 1907 : #endif // NO_INI_FILE
; 1908 : 
; 1909 : #ifndef NO_CLIENT_LIST
; 1910 : 	if (MaintainClients)

  0017a	40 38 2d 00 00
	00 00		 cmp	 BYTE PTR MaintainClients, bpl
  00181	74 05		 je	 SHORT $LN18@newmain

; 1911 : 		InitializeClientLists();

  00183	e8 00 00 00 00	 call	 InitializeClientLists
$LN18@newmain:

; 1912 : #endif // !NO_CLIENT_LIST
; 1913 : 
; 1914 : #if defined(USE_MSRPC) && !defined(NO_PRIVATE_IP_DETECT)
; 1915 : 	if (PublicIPProtectionLevel)
; 1916 : 	{
; 1917 : 		printerrorf("Warning: Public IP address protection using MS RPC is poor. See vlmcsd.8\n");
; 1918 : 	}
; 1919 : #endif // defined(USE_MSRPC) && !defined(NO_PRIVATE_IP_DETECT)
; 1920 : 
; 1921 : #if !defined(NO_LIMIT) && !defined(NO_SOCKETS) && !__minix__ && !defined(USE_MSRPC)
; 1922 : 	allocateSemaphore();

  00188	e8 00 00 00 00	 call	 allocateSemaphore

; 1923 : #endif // !defined(NO_LIMIT) && !defined(NO_SOCKETS) && __minix__
; 1924 : 
; 1925 : #ifdef _NTSERVICE
; 1926 : 	if (installService)

  0018d	40 38 2d 00 00
	00 00		 cmp	 BYTE PTR installService, bpl
  00194	74 0a		 je	 SHORT $LN19@newmain

; 1927 : 		return NtServiceInstallation(installService, ServiceUser, ServicePassword);

  00196	e8 00 00 00 00	 call	 NtServiceInstallation
  0019b	e9 8e 02 00 00	 jmp	 $LN1@newmain
$LN19@newmain:

; 1928 : #endif // _NTSERVICE
; 1929 : 
; 1930 : #ifndef NO_TAP
; 1931 : 	if (tapArgument && !InetdMode)

  001a0	48 39 2d 00 00
	00 00		 cmp	 QWORD PTR tapArgument, rbp
  001a7	74 0e		 je	 SHORT $LN20@newmain
  001a9	40 38 2d 00 00
	00 00		 cmp	 BYTE PTR InetdMode, bpl
  001b0	75 1b		 jne	 SHORT $LN22@newmain

; 1932 : 		startTap(tapArgument);

  001b2	e8 00 00 00 00	 call	 startTap
$LN20@newmain:

; 1933 : #endif // NO_TAP
; 1934 : 
; 1935 : #if !defined(NO_SOCKETS) && !defined(USE_MSRPC)
; 1936 : 	if (!InetdMode)

  001b7	40 38 2d 00 00
	00 00		 cmp	 BYTE PTR InetdMode, bpl
  001be	75 0d		 jne	 SHORT $LN22@newmain

; 1937 : 	{
; 1938 : 		int error;
; 1939 : #ifdef SIMPLE_SOCKETS
; 1940 : 		if ((error = listenOnAllAddresses()))
; 1941 : 			return error;
; 1942 : #else  // !SIMPLE_SOCKETS
; 1943 : 		if ((error = setupListeningSockets()))

  001c0	e8 00 00 00 00	 call	 setupListeningSockets
  001c5	85 c0		 test	 eax, eax
  001c7	0f 85 61 02 00
	00		 jne	 $LN1@newmain
$LN22@newmain:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 346  : 	srand(GetTickCount());

  001cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  001d3	8b c8		 mov	 ecx, eax
  001d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_srand
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c

; 1987 : 	if (RandomizationLevel == 1)

  001db	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR RandomizationLevel
  001e1	80 fa 01	 cmp	 dl, 1
  001e4	75 0b		 jne	 SHORT $LN23@newmain

; 1988 : 		randomPidInit();

  001e6	e8 00 00 00 00	 call	 randomPidInit
  001eb	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR RandomizationLevel
$LN23@newmain:

; 1989 : #if !defined(NO_LOG) && !defined(NO_VERBOSE_LOG)
; 1990 : 	if (logverbose)

  001f1	48 83 cb ff	 or	 rbx, -1
  001f5	40 38 2d 00 00
	00 00		 cmp	 BYTE PTR logverbose, bpl
  001fc	0f 84 cc 00 00
	00		 je	 $LN74@newmain

; 1991 : 	{
; 1992 : 		int32_t i;
; 1993 : 
; 1994 : 		for (i = 0; i < KmsData->CsvlkCount; i++)

  00202	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsData
  00209	8b f5		 mov	 esi, ebp
  0020b	40 38 69 08	 cmp	 BYTE PTR [rcx+8], bpl
  0020f	0f 86 b9 00 00
	00		 jbe	 $LN74@newmain
  00215	48 8b fd	 mov	 rdi, rbp
$LL9@newmain:

; 1995 : 		{
; 1996 : 			const CsvlkData_t *const csvlk = KmsData->CsvlkData + i;
; 1997 : 			const char *csvlkIniName = getNextString(csvlk->EPid);

  00218	48 8b 4c 0f 48	 mov	 rcx, QWORD PTR [rdi+rcx+72]
; File C:\Users\dev\source\repos\alpinevms\src\kms.c

; 73   : 	return s + strlen(s) + 1;

  0021d	48 8b c3	 mov	 rax, rbx
$LL68@newmain:
  00220	48 ff c0	 inc	 rax
  00223	40 38 2c 01	 cmp	 BYTE PTR [rcx+rax], bpl
  00227	75 f7		 jne	 SHORT $LL68@newmain
  00229	4c 8d 50 01	 lea	 r10, QWORD PTR [rax+1]
  0022d	48 8b c3	 mov	 rax, rbx
  00230	4c 03 d1	 add	 r10, rcx
$LL67@newmain:
  00233	48 ff c0	 inc	 rax
  00236	41 38 2c 02	 cmp	 BYTE PTR [r10+rax], bpl
  0023a	75 f7		 jne	 SHORT $LL67@newmain
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c

; 1999 : 			csvlkFullName = *csvlkFullName ? csvlkFullName : "unknown";

  0023c	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR KmsResponseParameters
  00243	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:??_C@_07CIFAGBMG@unknown@
; File C:\Users\dev\source\repos\alpinevms\src\kms.c

; 73   : 	return s + strlen(s) + 1;

  0024a	48 ff c0	 inc	 rax
  0024d	49 03 c2	 add	 rax, r10
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c

; 1999 : 			csvlkFullName = *csvlkFullName ? csvlkFullName : "unknown";

  00250	40 38 28	 cmp	 BYTE PTR [rax], bpl
  00253	4c 0f 45 d8	 cmovne	 r11, rax

; 2000 : 			const char *ePid = KmsResponseParameters[i].Epid ? KmsResponseParameters[i].Epid : RandomizationLevel == 2 ? ""

  00257	4a 8b 04 07	 mov	 rax, QWORD PTR [rdi+r8]
  0025b	48 85 c0	 test	 rax, rax
  0025e	74 22		 je	 SHORT $LN35@newmain
  00260	48 8b c8	 mov	 rcx, rax
$LN34@newmain:

; 2001 : 																													   : csvlk->EPid;
; 2002 : 			logger("Using CSVLK %s (%s) with %s ePID %s\n", csvlkIniName, csvlkFullName, (RandomizationLevel == 1 && KmsResponseParameters[i].IsRandom) || (RandomizationLevel == 2 && !KmsResponseParameters[i].Epid) ? "random" : "fixed", ePid);

  00263	80 fa 01	 cmp	 dl, 1
  00266	75 07		 jne	 SHORT $LN37@newmain
  00268	42 38 6c 07 18	 cmp	 BYTE PTR [rdi+r8+24], bpl
  0026d	75 0a		 jne	 SHORT $LN39@newmain
$LN37@newmain:
  0026f	80 fa 02	 cmp	 dl, 2
  00272	75 1c		 jne	 SHORT $LN60@newmain
  00274	48 85 c0	 test	 rax, rax
  00277	75 17		 jne	 SHORT $LN60@newmain
$LN39@newmain:
  00279	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_06NLFCANPD@random@
  00280	eb 15		 jmp	 SHORT $LN40@newmain
$LN35@newmain:

; 2000 : 			const char *ePid = KmsResponseParameters[i].Epid ? KmsResponseParameters[i].Epid : RandomizationLevel == 2 ? ""

  00282	80 fa 02	 cmp	 dl, 2
  00285	75 dc		 jne	 SHORT $LN34@newmain
  00287	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@@
  0028e	eb e9		 jmp	 SHORT $LN39@newmain
$LN60@newmain:

; 2001 : 																													   : csvlk->EPid;
; 2002 : 			logger("Using CSVLK %s (%s) with %s ePID %s\n", csvlkIniName, csvlkFullName, (RandomizationLevel == 1 && KmsResponseParameters[i].IsRandom) || (RandomizationLevel == 2 && !KmsResponseParameters[i].Epid) ? "random" : "fixed", ePid);

  00290	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_05OFLEIIDM@fixed@
$LN40@newmain:
  00297	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0029c	4d 8b c3	 mov	 r8, r11
  0029f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@MNAHGPHJ@Using?5CSVLK?5?$CFs?5?$CI?$CFs?$CJ?5with?5?$CFs?5ePI@
  002a6	49 8b d2	 mov	 rdx, r10
  002a9	e8 00 00 00 00	 call	 logger
  002ae	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsData
  002b5	ff c6		 inc	 esi
  002b7	48 83 c7 20	 add	 rdi, 32			; 00000020H
  002bb	0f b6 41 08	 movzx	 eax, BYTE PTR [rcx+8]
  002bf	3b f0		 cmp	 esi, eax
  002c1	7d 0b		 jge	 SHORT $LN74@newmain

; 1991 : 	{
; 1992 : 		int32_t i;
; 1993 : 
; 1994 : 		for (i = 0; i < KmsData->CsvlkCount; i++)

  002c3	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR RandomizationLevel
  002c9	e9 4a ff ff ff	 jmp	 $LL9@newmain
$LN74@newmain:

; 2003 : 		}
; 2004 : 	}
; 2005 : #endif // !defined(NO_LOG) && !defined(NO_VERBOSE_LOG)
; 2006 : #endif
; 2007 : 
; 2008 : #if !defined(NO_SOCKETS)
; 2009 : #ifdef _WIN32
; 2010 : 	if (!IsNTService)

  002ce	40 38 2d 00 00
	00 00		 cmp	 BYTE PTR IsNTService, bpl
  002d5	75 0d		 jne	 SHORT $LN26@newmain

; 2011 : 	{
; 2012 : #endif // _WIN32
; 2013 : 		int error;
; 2014 : 		if ((error = daemonizeAndSetSignalAction()))

  002d7	e8 00 00 00 00	 call	 daemonizeAndSetSignalAction
  002dc	85 c0		 test	 eax, eax
  002de	0f 85 4a 01 00
	00		 jne	 $LN1@newmain
$LN26@newmain:

; 2015 : 			return error;
; 2016 : #ifdef _WIN32
; 2017 : 	}
; 2018 : #endif // _WIN32
; 2019 : #endif // !defined(NO_SOCKETS)
; 2020 : 
; 2021 : 	writePidFile();

  002e4	e8 00 00 00 00	 call	 writePidFile

; 2022 : 
; 2023 : #if !defined(NO_LOG) && !defined(NO_SOCKETS) && !defined(USE_MSRPC)
; 2024 : 	if (!InetdMode)

  002e9	40 38 2d 00 00
	00 00		 cmp	 BYTE PTR InetdMode, bpl
  002f0	75 13		 jne	 SHORT $LN27@newmain

; 2025 : 		logger("vlmcsd %s started successfully\n", Version);

  002f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@LMFFFEAG@?B?$KJ?5Microsoft?5may?52023@
  002f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@NLOBOCBL@vlmcsd?5?$CFs?5started?5successfully?6@
  00300	e8 00 00 00 00	 call	 logger
$LN27@newmain:

; 2026 : #endif // !defined(NO_LOG) && !defined(NO_SOCKETS) && !defined(USE_MSRPC)
; 2027 : 
; 2028 : #if defined(_NTSERVICE) && !defined(USE_MSRPC)
; 2029 : 	if (IsNTService)

  00305	40 38 2d 00 00
	00 00		 cmp	 BYTE PTR IsNTService, bpl
  0030c	74 10		 je	 SHORT $LN28@newmain

; 2030 : 		ReportServiceStatus(SERVICE_RUNNING, NO_ERROR, 200);

  0030e	33 d2		 xor	 edx, edx
  00310	41 b8 c8 00 00
	00		 mov	 r8d, 200		; 000000c8H
  00316	8d 4a 04	 lea	 ecx, QWORD PTR [rdx+4]
  00319	e8 00 00 00 00	 call	 ReportServiceStatus
$LN28@newmain:

; 2031 : #endif // defined(_NTSERVICE) && !defined(USE_MSRPC)
; 2032 : 
; 2033 : #ifndef NO_MONGOOSE
; 2034 : 	struct mg_mgr mgr;
; 2035 : 	mg_mgr_init(&mgr);											   // Init manager

  0031e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR mgr$[rsp]
  00323	e8 00 00 00 00	 call	 mg_mgr_init

; 2036 : 	mg_log_set(logverbose);

  00328	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR logverbose

; 2037 : 	if (listen_params == NULL) listen_params = "0.0.0.0:8000";

  0032f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@CKBEMNGB@0?40?40?40?38000@
  00336	89 05 00 00 00
	00		 mov	 DWORD PTR mg_log_level, eax
  0033c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR listen_params
  00343	48 85 c0	 test	 rax, rax
  00346	48 0f 45 c8	 cmovne	 rcx, rax
  0034a	48 89 0d 00 00
	00 00		 mov	 QWORD PTR listen_params, rcx
$LL66@newmain:

; 2038 : 
; 2039 : 	const int listen_params_length = strlen(listen_params);

  00351	48 ff c3	 inc	 rbx
  00354	40 38 2c 19	 cmp	 BYTE PTR [rcx+rbx], bpl
  00358	75 f7		 jne	 SHORT $LL66@newmain

; 2040 : 	char* listener = malloc(strlen("http://") + listen_params_length + 1);

  0035a	48 63 cb	 movsxd	 rcx, ebx
  0035d	48 83 c1 08	 add	 rcx, 8
  00361	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 2041 : 	sprintf(listener, "http://%s", listen_params);

  00367	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR listen_params
  0036e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09JDMNIDNN@http?3?1?1?$CFs@
  00375	48 8b c8	 mov	 rcx, rax
  00378	48 8b f8	 mov	 rdi, rax
  0037b	e8 00 00 00 00	 call	 sprintf

; 2042 : 	logger("Starting Mongoose on %s\n", listener);

  00380	48 8b d7	 mov	 rdx, rdi
  00383	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@LGLGONCN@Starting?5Mongoose?5on?5?$CFs?6@
  0038a	e8 00 00 00 00	 call	 logger
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c

; 3273 :   struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);

  0038f	45 33 c9	 xor	 r9d, r9d
  00392	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:handle_web
  00399	48 8b d7	 mov	 rdx, rdi
  0039c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR mgr$[rsp]
  003a1	e8 00 00 00 00	 call	 mg_listen

; 3274 :   if (c != NULL) c->pfn = http_cb;

  003a6	48 85 c0	 test	 rax, rax
  003a9	74 0e		 je	 SHORT $LN46@newmain
  003ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:http_cb
  003b2	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx
$LN46@newmain:
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c

; 2046 : 	pthread_create(&thread, NULL, mongooseThread, &mgr); // Create thread for Mongoose

  003b9	4c 8d 4c 24 50	 lea	 r9, QWORD PTR mgr$[rsp]
  003be	33 d2		 xor	 edx, edx
  003c0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:mongooseThread
  003c7	48 8d 4c 24 30	 lea	 rcx, QWORD PTR thread$[rsp]
  003cc	e8 00 00 00 00	 call	 pthread_create

; 2047 : 
; 2048 : #endif // NO_MONGOOSE
; 2049 : 
; 2050 : 	int rc;
; 2051 : 	rc = runServer();

  003d1	e8 00 00 00 00	 call	 runServer

; 2052 : 
; 2053 : 	// Clean up things and exit
; 2054 : #ifdef _NTSERVICE
; 2055 : 	if (!ServiceShutdown)

  003d6	40 38 2d 00 00
	00 00		 cmp	 BYTE PTR ServiceShutdown, bpl
  003dd	8b d8		 mov	 ebx, eax
  003df	75 3e		 jne	 SHORT $LN30@newmain

; 2056 : 	{
; 2057 : #endif
; 2058 : 
; 2059 : #ifndef NO_MONGOOSE
; 2060 : 		pthread_join(thread, NULL);     // Wait for Mongoose thread to finish

  003e1	0f 28 44 24 30	 movaps	 xmm0, XMMWORD PTR thread$[rsp]
  003e6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T1[rsp]
  003eb	33 d2		 xor	 edx, edx
  003ed	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR $T1[rsp], xmm0
  003f3	e8 00 00 00 00	 call	 pthread_join

; 2061 : 		mg_mgr_free(&mgr);				// Cleanup manager

  003f8	48 8d 4c 24 50	 lea	 rcx, QWORD PTR mgr$[rsp]
  003fd	e8 00 00 00 00	 call	 mg_mgr_free

; 2062 : 		free(listener);					// Free listener

  00402	48 8b cf	 mov	 rcx, rdi
  00405	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2063 : 		free(listen_params);			// Free Mongoose parameters

  0040b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR listen_params
  00412	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2064 : #endif								    // NO_MONGOOSE
; 2065 : 
; 2066 : 	cleanup();

  00418	e8 00 00 00 00	 call	 cleanup

; 2067 : 
; 2068 : #ifdef _NTSERVICE
; 2069 : 	}

  0041d	eb 0d		 jmp	 SHORT $LN31@newmain
$LN30@newmain:

; 2070 : 	else ReportServiceStatus(SERVICE_STOPPED, NO_ERROR, 0);

  0041f	33 d2		 xor	 edx, edx
  00421	45 33 c0	 xor	 r8d, r8d
  00424	8d 4a 01	 lea	 ecx, QWORD PTR [rdx+1]
  00427	e8 00 00 00 00	 call	 ReportServiceStatus
$LN31@newmain:

; 2071 : #endif
; 2072 : 
; 2073 : 	return rc;
; 2074 : }

  0042c	8b c3		 mov	 eax, ebx
$LN1@newmain:
  0042e	4c 8d 9c 24 70
	02 00 00	 lea	 r11, QWORD PTR [rsp+624]
  00436	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  0043a	49 8b 6b 20	 mov	 rbp, QWORD PTR [r11+32]
  0043e	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  00442	49 8b e3	 mov	 rsp, r11
  00445	5f		 pop	 rdi
  00446	c3		 ret	 0
$LN78@newmain:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 366  : 	if (!buf) OutOfMemory();

  00447	e8 00 00 00 00	 call	 OutOfMemory
  0044c	cc		 int	 3
$LN79@newmain:
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c

; 1886 : 				usage();

  0044d	e8 00 00 00 00	 call	 usage
  00452	cc		 int	 3
$LN76@newmain:
newmain	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT usage
_TEXT	SEGMENT
usage	PROC						; COMDAT

; 272  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 273  : 	printerrorf("vlmcsd %s\n"

  00004	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR global_argv
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@LMFFFEAG@?B?$KJ?5Microsoft?5may?52023@
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0IEE@BNCCDJLA@vlmcsd?5?$CFs?6?6Usage?3?6?5?5?5?$CFs?5?$FL?5optio@
  00019	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  0001c	e8 00 00 00 00	 call	 printerrorf

; 274  : 				"\nUsage:\n"
; 275  : 				"   %s [ options ]\n\n"
; 276  : 				"Where:\n"
; 277  : #if !defined(_WIN32) && !defined(NO_USER_SWITCH)
; 278  : 				"  -u <user>\t\tset uid to <user>\n"
; 279  : 				"  -g <group>\t\tset gid to <group>\n"
; 280  : #endif // !defined(_WIN32) && !defined(NO_USER_SWITCH)
; 281  : #ifndef NO_CL_PIDS
; 282  : 				"  -a <csvlk>=<epid>\tuse <epid> for <csvlk>\n"
; 283  : #endif // NO_CL_PIDS
; 284  : #ifndef NO_RANDOM_EPID
; 285  : 				"  -r 0|1|2\t\tset ePID randomization level (default 1)\n"
; 286  : 				"  -C <LCID>\t\tuse fixed <LCID> in random ePIDs\n"
; 287  : 				"  -H <build>\t\tuse fixed <build> number in random ePIDs\n"
; 288  : #endif // NO_RANDOM_EPID
; 289  : #ifdef LOG_TO_MONGODB
; 290  : 				"  -X <url>\t\tMongoDB Api insertOne Url\n"
; 291  : 				"  -Y <key>\t\tMongoDB write api key\n"
; 292  : #endif
; 293  : #ifndef NO_MONGOOSE
; 294  : 				"  -w <address>:<port>\tstart web server on <address>:<port> (default to 0.0.0.0:8000)\n"
; 295  : #endif // NO_MONGOOSE
; 296  : #if !defined(NO_PRIVATE_IP_DETECT)
; 297  : #if HAVE_GETIFADDR
; 298  : 				"  -o 0|1|2|3\t\tset protection level against clients with public IP addresses (default 0)\n"
; 299  : #else // !HAVE_GETIFADDR
; 300  : #ifndef USE_MSRPC
; 301  : 				"  -o 0|2\t\tset protection level against clients with public IP addresses (default 0)\n"
; 302  : #else  // USE_MSRPC
; 303  : 				"  -o 0|2\t\tset protection level against clients with public IP addresses (default 0). Limited use with MS RPC\n"
; 304  : #endif // USE_MSRPC
; 305  : #endif // !HAVE_GETIFADDR
; 306  : #endif // !defined(NO_PRIVATE_IP_DETECT)
; 307  : #ifndef NO_TAP
; 308  : 				"  -O <v>[=<a>][/<c>]\tuse VPN adapter <v> with IPv4 address <a> and CIDR <c>\n"
; 309  : #endif
; 310  : #ifndef NO_SOCKETS
; 311  : 				"  -x <level>\t\texit if warning <level> reached (default 0)\n"
; 312  : #if !defined(USE_MSRPC) && !defined(SIMPLE_SOCKETS)
; 313  : 				"  -L <address>[:<port>]\tlisten on IP address <address> with optional <port>\n"
; 314  : 				"  -P <port>\t\tset TCP port <port> for subsequent -L statements (default 1688)\n"
; 315  : #if HAVE_FREEBIND
; 316  : 				"  -F0, -F1\t\tdisable/enable binding to foreign IP addresses\n"
; 317  : #endif // HAVE_FREEBIND
; 318  : #else  // defined(USE_MSRPC) || defined(SIMPLE_SOCKETS)
; 319  : 				"  -P <port>\t\tuse TCP port <port> (default 1688)\n"
; 320  : #endif // defined(USE_MSRPC) || defined(SIMPLE_SOCKETS)
; 321  : #if !defined(NO_LIMIT) && !__minix__
; 322  : 				"  -m <clients>\t\tHandle max. <clients> simultaneously (default no limit)\n"
; 323  : #endif // !defined(NO_LIMIT) && !__minix__
; 324  : #ifdef _NTSERVICE
; 325  : 				"  -s\t\t\tinstall vlmcsd as an NT service. Ignores -e"
; 326  : #ifndef _WIN32
; 327  : 				", -f and -D"
; 328  : #endif // _WIN32
; 329  : 				"\n"
; 330  : 				"  -S\t\t\tremove vlmcsd service. Ignores all other options\n"
; 331  : 				"  -U <username>\t\trun NT service as <username>. Must be used with -s\n"
; 332  : 				"  -W <password>\t\toptional <password> for -U. Must be used with -s\n"
; 333  : #endif // _NTSERVICE
; 334  : #ifndef NO_LOG
; 335  : 				"  -e\t\t\tlog to stdout\n"
; 336  : #endif		   // NO_LOG
; 337  : #ifndef _WIN32 //
; 338  : 				"  -D\t\t\trun in foreground\n"
; 339  : #else		   // _WIN32
; 340  : 				"  -D\t\t\tdoes nothing. Provided for compatibility with POSIX versions only\n"
; 341  : #endif		   // _WIN32
; 342  : #endif		   // NO_SOCKETS
; 343  : #ifndef NO_STRICT_MODES
; 344  : 				"  -K 0|1|2|3\t\tset white-listing level for KMS IDs (default -K0)\n"
; 345  : 				"  -c0, -c1\t\tdisable/enable client time checking (default -c0)\n"
; 346  : #ifndef NO_CLIENT_LIST
; 347  : 				"  -M0, -M1\t\tdisable/enable maintaining clients (default -M0)\n"
; 348  : 				"  -E0, -E1\t\tdisable/enable start with empty client list (default -E0, ignored if -M0)\n"
; 349  : #endif // !NO_CLIENT_LIST
; 350  : #endif // !NO_STRICT_MODES
; 351  : #ifndef USE_MSRPC
; 352  : #if !defined(NO_TIMEOUT) && !__minix__
; 353  : 				"  -t <seconds>\t\tdisconnect clients after <seconds> of inactivity (default 30)\n"
; 354  : #endif // !defined(NO_TIMEOUT) && !__minix__
; 355  : 				"  -d\t\t\tdisconnect clients after each request\n"
; 356  : 				"  -k\t\t\tdon't disconnect clients after each request (default)\n"
; 357  : #ifndef SIMPLE_RPC
; 358  : 				"  -N0, -N1\t\tdisable/enable NDR64\n"
; 359  : 				"  -B0, -B1\t\tdisable/enable bind time feature negotiation\n"
; 360  : #endif // !SIMPLE_RPC
; 361  : #endif // USE_MSRPC
; 362  : #ifndef NO_PID_FILE
; 363  : 				"  -p <file>\t\twrite pid to <file>\n"
; 364  : #endif // NO_PID_FILE
; 365  : #ifndef NO_INI_FILE
; 366  : 				"  -i <file>\t\tuse config file <file>\n"
; 367  : #endif // NO_INI_FILE
; 368  : #ifndef NO_EXTERNAL_DATA
; 369  : 				"  -j <file>\t\tuse KMS data file <file>\n"
; 370  : #endif // !NO_EXTERNAL_DATA
; 371  : #ifndef NO_CUSTOM_INTERVALS
; 372  : 				"  -R <interval>\t\trenew activation every <interval> (default 1w)\n"
; 373  : 				"  -A <interval>\t\tretry activation every <interval> (default 2h)\n"
; 374  : #endif // NO_CUSTOM_INTERVALS
; 375  : #ifndef NO_LOG
; 376  : #ifndef _WIN32
; 377  : 				"  -l syslog		log to syslog\n"
; 378  : #endif // _WIN32
; 379  : 				"  -l <file>\t\tlog to <file>\n"
; 380  : 				"  -T0, -T1\t\tdisable/enable logging with time and date (default -T1)\n"
; 381  : #ifndef NO_VERBOSE_LOG
; 382  : 				"  -v\t\t\tlog verbose (multiple v for more verbosity)\n"
; 383  : 				"  -q\t\t\tdon't log verbose (default)\n"
; 384  : #endif // NO_VERBOSE_LOG
; 385  : #endif // NO_LOG
; 386  : #ifndef NO_VERSION_INFORMATION
; 387  : 				"  -V\t\t\tdisplay version information and exit\n"
; 388  : #endif // NO_VERSION_INFORMATION
; 389  : 				,
; 390  : 				Version, global_argv[0]);
; 391  : 
; 392  : 	exit(VLMCSD_EINVAL);

  00021	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0002c	cc		 int	 3
$LN3@usage:
usage	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT getTimeSpanFromIniFile
_TEXT	SEGMENT
result$ = 48
argument$ = 56
getTimeSpanFromIniFile PROC				; COMDAT

; 400  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 401  : 	const DWORD val = timeSpanString2Minutes(argument);

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	e8 00 00 00 00	 call	 timeSpanString2Seconds
  00011	8b d0		 mov	 edx, eax
  00013	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00018	f7 e2		 mul	 edx
  0001a	c1 ea 05	 shr	 edx, 5

; 402  : 
; 403  : 	if (!val)

  0001d	85 d2		 test	 edx, edx
  0001f	75 12		 jne	 SHORT $LN2@getTimeSpa

; 404  : 	{
; 405  : 		IniFileErrorMessage = "Incorrect time span.";

  00021	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@DDLEHNLP@Incorrect?5time?5span?4@
  00028	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax

; 406  : 		return FALSE;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 07		 jmp	 SHORT $LN1@getTimeSpa
$LN2@getTimeSpa:

; 407  : 	}
; 408  : 
; 409  : 	*result = val;

  00033	89 13		 mov	 DWORD PTR [rbx], edx

; 410  : 	return TRUE;

  00035	b8 01 00 00 00	 mov	 eax, 1
$LN1@getTimeSpa:

; 411  : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5b		 pop	 rbx
  0003f	c3		 ret	 0
getTimeSpanFromIniFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT getTimeSpanFromCommandLine
_TEXT	SEGMENT
arg$dead$ = 48
optchar$ = 56
getTimeSpanFromCommandLine PROC				; COMDAT

; 416  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 417  : 	const DWORD val = timeSpanString2Minutes(arg);

  00006	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR optarg
  0000d	0f be da	 movsx	 ebx, dl
  00010	e8 00 00 00 00	 call	 timeSpanString2Seconds
  00015	8b c8		 mov	 ecx, eax
  00017	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  0001c	f7 e1		 mul	 ecx
  0001e	c1 ea 05	 shr	 edx, 5

; 418  : 
; 419  : 	if (!val)

  00021	85 d2		 test	 edx, edx
  00023	75 1a		 jne	 SHORT $LN2@getTimeSpa

; 420  : 	{
; 421  : 		printerrorf("Fatal: No valid time span specified in option -%c.\n", optchar);

  00025	8b d3		 mov	 edx, ebx
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DE@FKNLKBBJ@Fatal?3?5No?5valid?5time?5span?5speci@
  0002e	e8 00 00 00 00	 call	 printerrorf

; 422  : 		exit(VLMCSD_EINVAL);

  00033	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0003e	cc		 int	 3
$LN2@getTimeSpa:

; 423  : 	}
; 424  : 
; 425  : 	return val;

  0003f	8b c2		 mov	 eax, edx

; 426  : }

  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5b		 pop	 rbx
  00046	c3		 ret	 0
$LN4@getTimeSpa:
getTimeSpanFromCommandLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT isControlCharOrSlash
_TEXT	SEGMENT
c$ = 8
isControlCharOrSlash PROC				; COMDAT

; 433  : 	if ((unsigned char)c < '!')

  00000	80 f9 21	 cmp	 cl, 33			; 00000021H
  00003	72 09		 jb	 SHORT $LN5@isControlC

; 434  : 		return TRUE;
; 435  : 	if (c == '/')

  00005	33 c0		 xor	 eax, eax
  00007	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  0000a	0f 94 c0	 sete	 al

; 437  : 	return FALSE;
; 438  : }

  0000d	c3		 ret	 0
$LN5@isControlC:

; 436  : 		return TRUE;

  0000e	b8 01 00 00 00	 mov	 eax, 1

; 437  : 	return FALSE;
; 438  : }

  00013	c3		 ret	 0
isControlCharOrSlash ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT iniFileLineNextWord
_TEXT	SEGMENT
s$ = 48
iniFileLineNextWord PROC				; COMDAT

; 441  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 442  : 	while (**s && isspace((int)**s))

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	eb 13		 jmp	 SHORT $LN11@iniFileLin
$LL2@iniFileLin:
  0000e	0f be c9	 movsx	 ecx, cl
  00011	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isspace
  00017	85 c0		 test	 eax, eax
  00019	74 0c		 je	 SHORT $LN3@iniFileLin

; 443  : 		(*s)++;

  0001b	48 ff 03	 inc	 QWORD PTR [rbx]
  0001e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN11@iniFileLin:

; 442  : 	while (**s && isspace((int)**s))

  00021	8a 08		 mov	 cl, BYTE PTR [rax]
  00023	84 c9		 test	 cl, cl
  00025	75 e7		 jne	 SHORT $LL2@iniFileLin
$LN3@iniFileLin:

; 444  : }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5b		 pop	 rbx
  0002c	c3		 ret	 0
iniFileLineNextWord ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT setHwIdFromIniFileLine
_TEXT	SEGMENT
s$ = 48
index$ = 56
overwrite$ = 64
setHwIdFromIniFileLine PROC				; COMDAT

; 447  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	41 8a f8	 mov	 dil, r8b
  00012	8b da		 mov	 ebx, edx
  00014	48 8b f1	 mov	 rsi, rcx

; 448  : 	iniFileLineNextWord(s);

  00017	e8 00 00 00 00	 call	 iniFileLineNextWord

; 449  : 
; 450  : 	if (**s == '/')

  0001c	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0001f	80 38 2f	 cmp	 BYTE PTR [rax], 47	; 0000002fH
  00022	75 4b		 jne	 SHORT $LN2@setHwIdFro

; 451  : 	{
; 452  : 		if (!overwrite && KmsResponseParameters[index].HwId)

  00024	48 c1 e3 05	 shl	 rbx, 5
  00028	40 84 ff	 test	 dil, dil
  0002b	75 0f		 jne	 SHORT $LN9@setHwIdFro
  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR KmsResponseParameters
  00034	48 83 7c 03 08
	00		 cmp	 QWORD PTR [rbx+rax+8], 0
  0003a	75 33		 jne	 SHORT $LN2@setHwIdFro
$LN9@setHwIdFro:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  0003c	b9 08 00 00 00	 mov	 ecx, 8
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00047	48 8b f8	 mov	 rdi, rax

; 366  : 	if (!buf) OutOfMemory();

  0004a	48 85 c0	 test	 rax, rax
  0004d	74 35		 je	 SHORT $LN13@setHwIdFro
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c

; 456  : 		hex2bin(HwId, *s + 1, sizeof(((RESPONSE_V6 *)0)->HwId));

  0004f	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  00052	41 b8 08 00 00
	00		 mov	 r8d, 8
  00058	48 ff c2	 inc	 rdx
  0005b	48 8b c8	 mov	 rcx, rax
  0005e	e8 00 00 00 00	 call	 hex2bin

; 457  : 		KmsResponseParameters[index].HwId = HwId;

  00063	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsResponseParameters
  0006a	48 89 7c 0b 08	 mov	 QWORD PTR [rbx+rcx+8], rdi
$LN2@setHwIdFro:

; 461  : }

  0006f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00074	b8 01 00 00 00	 mov	 eax, 1
  00079	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
$LN13@setHwIdFro:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 366  : 	if (!buf) OutOfMemory();

  00084	e8 00 00 00 00	 call	 OutOfMemory
  00089	cc		 int	 3
$LN11@setHwIdFro:
setHwIdFromIniFileLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT setEpidFromIniFileLine
_TEXT	SEGMENT
s$ = 64
index$ = 72
ePidSource$ = 80
overwrite$ = 88
setEpidFromIniFileLine PROC				; COMDAT

; 464  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00018	41 8a f1	 mov	 sil, r9b
  0001b	8b ea		 mov	 ebp, edx
  0001d	4d 8b f8	 mov	 r15, r8
  00020	48 8b d9	 mov	 rbx, rcx

; 465  : 	iniFileLineNextWord(s);

  00023	e8 00 00 00 00	 call	 iniFileLineNextWord

; 466  : 	const char *savedPosition = *s;

  00028	4c 8b 33	 mov	 r14, QWORD PTR [rbx]

; 467  : 	uint_fast16_t i;
; 468  : 
; 469  : 	for (i = 0; !isControlCharOrSlash(**s); i++)

  0002b	45 33 d2	 xor	 r10d, r10d
$LL4@setEpidFro:
  0002e	48 8b 3b	 mov	 rdi, QWORD PTR [rbx]

; 433  : 	if ((unsigned char)c < '!')

  00031	80 3f 21	 cmp	 BYTE PTR [rdi], 33	; 00000021H
  00034	72 1f		 jb	 SHORT $LN24@setEpidFro

; 434  : 		return TRUE;
; 435  : 	if (c == '/')

  00036	80 3f 2f	 cmp	 BYTE PTR [rdi], 47	; 0000002fH
  00039	74 1a		 je	 SHORT $LN24@setEpidFro

; 470  : 	{
; 471  : 		if (utf8_to_ucs2_char((const unsigned char *)*s, (const unsigned char **)s) == (WCHAR)~0)

  0003b	48 8b d3	 mov	 rdx, rbx
  0003e	48 8b cf	 mov	 rcx, rdi
  00041	e8 00 00 00 00	 call	 utf8_to_ucs2_char
  00046	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0004b	66 3b c1	 cmp	 ax, cx
  0004e	74 6f		 je	 SHORT $LN7@setEpidFro

; 467  : 	uint_fast16_t i;
; 468  : 
; 469  : 	for (i = 0; !isControlCharOrSlash(**s); i++)

  00050	41 ff c2	 inc	 r10d
  00053	eb d9		 jmp	 SHORT $LL4@setEpidFro
$LN24@setEpidFro:

; 472  : 		{
; 473  : 			return FALSE;
; 474  : 		}
; 475  : 	}
; 476  : 
; 477  : 	if (i < 1 || i >= PID_BUFFER_SIZE)

  00055	41 8d 4a ff	 lea	 ecx, DWORD PTR [r10-1]
  00059	83 f9 3e	 cmp	 ecx, 62			; 0000003eH
  0005c	77 61		 ja	 SHORT $LN7@setEpidFro

; 479  : 	if (!overwrite && KmsResponseParameters[index].Epid)

  0005e	48 8b dd	 mov	 rbx, rbp
  00061	40 84 f6	 test	 sil, sil
  00064	75 1c		 jne	 SHORT $LN21@setEpidFro
  00066	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsResponseParameters
  0006d	48 8b d3	 mov	 rdx, rbx
  00070	48 c1 e2 05	 shl	 rdx, 5
  00074	48 83 3c 0a 00	 cmp	 QWORD PTR [rdx+rcx], 0
  00079	74 07		 je	 SHORT $LN21@setEpidFro
$LN27@setEpidFro:

; 495  : }

  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	eb 3f		 jmp	 SHORT $LN1@setEpidFro
$LN21@setEpidFro:

; 480  : 		return TRUE;
; 481  : 
; 482  : 	const size_t size = *s - savedPosition + 1;

  00082	49 2b fe	 sub	 rdi, r14
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  00085	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0008f	48 8b f0	 mov	 rsi, rax

; 366  : 	if (!buf) OutOfMemory();

  00092	48 85 c0	 test	 rax, rax
  00095	74 43		 je	 SHORT $LN29@setEpidFro
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c

; 485  : 	memcpy(epidbuffer, savedPosition, size - 1);

  00097	4c 8b c7	 mov	 r8, rdi
  0009a	49 8b d6	 mov	 rdx, r14
  0009d	48 8b c8	 mov	 rcx, rax
  000a0	e8 00 00 00 00	 call	 memcpy

; 486  : 	epidbuffer[size - 1] = 0;
; 487  : 
; 488  : 	KmsResponseParameters[index].Epid = epidbuffer;

  000a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR KmsResponseParameters
  000ac	48 c1 e3 05	 shl	 rbx, 5
  000b0	c6 04 3e 00	 mov	 BYTE PTR [rsi+rdi], 0
  000b4	48 89 34 03	 mov	 QWORD PTR [rbx+rax], rsi

; 489  : 
; 490  : #ifndef NO_LOG
; 491  : 	KmsResponseParameters[index].EpidSource = ePidSource;

  000b8	4c 89 7c 03 10	 mov	 QWORD PTR [rbx+rax+16], r15

; 492  : #endif // NO_LOG
; 493  : 
; 494  : 	return TRUE;

  000bd	eb bc		 jmp	 SHORT $LN27@setEpidFro
$LN7@setEpidFro:

; 478  : 		return FALSE;

  000bf	33 c0		 xor	 eax, eax
$LN1@setEpidFro:

; 495  : }

  000c1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c6	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000cb	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000d0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d4	41 5f		 pop	 r15
  000d6	41 5e		 pop	 r14
  000d8	5f		 pop	 rdi
  000d9	c3		 ret	 0
$LN29@setEpidFro:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 366  : 	if (!buf) OutOfMemory();

  000da	e8 00 00 00 00	 call	 OutOfMemory
  000df	cc		 int	 3
$LN26@setEpidFro:
setEpidFromIniFileLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT getIniFileArgumentBool
_TEXT	SEGMENT
result$ = 8
argument$ = 16
getIniFileArgumentBool PROC				; COMDAT

; 500  : 	IniFileErrorMessage = "Argument must be true/on/yes/1 or false/off/no/0";

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DB@GHHCGCFM@Argument?5must?5be?5true?1on?1yes?11?5@
  00007	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax

; 501  : 	return getArgumentBool(result, argument);

  0000e	e9 00 00 00 00	 jmp	 getArgumentBool
getIniFileArgumentBool ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT getIniFileArgumentInt
_TEXT	SEGMENT
tempResult$ = 48
result$ = 80
argument$ = 88
min$ = 96
max$ = 104
getIniFileArgumentInt PROC				; COMDAT

; 505  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	41 8b f9	 mov	 edi, r9d
  00012	41 8b f0	 mov	 esi, r8d
  00015	48 8b c2	 mov	 rax, rdx

; 506  : 	unsigned int tempResult;
; 507  : 
; 508  : 	if (!stringToInt(argument, min, max, &tempResult))

  00018	4c 8d 4c 24 30	 lea	 r9, QWORD PTR tempResult$[rsp]
  0001d	48 8b d9	 mov	 rbx, rcx
  00020	44 8b c7	 mov	 r8d, edi
  00023	8b d6		 mov	 edx, esi
  00025	48 8b c8	 mov	 rcx, rax
  00028	e8 00 00 00 00	 call	 stringToInt
  0002d	85 c0		 test	 eax, eax
  0002f	75 31		 jne	 SHORT $LN2@getIniFile

; 509  : 	{
; 510  : 		vlmcsd_snprintf(IniFileErrorBuffer, INIFILE_ERROR_BUFFERSIZE, "Must be integer between %u and %u", min, max);

  00031	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR IniFileErrorBuffer
  00038	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CC@DKAMOLDO@Must?5be?5integer?5between?5?$CFu?5and?5@
  0003f	44 8b ce	 mov	 r9d, esi
  00042	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  00046	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0004b	e8 00 00 00 00	 call	 _snprintf

; 511  : 		IniFileErrorMessage = IniFileErrorBuffer;

  00050	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR IniFileErrorBuffer
  00057	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax

; 512  : 		return FALSE;

  0005e	33 c0		 xor	 eax, eax
  00060	eb 0b		 jmp	 SHORT $LN1@getIniFile
$LN2@getIniFile:

; 513  : 	}
; 514  : 
; 515  : 	*result = tempResult;

  00062	8b 44 24 30	 mov	 eax, DWORD PTR tempResult$[rsp]
  00066	89 03		 mov	 DWORD PTR [rbx], eax

; 516  : 	return TRUE;

  00068	b8 01 00 00 00	 mov	 eax, 1
$LN1@getIniFile:

; 517  : }

  0006d	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00072	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00077	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
getIniFileArgumentInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT getIniFileArgumentInt8
_TEXT	SEGMENT
result$dead$ = 64
argument$ = 72
min$dead$ = 80
max$dead$ = 88
tempResult$ = 88
getIniFileArgumentInt8 PROC				; COMDAT

; 520  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	48 8b ca	 mov	 rcx, rdx

; 521  : 	unsigned int tempResult;
; 522  : 
; 523  : 	if (!stringToInt(argument, min, max, &tempResult))

  0000c	4c 8d 4c 24 58	 lea	 r9, QWORD PTR tempResult$[rsp]
  00011	33 d2		 xor	 edx, edx
  00013	41 b8 ff 00 00
	00		 mov	 r8d, 255		; 000000ffH
  00019	e8 00 00 00 00	 call	 stringToInt
  0001e	85 c0		 test	 eax, eax
  00020	75 35		 jne	 SHORT $LN2@getIniFile

; 524  : 	{
; 525  : 		vlmcsd_snprintf(IniFileErrorBuffer, INIFILE_ERROR_BUFFERSIZE, "Must be integer between %u and %u", min, max);

  00022	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR IniFileErrorBuffer
  00029	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CC@DKAMOLDO@Must?5be?5integer?5between?5?$CFu?5and?5@
  00030	45 33 c9	 xor	 r9d, r9d
  00033	c7 44 24 20 ff
	00 00 00	 mov	 DWORD PTR [rsp+32], 255	; 000000ffH
  0003b	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00040	e8 00 00 00 00	 call	 _snprintf

; 526  : 		IniFileErrorMessage = IniFileErrorBuffer;

  00045	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR IniFileErrorBuffer
  0004c	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax

; 527  : 		return FALSE;

  00053	33 c0		 xor	 eax, eax
  00055	eb 0f		 jmp	 SHORT $LN1@getIniFile
$LN2@getIniFile:

; 528  : 	}
; 529  : 
; 530  : 	*result = tempResult;

  00057	8a 44 24 58	 mov	 al, BYTE PTR tempResult$[rsp]
  0005b	88 05 00 00 00
	00		 mov	 BYTE PTR logverbose, al

; 531  : 	return TRUE;

  00061	b8 01 00 00 00	 mov	 eax, 1
$LN1@getIniFile:

; 532  : }

  00066	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006a	c3		 ret	 0
getIniFileArgumentInt8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT setIniFileParameter
_TEXT	SEGMENT
result$ = 48
id$ = 48
iniarg$ = 56
setIniFileParameter PROC				; COMDAT

; 535  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 536  : 	unsigned int result;
; 537  : 	BOOL success = TRUE;
; 538  : 	switch (id)

  0000a	44 0f b6 c1	 movzx	 r8d, cl
  0000e	bf 01 00 00 00	 mov	 edi, 1
  00013	8b df		 mov	 ebx, edi
  00015	41 83 f8 0f	 cmp	 r8d, 15
  00019	0f 87 c7 01 00
	00		 ja	 $LN36@setIniFile
  0001f	0f 84 91 01 00
	00		 je	 $LN28@setIniFile
  00025	41 83 f8 07	 cmp	 r8d, 7
  00029	0f 87 1a 01 00
	00		 ja	 $LN37@setIniFile
  0002f	0f 84 f6 00 00
	00		 je	 $LN20@setIniFile
  00035	44 2b c3	 sub	 r8d, ebx
  00038	0f 84 c1 00 00
	00		 je	 $LN7@setIniFile
  0003e	44 2b c3	 sub	 r8d, ebx
  00041	0f 84 8a 00 00
	00		 je	 $LN5@setIniFile
  00047	44 2b c3	 sub	 r8d, ebx
  0004a	74 77		 je	 SHORT $LN12@setIniFile
  0004c	44 2b c3	 sub	 r8d, ebx
  0004f	74 58		 je	 SHORT $LN13@setIniFile
  00051	44 2b c3	 sub	 r8d, ebx
  00054	74 27		 je	 SHORT $LN25@setIniFile
  00056	44 3b c3	 cmp	 r8d, ebx
  00059	0f 85 4b 02 00
	00		 jne	 $LN34@setIniFile
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 373  : 	char* dst = _strdup(src);

  0005f	48 8b ca	 mov	 rcx, rdx
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup

; 378  : 	if (!dst) OutOfMemory();

  00068	48 85 c0	 test	 rax, rax
  0006b	0f 84 c6 02 00
	00		 je	 $LN69@setIniFile
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c

; 633  : 		break;

  00071	48 89 05 00 00
	00 00		 mov	 QWORD PTR fn_pid, rax
  00078	e9 ad 02 00 00	 jmp	 $LN2@setIniFile
$LN25@setIniFile:

; 696  : 		break;
; 697  : 
; 698  : #endif // NO_CUSTOM_INTERVALS
; 699  : 
; 700  : #ifndef USE_MSRPC
; 701  : 
; 702  : #if !defined(NO_TIMEOUT) && !__minix__
; 703  : 
; 704  : 	case INI_PARAM_CONNECTION_TIMEOUT:
; 705  : 		success = getIniFileArgumentInt(&result, iniarg, 1, 600);

  0007d	41 b9 58 02 00
	00		 mov	 r9d, 600		; 00000258H
  00083	48 8d 4c 24 30	 lea	 rcx, QWORD PTR result$[rsp]
  00088	44 8b c7	 mov	 r8d, edi
  0008b	e8 00 00 00 00	 call	 getIniFileArgumentInt
  00090	8b d8		 mov	 ebx, eax

; 706  : 		if (success)

  00092	85 c0		 test	 eax, eax
  00094	0f 84 90 02 00
	00		 je	 $LN2@setIniFile

; 707  : 			ServerTimeout = (DWORD)result;

  0009a	8b 4c 24 30	 mov	 ecx, DWORD PTR result$[rsp]
  0009e	89 0d 00 00 00
	00		 mov	 DWORD PTR ServerTimeout, ecx

; 708  : 		break;

  000a4	e9 81 02 00 00	 jmp	 $LN2@setIniFile
$LN13@setIniFile:

; 615  : 
; 616  : #endif // !defined(NO_SOCKETS) && !defined(USE_MSRPC) && !defined(SIMPLE_SOCKETS)
; 617  : #if !defined(NO_LIMIT) && !defined(NO_SOCKETS) && !__minix__
; 618  : 
; 619  : 	case INI_PARAM_MAX_WORKERS:
; 620  : #ifdef USE_MSRPC
; 621  : 		success = getIniFileArgumentInt(&MaxTasks, iniarg, 1, RPC_C_LISTEN_MAX_CALLS_DEFAULT);
; 622  : #else  // !USE_MSRPC
; 623  : 		success = getIniFileArgumentInt(&MaxTasks, iniarg, 1, SEM_VALUE_MAX);

  000a9	41 b9 ff ff ff
	7f		 mov	 r9d, 2147483647		; 7fffffffH
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:MaxTasks
  000b6	44 8b c7	 mov	 r8d, edi
$LN77@setIniFile:

; 765  : 	}
; 766  : 
; 767  : 	return success;

  000b9	e8 00 00 00 00	 call	 getIniFileArgumentInt
  000be	e9 65 02 00 00	 jmp	 $LN75@setIniFile
$LN12@setIniFile:

; 607  : 
; 608  : #endif // (defined(USE_MSRPC) || defined(SIMPLE_SOCKETS) || defined(HAVE_GETIFADDR)) && !defined(NO_SOCKETS)
; 609  : 
; 610  : #if !defined(NO_SOCKETS) && !defined(USE_MSRPC) && !defined(SIMPLE_SOCKETS)
; 611  : 
; 612  : 	case INI_PARAM_LISTEN:
; 613  : 		maxsockets++;

  000c3	40 00 3d 00 00
	00 00		 add	 BYTE PTR maxsockets, dil

; 614  : 		return TRUE;

  000ca	8b c7		 mov	 eax, edi
  000cc	e9 5b 02 00 00	 jmp	 $LN1@setIniFile
$LN5@setIniFile:

; 545  : 
; 546  : #endif // NO_TAP
; 547  : 
; 548  : #if !defined(NO_USER_SWITCH) && !_WIN32
; 549  : 
; 550  : 	case INI_PARAM_GID:
; 551  : 	{
; 552  : 		struct group *g;
; 553  : 		IniFileErrorMessage = "Invalid group id or name";
; 554  : 		if (!(gname = vlmcsd_strdup(iniarg)))
; 555  : 			return FALSE;
; 556  : 
; 557  : 		if ((g = getgrnam(iniarg)))
; 558  : 			gid = g->gr_gid;
; 559  : 		else
; 560  : 			success = !GetNumericId(&gid, iniarg);
; 561  : 		break;
; 562  : 	}
; 563  : 
; 564  : 	case INI_PARAM_UID:
; 565  : 	{
; 566  : 		struct passwd *p;
; 567  : 		IniFileErrorMessage = "Invalid user id or name";
; 568  : 		if (!(uname = vlmcsd_strdup(iniarg)))
; 569  : 			return FALSE;
; 570  : 
; 571  : 		if ((p = getpwnam(iniarg)))
; 572  : 			uid = p->pw_uid;
; 573  : 		else
; 574  : 			success = !GetNumericId(&uid, iniarg);
; 575  : 		break;
; 576  : 	}
; 577  : 
; 578  : #endif // !defined(NO_USER_SWITCH) && !defined(_WIN32)
; 579  : 
; 580  : #ifndef NO_RANDOM_EPID
; 581  : 
; 582  : 	case INI_PARAM_LCID:
; 583  : 		success = getIniFileArgumentInt(&result, iniarg, 0, 32767);

  000d1	41 b9 ff 7f 00
	00		 mov	 r9d, 32767		; 00007fffH
  000d7	48 8d 4c 24 30	 lea	 rcx, QWORD PTR result$[rsp]
  000dc	45 33 c0	 xor	 r8d, r8d
  000df	e8 00 00 00 00	 call	 getIniFileArgumentInt
  000e4	8b d8		 mov	 ebx, eax

; 584  : 		if (success)

  000e6	85 c0		 test	 eax, eax
  000e8	0f 84 3c 02 00
	00		 je	 $LN2@setIniFile

; 585  : 			Lcid = (uint16_t)result;

  000ee	0f b7 44 24 30	 movzx	 eax, WORD PTR result$[rsp]
  000f3	66 89 05 00 00
	00 00		 mov	 WORD PTR Lcid, ax

; 586  : 		break;

  000fa	e9 2b 02 00 00	 jmp	 $LN2@setIniFile
$LN7@setIniFile:

; 587  : 
; 588  : 	case INI_PARAM_RANDOMIZATION_LEVEL:
; 589  : 		success = getIniFileArgumentInt(&result, iniarg, 0, 2);

  000ff	41 b9 02 00 00
	00		 mov	 r9d, 2
  00105	48 8d 4c 24 30	 lea	 rcx, QWORD PTR result$[rsp]
  0010a	45 33 c0	 xor	 r8d, r8d
  0010d	e8 00 00 00 00	 call	 getIniFileArgumentInt
  00112	8b d8		 mov	 ebx, eax

; 590  : 		if (success)

  00114	85 c0		 test	 eax, eax
  00116	0f 84 0e 02 00
	00		 je	 $LN2@setIniFile

; 591  : 			RandomizationLevel = (int_fast8_t)result;

  0011c	8a 44 24 30	 mov	 al, BYTE PTR result$[rsp]
  00120	88 05 00 00 00
	00		 mov	 BYTE PTR RandomizationLevel, al

; 592  : 		break;

  00126	e9 ff 01 00 00	 jmp	 $LN2@setIniFile
$LN20@setIniFile:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 373  : 	char* dst = _strdup(src);

  0012b	48 8b ca	 mov	 rcx, rdx
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup

; 378  : 	if (!dst) OutOfMemory();

  00134	48 85 c0	 test	 rax, rax
  00137	0f 84 fa 01 00
	00		 je	 $LN69@setIniFile
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c

; 674  : 		break;

  0013d	48 89 05 00 00
	00 00		 mov	 QWORD PTR fn_log, rax
  00144	e9 e1 01 00 00	 jmp	 $LN2@setIniFile
$LN37@setIniFile:

; 536  : 	unsigned int result;
; 537  : 	BOOL success = TRUE;
; 538  : 	switch (id)

  00149	41 83 e8 08	 sub	 r8d, 8
  0014d	74 5d		 je	 SHORT $LN22@setIniFile
  0014f	44 2b c3	 sub	 r8d, ebx
  00152	74 4f		 je	 SHORT $LN23@setIniFile
  00154	44 2b c3	 sub	 r8d, ebx
  00157	74 39		 je	 SHORT $LN24@setIniFile
  00159	44 2b c3	 sub	 r8d, ebx
  0015c	74 28		 je	 SHORT $LN27@setIniFile
  0015e	41 83 f8 03	 cmp	 r8d, 3
  00162	0f 85 42 01 00
	00		 jne	 $LN34@setIniFile
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 373  : 	char* dst = _strdup(src);

  00168	48 8b ca	 mov	 rcx, rdx
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup

; 378  : 	if (!dst) OutOfMemory();

  00171	48 85 c0	 test	 rax, rax
  00174	0f 84 bd 01 00
	00		 je	 $LN69@setIniFile
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c

; 606  : 		break;

  0017a	48 89 05 00 00
	00 00		 mov	 QWORD PTR defaultport, rax
  00181	e9 a4 01 00 00	 jmp	 $LN2@setIniFile
$LN27@setIniFile:

; 501  : 	return getArgumentBool(result, argument);

  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DisconnectImmediately

; 709  : 
; 710  : #endif // !defined(NO_TIMEOUT) && !__minix__
; 711  : 
; 712  : 	case INI_PARAM_DISCONNECT_IMMEDIATELY:
; 713  : 		success = getIniFileArgumentBool(&DisconnectImmediately, iniarg);
; 714  : 		break;

  0018d	e9 83 01 00 00	 jmp	 $LN76@setIniFile
$LN24@setIniFile:

; 693  : 
; 694  : 	case INI_PARAM_RENEWAL_INTERVAL:
; 695  : 		success = getTimeSpanFromIniFile(&VLRenewalInterval, iniarg);

  00192	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:VLRenewalInterval
$LN78@setIniFile:

; 765  : 	}
; 766  : 
; 767  : 	return success;

  00199	e8 00 00 00 00	 call	 getTimeSpanFromIniFile
  0019e	e9 85 01 00 00	 jmp	 $LN75@setIniFile
$LN23@setIniFile:

; 684  : 
; 685  : #endif // NO_VERBOSE_LOG
; 686  : #endif // NO_LOG
; 687  : 
; 688  : #ifndef NO_CUSTOM_INTERVALS
; 689  : 
; 690  : 	case INI_PARAM_ACTIVATION_INTERVAL:
; 691  : 		success = getTimeSpanFromIniFile(&VLActivationInterval, iniarg);

  001a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:VLActivationInterval

; 692  : 		break;

  001aa	eb ed		 jmp	 SHORT $LN78@setIniFile
$LN22@setIniFile:

; 679  : 
; 680  : #ifndef NO_VERBOSE_LOG
; 681  : 	case INI_PARAM_LOG_VERBOSE:
; 682  : 		success = getIniFileArgumentInt8(&logverbose, iniarg, 0, 255);

  001ac	e8 00 00 00 00	 call	 getIniFileArgumentInt8

; 683  : 		break;

  001b1	e9 72 01 00 00	 jmp	 $LN75@setIniFile
$LN28@setIniFile:

; 500  : 	IniFileErrorMessage = "Argument must be true/on/yes/1 or false/off/no/0";

  001b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DB@GHHCGCFM@Argument?5must?5be?5true?1on?1yes?11?5@

; 501  : 	return getArgumentBool(result, argument);

  001bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UseServerRpcNDR64
  001c4	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax
  001cb	e8 00 00 00 00	 call	 getArgumentBool
  001d0	8b d8		 mov	 ebx, eax

; 715  : 
; 716  : 	case INI_PARAM_RPC_NDR64:
; 717  : 		success = getIniFileArgumentBool(&UseServerRpcNDR64, iniarg);
; 718  : 		if (success)

  001d2	85 c0		 test	 eax, eax
  001d4	0f 84 50 01 00
	00		 je	 $LN2@setIniFile

; 719  : 			IsNDR64Defined = TRUE;

  001da	40 88 3d 00 00
	00 00		 mov	 BYTE PTR IsNDR64Defined, dil

; 720  : 		break;

  001e1	e9 44 01 00 00	 jmp	 $LN2@setIniFile
$LN36@setIniFile:

; 536  : 	unsigned int result;
; 537  : 	BOOL success = TRUE;
; 538  : 	switch (id)

  001e6	41 83 f8 19	 cmp	 r8d, 25
  001ea	0f 87 a0 00 00
	00		 ja	 $LN38@setIniFile
  001f0	0f 84 8e 00 00
	00		 je	 $LN17@setIniFile
  001f6	41 83 e8 10	 sub	 r8d, 16
  001fa	74 7c		 je	 SHORT $LN30@setIniFile
  001fc	41 83 e8 02	 sub	 r8d, 2
  00200	74 61		 je	 SHORT $LN33@setIniFile
  00202	44 2b c3	 sub	 r8d, ebx
  00205	74 50		 je	 SHORT $LN21@setIniFile
  00207	44 2b c3	 sub	 r8d, ebx
  0020a	74 1d		 je	 SHORT $LN9@setIniFile
  0020c	41 83 f8 04	 cmp	 r8d, 4
  00210	0f 85 94 00 00
	00		 jne	 $LN34@setIniFile

; 645  : 
; 646  : #endif // NO_EXTERNAL_DATA
; 647  : 
; 648  : #ifndef NO_STRICT_MODES
; 649  : 
; 650  : 	case INI_PARAM_WHITELISTING_LEVEL:
; 651  : 		success = getIniFileArgumentInt(&WhitelistingLevel, iniarg, 0, 3);

  00216	45 8d 48 ff	 lea	 r9d, QWORD PTR [r8-1]
  0021a	45 33 c0	 xor	 r8d, r8d
  0021d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WhitelistingLevel

; 652  : 		break;

  00224	e9 90 fe ff ff	 jmp	 $LN77@setIniFile
$LN9@setIniFile:

; 593  : 
; 594  : 	case INI_PARAM_HOST_BUILD:
; 595  : 		success = getIniFileArgumentInt(&result, iniarg, 0, 65535);

  00229	41 b9 ff ff 00
	00		 mov	 r9d, 65535		; 0000ffffH
  0022f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR result$[rsp]
  00234	45 33 c0	 xor	 r8d, r8d
  00237	e8 00 00 00 00	 call	 getIniFileArgumentInt
  0023c	8b d8		 mov	 ebx, eax

; 596  : 		if (success)

  0023e	85 c0		 test	 eax, eax
  00240	0f 84 e4 00 00
	00		 je	 $LN2@setIniFile

; 597  : 			HostBuild = (uint16_t)result;

  00246	0f b7 44 24 30	 movzx	 eax, WORD PTR result$[rsp]
  0024b	66 89 05 00 00
	00 00		 mov	 WORD PTR HostBuild, ax

; 598  : 		break;

  00252	e9 d3 00 00 00	 jmp	 $LN2@setIniFile
$LN21@setIniFile:

; 501  : 	return getArgumentBool(result, argument);

  00257	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:LogDateAndTime

; 675  : 
; 676  : 	case INI_PARAM_LOG_DATE_AND_TIME:
; 677  : 		success = getIniFileArgumentBool(&LogDateAndTime, iniarg);
; 678  : 		break;

  0025e	e9 b2 00 00 00	 jmp	 $LN76@setIniFile
$LN33@setIniFile:

; 735  : 
; 736  : #endif // NO_SOCKETS
; 737  : 
; 738  : #if HAVE_FREEBIND
; 739  : 
; 740  : 	case INI_PARAM_FREEBIND:
; 741  : 		success = getIniFileArgumentBool(&freebind, iniarg);
; 742  : 		break;
; 743  : 
; 744  : #endif // HAVE_FREEBIND
; 745  : 
; 746  : #if !defined(NO_PRIVATE_IP_DETECT)
; 747  : 
; 748  : 	case INI_PARAM_PUBLIC_IP_PROTECTION_LEVEL:
; 749  : 		success = getIniFileArgumentInt(&PublicIPProtectionLevel, iniarg, 0, 3);

  00263	41 b9 03 00 00
	00		 mov	 r9d, 3
  00269	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PublicIPProtectionLevel
  00270	45 33 c0	 xor	 r8d, r8d

; 750  : 
; 751  : #if !HAVE_GETIFADDR
; 752  : 		if (PublicIPProtectionLevel & 1)
; 753  : 		{
; 754  : 			IniFileErrorMessage = "Must be 0 or 2";
; 755  : 			success = FALSE;
; 756  : 		}
; 757  : #endif // !HAVE_GETIFADDR
; 758  : 
; 759  : 		break;

  00273	e9 41 fe ff ff	 jmp	 $LN77@setIniFile
$LN30@setIniFile:

; 501  : 	return getArgumentBool(result, argument);

  00278	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UseServerRpcBTFN

; 721  : 
; 722  : 	case INI_PARAM_RPC_BTFN:
; 723  : 		success = getIniFileArgumentBool(&UseServerRpcBTFN, iniarg);
; 724  : 		break;

  0027f	e9 91 00 00 00	 jmp	 $LN76@setIniFile
$LN17@setIniFile:

; 501  : 	return getArgumentBool(result, argument);

  00284	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CheckClientTime

; 653  : 
; 654  : 	case INI_PARAM_CHECK_CLIENT_TIME:
; 655  : 		success = getIniFileArgumentBool(&CheckClientTime, iniarg);
; 656  : 		break;

  0028b	e9 85 00 00 00	 jmp	 $LN76@setIniFile
$LN38@setIniFile:

; 536  : 	unsigned int result;
; 537  : 	BOOL success = TRUE;
; 538  : 	switch (id)

  00290	41 83 e8 1a	 sub	 r8d, 26
  00294	74 78		 je	 SHORT $LN18@setIniFile
  00296	44 2b c3	 sub	 r8d, ebx
  00299	74 6a		 je	 SHORT $LN19@setIniFile
  0029b	44 2b c3	 sub	 r8d, ebx
  0029e	74 47		 je	 SHORT $LN15@setIniFile
  002a0	44 2b c3	 sub	 r8d, ebx
  002a3	74 2b		 je	 SHORT $LN4@setIniFile
  002a5	44 3b c3	 cmp	 r8d, ebx
  002a8	74 04		 je	 SHORT $LN31@setIniFile
$LN34@setIniFile:

; 760  : 
; 761  : #endif // !defined(NO_PRIVATE_IP_DETECT)
; 762  : 
; 763  : 	default:
; 764  : 		return FALSE;

  002aa	33 c0		 xor	 eax, eax
  002ac	eb 7e		 jmp	 SHORT $LN1@setIniFile
$LN31@setIniFile:

; 725  : 
; 726  : #endif // USE_MSRPC
; 727  : 
; 728  : #ifndef NO_SOCKETS
; 729  : 
; 730  : 	case INI_PARAM_EXIT_LEVEL:
; 731  : 		success = getIniFileArgumentInt(&result, iniarg, 0, 1);

  002ae	44 8b cf	 mov	 r9d, edi
  002b1	48 8d 4c 24 30	 lea	 rcx, QWORD PTR result$[rsp]
  002b6	45 33 c0	 xor	 r8d, r8d
  002b9	e8 00 00 00 00	 call	 getIniFileArgumentInt
  002be	8b d8		 mov	 ebx, eax

; 732  : 		if (success)

  002c0	85 c0		 test	 eax, eax
  002c2	74 66		 je	 SHORT $LN2@setIniFile

; 733  : 			ExitLevel = (int_fast8_t)result;

  002c4	8a 44 24 30	 mov	 al, BYTE PTR result$[rsp]
  002c8	88 05 00 00 00
	00		 mov	 BYTE PTR ExitLevel, al

; 734  : 		break;

  002ce	eb 5a		 jmp	 SHORT $LN2@setIniFile
$LN4@setIniFile:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 373  : 	char* dst = _strdup(src);

  002d0	48 8b ca	 mov	 rcx, rdx
  002d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup

; 378  : 	if (!dst) OutOfMemory();

  002d9	48 85 c0	 test	 rax, rax
  002dc	74 59		 je	 SHORT $LN69@setIniFile
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c

; 544  : 		break;

  002de	48 89 05 00 00
	00 00		 mov	 QWORD PTR tapArgument, rax
  002e5	eb 43		 jmp	 SHORT $LN2@setIniFile
$LN15@setIniFile:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 373  : 	char* dst = _strdup(src);

  002e7	48 8b ca	 mov	 rcx, rdx
  002ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup

; 378  : 	if (!dst) OutOfMemory();

  002f0	48 85 c0	 test	 rax, rax
  002f3	74 42		 je	 SHORT $LN69@setIniFile
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c

; 642  : 		ExplicitDataLoad = TRUE;

  002f5	48 89 05 00 00
	00 00		 mov	 QWORD PTR fn_data, rax
  002fc	40 88 3d 00 00
	00 00		 mov	 BYTE PTR ExplicitDataLoad, dil

; 643  : #endif // NO_INTERNAL_DATA
; 644  : 		break;

  00303	eb 25		 jmp	 SHORT $LN2@setIniFile
$LN19@setIniFile:

; 501  : 	return getArgumentBool(result, argument);

  00305	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:StartEmpty

; 657  : 
; 658  : #ifndef NO_CLIENT_LIST
; 659  : 	case INI_PARAM_MAINTAIN_CLIENTS:
; 660  : 		success = getIniFileArgumentBool(&MaintainClients, iniarg);
; 661  : 		break;
; 662  : 
; 663  : 	case INI_PARAM_START_EMPTY:
; 664  : 		success = getIniFileArgumentBool(&StartEmpty, iniarg);
; 665  : 		break;

  0030c	eb 07		 jmp	 SHORT $LN76@setIniFile
$LN18@setIniFile:

; 501  : 	return getArgumentBool(result, argument);

  0030e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:MaintainClients
$LN76@setIniFile:

; 765  : 	}
; 766  : 
; 767  : 	return success;

  00315	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DB@GHHCGCFM@Argument?5must?5be?5true?1on?1yes?11?5@
  0031c	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax
  00323	e8 00 00 00 00	 call	 getArgumentBool
$LN75@setIniFile:
  00328	8b d8		 mov	 ebx, eax
$LN2@setIniFile:
  0032a	8b c3		 mov	 eax, ebx
$LN1@setIniFile:

; 768  : }

  0032c	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00331	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00335	5f		 pop	 rdi
  00336	c3		 ret	 0
$LN69@setIniFile:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 378  : 	if (!dst) OutOfMemory();

  00337	e8 00 00 00 00	 call	 OutOfMemory
  0033c	cc		 int	 3
$LN74@setIniFile:
setIniFileParameter ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT getIniFileArgument
_TEXT	SEGMENT
s$ = 48
getIniFileArgument PROC					; COMDAT

; 772  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 773  : 	while (!isspace((int)**s) && **s != '=' && **s)

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	eb 14		 jmp	 SHORT $LN13@getIniFile
$LL2@getIniFile:
  0000e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00011	8a 01		 mov	 al, BYTE PTR [rcx]
  00013	3c 3d		 cmp	 al, 61			; 0000003dH
  00015	74 18		 je	 SHORT $LN3@getIniFile
  00017	84 c0		 test	 al, al
  00019	74 14		 je	 SHORT $LN3@getIniFile

; 774  : 		(*s)++;

  0001b	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  0001f	48 89 03	 mov	 QWORD PTR [rbx], rax
$LN13@getIniFile:

; 773  : 	while (!isspace((int)**s) && **s != '=' && **s)

  00022	0f be 08	 movsx	 ecx, BYTE PTR [rax]
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isspace
  0002b	85 c0		 test	 eax, eax
  0002d	74 df		 je	 SHORT $LL2@getIniFile
$LN3@getIniFile:

; 775  : 	iniFileLineNextWord(s);

  0002f	48 8b cb	 mov	 rcx, rbx
  00032	e8 00 00 00 00	 call	 iniFileLineNextWord

; 776  : 
; 777  : 	if (*((*s)++) != '=')

  00037	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003a	8a 08		 mov	 cl, BYTE PTR [rax]
  0003c	48 ff c0	 inc	 rax
  0003f	48 89 03	 mov	 QWORD PTR [rbx], rax
  00042	80 f9 3d	 cmp	 cl, 61			; 0000003dH
  00045	74 12		 je	 SHORT $LN4@getIniFile

; 778  : 	{
; 779  : 		IniFileErrorMessage = "'=' required after keyword.";

  00047	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@OKFKNBIN@?8?$DN?8?5required?5after?5keyword?4@
$LN14@getIniFile:

; 792  : }

  0004e	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax
  00055	33 c0		 xor	 eax, eax
  00057	eb 1e		 jmp	 SHORT $LN1@getIniFile
$LN4@getIniFile:

; 780  : 		return FALSE;
; 781  : 	}
; 782  : 
; 783  : 	iniFileLineNextWord(s);

  00059	48 8b cb	 mov	 rcx, rbx
  0005c	e8 00 00 00 00	 call	 iniFileLineNextWord

; 784  : 
; 785  : 	if (!**s)

  00061	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00064	80 38 00	 cmp	 BYTE PTR [rax], 0
  00067	75 09		 jne	 SHORT $LN5@getIniFile

; 786  : 	{
; 787  : 		IniFileErrorMessage = "missing argument after '='.";

  00069	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@MPPMKLEJ@missing?5argument?5after?5?8?$DN?8?4@

; 788  : 		return FALSE;

  00070	eb dc		 jmp	 SHORT $LN14@getIniFile
$LN5@getIniFile:

; 789  : 	}
; 790  : 
; 791  : 	return TRUE;

  00072	b8 01 00 00 00	 mov	 eax, 1
$LN1@getIniFile:

; 792  : }

  00077	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007b	5b		 pop	 rbx
  0007c	c3		 ret	 0
getIniFileArgument ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\kms.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT GetCsvlkIndexFromName
_TEXT	SEGMENT
s$ = 48
GetCsvlkIndexFromName PROC				; COMDAT

; 795  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 796  : 	int8_t i;
; 797  : 
; 798  : 	for (i = 0; i < KmsData->CsvlkCount; i++)

  0000a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR KmsData
  00011	32 db		 xor	 bl, bl
  00013	48 8b f9	 mov	 rdi, rcx
  00016	38 5a 08	 cmp	 BYTE PTR [rdx+8], bl
  00019	76 51		 jbe	 SHORT $LN3@GetCsvlkIn
$LL4@GetCsvlkIn:

; 799  : 	{
; 800  : 		const char *csvlkName = getNextString(KmsData->CsvlkData[i].EPid);

  0001b	48 0f be c3	 movsx	 rax, bl
  0001f	48 c1 e0 05	 shl	 rax, 5
  00023	4c 8b 44 10 48	 mov	 r8, QWORD PTR [rax+rdx+72]
; File C:\Users\dev\source\repos\alpinevms\src\kms.c

; 73   : 	return s + strlen(s) + 1;

  00028	48 83 c8 ff	 or	 rax, -1
$LL15@GetCsvlkIn:
  0002c	48 ff c0	 inc	 rax
  0002f	41 80 3c 00 00	 cmp	 BYTE PTR [r8+rax], 0
  00034	75 f6		 jne	 SHORT $LL15@GetCsvlkIn
  00036	49 8d 48 01	 lea	 rcx, QWORD PTR [r8+1]
  0003a	48 03 c8	 add	 rcx, rax
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c

; 802  : 		if (!strncasecmp(csvlkName, s, strlen(csvlkName)))

  0003d	49 83 c8 ff	 or	 r8, -1
$LL14@GetCsvlkIn:
  00041	49 ff c0	 inc	 r8
  00044	42 80 3c 01 00	 cmp	 BYTE PTR [rcx+r8], 0
  00049	75 f6		 jne	 SHORT $LL14@GetCsvlkIn
  0004b	48 8b d7	 mov	 rdx, rdi
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00054	85 c0		 test	 eax, eax
  00056	74 21		 je	 SHORT $LN10@GetCsvlkIn

; 796  : 	int8_t i;
; 797  : 
; 798  : 	for (i = 0; i < KmsData->CsvlkCount; i++)

  00058	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR KmsData
  0005f	fe c3		 inc	 bl
  00061	0f be c3	 movsx	 eax, bl
  00064	0f b6 4a 08	 movzx	 ecx, BYTE PTR [rdx+8]
  00068	3b c1		 cmp	 eax, ecx
  0006a	7c af		 jl	 SHORT $LL4@GetCsvlkIn
$LN3@GetCsvlkIn:

; 805  : 		}
; 806  : 	}
; 807  : 
; 808  : 	return -1;

  0006c	b0 ff		 mov	 al, -1
$LN1@GetCsvlkIn:

; 809  : }

  0006e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
$LN10@GetCsvlkIn:

; 803  : 		{
; 804  : 			return i;

  00079	8a c3		 mov	 al, bl
  0007b	eb f1		 jmp	 SHORT $LN1@GetCsvlkIn
GetCsvlkIndexFromName ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT handleIniFileEpidParameter
_TEXT	SEGMENT
s$ = 64
allowIniFileDirectives$ = 72
ePidSource$ = 80
handleIniFileEpidParameter PROC				; COMDAT

; 812  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00007	48 89 68 18	 mov	 QWORD PTR [rax+24], rbp
  0000b	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  0000f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00013	57		 push	 rdi
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 813  : 	int_fast16_t i;
; 814  : 
; 815  : 	if (allowIniFileDirectives)

  0001c	33 db		 xor	 ebx, ebx
  0001e	4d 8b f8	 mov	 r15, r8
  00021	44 8a f2	 mov	 r14b, dl
  00024	48 8b e9	 mov	 rbp, rcx
  00027	84 d2		 test	 dl, dl
  00029	74 31		 je	 SHORT $LN3@handleIniF

; 816  : 	{
; 817  : 		for (i = 0; i < (int_fast16_t)vlmcsd_countof(IniFileParameterList); i++)

  0002b	8b fb		 mov	 edi, ebx
  0002d	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:IniFileParameterList
$LL4@handleIniF:

; 818  : 		{
; 819  : 			if (!strncasecmp(IniFileParameterList[i].Name, s, strlen(IniFileParameterList[i].Name)))

  00034	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00037	49 83 c8 ff	 or	 r8, -1
$LL20@handleIniF:
  0003b	49 ff c0	 inc	 r8
  0003e	42 38 1c 01	 cmp	 BYTE PTR [rcx+r8], bl
  00042	75 f7		 jne	 SHORT $LL20@handleIniF
  00044	48 8b d5	 mov	 rdx, rbp
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0004d	85 c0		 test	 eax, eax
  0004f	74 5d		 je	 SHORT $LN10@handleIniF

; 816  : 	{
; 817  : 		for (i = 0; i < (int_fast16_t)vlmcsd_countof(IniFileParameterList); i++)

  00051	ff c7		 inc	 edi
  00053	48 83 c6 10	 add	 rsi, 16
  00057	83 ff 18	 cmp	 edi, 24
  0005a	7c d8		 jl	 SHORT $LL4@handleIniF
$LN3@handleIniF:

; 820  : 			{
; 821  : 				return TRUE;
; 822  : 			}
; 823  : 		}
; 824  : 	}
; 825  : 
; 826  : 	i = GetCsvlkIndexFromName(s);

  0005c	48 8b cd	 mov	 rcx, rbp
  0005f	e8 00 00 00 00	 call	 GetCsvlkIndexFromName
  00064	0f be f8	 movsx	 edi, al

; 827  : 
; 828  : 	if (i >= 0)

  00067	84 c0		 test	 al, al
  00069	78 4a		 js	 SHORT $LN7@handleIniF

; 829  : 	{
; 830  : 		if (!getIniFileArgument(&s))

  0006b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00070	e8 00 00 00 00	 call	 getIniFileArgument
  00075	85 c0		 test	 eax, eax
  00077	74 4a		 je	 SHORT $LN17@handleIniF

; 831  : 			return FALSE;
; 832  : 		if (!setEpidFromIniFileLine(&s, i, ePidSource, !allowIniFileDirectives))

  00079	45 84 f6	 test	 r14b, r14b
  0007c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00081	4d 8b c7	 mov	 r8, r15
  00084	8b d7		 mov	 edx, edi
  00086	40 0f 94 c6	 sete	 sil
  0008a	44 8a ce	 mov	 r9b, sil
  0008d	e8 00 00 00 00	 call	 setEpidFromIniFileLine
  00092	85 c0		 test	 eax, eax
  00094	74 2d		 je	 SHORT $LN17@handleIniF

; 833  : 			return FALSE;
; 834  : 		if (!setHwIdFromIniFileLine(&s, i, !allowIniFileDirectives))

  00096	44 8a c6	 mov	 r8b, sil
  00099	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  0009e	8b d7		 mov	 edx, edi
  000a0	e8 00 00 00 00	 call	 setHwIdFromIniFileLine
  000a5	85 c0		 test	 eax, eax
  000a7	0f 95 c3	 setne	 bl
  000aa	8b c3		 mov	 eax, ebx
  000ac	eb 17		 jmp	 SHORT $LN1@handleIniF
$LN10@handleIniF:

; 835  : 			return FALSE;
; 836  : 		return TRUE;

  000ae	b8 01 00 00 00	 mov	 eax, 1
  000b3	eb 10		 jmp	 SHORT $LN1@handleIniF
$LN7@handleIniF:

; 837  : 	}
; 838  : 
; 839  : 	IniFileErrorMessage = "Unknown keyword.";

  000b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BB@MJCPHOFN@Unknown?5keyword?4@
  000bc	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax
$LN17@handleIniF:

; 840  : 	return FALSE;
; 841  : }

  000c3	33 c0		 xor	 eax, eax
$LN1@handleIniF:
  000c5	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000ca	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000cf	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  000d4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d8	41 5f		 pop	 r15
  000da	41 5e		 pop	 r14
  000dc	5f		 pop	 rdi
  000dd	c3		 ret	 0
handleIniFileEpidParameter ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT ignoreIniFileParameter
_TEXT	SEGMENT
iniFileParameterId$ = 8
ignoreIniFileParameter PROC				; COMDAT

; 848  : 	uint_fast8_t i;
; 849  : 
; 850  : 	for (i = 0; i < vlmcsd_countof(IniFileParameterList); i++)

  00000	32 c0		 xor	 al, al
$LL4@ignoreIniF:

; 851  : 	{
; 852  : 		if (IniFileParameterList[i].Id != iniFileParameterId)

  00002	0f b6 d0	 movzx	 edx, al
  00005	4c 8d 05 08 00
	00 00		 lea	 r8, OFFSET FLAT:IniFileParameterList+8
  0000c	48 03 d2	 add	 rdx, rdx
  0000f	41 38 0c d0	 cmp	 BYTE PTR [r8+rdx*8], cl
  00013	74 07		 je	 SHORT $LN5@ignoreIniF

; 848  : 	uint_fast8_t i;
; 849  : 
; 850  : 	for (i = 0; i < vlmcsd_countof(IniFileParameterList); i++)

  00015	fe c0		 inc	 al
  00017	3c 18		 cmp	 al, 24
  00019	72 e7		 jb	 SHORT $LL4@ignoreIniF

; 855  : 		break;
; 856  : 	}
; 857  : }

  0001b	c3		 ret	 0
$LN5@ignoreIniF:

; 853  : 			continue;
; 854  : 		IniFileParameterList[i].Id = 0;

  0001c	41 c6 04 d0 00	 mov	 BYTE PTR [r8+rdx*8], 0

; 855  : 		break;
; 856  : 	}
; 857  : }

  00021	c3		 ret	 0
ignoreIniFileParameter ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT handleIniFileParameter
_TEXT	SEGMENT
s$ = 48
handleIniFileParameter PROC				; COMDAT

; 864  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00007	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000b	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  0000f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00013	41 57		 push	 r15
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	48 8b f1	 mov	 rsi, rcx

; 865  : 	uint_fast8_t i;
; 866  : 
; 867  : 	for (i = 0; i < vlmcsd_countof(IniFileParameterList); i++)

  0001c	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:IniFileParameterList
  00023	32 db		 xor	 bl, bl
$LL4@handleIniF:

; 868  : 	{
; 869  : 		if (strncasecmp(IniFileParameterList[i].Name, s, strlen(IniFileParameterList[i].Name)))

  00025	0f b6 fb	 movzx	 edi, bl
  00028	48 03 ff	 add	 rdi, rdi
  0002b	49 83 c8 ff	 or	 r8, -1
  0002f	49 8b 0c ff	 mov	 rcx, QWORD PTR [r15+rdi*8]
$LL13@handleIniF:
  00033	49 ff c0	 inc	 r8
  00036	42 80 3c 01 00	 cmp	 BYTE PTR [rcx+r8], 0
  0003b	75 f6		 jne	 SHORT $LL13@handleIniF
  0003d	48 8b d6	 mov	 rdx, rsi
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00046	85 c0		 test	 eax, eax
  00048	74 11		 je	 SHORT $LN5@handleIniF

; 865  : 	uint_fast8_t i;
; 866  : 
; 867  : 	for (i = 0; i < vlmcsd_countof(IniFileParameterList); i++)

  0004a	fe c3		 inc	 bl
  0004c	80 fb 18	 cmp	 bl, 24
  0004f	72 d4		 jb	 SHORT $LL4@handleIniF

; 877  : 	}
; 878  : 
; 879  : 	IniFileErrorMessage = NULL;

  00051	48 83 25 00 00
	00 00 00	 and	 QWORD PTR IniFileErrorMessage, 0

; 880  : 	return TRUE;

  00059	eb 08		 jmp	 SHORT $LN14@handleIniF
$LN5@handleIniF:

; 870  : 			continue;
; 871  : 		if (!IniFileParameterList[i].Id)

  0005b	41 80 7c ff 08
	00		 cmp	 BYTE PTR [r15+rdi*8+8], 0
  00061	75 07		 jne	 SHORT $LN6@handleIniF
$LN14@handleIniF:

; 881  : }

  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	eb 1d		 jmp	 SHORT $LN1@handleIniF
$LN6@handleIniF:

; 872  : 			return TRUE;
; 873  : 		if (!getIniFileArgument(&s))

  0006a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0006f	e8 00 00 00 00	 call	 getIniFileArgument
  00074	85 c0		 test	 eax, eax
  00076	74 0f		 je	 SHORT $LN1@handleIniF
$LN7@handleIniF:

; 874  : 			return FALSE;
; 875  : 
; 876  : 		return setIniFileParameter(IniFileParameterList[i].Id, s);

  00078	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$[rsp]
  0007d	41 8a 4c ff 08	 mov	 cl, BYTE PTR [r15+rdi*8+8]
  00082	e8 00 00 00 00	 call	 setIniFileParameter
$LN1@handleIniF:

; 881  : }

  00087	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0008c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00091	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00096	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009a	41 5f		 pop	 r15
  0009c	c3		 ret	 0
handleIniFileParameter ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT setupListeningSocketsFromIniFile
_TEXT	SEGMENT
s$ = 48
setupListeningSocketsFromIniFile PROC			; COMDAT

; 885  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 886  : 	if (!maxsockets)

  00009	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR maxsockets, 0
  00010	74 61		 je	 SHORT $LN6@setupListe

; 887  : 		return TRUE;
; 888  : 	if (strncasecmp("Listen", s, 6))

  00012	48 8b d1	 mov	 rdx, rcx
  00015	41 b8 06 00 00
	00		 mov	 r8d, 6
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06CBIOIDCI@Listen@
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00028	85 c0		 test	 eax, eax
  0002a	75 47		 jne	 SHORT $LN6@setupListe

; 889  : 		return TRUE;
; 890  : 	if (!getIniFileArgument(&s))

  0002c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00031	e8 00 00 00 00	 call	 getIniFileArgument
  00036	85 c0		 test	 eax, eax
  00038	74 39		 je	 SHORT $LN6@setupListe

; 892  : 
; 893  : 	vlmcsd_snprintf(IniFileErrorBuffer, INIFILE_ERROR_BUFFERSIZE, "Cannot listen on %s.", s);

  0003a	4c 8b 4c 24 30	 mov	 r9, QWORD PTR s$[rsp]
  0003f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BF@GAGAHLAN@Cannot?5listen?5on?5?$CFs?4@
  00046	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR IniFileErrorBuffer
  0004d	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00052	e8 00 00 00 00	 call	 _snprintf

; 894  : 	IniFileErrorMessage = IniFileErrorBuffer;

  00057	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR IniFileErrorBuffer

; 895  : 	return addListeningSocket(s);

  0005e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax

; 896  : }

  0006a	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 895  : 	return addListeningSocket(s);

  0006e	e9 00 00 00 00	 jmp	 addListeningSocket
$LN6@setupListe:

; 891  : 		return TRUE;

  00073	b8 01 00 00 00	 mov	 eax, 1

; 896  : }

  00078	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007c	c3		 ret	 0
setupListeningSocketsFromIniFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT readIniFile
_TEXT	SEGMENT
line$ = 48
pass$ = 320
s$ = 328
readIniFile PROC					; COMDAT

; 900  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 30 01
	00 00		 sub	 rsp, 304		; 00000130H
  00017	40 8a f9	 mov	 dil, cl
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  0001a	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 366  : 	if (!buf) OutOfMemory();

  00025	33 ed		 xor	 ebp, ebp
  00027	48 85 c0	 test	 rax, rax
  0002a	0f 84 8b 01 00
	00		 je	 $LN49@readIniFil
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c

; 911  : 	if (!((f = fopen(fn_ini, "r"))))

  00030	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fn_ini
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01KDCPPGHE@r@
  0003e	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorBuffer, rax
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  0004b	48 8b f0	 mov	 rsi, rax
  0004e	48 85 c0	 test	 rax, rax
  00051	0f 84 49 01 00
	00		 je	 $LN18@readIniFil

; 912  : 		return FALSE;
; 913  : 
; 914  : 	for (lineNumber = 1; (s = fgets(line, sizeof(line), f)); lineNumber++)

  00057	8d 5d 01	 lea	 ebx, QWORD PTR [rbp+1]
  0005a	e9 c1 00 00 00	 jmp	 $LN46@readIniFil
$LL4@readIniFil:

; 915  : 	{
; 916  : 		size_t i;
; 917  : 
; 918  : 		for (i = strlen(line); i > 0; i--)

  0005f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR line$[rsp]
  00064	48 83 c8 ff	 or	 rax, -1
$LL42@readIniFil:
  00068	48 ff c0	 inc	 rax
  0006b	40 38 2c 01	 cmp	 BYTE PTR [rcx+rax], bpl
  0006f	75 f7		 jne	 SHORT $LL42@readIniFil
  00071	48 85 c0	 test	 rax, rax
  00074	74 18		 je	 SHORT $LN31@readIniFil
  00076	48 8d 4c 04 2f	 lea	 rcx, QWORD PTR line$[rsp+rax-1]
$LL7@readIniFil:

; 919  : 		{
; 920  : 			if (line[i - 1] != 0xd && line[i - 1] != 0xa)

  0007b	80 39 0d	 cmp	 BYTE PTR [rcx], 13
  0007e	74 05		 je	 SHORT $LN5@readIniFil
  00080	80 39 0a	 cmp	 BYTE PTR [rcx], 10
  00083	75 09		 jne	 SHORT $LN31@readIniFil
$LN5@readIniFil:

; 915  : 	{
; 916  : 		size_t i;
; 917  : 
; 918  : 		for (i = strlen(line); i > 0; i--)

  00085	48 ff c9	 dec	 rcx
  00088	48 83 e8 01	 sub	 rax, 1
  0008c	75 ed		 jne	 SHORT $LL7@readIniFil
$LN31@readIniFil:

; 921  : 			{
; 922  : 				break;
; 923  : 			}
; 924  : 		}
; 925  : 
; 926  : 		line[i] = 0;
; 927  : 
; 928  : 		iniFileLineNextWord(&s);

  0008e	48 8d 8c 24 48
	01 00 00	 lea	 rcx, QWORD PTR s$[rsp]
  00096	40 88 6c 04 30	 mov	 BYTE PTR line$[rsp+rax], bpl
  0009b	e8 00 00 00 00	 call	 iniFileLineNextWord

; 929  : 		if (*s == ';' || *s == '#' || !*s)

  000a0	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000a8	80 39 3b	 cmp	 BYTE PTR [rcx], 59	; 0000003bH
  000ab	77 14		 ja	 SHORT $LN40@readIniFil
  000ad	48 0f be 01	 movsx	 rax, BYTE PTR [rcx]
  000b1	48 ba 01 00 00
	00 08 00 00 08	 mov	 rdx, 576460786663161857	; 0800000800000001H
  000bb	48 0f a3 c2	 bt	 rdx, rax
  000bf	72 5d		 jb	 SHORT $LN2@readIniFil
$LN40@readIniFil:

; 930  : 			continue;
; 931  : 
; 932  : 		if (pass == INI_FILE_PASS_1)

  000c1	40 80 ff 01	 cmp	 dil, 1
  000c5	75 07		 jne	 SHORT $LN12@readIniFil

; 933  : 		{
; 934  : 			if (handleIniFileParameter(s))

  000c7	e8 00 00 00 00	 call	 handleIniFileParameter

; 935  : 				continue;
; 936  : 			lineParseError = TRUE;
; 937  : 		}

  000cc	eb 25		 jmp	 SHORT $LN47@readIniFil
$LN12@readIniFil:

; 938  : 		else if (pass == INI_FILE_PASS_2)

  000ce	40 80 ff 02	 cmp	 dil, 2
  000d2	75 10		 jne	 SHORT $LN15@readIniFil

; 939  : 		{
; 940  : 			if (handleIniFileEpidParameter(s, TRUE, fn_ini))

  000d4	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR fn_ini
  000db	b2 01		 mov	 dl, 1
  000dd	e8 00 00 00 00	 call	 handleIniFileEpidParameter

; 941  : 				continue;
; 942  : 			lineParseError = TRUE;
; 943  : 		}

  000e2	eb 0f		 jmp	 SHORT $LN47@readIniFil
$LN15@readIniFil:

; 944  : #if !defined(NO_SOCKETS) && !defined(SIMPLE_SOCKETS) && !defined(USE_MSRPC)
; 945  : 		else if (pass == INI_FILE_PASS_3)

  000e4	40 80 ff 03	 cmp	 dil, 3
  000e8	0f 85 b2 00 00
	00		 jne	 $LN18@readIniFil

; 946  : 		{
; 947  : 			lineParseError = !setupListeningSocketsFromIniFile(s);

  000ee	e8 00 00 00 00	 call	 setupListeningSocketsFromIniFile
$LN47@readIniFil:

; 952  : 		}
; 953  : #endif // !defined(NO_SOCKETS) &&  && !defined(SIMPLE_SOCKETS) && !defined(USE_MSRPC)
; 954  : 
; 955  : 		if (lineParseError)
; 956  : 		{
; 957  : 			printerrorf("Warning: %s line %u: \"%s\". %s\n", fn_ini, lineNumber, line, IniFileErrorMessage);

  000f3	85 c0		 test	 eax, eax
  000f5	75 27		 jne	 SHORT $LN2@readIniFil
  000f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR IniFileErrorMessage
  000fe	4c 8d 4c 24 30	 lea	 r9, QWORD PTR line$[rsp]
  00103	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR fn_ini
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@LIEMBDLF@Warning?3?5?$CFs?5line?5?$CFu?3?5?$CC?$CFs?$CC?4?5?$CFs?6@
  00111	44 8b c3	 mov	 r8d, ebx
  00114	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00119	e8 00 00 00 00	 call	 printerrorf
$LN2@readIniFil:

; 912  : 		return FALSE;
; 913  : 
; 914  : 	for (lineNumber = 1; (s = fgets(line, sizeof(line), f)); lineNumber++)

  0011e	ff c3		 inc	 ebx
$LN46@readIniFil:
  00120	4c 8b c6	 mov	 r8, rsi
  00123	48 8d 4c 24 30	 lea	 rcx, QWORD PTR line$[rsp]
  00128	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets
  00133	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR s$[rsp], rax
  0013b	48 85 c0	 test	 rax, rax
  0013e	0f 85 1b ff ff
	ff		 jne	 $LL4@readIniFil

; 958  : 			continue;
; 959  : 		}
; 960  : 	}
; 961  : 
; 962  : 	if (ferror(f))

  00144	48 8b ce	 mov	 rcx, rsi
  00147	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ferror

; 963  : 		result = FALSE;
; 964  : 
; 965  : 	free(IniFileErrorBuffer);

  0014d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR IniFileErrorBuffer
  00154	bb 01 00 00 00	 mov	 ebx, 1
  00159	85 c0		 test	 eax, eax
  0015b	0f 45 dd	 cmovne	 ebx, ebp
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 966  : 	fclose(f);

  00164	48 8b ce	 mov	 rcx, rsi
  00167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 967  : 
; 968  : #if !defined(NO_SOCKETS) && !defined(NO_LOG)
; 969  : 
; 970  : 	if (pass == INI_FILE_PASS_1 && !InetdMode && result)

  0016d	40 80 ff 01	 cmp	 dil, 1
  00171	75 29		 jne	 SHORT $LN23@readIniFil
  00173	40 38 2d 00 00
	00 00		 cmp	 BYTE PTR InetdMode, bpl
  0017a	75 20		 jne	 SHORT $LN23@readIniFil
  0017c	85 db		 test	 ebx, ebx
  0017e	74 1c		 je	 SHORT $LN23@readIniFil

; 971  : 	{
; 972  : #ifdef _NTSERVICE
; 973  : 		if (!installService)

  00180	40 38 2d 00 00
	00 00		 cmp	 BYTE PTR installService, bpl
  00187	75 13		 jne	 SHORT $LN23@readIniFil

; 974  : #endif // _NTSERVICE
; 975  : 			logger("Read ini file %s\n", fn_ini);

  00189	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR fn_ini
  00190	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@DOBMPJAF@Read?5ini?5file?5?$CFs?6@
  00197	e8 00 00 00 00	 call	 logger
$LN23@readIniFil:

; 976  : 	}
; 977  : 
; 978  : #endif // !defined(NO_SOCKETS) && !defined(NO_LOG)
; 979  : 
; 980  : 	return result;

  0019c	8b c3		 mov	 eax, ebx
  0019e	eb 02		 jmp	 SHORT $LN1@readIniFil
$LN18@readIniFil:

; 948  : 		}
; 949  : 		else
; 950  : 		{
; 951  : 			return FALSE;

  001a0	33 c0		 xor	 eax, eax
$LN1@readIniFil:

; 981  : }

  001a2	4c 8d 9c 24 30
	01 00 00	 lea	 r11, QWORD PTR [rsp+304]
  001aa	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  001ae	49 8b 6b 20	 mov	 rbp, QWORD PTR [r11+32]
  001b2	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  001b6	49 8b e3	 mov	 rsp, r11
  001b9	5f		 pop	 rdi
  001ba	c3		 ret	 0
$LN49@readIniFil:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 366  : 	if (!buf) OutOfMemory();

  001bb	e8 00 00 00 00	 call	 OutOfMemory
  001c0	cc		 int	 3
$LN44@readIniFil:
readIniFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT terminationHandler
_TEXT	SEGMENT
fdwCtrlType$ = 48
terminationHandler PROC					; COMDAT

; 1100 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1101 : 	// What a lame substitute for Unix signal handling
; 1102 : 	switch (fdwCtrlType)

  00004	85 c9		 test	 ecx, ecx
  00006	74 1b		 je	 SHORT $LN4@terminatio
  00008	83 e9 01	 sub	 ecx, 1
  0000b	74 16		 je	 SHORT $LN4@terminatio
  0000d	83 e9 01	 sub	 ecx, 1
  00010	74 11		 je	 SHORT $LN4@terminatio
  00012	83 e9 03	 sub	 ecx, 3
  00015	74 0c		 je	 SHORT $LN4@terminatio
  00017	83 f9 01	 cmp	 ecx, 1
  0001a	74 07		 je	 SHORT $LN4@terminatio

; 1111 : 	default:
; 1112 : 		return FALSE;

  0001c	33 c0		 xor	 eax, eax

; 1113 : 	}
; 1114 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
$LN4@terminatio:

; 1103 : 	{
; 1104 : 	case CTRL_C_EVENT:
; 1105 : 	case CTRL_CLOSE_EVENT:
; 1106 : 	case CTRL_BREAK_EVENT:
; 1107 : 	case CTRL_LOGOFF_EVENT:
; 1108 : 	case CTRL_SHUTDOWN_EVENT:
; 1109 : 		cleanup();

  00023	e8 00 00 00 00	 call	 cleanup

; 1110 : 		exit(0);

  00028	33 c9		 xor	 ecx, ecx
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00030	cc		 int	 3
$LN11@terminatio:
terminationHandler ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT daemonizeAndSetSignalAction
_TEXT	SEGMENT
daemonizeAndSetSignalAction PROC			; COMDAT

; 1117 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1118 : 	if (!SetConsoleCtrlHandler((PHANDLER_ROUTINE)terminationHandler, TRUE))

  00004	ba 01 00 00 00	 mov	 edx, 1
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:terminationHandler
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleCtrlHandler
  00016	85 c0		 test	 eax, eax
  00018	75 14		 jne	 SHORT $LN2@daemonizeA

; 1119 : 	{
; 1120 : #ifndef NO_LOG
; 1121 : 		const DWORD rc = GetLastError();

  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 1122 : 		logger("Warning: Could not register Windows signal handler: Error %u\n", rc);

  00020	8b d0		 mov	 edx, eax
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DO@FOGLIAKA@Warning?3?5Could?5not?5register?5Win@
  00029	e8 00 00 00 00	 call	 logger
$LN2@daemonizeA:

; 1123 : #endif // NO_LOG
; 1124 : 	}
; 1125 : 
; 1126 : 	return ERROR_SUCCESS;

  0002e	33 c0		 xor	 eax, eax

; 1127 : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
daemonizeAndSetSignalAction ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT getCommandLineArg
_TEXT	SEGMENT
arg$dead$ = 8
getCommandLineArg PROC					; COMDAT

; 1136 : #if !__CYGWIN__ || defined(USE_THREADS) || defined(NO_SOCKETS)
; 1137 : 	return arg;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg

; 1138 : #else
; 1139 : 	if (!IsNTService)
; 1140 : 		return arg;
; 1141 : 
; 1142 : 	return vlmcsd_strdup(arg);
; 1143 : #endif
; 1144 : }

  00007	c3		 ret	 0
getCommandLineArg ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT parseGeneralArguments
_TEXT	SEGMENT
parseGeneralArguments PROC				; COMDAT

; 1148 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN94@parseGener:

; 1152 : 		switch (o)

  00004	e8 00 00 00 00	 call	 getopt
  00009	8b c8		 mov	 ecx, eax
  0000b	85 c0		 test	 eax, eax
  0000d	0f 8e 93 04 00
	00		 jle	 $LN86@parseGener
  00013	83 f8 61	 cmp	 eax, 97			; 00000061H
  00016	0f 87 6e 02 00
	00		 ja	 $LN59@parseGener
  0001c	74 e6		 je	 SHORT $LN94@parseGener
  0001e	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00021	0f 87 4e 01 00
	00		 ja	 $LN60@parseGener
  00027	0f 84 1f 01 00
	00		 je	 $LN48@parseGener
  0002d	83 e9 41	 sub	 ecx, 65			; 00000041H
  00030	0f 84 02 01 00
	00		 je	 $LN45@parseGener
  00036	83 e9 01	 sub	 ecx, 1
  00039	0f 84 d7 00 00
	00		 je	 $LN50@parseGener
  0003f	83 e9 01	 sub	 ecx, 1
  00042	0f 84 b1 00 00
	00		 je	 $LN42@parseGener
  00048	83 e9 01	 sub	 ecx, 1
  0004b	74 b7		 je	 SHORT $LN94@parseGener
  0004d	83 e9 01	 sub	 ecx, 1
  00050	0f 84 81 00 00
	00		 je	 $LN35@parseGener
  00056	83 e9 03	 sub	 ecx, 3
  00059	74 5f		 je	 SHORT $LN43@parseGener
  0005b	83 e9 03	 sub	 ecx, 3
  0005e	74 3d		 je	 SHORT $LN32@parseGener
  00060	83 e9 01	 sub	 ecx, 1
  00063	74 2b		 je	 SHORT $LN24@parseGener
  00065	83 f9 01	 cmp	 ecx, 1
  00068	0f 85 6a 04 00
	00		 jne	 $LN84@parseGener

; 1351 : 
; 1352 : 		case 'M':
; 1353 : 			if (!getArgumentBool(&MaintainClients, optarg))

  0006e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR optarg
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:MaintainClients
  0007c	e8 00 00 00 00	 call	 getArgumentBool
  00081	85 c0		 test	 eax, eax
  00083	0f 84 4f 04 00
	00		 je	 $LN84@parseGener

; 1354 : 				usage();
; 1355 : 			ignoreIniFileParameter(INI_PARAM_MAINTAIN_CLIENTS);

  00089	b1 1a		 mov	 cl, 26

; 1356 : 			break;

  0008b	e9 0c 04 00 00	 jmp	 $LN92@parseGener
$LN24@parseGener:

; 1291 : #endif // !defined(NO_PRIVATE_IP_DETECT)
; 1292 : 
; 1293 : #ifndef NO_SOCKETS
; 1294 : #if !defined(USE_MSRPC) && !defined(SIMPLE_SOCKETS)
; 1295 : 		case 'L':
; 1296 : 			maxsockets++;

  00090	fe 05 00 00 00
	00		 inc	 BYTE PTR maxsockets
$LN93@parseGener:

; 1149 : 	int o;
; 1150 : 
; 1151 : 	for (opterr = 0; (o = getopt(global_argc, (char *const *)global_argv, (const char *)optstring)) > 0;)

  00096	b1 03		 mov	 cl, 3
  00098	e9 ff 03 00 00	 jmp	 $LN92@parseGener
$LN32@parseGener:

; 1330 : #endif // _NTSERVICE
; 1331 : 
; 1332 : #ifndef NO_STRICT_MODES
; 1333 : 
; 1334 : 		case 'K':
; 1335 : 			WhitelistingLevel = (int_fast8_t)getOptionArgumentInt((char)o, 0, 3);

  0009d	33 d2		 xor	 edx, edx
  0009f	b1 4b		 mov	 cl, 75			; 0000004bH
  000a1	44 8d 42 03	 lea	 r8d, QWORD PTR [rdx+3]
  000a5	e8 00 00 00 00	 call	 getOptionArgumentInt
  000aa	0f be c8	 movsx	 ecx, al
  000ad	89 0d 00 00 00
	00		 mov	 DWORD PTR WhitelistingLevel, ecx

; 1336 : 			ignoreIniFileParameter(INI_PARAM_WHITELISTING_LEVEL);

  000b3	b1 18		 mov	 cl, 24

; 1337 : 			break;

  000b5	e9 e2 03 00 00	 jmp	 $LN92@parseGener
$LN43@parseGener:

; 1399 : 
; 1400 : 		case 'H':
; 1401 : 			HostBuild = (uint16_t)getOptionArgumentInt((char)o, 0, 0xffff);

  000ba	33 d2		 xor	 edx, edx
  000bc	41 b8 ff ff 00
	00		 mov	 r8d, 65535		; 0000ffffH
  000c2	b1 48		 mov	 cl, 72			; 00000048H
  000c4	e8 00 00 00 00	 call	 getOptionArgumentInt
  000c9	66 89 05 00 00
	00 00		 mov	 WORD PTR HostBuild, ax

; 1402 : 			ignoreIniFileParameter(INI_PARAM_HOST_BUILD);

  000d0	b1 14		 mov	 cl, 20

; 1403 : 			break;

  000d2	e9 c5 03 00 00	 jmp	 $LN92@parseGener
$LN35@parseGener:

; 1344 : 
; 1345 : #ifndef NO_CLIENT_LIST
; 1346 : 		case 'E':
; 1347 : 			if (!getArgumentBool(&StartEmpty, optarg))

  000d7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR optarg
  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:StartEmpty
  000e5	e8 00 00 00 00	 call	 getArgumentBool
  000ea	85 c0		 test	 eax, eax
  000ec	0f 84 e6 03 00
	00		 je	 $LN84@parseGener

; 1348 : 				usage();
; 1349 : 			ignoreIniFileParameter(INI_PARAM_START_EMPTY);

  000f2	b1 1b		 mov	 cl, 27

; 1350 : 			break;

  000f4	e9 a3 03 00 00	 jmp	 $LN92@parseGener
$LN42@parseGener:

; 1385 : 
; 1386 : 		case 'C':
; 1387 : 			Lcid = (uint16_t)getOptionArgumentInt((char)o, 0, 32767);

  000f9	33 d2		 xor	 edx, edx
  000fb	41 b8 ff 7f 00
	00		 mov	 r8d, 32767		; 00007fffH
  00101	b1 43		 mov	 cl, 67			; 00000043H
  00103	e8 00 00 00 00	 call	 getOptionArgumentInt
  00108	66 89 05 00 00
	00 00		 mov	 WORD PTR Lcid, ax

; 1388 : 
; 1389 : 			ignoreIniFileParameter(INI_PARAM_LCID);

  0010f	b1 02		 mov	 cl, 2

; 1390 : 
; 1391 : #ifdef _PEDANTIC
; 1392 : 			if (!IsValidLcid(Lcid))
; 1393 : 			{
; 1394 : 				printerrorf("Warning: %s is not a valid LCID.\n", optarg);
; 1395 : 			}
; 1396 : #endif // _PEDANTIC
; 1397 : 
; 1398 : 			break;

  00111	e9 86 03 00 00	 jmp	 $LN92@parseGener
$LN50@parseGener:

; 1460 : 
; 1461 : 		case 'B':
; 1462 : 			if (!getArgumentBool(&UseServerRpcBTFN, optarg))

  00116	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR optarg
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UseServerRpcBTFN
  00124	e8 00 00 00 00	 call	 getArgumentBool
  00129	85 c0		 test	 eax, eax
  0012b	0f 84 a7 03 00
	00		 je	 $LN84@parseGener

; 1463 : 				usage();
; 1464 : 			ignoreIniFileParameter(INI_PARAM_RPC_BTFN);

  00131	b1 10		 mov	 cl, 16

; 1465 : 			break;

  00133	e9 64 03 00 00	 jmp	 $LN92@parseGener
$LN45@parseGener:

; 1439 : 
; 1440 : 		case 'A':
; 1441 : 			VLActivationInterval = getTimeSpanFromCommandLine(optarg, (char)o);

  00138	b2 41		 mov	 dl, 65			; 00000041H
  0013a	e8 00 00 00 00	 call	 getTimeSpanFromCommandLine
  0013f	89 05 00 00 00
	00		 mov	 DWORD PTR VLActivationInterval, eax

; 1442 : 			ignoreIniFileParameter(INI_PARAM_ACTIVATION_INTERVAL);

  00145	b1 09		 mov	 cl, 9

; 1443 : 			break;

  00147	e9 50 03 00 00	 jmp	 $LN92@parseGener
$LN48@parseGener:

; 1452 : 
; 1453 : #ifndef SIMPLE_RPC
; 1454 : 		case 'N':
; 1455 : 			if (!getArgumentBool(&UseServerRpcNDR64, optarg))

  0014c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR optarg
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UseServerRpcNDR64
  0015a	e8 00 00 00 00	 call	 getArgumentBool
  0015f	85 c0		 test	 eax, eax
  00161	0f 84 71 03 00
	00		 je	 $LN84@parseGener

; 1456 : 				usage();
; 1457 : 			IsNDR64Defined = TRUE;

  00167	c6 05 00 00 00
	00 01		 mov	 BYTE PTR IsNDR64Defined, 1

; 1458 : 			ignoreIniFileParameter(INI_PARAM_RPC_NDR64);

  0016e	b1 0f		 mov	 cl, 15

; 1459 : 			break;

  00170	e9 27 03 00 00	 jmp	 $LN92@parseGener
$LN60@parseGener:

; 1152 : 		switch (o)

  00175	83 e9 4f	 sub	 ecx, 79			; 0000004fH
  00178	0f 84 f2 00 00
	00		 je	 $LN7@parseGener
  0017e	83 e9 01	 sub	 ecx, 1
  00181	0f 84 dd 00 00
	00		 je	 $LN11@parseGener
  00187	83 e9 02	 sub	 ecx, 2
  0018a	0f 84 c0 00 00
	00		 je	 $LN44@parseGener
  00190	83 e9 01	 sub	 ecx, 1
  00193	0f 84 9e 00 00
	00		 je	 $LN30@parseGener
  00199	83 e9 01	 sub	 ecx, 1
  0019c	74 77		 je	 SHORT $LN17@parseGener
  0019e	83 e9 01	 sub	 ecx, 1
  001a1	74 5f		 je	 SHORT $LN25@parseGener
  001a3	83 e9 01	 sub	 ecx, 1
  001a6	74 1c		 je	 SHORT $LN52@parseGener
  001a8	83 f9 01	 cmp	 ecx, 1
  001ab	0f 85 27 03 00
	00		 jne	 $LN84@parseGener

; 1312 : 
; 1313 : 		case 'W':
; 1314 : 			ServicePassword = optarg;

  001b1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg
  001b8	48 89 05 00 00
	00 00		 mov	 QWORD PTR ServicePassword, rax

; 1315 : 			break;

  001bf	e9 40 fe ff ff	 jmp	 $LN94@parseGener
$LN52@parseGener:

; 1466 : #endif // !SIMPLE_RPC
; 1467 : #endif // !USE_MSRPC
; 1468 : 
; 1469 : #ifndef NO_VERSION_INFORMATION
; 1470 : 		case 'V':
; 1471 : #ifdef _NTSERVICE
; 1472 : 			if (IsNTService)

  001c4	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR IsNTService, 0
  001cb	0f 85 33 fe ff
	ff		 jne	 $LN94@parseGener

; 1473 : 				break;
; 1474 : #endif
; 1475 : #if defined(__s390__) && !defined(__zarch__) && !defined(__s390x__)
; 1476 : 			printf("vlmcsd %s %i-bit\n", Version, sizeof(void *) == 4 ? 31 : (int)sizeof(void *) << 3);
; 1477 : #else
; 1478 : 			printf("vlmcsd %s %i-bit\n", Version, (int)sizeof(void *) << 3);

  001d1	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  001d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@LMFFFEAG@?B?$KJ?5Microsoft?5may?52023@
  001de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@OKDFGCCJ@vlmcsd?5?$CFs?5?$CFi?9bit?6@
  001e5	e8 00 00 00 00	 call	 printf

; 1479 : #endif // defined(__s390__) && !defined(__zarch__) && !defined(__s390x__)
; 1480 : 			printPlatform();

  001ea	e8 00 00 00 00	 call	 printPlatform

; 1481 : 			printCommonFlags();

  001ef	e8 00 00 00 00	 call	 printCommonFlags

; 1482 : 			printServerFlags();

  001f4	e8 00 00 00 00	 call	 printServerFlags

; 1483 : 			exit(0);

  001f9	33 c9		 xor	 ecx, ecx
  001fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00201	cc		 int	 3
$LN25@parseGener:

; 1297 : 			ignoreIniFileParameter(INI_PARAM_LISTEN);
; 1298 : 			break;
; 1299 : #if HAVE_FREEBIND
; 1300 : 		case 'F':
; 1301 : 			if (!getArgumentBool(&freebind, optarg))
; 1302 : 				usage();
; 1303 : 			ignoreIniFileParameter(INI_PARAM_FREEBIND);
; 1304 : 			break;
; 1305 : #endif // HAVE_FREEBIND
; 1306 : #endif // !defined(USE_MSRPC) && !defined(SIMPLE_SOCKETS)
; 1307 : 
; 1308 : #ifdef _NTSERVICE
; 1309 : 		case 'U':
; 1310 : 			ServiceUser = optarg;

  00202	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg
  00209	48 89 05 00 00
	00 00		 mov	 QWORD PTR ServiceUser, rax

; 1311 : 			break;

  00210	e9 ef fd ff ff	 jmp	 $LN94@parseGener
$LN17@parseGener:

; 1249 : #endif
; 1250 : 
; 1251 : #ifndef NO_LOG
; 1252 : 
; 1253 : 		case 'T':
; 1254 : 			if (!getArgumentBool(&LogDateAndTime, optarg))

  00215	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR optarg
  0021c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:LogDateAndTime
  00223	e8 00 00 00 00	 call	 getArgumentBool
  00228	85 c0		 test	 eax, eax
  0022a	0f 84 a8 02 00
	00		 je	 $LN84@parseGener

; 1255 : 				usage();
; 1256 : 			ignoreIniFileParameter(INI_PARAM_LOG_DATE_AND_TIME);

  00230	b1 13		 mov	 cl, 19

; 1257 : 			break;

  00232	e9 65 02 00 00	 jmp	 $LN92@parseGener
$LN30@parseGener:

; 1325 : 
; 1326 : 		case 'S':
; 1327 : 			if (!IsNTService)

  00237	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR IsNTService, 0
  0023e	0f 85 c0 fd ff
	ff		 jne	 $LN94@parseGener

; 1328 : 				installService = 2; // Remove

  00244	c6 05 00 00 00
	00 02		 mov	 BYTE PTR installService, 2

; 1329 : 			break;

  0024b	e9 b4 fd ff ff	 jmp	 $LN94@parseGener
$LN44@parseGener:

; 1404 : #endif // NO_RANDOM_PID
; 1405 : 
; 1406 : #if !defined(NO_USER_SWITCH) && !defined(_WIN32)
; 1407 : 		case 'g':
; 1408 : 			gname = optarg;
; 1409 : 			ignoreIniFileParameter(INI_PARAM_GID);
; 1410 : #ifndef NO_SIGHUP
; 1411 : 			if (!IsRestarted)
; 1412 : #endif // NO_SIGHUP
; 1413 : 				if (GetGid())
; 1414 : 				{
; 1415 : 					printerrorf("Fatal: %s for %s failed: %s\n", "setgid", gname, strerror(errno));
; 1416 : 					exit(errno);
; 1417 : 				}
; 1418 : 			break;
; 1419 : 
; 1420 : 		case 'u':
; 1421 : 			uname = optarg;
; 1422 : 			ignoreIniFileParameter(INI_PARAM_UID);
; 1423 : #ifndef NO_SIGHUP
; 1424 : 			if (!IsRestarted)
; 1425 : #endif // NO_SIGHUP
; 1426 : 				if (GetUid())
; 1427 : 				{
; 1428 : 					printerrorf("Fatal: %s for %s failed: %s\n", "setuid", uname, strerror(errno));
; 1429 : 					exit(errno);
; 1430 : 				}
; 1431 : 			break;
; 1432 : #endif // NO_USER_SWITCH && !_WIN32
; 1433 : 
; 1434 : #ifndef NO_CUSTOM_INTERVALS
; 1435 : 		case 'R':
; 1436 : 			VLRenewalInterval = getTimeSpanFromCommandLine(optarg, (char)o);

  00250	b2 52		 mov	 dl, 82			; 00000052H
  00252	e8 00 00 00 00	 call	 getTimeSpanFromCommandLine
  00257	89 05 00 00 00
	00		 mov	 DWORD PTR VLRenewalInterval, eax

; 1437 : 			ignoreIniFileParameter(INI_PARAM_RENEWAL_INTERVAL);

  0025d	b1 0a		 mov	 cl, 10

; 1438 : 			break;

  0025f	e9 38 02 00 00	 jmp	 $LN92@parseGener
$LN11@parseGener:

; 1195 : 
; 1196 : 		case 'P':
; 1197 : 			ignoreIniFileParameter(INI_PARAM_PORT);

  00264	b1 0e		 mov	 cl, 14
  00266	e8 00 00 00 00	 call	 ignoreIniFileParameter

; 1198 : #if !defined(SIMPLE_SOCKETS) && !defined(USE_MSRPC)
; 1199 : 			ignoreIniFileParameter(INI_PARAM_LISTEN);
; 1200 : #else
; 1201 : 			defaultport = optarg;
; 1202 : #endif // !SIMPLE_SOCKETS
; 1203 : 			break;

  0026b	e9 26 fe ff ff	 jmp	 $LN93@parseGener
$LN7@parseGener:

; 1153 : 		{
; 1154 : #if !defined(NO_SOCKETS) && !defined(NO_SIGHUP) && !defined(_WIN32)
; 1155 : 		case 'Z':
; 1156 : 			IsRestarted = TRUE;
; 1157 : 			nodaemon = TRUE;
; 1158 : 			break;
; 1159 : #endif // !defined(NO_SOCKETS) && !defined(NO_SIGHUP) && !defined(_WIN32)
; 1160 : 
; 1161 : #ifndef NO_TAP
; 1162 : 
; 1163 : 		case 'O':
; 1164 : 			ignoreIniFileParameter(INI_PARAM_VPN);

  00270	b1 1d		 mov	 cl, 29
  00272	e8 00 00 00 00	 call	 ignoreIniFileParameter

; 1165 : 			tapArgument = getCommandLineArg(optarg);

  00277	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR optarg
  0027e	48 89 0d 00 00
	00 00		 mov	 QWORD PTR tapArgument, rcx

; 1166 : 			break;

  00285	e9 7a fd ff ff	 jmp	 $LN94@parseGener
$LN59@parseGener:

; 1152 : 		switch (o)

  0028a	83 f9 6f	 cmp	 ecx, 111		; 0000006fH
  0028d	0f 87 20 01 00
	00		 ja	 $LN61@parseGener
  00293	0f 84 fb 00 00
	00		 je	 $LN23@parseGener
  00299	8b d1		 mov	 edx, ecx
  0029b	83 ea 63	 sub	 edx, 99			; 00000063H
  0029e	0f 84 ce 00 00
	00		 je	 $LN33@parseGener
  002a4	83 ea 01	 sub	 edx, 1
  002a7	0f 84 b4 00 00
	00		 je	 $LN46@parseGener
  002ad	83 ea 01	 sub	 edx, 1
  002b0	0f 84 9f 00 00
	00		 je	 $LN40@parseGener
  002b6	83 ea 04	 sub	 edx, 4
  002b9	74 6c		 je	 SHORT $LN15@parseGener
  002bb	83 ea 01	 sub	 edx, 1
  002be	74 46		 je	 SHORT $LN9@parseGener
  002c0	83 ea 01	 sub	 edx, 1
  002c3	0f 84 98 00 00
	00		 je	 $LN46@parseGener
  002c9	83 ea 01	 sub	 edx, 1
  002cc	74 23		 je	 SHORT $LN19@parseGener
  002ce	83 fa 01	 cmp	 edx, 1
  002d1	0f 85 01 02 00
	00		 jne	 $LN84@parseGener

; 1204 : 
; 1205 : #ifdef LOG_TO_MONGODB
; 1206 : 		case 'X':
; 1207 : 			mongoDbApiURL = optarg;
; 1208 : 			break;
; 1209 : 
; 1210 : 		case 'Y':
; 1211 : 			mongoDbApiKey = optarg;
; 1212 : 			break;
; 1213 : #endif
; 1214 : 
; 1215 : #if !defined(NO_LIMIT) && !__minix__
; 1216 : 
; 1217 : 		case 'm':
; 1218 : #ifdef USE_MSRPC
; 1219 : 			MaxTasks = getOptionArgumentInt(o, 1, RPC_C_LISTEN_MAX_CALLS_DEFAULT);
; 1220 : #else  // !USE_MSRPC
; 1221 : 			MaxTasks = getOptionArgumentInt((char)o, 1, SEM_VALUE_MAX);

  002d7	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  002dd	b1 6d		 mov	 cl, 109			; 0000006dH
  002df	e8 00 00 00 00	 call	 getOptionArgumentInt
  002e4	89 05 00 00 00
	00		 mov	 DWORD PTR MaxTasks, eax

; 1222 : #endif // !USE_MSRPC
; 1223 : 			ignoreIniFileParameter(INI_PARAM_MAX_WORKERS);

  002ea	b1 04		 mov	 cl, 4

; 1224 : 			break;

  002ec	e9 ab 01 00 00	 jmp	 $LN92@parseGener
$LN19@parseGener:

; 1258 : 
; 1259 : 		case 'l':
; 1260 : 			fn_log = getCommandLineArg(optarg);

  002f1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg

; 1261 : 			ignoreIniFileParameter(INI_PARAM_LOG_FILE);

  002f8	b1 07		 mov	 cl, 7
  002fa	48 89 05 00 00
	00 00		 mov	 QWORD PTR fn_log, rax

; 1262 : 			break;

  00301	e9 96 01 00 00	 jmp	 $LN92@parseGener
$LN9@parseGener:

; 1167 : 
; 1168 : #endif // NO_TAP
; 1169 : 
; 1170 : #ifndef NO_CL_PIDS
; 1171 : 
; 1172 : 		case 'a':
; 1173 : 			break;
; 1174 : 
; 1175 : #endif // NO_CL_PIDS
; 1176 : 
; 1177 : #ifndef NO_EXTERNAL_DATA
; 1178 : 
; 1179 : 		case 'j':
; 1180 : 			ignoreIniFileParameter(INI_PARAM_DATA_FILE);

  00306	b1 1c		 mov	 cl, 28
  00308	e8 00 00 00 00	 call	 ignoreIniFileParameter

; 1181 : 			fn_data = getCommandLineArg(optarg);

  0030d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR optarg
  00314	48 89 0d 00 00
	00 00		 mov	 QWORD PTR fn_data, rcx

; 1182 : #ifndef NO_INTERNAL_DATA
; 1183 : 			ExplicitDataLoad = TRUE;

  0031b	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ExplicitDataLoad, 1

; 1184 : #endif // NO_INTERNAL_DATA
; 1185 : 			break;

  00322	e9 dd fc ff ff	 jmp	 $LN94@parseGener
$LN15@parseGener:

; 1240 : 			break;
; 1241 : #endif
; 1242 : 
; 1243 : #ifndef NO_INI_FILE
; 1244 : 		case 'i':
; 1245 : 			fn_ini = getCommandLineArg(optarg);

  00327	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg
  0032e	48 89 05 00 00
	00 00		 mov	 QWORD PTR fn_ini, rax

; 1246 : 			if (!strcmp(fn_ini, "-"))

  00335	80 38 2d	 cmp	 BYTE PTR [rax], 45	; 0000002dH
  00338	0f 85 c6 fc ff
	ff		 jne	 $LN94@parseGener
  0033e	80 78 01 00	 cmp	 BYTE PTR [rax+1], 0
  00342	0f 85 bc fc ff
	ff		 jne	 $LN94@parseGener

; 1247 : 				fn_ini = NULL;

  00348	48 83 25 00 00
	00 00 00	 and	 QWORD PTR fn_ini, 0

; 1248 : 			break;

  00350	e9 af fc ff ff	 jmp	 $LN94@parseGener
$LN40@parseGener:

; 1357 : 
; 1358 : #endif // !NO_CLIENT_LIST
; 1359 : #endif // !NO_STRICT_MODES
; 1360 : 
; 1361 : 		case 'D':
; 1362 : #ifndef _WIN32
; 1363 : 			nodaemon = 1;
; 1364 : #else // _WIN32
; 1365 : #ifdef _PEDANTIC
; 1366 : 			printerrorf("Warning: Option -D has no effect in the Windows version of vlmcsd.\n");
; 1367 : #endif // _PEDANTIC
; 1368 : #endif // _WIN32
; 1369 : 			break;
; 1370 : 
; 1371 : #ifndef NO_LOG
; 1372 : 
; 1373 : 		case 'e':
; 1374 : 			logstdout = 1;

  00355	c6 05 00 00 00
	00 01		 mov	 BYTE PTR logstdout, 1

; 1375 : 			break;

  0035c	e9 a3 fc ff ff	 jmp	 $LN94@parseGener
$LN46@parseGener:

; 1444 : #endif // NO_CUSTOM_INTERVALS
; 1445 : 
; 1446 : #ifndef USE_MSRPC
; 1447 : 		case 'd':
; 1448 : 		case 'k':
; 1449 : 			DisconnectImmediately = o == 'd';

  00361	83 f9 64	 cmp	 ecx, 100		; 00000064H

; 1450 : 			ignoreIniFileParameter(INI_PARAM_DISCONNECT_IMMEDIATELY);

  00364	b1 0b		 mov	 cl, 11
  00366	0f 94 05 00 00
	00 00		 sete	 BYTE PTR DisconnectImmediately

; 1451 : 			break;

  0036d	e9 2a 01 00 00	 jmp	 $LN92@parseGener
$LN33@parseGener:

; 1338 : 
; 1339 : 		case 'c':
; 1340 : 			if (!getArgumentBool(&CheckClientTime, optarg))

  00372	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR optarg
  00379	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CheckClientTime
  00380	e8 00 00 00 00	 call	 getArgumentBool
  00385	85 c0		 test	 eax, eax
  00387	0f 84 4b 01 00
	00		 je	 $LN84@parseGener

; 1341 : 				usage();
; 1342 : 			ignoreIniFileParameter(INI_PARAM_CHECK_CLIENT_TIME);

  0038d	b1 19		 mov	 cl, 25

; 1343 : 			break;

  0038f	e9 08 01 00 00	 jmp	 $LN92@parseGener
$LN23@parseGener:

; 1278 : #endif // NO_MONGOOSE
; 1279 : 
; 1280 : #if !defined(NO_PRIVATE_IP_DETECT)
; 1281 : 		case 'o':
; 1282 : 			ignoreIniFileParameter(INI_PARAM_PUBLIC_IP_PROTECTION_LEVEL);

  00394	b1 12		 mov	 cl, 18
  00396	e8 00 00 00 00	 call	 ignoreIniFileParameter

; 1283 : 			PublicIPProtectionLevel = getOptionArgumentInt((char)o, 0, 3);

  0039b	33 d2		 xor	 edx, edx
  0039d	b1 6f		 mov	 cl, 111			; 0000006fH
  0039f	44 8d 42 03	 lea	 r8d, QWORD PTR [rdx+3]
  003a3	e8 00 00 00 00	 call	 getOptionArgumentInt
  003a8	89 05 00 00 00
	00		 mov	 DWORD PTR PublicIPProtectionLevel, eax

; 1284 : 
; 1285 : #if !HAVE_GETIFADDR
; 1286 : 			if (PublicIPProtectionLevel & 1)
; 1287 : 				usage();
; 1288 : #endif // !HAVE_GETIFADDR
; 1289 : 
; 1290 : 			break;

  003ae	e9 51 fc ff ff	 jmp	 $LN94@parseGener
$LN61@parseGener:

; 1152 : 		switch (o)

  003b3	8b d1		 mov	 edx, ecx
  003b5	83 ea 70	 sub	 edx, 112		; 00000070H
  003b8	0f 84 ce 00 00
	00		 je	 $LN14@parseGener
  003be	83 ea 01	 sub	 edx, 1
  003c1	0f 84 b5 00 00
	00		 je	 $LN20@parseGener
  003c7	83 ea 01	 sub	 edx, 1
  003ca	0f 84 95 00 00
	00		 je	 $LN41@parseGener
  003d0	83 ea 01	 sub	 edx, 1
  003d3	74 6a		 je	 SHORT $LN27@parseGener
  003d5	83 ea 01	 sub	 edx, 1
  003d8	74 49		 je	 SHORT $LN13@parseGener
  003da	83 ea 02	 sub	 edx, 2
  003dd	0f 84 99 00 00
	00		 je	 $LN20@parseGener
  003e3	83 ea 01	 sub	 edx, 1
  003e6	74 28		 je	 SHORT $LN22@parseGener
  003e8	83 fa 01	 cmp	 edx, 1
  003eb	0f 85 e7 00 00
	00		 jne	 $LN84@parseGener

; 1186 : 
; 1187 : #endif // NO_EXTERNAL_DATA
; 1188 : 
; 1189 : #ifndef NO_SOCKETS
; 1190 : 
; 1191 : 		case 'x':
; 1192 : 			ignoreIniFileParameter(INI_PARAM_EXIT_LEVEL);

  003f1	b1 1e		 mov	 cl, 30
  003f3	e8 00 00 00 00	 call	 ignoreIniFileParameter

; 1193 : 			ExitLevel = (int_fast8_t)getOptionArgumentInt((char)o, 0, 1);

  003f8	33 d2		 xor	 edx, edx
  003fa	b1 78		 mov	 cl, 120			; 00000078H
  003fc	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]
  00400	e8 00 00 00 00	 call	 getOptionArgumentInt
  00405	88 05 00 00 00
	00		 mov	 BYTE PTR ExitLevel, al

; 1194 : 			break;

  0040b	e9 f4 fb ff ff	 jmp	 $LN94@parseGener
$LN22@parseGener:

; 1270 : 
; 1271 : #endif // NO_VERBOSE_LOG
; 1272 : #endif // NO_LOG
; 1273 : 
; 1274 : #ifndef NO_MONGOOSE
; 1275 : 		case 'w':
; 1276 : 			listen_params = getCommandLineArg(optarg);

  00410	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg
  00417	48 89 05 00 00
	00 00		 mov	 QWORD PTR listen_params, rax

; 1277 : 			break;

  0041e	e9 e1 fb ff ff	 jmp	 $LN94@parseGener
$LN13@parseGener:

; 1225 : 
; 1226 : #endif // !defined(NO_LIMIT) && !__minix__
; 1227 : #endif // NO_SOCKETS
; 1228 : 
; 1229 : #if !defined(NO_TIMEOUT) && !__minix__ && !defined(USE_MSRPC)
; 1230 : 		case 't':
; 1231 : 			ServerTimeout = getOptionArgumentInt((char)o, 1, 600);

  00423	ba 01 00 00 00	 mov	 edx, 1
  00428	41 b8 58 02 00
	00		 mov	 r8d, 600		; 00000258H
  0042e	b1 74		 mov	 cl, 116			; 00000074H
  00430	e8 00 00 00 00	 call	 getOptionArgumentInt
  00435	89 05 00 00 00
	00		 mov	 DWORD PTR ServerTimeout, eax

; 1232 : 			ignoreIniFileParameter(INI_PARAM_CONNECTION_TIMEOUT);

  0043b	b1 05		 mov	 cl, 5

; 1233 : 			break;

  0043d	eb 5d		 jmp	 SHORT $LN92@parseGener
$LN27@parseGener:

; 1316 : 
; 1317 : 		case 's':
; 1318 : #ifndef USE_MSRPC
; 1319 : 			if (InetdMode)

  0043f	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  00446	0f 85 8c 00 00
	00		 jne	 $LN84@parseGener

; 1320 : 				usage();
; 1321 : #endif // USE_MSRPC
; 1322 : 			if (!IsNTService)

  0044c	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR IsNTService, 0
  00453	0f 85 ab fb ff
	ff		 jne	 $LN94@parseGener

; 1323 : 				installService = 1; // Install

  00459	c6 05 00 00 00
	00 01		 mov	 BYTE PTR installService, 1

; 1324 : 			break;

  00460	e9 9f fb ff ff	 jmp	 $LN94@parseGener
$LN41@parseGener:

; 1376 : 
; 1377 : #endif // NO_LOG
; 1378 : #endif // NO_SOCKETS
; 1379 : 
; 1380 : #ifndef NO_RANDOM_EPID
; 1381 : 		case 'r':
; 1382 : 			RandomizationLevel = (int_fast8_t)getOptionArgumentInt((char)o, 0, 2);

  00465	33 d2		 xor	 edx, edx
  00467	b1 72		 mov	 cl, 114			; 00000072H
  00469	44 8d 42 02	 lea	 r8d, QWORD PTR [rdx+2]
  0046d	e8 00 00 00 00	 call	 getOptionArgumentInt
  00472	88 05 00 00 00
	00		 mov	 BYTE PTR RandomizationLevel, al

; 1383 : 			ignoreIniFileParameter(INI_PARAM_RANDOMIZATION_LEVEL);

  00478	b1 01		 mov	 cl, 1

; 1384 : 			break;

  0047a	eb 20		 jmp	 SHORT $LN92@parseGener
$LN20@parseGener:

; 1263 : 
; 1264 : #ifndef NO_VERBOSE_LOG
; 1265 : 		case 'v':
; 1266 : 		case 'q':
; 1267 : 			logverbose += o == 'v';

  0047c	83 f9 76	 cmp	 ecx, 118		; 00000076H

; 1268 : 			ignoreIniFileParameter(INI_PARAM_LOG_VERBOSE);

  0047f	b1 08		 mov	 cl, 8
  00481	0f 94 c0	 sete	 al
  00484	00 05 00 00 00
	00		 add	 BYTE PTR logverbose, al

; 1269 : 			break;

  0048a	eb 10		 jmp	 SHORT $LN92@parseGener
$LN14@parseGener:

; 1234 : #endif // !defined(NO_TIMEOUT) && !__minix__ && !defined(USE_MSRPC)
; 1235 : 
; 1236 : #ifndef NO_PID_FILE
; 1237 : 		case 'p':
; 1238 : 			fn_pid = getCommandLineArg(optarg);

  0048c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg

; 1239 : 			ignoreIniFileParameter(INI_PARAM_PID_FILE);

  00493	b1 06		 mov	 cl, 6
  00495	48 89 05 00 00
	00 00		 mov	 QWORD PTR fn_pid, rax
$LN92@parseGener:

; 1149 : 	int o;
; 1150 : 
; 1151 : 	for (opterr = 0; (o = getopt(global_argc, (char *const *)global_argv, (const char *)optstring)) > 0;)

  0049c	e8 00 00 00 00	 call	 ignoreIniFileParameter
  004a1	e9 5e fb ff ff	 jmp	 $LN94@parseGener
$LN86@parseGener:

; 1484 : #endif // NO_VERSION_INFORMATION
; 1485 : 
; 1486 : 		default:
; 1487 : 			usage();
; 1488 : 		}
; 1489 : 
; 1490 : 	// Do not allow non-option arguments
; 1491 : 	if (optind != global_argc)

  004a6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR global_argc
  004ac	39 05 00 00 00
	00		 cmp	 DWORD PTR optind, eax
  004b2	75 24		 jne	 SHORT $LN84@parseGener

; 1492 : 		usage();
; 1493 : 
; 1494 : #ifdef _NTSERVICE
; 1495 : 	// -U and -W must be used with -s
; 1496 : 	if ((ServiceUser || *ServicePassword) && installService != 1)

  004b4	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ServiceUser, 0
  004bc	75 0c		 jne	 SHORT $LN57@parseGener
  004be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ServicePassword
  004c5	80 38 00	 cmp	 BYTE PTR [rax], 0
  004c8	74 09		 je	 SHORT $LN56@parseGener
$LN57@parseGener:
  004ca	80 3d 00 00 00
	00 01		 cmp	 BYTE PTR installService, 1
  004d1	75 05		 jne	 SHORT $LN84@parseGener
$LN56@parseGener:

; 1498 : #endif // _NTSERVICE
; 1499 : }

  004d3	48 83 c4 28	 add	 rsp, 40			; 00000028H
  004d7	c3		 ret	 0
$LN84@parseGener:

; 1497 : 		usage();

  004d8	e8 00 00 00 00	 call	 usage
  004dd	cc		 int	 3
$LN91@parseGener:
parseGeneralArguments ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT writePidFile
_TEXT	SEGMENT
writePidFile PROC					; COMDAT

; 1503 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1504 : #ifndef NO_SIGHUP
; 1505 : 	if (IsRestarted)
; 1506 : 		return;
; 1507 : #endif // NO_SIGHUP
; 1508 : 
; 1509 : 	if (fn_pid && !InetdMode)

  00006	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fn_pid
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 69		 je	 SHORT $LN4@writePidFi
  00012	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  00019	75 60		 jne	 SHORT $LN4@writePidFi

; 1510 : 	{
; 1511 : 		FILE *file = fopen(fn_pid, "w");

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01NOFIACDB@w@
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  00028	48 8b d8	 mov	 rbx, rax

; 1512 : 
; 1513 : 		if (file)

  0002b	48 85 c0	 test	 rax, rax
  0002e	74 27		 je	 SHORT $LN3@writePidFi

; 1514 : 		{
; 1515 : #if _MSC_VER
; 1516 : 			fprintf(file, "%u", (unsigned int)GetCurrentProcessId());

  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentProcessId
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02GMHACPFF@?$CFu@
  0003d	48 8b cb	 mov	 rcx, rbx
  00040	44 8b c0	 mov	 r8d, eax
  00043	e8 00 00 00 00	 call	 fprintf

; 1517 : #else
; 1518 : 			fprintf(file, "%u", (unsigned int)getpid());
; 1519 : #endif
; 1520 : 			fclose(file);

  00048	48 8b cb	 mov	 rcx, rbx

; 1527 : 		}
; 1528 : #endif // NO_LOG
; 1529 : 	}
; 1530 : }

  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5b		 pop	 rbx

; 1517 : #else
; 1518 : 			fprintf(file, "%u", (unsigned int)getpid());
; 1519 : #endif
; 1520 : 			fclose(file);

  00050	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_fclose
$LN3@writePidFi:

; 1521 : 		}
; 1522 : 
; 1523 : #ifndef NO_LOG
; 1524 : 		else
; 1525 : 		{
; 1526 : 			logger("Warning: Cannot write pid file '%s'. %s.\n", fn_pid, strerror(errno));

  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0005d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00065	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR fn_pid
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CK@KCAHIBIN@Warning?3?5Cannot?5write?5pid?5file?5@
  00073	4c 8b c0	 mov	 r8, rax
  00076	e8 00 00 00 00	 call	 logger
$LN4@writePidFi:

; 1527 : 		}
; 1528 : #endif // NO_LOG
; 1529 : 	}
; 1530 : }

  0007b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007f	5b		 pop	 rbx
  00080	c3		 ret	 0
writePidFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT allocateSemaphore
_TEXT	SEGMENT
allocateSemaphore PROC					; COMDAT

; 1595 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1596 : #ifdef USE_THREADS
; 1597 : #define sharemode 0
; 1598 : #else
; 1599 : #define sharemode 1
; 1600 : #endif
; 1601 : 
; 1602 : #ifndef _WIN32
; 1603 : 	sem_unlink("/vlmcsd");
; 1604 : #endif
; 1605 : 
; 1606 : 	if (MaxTasks < SEM_VALUE_MAX && !InetdMode)

  00004	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR MaxTasks
  0000a	81 fa ff ff ff
	7f		 cmp	 edx, 2147483647		; 7fffffffH
  00010	73 49		 jae	 SHORT $LN3@allocateSe
  00012	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  00019	75 40		 jne	 SHORT $LN3@allocateSe

; 1607 : 	{
; 1608 : #ifndef _WIN32
; 1609 : 
; 1610 : #if !defined(USE_THREADS) && !defined(CYGWIN)
; 1611 : 
; 1612 : 		if ((MaxTaskSemaphore = sem_open("/vlmcsd", O_CREAT /*| O_EXCL*/, 0700, MaxTasks)) == SEM_FAILED) // fails on many systems
; 1613 : 		{
; 1614 : 			// We didn't get a named Semaphore (/dev/shm on Linux) so let's try our own shared page
; 1615 : 
; 1616 : 			if (
; 1617 : 				(shmid = shmget(IPC_PRIVATE, sizeof(sem_t), IPC_CREAT | 0600)) < 0 ||
; 1618 : 				(MaxTaskSemaphore = (sem_t *)shmat(shmid, NULL, 0)) == (sem_t *)-1 ||
; 1619 : 				sem_init(MaxTaskSemaphore, 1, MaxTasks) < 0)
; 1620 : 			{
; 1621 : 				int errno_save = errno;
; 1622 : 				if (MaxTaskSemaphore != (sem_t *)-1)
; 1623 : 					shmdt(MaxTaskSemaphore);
; 1624 : 				if (shmid >= 0)
; 1625 : 					shmctl(shmid, IPC_RMID, NULL);
; 1626 : 				printerrorf("Warning: Could not create semaphore: %s\n", vlmcsd_strerror(errno_save));
; 1627 : 				MaxTasks = SEM_VALUE_MAX;
; 1628 : 			}
; 1629 : 		}
; 1630 : 
; 1631 : #else // THREADS or CYGWIN
; 1632 : 
; 1633 : 		MaxTaskSemaphore = (sem_t *)vlmcsd_malloc(sizeof(sem_t));
; 1634 : 
; 1635 : 		if (sem_init(MaxTaskSemaphore, sharemode, MaxTasks) < 0) // sem_init is not implemented on Darwin (returns ENOSYS)
; 1636 : 		{
; 1637 : 			free(MaxTaskSemaphore);
; 1638 : 
; 1639 : 			if ((MaxTaskSemaphore = sem_open("/vlmcsd", O_CREAT /*| O_EXCL*/, 0700, MaxTasks)) == SEM_FAILED)
; 1640 : 			{
; 1641 : 				printerrorf("Warning: Could not create semaphore: %s\n", vlmcsd_strerror(errno));
; 1642 : 				MaxTasks = SEM_VALUE_MAX;
; 1643 : 			}
; 1644 : 		}
; 1645 : 
; 1646 : #endif // THREADS or CYGWIN
; 1647 : 
; 1648 : #else // _WIN32
; 1649 : 
; 1650 : 		if (!((MaxTaskSemaphore = CreateSemaphoreA(NULL, MaxTasks, MaxTasks, NULL))))

  0001b	45 33 c9	 xor	 r9d, r9d
  0001e	44 8b c2	 mov	 r8d, edx
  00021	33 c9		 xor	 ecx, ecx
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateSemaphoreA
  00029	48 89 05 00 00
	00 00		 mov	 QWORD PTR MaxTaskSemaphore, rax
  00030	48 85 c0	 test	 rax, rax
  00033	75 26		 jne	 SHORT $LN3@allocateSe

; 1651 : 		{
; 1652 : 			printerrorf("Warning: Could not create semaphore: %s\n", vlmcsd_strerror(GetLastError()));

  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0003b	8b c8		 mov	 ecx, eax
  0003d	e8 00 00 00 00	 call	 win_strerror
  00042	48 8b d0	 mov	 rdx, rax
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CJ@LKGGDOJH@Warning?3?5Could?5not?5create?5semap@
  0004c	e8 00 00 00 00	 call	 printerrorf

; 1653 : 			MaxTasks = SEM_VALUE_MAX;

  00051	c7 05 00 00 00
	00 ff ff ff 7f	 mov	 DWORD PTR MaxTasks, 2147483647 ; 7fffffffH
$LN3@allocateSe:

; 1654 : 		}
; 1655 : 
; 1656 : #endif // _WIN32
; 1657 : 	}
; 1658 : }

  0005b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005f	c3		 ret	 0
allocateSemaphore ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT setupListeningSockets
_TEXT	SEGMENT
numPrivateIPs$ = 64
privateIPList$ = 72
setupListeningSockets PROC				; COMDAT

; 1663 : {

$LN40:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 18	 mov	 QWORD PTR [r11+24], rbx
  00007	49 89 6b 20	 mov	 QWORD PTR [r11+32], rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 56		 push	 r14
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1664 : 	int o;
; 1665 : #if HAVE_GETIFADDR
; 1666 : 	char **privateIPList = NULL;
; 1667 : 	int numPrivateIPs = 0;
; 1668 : 	if (PublicIPProtectionLevel & 1)

  00013	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR PublicIPProtectionLevel
  00019	33 f6		 xor	 esi, esi
  0001b	33 db		 xor	 ebx, ebx
  0001d	49 89 73 10	 mov	 QWORD PTR [r11+16], rsi
  00021	89 5c 24 40	 mov	 DWORD PTR numPrivateIPs$[rsp], ebx
  00025	a8 01		 test	 al, 1
  00027	74 1c		 je	 SHORT $LN10@setupListe

; 1669 : 		getPrivateIPAddresses(&numPrivateIPs, &privateIPList);

  00029	49 8d 53 10	 lea	 rdx, QWORD PTR [r11+16]
  0002d	49 8d 4b 08	 lea	 rcx, QWORD PTR [r11+8]
  00031	e8 00 00 00 00	 call	 getPrivateIPAddresses
  00036	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR PublicIPProtectionLevel
  0003c	48 8b 74 24 48	 mov	 rsi, QWORD PTR privateIPList$[rsp]
  00041	8b 5c 24 40	 mov	 ebx, DWORD PTR numPrivateIPs$[rsp]
$LN10@setupListe:

; 1670 : 	const uint_fast8_t allocsockets = (uint_fast8_t)(maxsockets ? (maxsockets + numPrivateIPs) : ((PublicIPProtectionLevel & 1) ? numPrivateIPs : 2));

  00045	44 8a 0d 00 00
	00 00		 mov	 r9b, BYTE PTR maxsockets
  0004c	a8 01		 test	 al, 1
  0004e	0f b6 c3	 movzx	 eax, bl
  00051	bf 02 00 00 00	 mov	 edi, 2
  00056	8b cf		 mov	 ecx, edi
  00058	0f 45 c8	 cmovne	 ecx, eax
  0005b	45 84 c9	 test	 r9b, r9b
  0005e	0f b6 d1	 movzx	 edx, cl
  00061	46 8d 04 0b	 lea	 r8d, DWORD PTR [rbx+r9]
  00065	41 0f b6 c0	 movzx	 eax, r8b
  00069	0f 45 d0	 cmovne	 edx, eax

; 1675 : 	SocketList = (SOCKET *)vlmcsd_malloc((size_t)allocsockets * sizeof(SOCKET));

  0006c	0f b6 ca	 movzx	 ecx, dl
  0006f	48 c1 e1 03	 shl	 rcx, 3
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 366  : 	if (!buf) OutOfMemory();

  00079	48 85 c0	 test	 rax, rax
  0007c	0f 84 47 01 00
	00		 je	 $LN39@setupListe
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c

; 1675 : 	SocketList = (SOCKET *)vlmcsd_malloc((size_t)allocsockets * sizeof(SOCKET));

  00082	8b cf		 mov	 ecx, edi
  00084	48 89 05 00 00
	00 00		 mov	 QWORD PTR SocketList, rax

; 1676 : 
; 1677 : 	const int_fast8_t haveIPv4Stack = checkProtocolStack(AF_INET);

  0008b	e8 00 00 00 00	 call	 checkProtocolStack

; 1678 : 	const int_fast8_t haveIPv6Stack = checkProtocolStack(AF_INET6);

  00090	8d 4f 15	 lea	 ecx, QWORD PTR [rdi+21]
  00093	40 8a e8	 mov	 bpl, al
  00096	e8 00 00 00 00	 call	 checkProtocolStack
  0009b	44 8a f0	 mov	 r14b, al

; 1679 : 
; 1680 : 	// Reset getopt since we've alread used it
; 1681 : 	optReset();

  0009e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR optind, 1

; 1682 : 
; 1683 : 	for (opterr = 0; (o = getopt(global_argc, (char *const *)global_argv, (const char *)optstring)) > 0;)

  000a8	eb 26		 jmp	 SHORT $LN13@setupListe
$LL2@setupListe:

; 1684 : 		switch (o)

  000aa	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  000ad	74 15		 je	 SHORT $LN12@setupListe
  000af	83 f8 50	 cmp	 eax, 80			; 00000050H
  000b2	75 1c		 jne	 SHORT $LN13@setupListe

; 1685 : 		{
; 1686 : 		case 'P':
; 1687 : 			defaultport = optarg;

  000b4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg
  000bb	48 89 05 00 00
	00 00		 mov	 QWORD PTR defaultport, rax

; 1688 : 			break;

  000c2	eb 0c		 jmp	 SHORT $LN13@setupListe
$LN12@setupListe:

; 1689 : 
; 1690 : 		case 'L':
; 1691 : 			addListeningSocket(optarg);

  000c4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR optarg
  000cb	e8 00 00 00 00	 call	 addListeningSocket
$LN13@setupListe:

; 1682 : 
; 1683 : 	for (opterr = 0; (o = getopt(global_argc, (char *const *)global_argv, (const char *)optstring)) > 0;)

  000d0	e8 00 00 00 00	 call	 getopt
  000d5	85 c0		 test	 eax, eax
  000d7	7f d1		 jg	 SHORT $LL2@setupListe

; 1692 : 			break;
; 1693 : 
; 1694 : 		default:
; 1695 : 			break;
; 1696 : 		}
; 1697 : 
; 1698 : #ifndef NO_INI_FILE
; 1699 : 	if (maxsockets && !numsockets)

  000d9	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR maxsockets, 0
  000e0	74 42		 je	 SHORT $LN33@setupListe
  000e2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR numsockets, 0
  000e9	75 39		 jne	 SHORT $LN33@setupListe

; 1700 : 	{
; 1701 : 		if (fn_ini && !readIniFile(INI_FILE_PASS_3))

  000eb	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR fn_ini, 0
  000f3	74 2f		 je	 SHORT $LN33@setupListe
  000f5	b1 03		 mov	 cl, 3
  000f7	e8 00 00 00 00	 call	 readIniFile
  000fc	85 c0		 test	 eax, eax
  000fe	75 24		 jne	 SHORT $LN33@setupListe

; 1702 : 		{
; 1703 : #ifdef INI_FILE
; 1704 : 			if (strcmp(fn_ini, INI_FILE))
; 1705 : #endif // INI_FILE
; 1706 : 				printerrorf("Warning: Can't read %s: %s\n", fn_ini, strerror(errno));

  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00106	8b 08		 mov	 ecx, DWORD PTR [rax]
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  0010e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR fn_ini
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@GJMMPBLN@Warning?3?5Can?8t?5read?5?$CFs?3?5?$CFs?6@
  0011c	4c 8b c0	 mov	 r8, rax
  0011f	e8 00 00 00 00	 call	 printerrorf
$LN33@setupListe:

; 1707 : 		}
; 1708 : 	}
; 1709 : #endif
; 1710 : 
; 1711 : #if HAVE_GETIFADDR
; 1712 : 	if (PublicIPProtectionLevel & 1)

  00124	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR PublicIPProtectionLevel
  0012a	a8 01		 test	 al, 1
  0012c	74 31		 je	 SHORT $LN16@setupListe

; 1713 : 	{
; 1714 : 		int i;
; 1715 : 		for (i = 0; i < numPrivateIPs; i++)

  0012e	85 db		 test	 ebx, ebx
  00130	7e 1e		 jle	 SHORT $LN8@setupListe
  00132	48 8b fe	 mov	 rdi, rsi
$LL9@setupListe:

; 1716 : 		{
; 1717 : 			addListeningSocket(privateIPList[i]);

  00135	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00138	e8 00 00 00 00	 call	 addListeningSocket

; 1718 : 			free(privateIPList[i]);

  0013d	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00146	48 8d 7f 08	 lea	 rdi, QWORD PTR [rdi+8]
  0014a	48 83 eb 01	 sub	 rbx, 1
  0014e	75 e5		 jne	 SHORT $LL9@setupListe
$LN8@setupListe:

; 1719 : 		}
; 1720 : 
; 1721 : 		free(privateIPList);

  00150	48 8b ce	 mov	 rcx, rsi
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00159	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR PublicIPProtectionLevel
$LN16@setupListe:

; 1722 : 	}
; 1723 : #endif // HAVE_GETIFADDR
; 1724 : 
; 1725 : 	// if -L hasn't been specified on the command line, use default sockets (all IP addresses)
; 1726 : 	// maxsocket results from first pass parsing the arguments
; 1727 : 	if (!maxsockets)

  0015f	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR maxsockets, 0
  00166	75 30		 jne	 SHORT $LN19@setupListe

; 1728 : 	{
; 1729 : #if HAVE_GETIFADDR
; 1730 : 		if (!(PublicIPProtectionLevel & 1) && haveIPv6Stack)

  00168	a8 01		 test	 al, 1
  0016a	75 2c		 jne	 SHORT $LN19@setupListe
  0016c	45 84 f6	 test	 r14b, r14b
  0016f	74 12		 je	 SHORT $LN18@setupListe

; 1731 : 			addListeningSocket("::");

  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02MOLJINC@?3?3@
  00178	e8 00 00 00 00	 call	 addListeningSocket
  0017d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR PublicIPProtectionLevel
$LN18@setupListe:

; 1732 : 		if (!(PublicIPProtectionLevel & 1) && haveIPv4Stack)

  00183	a8 01		 test	 al, 1
  00185	75 11		 jne	 SHORT $LN19@setupListe
  00187	40 84 ed	 test	 bpl, bpl
  0018a	74 0c		 je	 SHORT $LN19@setupListe

; 1733 : 			addListeningSocket("0.0.0.0");

  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07OHKHACFK@0?40?40?40@
  00193	e8 00 00 00 00	 call	 addListeningSocket
$LN19@setupListe:

; 1734 : #else  // !HAVE_GETIFADDR
; 1735 : 		if (haveIPv6Stack)
; 1736 : 			addListeningSocket("::");
; 1737 : 		if (haveIPv4Stack)
; 1738 : 			addListeningSocket("0.0.0.0");
; 1739 : #endif // !HAVE_GETIFADDR
; 1740 : 	}
; 1741 : 
; 1742 : 	if (!numsockets)

  00198	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR numsockets, 0
  0019f	75 13		 jne	 SHORT $LN20@setupListe

; 1743 : 	{
; 1744 : 		printerrorf("Fatal: Could not listen on any socket.\n");

  001a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CI@NMNKDLLC@Fatal?3?5Could?5not?5listen?5on?5any?5@
  001a8	e8 00 00 00 00	 call	 printerrorf

; 1745 : 		return (!0);

  001ad	b8 01 00 00 00	 mov	 eax, 1
  001b2	eb 02		 jmp	 SHORT $LN1@setupListe
$LN20@setupListe:

; 1746 : 	}
; 1747 : 
; 1748 : 	return 0;

  001b4	33 c0		 xor	 eax, eax
$LN1@setupListe:

; 1749 : }

  001b6	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001bb	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  001c0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001c4	41 5e		 pop	 r14
  001c6	5f		 pop	 rdi
  001c7	5e		 pop	 rsi
  001c8	c3		 ret	 0
$LN39@setupListe:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 366  : 	if (!buf) OutOfMemory();

  001c9	e8 00 00 00 00	 call	 OutOfMemory
  001ce	cc		 int	 3
$LN35@setupListe:
setupListeningSockets ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT main
_TEXT	SEGMENT
argc$ = 48
argv$ = 56
main	PROC						; COMDAT

; 1753 : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1754 : #ifndef _WIN32
; 1755 : 	// initialize the HAProxu proxy protocol support
; 1756 : 	_proxy_protocol_init();
; 1757 : #endif
; 1758 : 	global_argc = argc;

  00006	89 0d 00 00 00
	00		 mov	 DWORD PTR global_argc, ecx

; 1759 : 	global_argv = argv;
; 1760 : 
; 1761 : #ifdef _NTSERVICE
; 1762 : 	DWORD lasterror = ERROR_SUCCESS;

  0000c	33 db		 xor	 ebx, ebx

; 1763 : 
; 1764 : 	if (!StartServiceCtrlDispatcher(NTServiceDispatchTable) && (lasterror = GetLastError()) == ERROR_FAILED_SERVICE_CONTROLLER_CONNECT)

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NTServiceDispatchTable
  00015	48 89 15 00 00
	00 00		 mov	 QWORD PTR global_argv, rdx
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_StartServiceCtrlDispatcherA
  00022	85 c0		 test	 eax, eax
  00024	75 20		 jne	 SHORT $LN2@main
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0002c	8b d8		 mov	 ebx, eax
  0002e	3d 27 04 00 00	 cmp	 eax, 1063		; 00000427H
  00033	75 11		 jne	 SHORT $LN2@main

; 1765 : 	{
; 1766 : 		IsNTService = FALSE;

  00035	c6 05 00 00 00
	00 00		 mov	 BYTE PTR IsNTService, 0

; 1771 : #else  // !_NTSERVICE
; 1772 : 	return newmain();
; 1773 : #endif // !_NTSERVICE
; 1774 : }

  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5b		 pop	 rbx

; 1767 : 		return newmain();

  00041	e9 00 00 00 00	 jmp	 newmain
$LN2@main:

; 1768 : 	}
; 1769 : 
; 1770 : 	return lasterror;

  00046	8b c3		 mov	 eax, ebx

; 1771 : #else  // !_NTSERVICE
; 1772 : 	return newmain();
; 1773 : #endif // !_NTSERVICE
; 1774 : }

  00048	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004c	5b		 pop	 rbx
  0004d	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\vlmcsd.c
;	COMDAT WinStartUp
_TEXT	SEGMENT
argc$ = 96
WinStartUp PROC						; COMDAT

; 2078 : {

$LN11:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 56		 push	 r14
  0000e	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 2079 : 	WCHAR **szArgList;
; 2080 : 	int argc;
; 2081 : 	szArgList = CommandLineToArgvW(GetCommandLineW(), &argc);

  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCommandLineW
  00018	48 8b c8	 mov	 rcx, rax
  0001b	48 8d 54 24 60	 lea	 rdx, QWORD PTR argc$[rsp]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CommandLineToArgvW

; 2082 : 
; 2083 : 	int i;
; 2084 : 	char **argv = (char **)vlmcsd_malloc(sizeof(char *) * argc);

  00026	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR argc$[rsp]
  0002b	48 8b f0	 mov	 rsi, rax
  0002e	48 c1 e1 03	 shl	 rcx, 3
  00032	e8 00 00 00 00	 call	 vlmcsd_malloc

; 2085 : 
; 2086 : 	for (i = 0; i < argc; i++)

  00037	8b 4c 24 60	 mov	 ecx, DWORD PTR argc$[rsp]
  0003b	45 33 f6	 xor	 r14d, r14d
  0003e	48 8b e8	 mov	 rbp, rax
  00041	85 c9		 test	 ecx, ecx
  00043	7e 7c		 jle	 SHORT $LN3@WinStartUp
  00045	48 8b f8	 mov	 rdi, rax
  00048	48 2b fe	 sub	 rdi, rsi
$LL4@WinStartUp:

; 2087 : 	{
; 2088 : 		int size = WideCharToMultiByte(CP_UTF8, 0, szArgList[i], -1, argv[i], 0, NULL, NULL);

  0004b	48 83 64 24 38
	00		 and	 QWORD PTR [rsp+56], 0
  00051	41 83 c9 ff	 or	 r9d, -1
  00055	48 83 64 24 30
	00		 and	 QWORD PTR [rsp+48], 0
  0005b	33 d2		 xor	 edx, edx
  0005d	48 8b 04 37	 mov	 rax, QWORD PTR [rdi+rsi]
  00061	b9 e9 fd 00 00	 mov	 ecx, 65001		; 0000fde9H
  00066	83 64 24 28 00	 and	 DWORD PTR [rsp+40], 0
  0006b	4c 8b 06	 mov	 r8, QWORD PTR [rsi]
  0006e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WideCharToMultiByte
  00079	48 63 d8	 movsxd	 rbx, eax

; 2089 : 		argv[i] = (char *)vlmcsd_malloc(size);

  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	e8 00 00 00 00	 call	 vlmcsd_malloc

; 2090 : 		WideCharToMultiByte(CP_UTF8, 0, szArgList[i], -1, argv[i], size, NULL, NULL);

  00084	48 83 64 24 38
	00		 and	 QWORD PTR [rsp+56], 0
  0008a	41 83 c9 ff	 or	 r9d, -1
  0008e	48 83 64 24 30
	00		 and	 QWORD PTR [rsp+48], 0
  00094	33 d2		 xor	 edx, edx
  00096	48 89 04 37	 mov	 QWORD PTR [rdi+rsi], rax
  0009a	b9 e9 fd 00 00	 mov	 ecx, 65001		; 0000fde9H
  0009f	4c 8b 06	 mov	 r8, QWORD PTR [rsi]
  000a2	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  000a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WideCharToMultiByte
  000b1	8b 4c 24 60	 mov	 ecx, DWORD PTR argc$[rsp]
  000b5	48 8d 76 08	 lea	 rsi, QWORD PTR [rsi+8]
  000b9	41 ff c6	 inc	 r14d
  000bc	44 3b f1	 cmp	 r14d, ecx
  000bf	7c 8a		 jl	 SHORT $LL4@WinStartUp
$LN3@WinStartUp:

; 2091 : 	}
; 2092 : 
; 2093 : 	exit(server_main(argc, argv));

  000c1	48 8b d5	 mov	 rdx, rbp
  000c4	e8 00 00 00 00	 call	 main
  000c9	8b c8		 mov	 ecx, eax
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  000d1	cc		 int	 3
$LN10@WinStartUp:
WinStartUp ENDP
_TEXT	ENDS
END
