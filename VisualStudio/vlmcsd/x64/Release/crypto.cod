; Listing generated by Microsoft (R) Optimizing Compiler Version 19.32.31332.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	AesKeyV5
PUBLIC	AesKeyV4
PUBLIC	AesKeyV6
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
?RCon@?1??AesInitKey@@9@9 DD 00H			; `AesInitKey'::`2'::RCon
	DD	01000000H
	DD	02000000H
	DD	04000000H
	DD	08000000H
	DD	010000000H
	DD	020000000H
	DD	040000000H
	DD	080000000H
	DD	01b000000H
	DD	036000000H
	ORG $+1
SBox	DB	063H
	DB	07cH
	DB	077H
	DB	07bH
	DB	0f2H
	DB	06bH
	DB	06fH
	DB	0c5H
	DB	030H
	DB	01H
	DB	067H
	DB	02bH
	DB	0feH
	DB	0d7H
	DB	0abH
	DB	076H
	DB	0caH
	DB	082H
	DB	0c9H
	DB	07dH
	DB	0faH
	DB	059H
	DB	047H
	DB	0f0H
	DB	0adH
	DB	0d4H
	DB	0a2H
	DB	0afH
	DB	09cH
	DB	0a4H
	DB	072H
	DB	0c0H
	DB	0b7H
	DB	0fdH
	DB	093H
	DB	026H
	DB	036H
	DB	03fH
	DB	0f7H
	DB	0ccH
	DB	034H
	DB	0a5H
	DB	0e5H
	DB	0f1H
	DB	071H
	DB	0d8H
	DB	031H
	DB	015H
	DB	04H
	DB	0c7H
	DB	023H
	DB	0c3H
	DB	018H
	DB	096H
	DB	05H
	DB	09aH
	DB	07H
	DB	012H
	DB	080H
	DB	0e2H
	DB	0ebH
	DB	027H
	DB	0b2H
	DB	075H
	DB	09H
	DB	083H
	DB	02cH
	DB	01aH
	DB	01bH
	DB	06eH
	DB	05aH
	DB	0a0H
	DB	052H
	DB	03bH
	DB	0d6H
	DB	0b3H
	DB	029H
	DB	0e3H
	DB	02fH
	DB	084H
	DB	053H
	DB	0d1H
	DB	00H
	DB	0edH
	DB	020H
	DB	0fcH
	DB	0b1H
	DB	05bH
	DB	06aH
	DB	0cbH
	DB	0beH
	DB	039H
	DB	04aH
	DB	04cH
	DB	058H
	DB	0cfH
	DB	0d0H
	DB	0efH
	DB	0aaH
	DB	0fbH
	DB	043H
	DB	04dH
	DB	033H
	DB	085H
	DB	045H
	DB	0f9H
	DB	02H
	DB	07fH
	DB	050H
	DB	03cH
	DB	09fH
	DB	0a8H
	DB	051H
	DB	0a3H
	DB	040H
	DB	08fH
	DB	092H
	DB	09dH
	DB	038H
	DB	0f5H
	DB	0bcH
	DB	0b6H
	DB	0daH
	DB	021H
	DB	010H
	DB	0ffH
	DB	0f3H
	DB	0d2H
	DB	0cdH
	DB	0cH
	DB	013H
	DB	0ecH
	DB	05fH
	DB	097H
	DB	044H
	DB	017H
	DB	0c4H
	DB	0a7H
	DB	07eH
	DB	03dH
	DB	064H
	DB	05dH
	DB	019H
	DB	073H
	DB	060H
	DB	081H
	DB	04fH
	DB	0dcH
	DB	022H
	DB	02aH
	DB	090H
	DB	088H
	DB	046H
	DB	0eeH
	DB	0b8H
	DB	014H
	DB	0deH
	DB	05eH
	DB	0bH
	DB	0dbH
	DB	0e0H
	DB	032H
	DB	03aH
	DB	0aH
	DB	049H
	DB	06H
	DB	024H
	DB	05cH
	DB	0c2H
	DB	0d3H
	DB	0acH
	DB	062H
	DB	091H
	DB	095H
	DB	0e4H
	DB	079H
	DB	0e7H
	DB	0c8H
	DB	037H
	DB	06dH
	DB	08dH
	DB	0d5H
	DB	04eH
	DB	0a9H
	DB	06cH
	DB	056H
	DB	0f4H
	DB	0eaH
	DB	065H
	DB	07aH
	DB	0aeH
	DB	08H
	DB	0baH
	DB	078H
	DB	025H
	DB	02eH
	DB	01cH
	DB	0a6H
	DB	0b4H
	DB	0c6H
	DB	0e8H
	DB	0ddH
	DB	074H
	DB	01fH
	DB	04bH
	DB	0bdH
	DB	08bH
	DB	08aH
	DB	070H
	DB	03eH
	DB	0b5H
	DB	066H
	DB	048H
	DB	03H
	DB	0f6H
	DB	0eH
	DB	061H
	DB	035H
	DB	057H
	DB	0b9H
	DB	086H
	DB	0c1H
	DB	01dH
	DB	09eH
	DB	0e1H
	DB	0f8H
	DB	098H
	DB	011H
	DB	069H
	DB	0d9H
	DB	08eH
	DB	094H
	DB	09bH
	DB	01eH
	DB	087H
	DB	0e9H
	DB	0ceH
	DB	055H
	DB	028H
	DB	0dfH
	DB	08cH
	DB	0a1H
	DB	089H
	DB	0dH
	DB	0bfH
	DB	0e6H
	DB	042H
	DB	068H
	DB	041H
	DB	099H
	DB	02dH
	DB	0fH
	DB	0b0H
	DB	054H
	DB	0bbH
	DB	016H
AesKeyV5 DB	0cdH
	DB	07eH
	DB	079H
	DB	06fH
	DB	02aH
	DB	0b2H
	DB	05dH
	DB	0cbH
	DB	055H
	DB	0ffH
	DB	0c8H
	DB	0efH
	DB	083H
	DB	064H
	DB	0c4H
	DB	070H
AesKeyV4 DB	05H
	DB	03dH
	DB	083H
	DB	07H
	DB	0f9H
	DB	0e5H
	DB	0f0H
	DB	088H
	DB	0ebH
	DB	05eH
	DB	0a6H
	DB	068H
	DB	06cH
	DB	0f0H
	DB	037H
	DB	0c7H
	DB	0e4H
	DB	0efH
	DB	0d2H
	DB	0d6H
	ORG $+4
AesKeyV6 DB	0a9H
	DB	04aH
	DB	041H
	DB	095H
	DB	0e2H
	DB	01H
	DB	043H
	DB	02dH
	DB	09bH
	DB	0cbH
	DB	046H
	DB	04H
	DB	05H
	DB	0d8H
	DB	04aH
	DB	021H
SBoxR	DB	052H
	DB	09H
	DB	06aH
	DB	0d5H
	DB	030H
	DB	036H
	DB	0a5H
	DB	038H
	DB	0bfH
	DB	040H
	DB	0a3H
	DB	09eH
	DB	081H
	DB	0f3H
	DB	0d7H
	DB	0fbH
	DB	07cH
	DB	0e3H
	DB	039H
	DB	082H
	DB	09bH
	DB	02fH
	DB	0ffH
	DB	087H
	DB	034H
	DB	08eH
	DB	043H
	DB	044H
	DB	0c4H
	DB	0deH
	DB	0e9H
	DB	0cbH
	DB	054H
	DB	07bH
	DB	094H
	DB	032H
	DB	0a6H
	DB	0c2H
	DB	023H
	DB	03dH
	DB	0eeH
	DB	04cH
	DB	095H
	DB	0bH
	DB	042H
	DB	0faH
	DB	0c3H
	DB	04eH
	DB	08H
	DB	02eH
	DB	0a1H
	DB	066H
	DB	028H
	DB	0d9H
	DB	024H
	DB	0b2H
	DB	076H
	DB	05bH
	DB	0a2H
	DB	049H
	DB	06dH
	DB	08bH
	DB	0d1H
	DB	025H
	DB	072H
	DB	0f8H
	DB	0f6H
	DB	064H
	DB	086H
	DB	068H
	DB	098H
	DB	016H
	DB	0d4H
	DB	0a4H
	DB	05cH
	DB	0ccH
	DB	05dH
	DB	065H
	DB	0b6H
	DB	092H
	DB	06cH
	DB	070H
	DB	048H
	DB	050H
	DB	0fdH
	DB	0edH
	DB	0b9H
	DB	0daH
	DB	05eH
	DB	015H
	DB	046H
	DB	057H
	DB	0a7H
	DB	08dH
	DB	09dH
	DB	084H
	DB	090H
	DB	0d8H
	DB	0abH
	DB	00H
	DB	08cH
	DB	0bcH
	DB	0d3H
	DB	0aH
	DB	0f7H
	DB	0e4H
	DB	058H
	DB	05H
	DB	0b8H
	DB	0b3H
	DB	045H
	DB	06H
	DB	0d0H
	DB	02cH
	DB	01eH
	DB	08fH
	DB	0caH
	DB	03fH
	DB	0fH
	DB	02H
	DB	0c1H
	DB	0afH
	DB	0bdH
	DB	03H
	DB	01H
	DB	013H
	DB	08aH
	DB	06bH
	DB	03aH
	DB	091H
	DB	011H
	DB	041H
	DB	04fH
	DB	067H
	DB	0dcH
	DB	0eaH
	DB	097H
	DB	0f2H
	DB	0cfH
	DB	0ceH
	DB	0f0H
	DB	0b4H
	DB	0e6H
	DB	073H
	DB	096H
	DB	0acH
	DB	074H
	DB	022H
	DB	0e7H
	DB	0adH
	DB	035H
	DB	085H
	DB	0e2H
	DB	0f9H
	DB	037H
	DB	0e8H
	DB	01cH
	DB	075H
	DB	0dfH
	DB	06eH
	DB	047H
	DB	0f1H
	DB	01aH
	DB	071H
	DB	01dH
	DB	029H
	DB	0c5H
	DB	089H
	DB	06fH
	DB	0b7H
	DB	062H
	DB	0eH
	DB	0aaH
	DB	018H
	DB	0beH
	DB	01bH
	DB	0fcH
	DB	056H
	DB	03eH
	DB	04bH
	DB	0c6H
	DB	0d2H
	DB	079H
	DB	020H
	DB	09aH
	DB	0dbH
	DB	0c0H
	DB	0feH
	DB	078H
	DB	0cdH
	DB	05aH
	DB	0f4H
	DB	01fH
	DB	0ddH
	DB	0a8H
	DB	033H
	DB	088H
	DB	07H
	DB	0c7H
	DB	031H
	DB	0b1H
	DB	012H
	DB	010H
	DB	059H
	DB	027H
	DB	080H
	DB	0ecH
	DB	05fH
	DB	060H
	DB	051H
	DB	07fH
	DB	0a9H
	DB	019H
	DB	0b5H
	DB	04aH
	DB	0dH
	DB	02dH
	DB	0e5H
	DB	07aH
	DB	09fH
	DB	093H
	DB	0c9H
	DB	09cH
	DB	0efH
	DB	0a0H
	DB	0e0H
	DB	03bH
	DB	04dH
	DB	0aeH
	DB	02aH
	DB	0f5H
	DB	0b0H
	DB	0c8H
	DB	0ebH
	DB	0bbH
	DB	03cH
	DB	083H
	DB	053H
	DB	099H
	DB	061H
	DB	017H
	DB	02bH
	DB	04H
	DB	07eH
	DB	0baH
	DB	077H
	DB	0d6H
	DB	026H
	DB	0e1H
	DB	069H
	DB	014H
	DB	063H
	DB	055H
	DB	021H
	DB	0cH
	DB	07dH
PUBLIC	AesDecryptCbc
PUBLIC	AesDecryptBlock
PUBLIC	AesEncryptCbc
PUBLIC	AesCmacV4
PUBLIC	AesEncryptBlock
PUBLIC	AesInitKey
PUBLIC	MixColumnsR
PUBLIC	XorBlock
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4014000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@41efffffffe00000
PUBLIC	__real@c1efffffffe00000
PUBLIC	__xmm@80000000000000008000000000000000
EXTRN	__chkstk:PROC
EXTRN	memchr:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	strcmp:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$AesDecryptCbc DD imagerel $LN30
	DD	imagerel $LN30+103
	DD	imagerel $unwind$AesDecryptCbc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AesDecryptBlock DD imagerel $LN40
	DD	imagerel $LN40+185
	DD	imagerel $unwind$AesDecryptBlock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AesEncryptCbc DD imagerel $LN30
	DD	imagerel $LN30+188
	DD	imagerel $unwind$AesEncryptCbc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ShiftRowsR DD imagerel ShiftRowsR
	DD	imagerel ShiftRowsR+58
	DD	imagerel $unwind$ShiftRowsR
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AesCmacV4 DD imagerel $LN20
	DD	imagerel $LN20+176
	DD	imagerel $unwind$AesCmacV4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AesEncryptBlock DD imagerel $LN40
	DD	imagerel $LN40+212
	DD	imagerel $unwind$AesEncryptBlock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MixColumns DD imagerel MixColumns
	DD	imagerel MixColumns+144
	DD	imagerel $unwind$MixColumns
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ShiftRows DD imagerel ShiftRows
	DD	imagerel ShiftRows+47
	DD	imagerel $unwind$ShiftRows
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AesInitKey DD imagerel $LN13
	DD	imagerel $LN13+207
	DD	imagerel $unwind$AesInitKey
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MixColumnsR DD imagerel $LN11
	DD	imagerel $LN11+710
	DD	imagerel $unwind$MixColumnsR
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c1efffffffe00000
CONST	SEGMENT
__real@c1efffffffe00000 DQ 0c1efffffffe00000r	; -4.29497e+09
CONST	ENDS
;	COMDAT __real@41efffffffe00000
CONST	SEGMENT
__real@41efffffffe00000 DQ 041efffffffe00000r	; 4.29497e+09
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MixColumnsR DD 091501H
	DD	0b3415H
	DD	0e013f015H
	DD	0c00fd011H
	DD	0600c700dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AesInitKey DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ShiftRows DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MixColumns DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AesEncryptBlock DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AesCmacV4 DD 091701H
	DD	0246417H
	DD	0235417H
	DD	0223417H
	DD	0200117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ShiftRowsR DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AesEncryptCbc DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AesDecryptBlock DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AesDecryptCbc DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\crypto.c
;	COMDAT XorBlock
_TEXT	SEGMENT
in$ = 8
out$ = 16
XorBlock PROC						; COMDAT

; 41   : 	/*UAA64( out, 0 ) ^= UAA64( in, 0 );
; 42   : 	UAA64( out, 1 ) ^= UAA64( in, 1 );*/
; 43   : 
; 44   : 	uint_fast8_t i;
; 45   : 
; 46   : 	for (i = 0; i < AES_BLOCK_WORDS; i++)

  00000	48 2b ca	 sub	 rcx, rdx
  00003	41 b8 04 00 00
	00		 mov	 r8d, 4
$LL4@XorBlock:

; 47   : 	{
; 48   : 		((DWORD*)out)[i] ^= ((DWORD*)in)[i];

  00009	8b 04 11	 mov	 eax, DWORD PTR [rcx+rdx]
  0000c	31 02		 xor	 DWORD PTR [rdx], eax
  0000e	48 8d 52 04	 lea	 rdx, QWORD PTR [rdx+4]
  00012	49 83 e8 01	 sub	 r8, 1
  00016	75 f1		 jne	 SHORT $LL4@XorBlock

; 49   : 	}
; 50   : }

  00018	c3		 ret	 0
XorBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\crypto.c
;	COMDAT MixColumnsR
_TEXT	SEGMENT
state$ = 64
tv948 = 72
tv952 = 80
MixColumnsR PROC					; COMDAT

; 80   : {

$LN11:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 55		 push	 r13
  00011	41 56		 push	 r14
  00013	41 57		 push	 r15
  00015	48 8b c1	 mov	 rax, rcx

; 81   : 	uint_fast8_t i = 0;

  00018	48 c7 44 24 50
	04 00 00 00	 mov	 QWORD PTR tv952[rsp], 4
  00021	41 b8 01 01 01
	01		 mov	 r8d, 16843009		; 01010101H
$LL4@MixColumns:

; 82   : 	for (; i < AES_BLOCK_WORDS; i++)
; 83   : 	{
; 84   : 		#if defined(_CRYPTO_OPENSSL) && defined(_OPENSSL_SOFTWARE) && defined(_USE_AES_FROM_OPENSSL) //Always byte swap regardless of endianess
; 85   : 			DWORD word = BS32(((DWORD *) state)[i]);
; 86   : 			((DWORD *) state)[i] = BS32(MulE(word) ^ ROR32(MulB(word), 8) ^ ROR32(MulD(word), 16) ^ ROR32(Mul9(word), 24));
; 87   : 		#else
; 88   : 			DWORD word = LE32(((DWORD *) state)[i]);

  00027	8b 08		 mov	 ecx, DWORD PTR [rax]

; 89   : 			((DWORD *) state)[i] = LE32(MulE(word) ^ ROR32(MulB(word), 8) ^ ROR32(MulD(word), 16) ^ ROR32(Mul9(word), 24));

  00029	8b f9		 mov	 edi, ecx
  0002b	8b e9		 mov	 ebp, ecx
  0002d	c1 ef 07	 shr	 edi, 7
  00030	81 e5 1f ff ff
	ff		 and	 ebp, -225		; ffffff1fH
  00036	44 8b e7	 mov	 r12d, edi
  00039	03 ed		 add	 ebp, ebp
  0003b	45 23 e0	 and	 r12d, r8d
  0003e	41 6b d4 1b	 imul	 edx, r12d, 27
  00042	44 8b d7	 mov	 r10d, edi
  00045	41 81 e2 01 01
	01 00		 and	 r10d, 65793		; 00010101H
  0004c	41 6b da 1b	 imul	 ebx, r10d, 27
  00050	44 8b fa	 mov	 r15d, edx
  00053	89 54 24 48	 mov	 DWORD PTR tv948[rsp], edx
  00057	41 d1 ef	 shr	 r15d, 1
  0005a	44 33 f9	 xor	 r15d, ecx
  0005d	44 8b db	 mov	 r11d, ebx
  00060	41 d1 eb	 shr	 r11d, 1
  00063	44 33 d9	 xor	 r11d, ecx
  00066	41 c1 ef 06	 shr	 r15d, 6
  0006a	45 23 f8	 and	 r15d, r8d
  0006d	41 c1 eb 06	 shr	 r11d, 6
  00071	45 6b ef 1b	 imul	 r13d, r15d, 27
  00075	41 81 e3 01 01
	01 00		 and	 r11d, 65793		; 00010101H
  0007c	41 8b f5	 mov	 esi, r13d
  0007f	d1 ee		 shr	 esi, 1
  00081	8b c6		 mov	 eax, esi
  00083	33 c2		 xor	 eax, edx
  00085	8b d7		 mov	 edx, edi
  00087	d1 e8		 shr	 eax, 1
  00089	81 e2 01 01 00
	00		 and	 edx, 257		; 00000101H
  0008f	33 c1		 xor	 eax, ecx
  00091	83 e7 01	 and	 edi, 1
  00094	c1 e8 05	 shr	 eax, 5
  00097	41 23 c0	 and	 eax, r8d
  0009a	44 6b c2 1b	 imul	 r8d, edx, 27
  0009e	44 6b f0 1b	 imul	 r14d, eax, 27
  000a2	8b c1		 mov	 eax, ecx
  000a4	25 3f ff ff ff	 and	 eax, -193		; ffffff3fH
  000a9	33 e8		 xor	 ebp, eax
  000ab	69 c2 00 00 36
	00		 imul	 eax, edx, 3538944	; 00360000H
  000b1	c1 e5 02	 shl	 ebp, 2
  000b4	33 e9		 xor	 ebp, ecx
  000b6	45 8b c8	 mov	 r9d, r8d
  000b9	41 d1 e9	 shr	 r9d, 1
  000bc	44 33 c9	 xor	 r9d, ecx
  000bf	c1 e5 10	 shl	 ebp, 16
  000c2	69 ca 00 00 6c
	00		 imul	 ecx, edx, 7077888	; 006c0000H
  000c8	41 c1 e9 06	 shr	 r9d, 6
  000cc	41 81 e1 01 01
	00 00		 and	 r9d, 257		; 00000101H
  000d3	81 e1 ff ff fd
	fd		 and	 ecx, -33685505		; fdfdffffH
  000d9	33 c8		 xor	 ecx, eax
  000db	41 69 c1 00 00
	36 00		 imul	 eax, r9d, 3538944	; 00360000H
  000e2	33 c8		 xor	 ecx, eax
  000e4	41 6b c1 1b	 imul	 eax, r9d, 27
  000e8	81 e1 00 00 fe
	fe		 and	 ecx, -16908288		; fefe0000H
  000ee	33 e9		 xor	 ebp, ecx
  000f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  000f5	d1 e8		 shr	 eax, 1
  000f7	41 33 c0	 xor	 eax, r8d
  000fa	44 8b 01	 mov	 r8d, DWORD PTR [rcx]
  000fd	d1 e8		 shr	 eax, 1
  000ff	41 8b ce	 mov	 ecx, r14d
  00102	41 33 c0	 xor	 eax, r8d
  00105	41 33 cd	 xor	 ecx, r13d
  00108	c1 e8 05	 shr	 eax, 5
  0010b	41 33 c8	 xor	 ecx, r8d
  0010e	25 01 01 00 00	 and	 eax, 257		; 00000101H
  00113	d1 e9		 shr	 ecx, 1
  00115	69 c0 00 00 1b
	00		 imul	 eax, eax, 1769472	; 001b0000H
  0011b	33 e8		 xor	 ebp, eax
  0011d	41 69 c1 00 00
	1b 00		 imul	 eax, r9d, 1769472	; 001b0000H
  00124	44 8b 4c 24 48	 mov	 r9d, DWORD PTR tv948[rsp]
  00129	33 e8		 xor	 ebp, eax
  0012b	41 8b c1	 mov	 eax, r9d
  0012e	41 33 c5	 xor	 eax, r13d
  00131	25 00 00 7f 7f	 and	 eax, 2139029504		; 7f7f0000H
  00136	33 c8		 xor	 ecx, eax
  00138	41 8b c1	 mov	 eax, r9d
  0013b	d1 e9		 shr	 ecx, 1
  0013d	41 33 c0	 xor	 eax, r8d
  00140	25 00 00 3f 3f	 and	 eax, 1061093376		; 3f3f0000H
  00145	42 8d 14 85 00
	00 00 00	 lea	 edx, DWORD PTR [r8*4]
  0014d	33 c8		 xor	 ecx, eax
  0014f	41 33 d0	 xor	 edx, r8d
  00152	d1 e9		 shr	 ecx, 1
  00154	03 d2		 add	 edx, edx
  00156	41 33 d0	 xor	 edx, r8d
  00159	41 8b c0	 mov	 eax, r8d
  0015c	25 00 00 1f 1f	 and	 eax, 522125312		; 1f1f0000H
  00161	c1 e2 18	 shl	 edx, 24
  00164	33 c8		 xor	 ecx, eax
  00166	41 8b c0	 mov	 eax, r8d
  00169	c1 e8 06	 shr	 eax, 6
  0016c	83 e0 01	 and	 eax, 1
  0016f	c1 e9 0d	 shr	 ecx, 13
  00172	69 c0 00 00 00
	36		 imul	 eax, eax, 905969664	; 36000000H
  00178	0b e9		 or	 ebp, ecx
  0017a	41 8b ce	 mov	 ecx, r14d
  0017d	41 33 c9	 xor	 ecx, r9d
  00180	41 33 c8	 xor	 ecx, r8d
  00183	d1 e9		 shr	 ecx, 1
  00185	33 d0		 xor	 edx, eax
  00187	41 8b c0	 mov	 eax, r8d
  0018a	c1 e8 05	 shr	 eax, 5
  0018d	83 e0 01	 and	 eax, 1
  00190	69 c0 00 00 00
	1b		 imul	 eax, eax, 452984832	; 1b000000H
  00196	33 d0		 xor	 edx, eax
  00198	69 c7 00 00 00
	6c		 imul	 eax, edi, 1811939328	; 6c000000H
  0019e	33 d0		 xor	 edx, eax
  001a0	69 c7 00 00 00
	1b		 imul	 eax, edi, 452984832	; 1b000000H
  001a6	33 d0		 xor	 edx, eax
  001a8	41 8b c5	 mov	 eax, r13d
  001ab	41 33 c0	 xor	 eax, r8d
  001ae	25 00 7f 7f 7f	 and	 eax, 2139062016		; 7f7f7f00H
  001b3	33 c8		 xor	 ecx, eax
  001b5	41 8b c1	 mov	 eax, r9d
  001b8	25 00 3f 3f 3f	 and	 eax, 1061109504		; 3f3f3f00H
  001bd	d1 e9		 shr	 ecx, 1
  001bf	33 c8		 xor	 ecx, eax
  001c1	41 8b c0	 mov	 eax, r8d
  001c4	25 00 1f 1f 1f	 and	 eax, 522133248		; 1f1f1f00H
  001c9	d1 e9		 shr	 ecx, 1
  001cb	33 c8		 xor	 ecx, eax
  001cd	41 69 c3 00 36
	00 00		 imul	 eax, r11d, 13824	; 00003600H
  001d4	c1 e9 05	 shr	 ecx, 5
  001d7	0b d1		 or	 edx, ecx
  001d9	41 8b c9	 mov	 ecx, r9d
  001dc	33 ea		 xor	 ebp, edx
  001de	0f ba f1 17	 btr	 ecx, 23
  001e2	33 ce		 xor	 ecx, esi
  001e4	41 69 d2 00 6c
	00 00		 imul	 edx, r10d, 27648	; 00006c00H
  001eb	81 e1 00 00 80
	3f		 and	 ecx, 1065353216		; 3f800000H
  001f1	81 e2 ff fd fd
	fd		 and	 edx, -33686017		; fdfdfdffH
  001f7	33 d0		 xor	 edx, eax
  001f9	41 6b c3 1b	 imul	 eax, r11d, 27
  001fd	81 e2 00 fe fe
	fe		 and	 edx, -16843264		; fefefe00H
  00203	d1 e8		 shr	 eax, 1
  00205	33 c3		 xor	 eax, ebx
  00207	d1 e8		 shr	 eax, 1
  00209	41 33 c0	 xor	 eax, r8d
  0020c	c1 e8 05	 shr	 eax, 5
  0020f	25 01 01 01 00	 and	 eax, 65793		; 00010101H
  00214	69 c0 00 1b 00
	00		 imul	 eax, eax, 6912		; 00001b00H
  0021a	33 d0		 xor	 edx, eax
  0021c	41 8b c0	 mov	 eax, r8d
  0021f	25 1f 1f ff ff	 and	 eax, -57569		; ffff1f1fH
  00224	c1 e0 03	 shl	 eax, 3
  00227	41 33 c0	 xor	 eax, r8d
  0022a	c1 e0 08	 shl	 eax, 8
  0022d	33 d0		 xor	 edx, eax
  0022f	41 8b c6	 mov	 eax, r14d
  00232	41 33 c0	 xor	 eax, r8d
  00235	c1 e8 02	 shr	 eax, 2
  00238	33 c8		 xor	 ecx, eax
  0023a	41 8b c0	 mov	 eax, r8d
  0023d	d1 e9		 shr	 ecx, 1
  0023f	25 00 00 00 1f	 and	 eax, 520093696		; 1f000000H
  00244	33 c8		 xor	 ecx, eax
  00246	c1 e9 15	 shr	 ecx, 21
  00249	0b d1		 or	 edx, ecx
  0024b	33 ea		 xor	 ebp, edx
  0024d	41 6b c4 36	 imul	 eax, r12d, 54		; 00000036H
  00251	41 6b cc 6c	 imul	 ecx, r12d, 108		; 0000006cH
  00255	81 e1 fd fd fd
	fd		 and	 ecx, -33686019		; fdfdfdfdH
  0025b	33 c8		 xor	 ecx, eax
  0025d	41 6b c7 36	 imul	 eax, r15d, 54		; 00000036H
  00261	33 c8		 xor	 ecx, eax
  00263	43 8d 04 00	 lea	 eax, DWORD PTR [r8+r8]
  00267	33 c8		 xor	 ecx, eax
  00269	41 8b c0	 mov	 eax, r8d
  0026c	25 1f 1f 1f ff	 and	 eax, -14737633		; ff1f1f1fH
  00271	41 81 e0 3f 3f
	3f ff		 and	 r8d, -12632257		; ff3f3f3fH
  00278	03 c0		 add	 eax, eax
  0027a	81 e1 fe fe fe
	fe		 and	 ecx, -16843010		; fefefefeH
  00280	41 33 c0	 xor	 eax, r8d
  00283	33 e9		 xor	 ebp, ecx
  00285	c1 e0 02	 shl	 eax, 2
  00288	41 b8 01 01 01
	01		 mov	 r8d, 16843009		; 01010101H
  0028e	33 e8		 xor	 ebp, eax
  00290	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00295	41 33 ee	 xor	 ebp, r14d
  00298	41 33 e9	 xor	 ebp, r9d
  0029b	41 33 ed	 xor	 ebp, r13d
  0029e	89 28		 mov	 DWORD PTR [rax], ebp
  002a0	48 83 c0 04	 add	 rax, 4
  002a4	48 83 6c 24 50
	01		 sub	 QWORD PTR tv952[rsp], 1
  002aa	48 89 44 24 40	 mov	 QWORD PTR state$[rsp], rax
  002af	0f 85 72 fd ff
	ff		 jne	 $LL4@MixColumns

; 90   : 		#endif
; 91   : 	}
; 92   : }

  002b5	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  002ba	41 5f		 pop	 r15
  002bc	41 5e		 pop	 r14
  002be	41 5d		 pop	 r13
  002c0	41 5c		 pop	 r12
  002c2	5f		 pop	 rdi
  002c3	5e		 pop	 rsi
  002c4	5d		 pop	 rbp
  002c5	c3		 ret	 0
MixColumnsR ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\crypto.c
;	COMDAT SubDword
_TEXT	SEGMENT
v$ = 8
SubDword PROC						; COMDAT

; 96   : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 97   : 	BYTE *b = (BYTE *)&v;
; 98   : 	uint_fast8_t i = 0;

  00004	ba 04 00 00 00	 mov	 edx, 4
  00009	48 8d 4c 24 08	 lea	 rcx, QWORD PTR v$[rsp]
$LL4@SubDword:

; 99   : 
; 100  : 	for (; i < sizeof(DWORD); i++) b[i] = SBox[b[i]];

  0000e	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00011	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:SBox
  00018	42 8a 04 00	 mov	 al, BYTE PTR [rax+r8]
  0001c	88 01		 mov	 BYTE PTR [rcx], al
  0001e	48 ff c1	 inc	 rcx
  00021	48 83 ea 01	 sub	 rdx, 1
  00025	75 e7		 jne	 SHORT $LL4@SubDword

; 101  : 
; 102  : 	return v;

  00027	8b 44 24 08	 mov	 eax, DWORD PTR v$[rsp]

; 103  : }

  0002b	c3		 ret	 0
SubDword ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\crypto.c
;	COMDAT AesInitKey
_TEXT	SEGMENT
Ctx$ = 48
Key$ = 56
IsV6$ = 64
RijndaelKeyBytes$ = 72
AesInitKey PROC						; COMDAT

; 107  : {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	41 8a f0	 mov	 sil, r8b
  00012	48 8b d9	 mov	 rbx, rcx

; 108  : 	int RijndaelKeyDwords = RijndaelKeyBytes / sizeof(DWORD);

  00015	4d 63 c1	 movsxd	 r8, r9d
  00018	49 8b f8	 mov	 rdi, r8
  0001b	48 c1 ef 02	 shr	 rdi, 2

; 109  : 	Ctx->rounds = (uint_fast8_t)(RijndaelKeyDwords + 6);

  0001f	8d 47 06	 lea	 eax, DWORD PTR [rdi+6]
  00022	88 81 c0 00 00
	00		 mov	 BYTE PTR [rcx+192], al

; 110  : 
; 111  : 	static const DWORD RCon[] = {
; 112  : 		0x00000000, 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000,
; 113  : 		0x20000000, 0x40000000, 0x80000000, 0x1B000000, 0x36000000 };
; 114  : 
; 115  : 	uint_fast8_t  i;
; 116  : 	DWORD  temp;
; 117  : 
; 118  : 	memcpy(Ctx->Key, Key, RijndaelKeyBytes);

  00028	e8 00 00 00 00	 call	 memcpy

; 119  : 
; 120  : 	for ( i = (uint_fast8_t)RijndaelKeyDwords; i < ( Ctx->rounds + 1 ) << 2; i++ )

  0002d	0f b6 83 c0 00
	00 00		 movzx	 eax, BYTE PTR [rbx+192]
  00034	44 0f b6 d7	 movzx	 r10d, dil
  00038	45 8b ca	 mov	 r9d, r10d
  0003b	8d 04 85 04 00
	00 00		 lea	 eax, DWORD PTR [rax*4+4]
  00042	44 3b d0	 cmp	 r10d, eax
  00045	73 64		 jae	 SHORT $LN3@AesInitKey
$LL4@AesInitKey:

; 121  : 	{
; 122  : 		temp = Ctx->Key[ i - 1 ];

  00047	46 8b 44 8b fc	 mov	 r8d, DWORD PTR [rbx+r9*4-4]

; 123  : 
; 124  : 		if ( ( i % RijndaelKeyDwords ) == 0 )

  0004c	41 8b c1	 mov	 eax, r9d
  0004f	99		 cdq
  00050	f7 ff		 idiv	 edi
  00052	85 d2		 test	 edx, edx
  00054	75 29		 jne	 SHORT $LN5@AesInitKey

; 125  : 			temp = BE32( SubDword( ROR32( BE32(temp), 24)  ) ^ RCon[ i / RijndaelKeyDwords ] );

  00056	41 0f c8	 bswap	 r8d
  00059	41 c1 c0 08	 rol	 r8d, 8
  0005d	41 8b c8	 mov	 ecx, r8d
  00060	e8 00 00 00 00	 call	 SubDword
  00065	44 8b c0	 mov	 r8d, eax
  00068	41 8b c1	 mov	 eax, r9d
  0006b	99		 cdq
  0006c	f7 ff		 idiv	 edi
  0006e	48 63 c8	 movsxd	 rcx, eax
  00071	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?RCon@?1??AesInitKey@@9@9
  00078	44 33 04 88	 xor	 r8d, DWORD PTR [rax+rcx*4]
  0007c	41 0f c8	 bswap	 r8d
$LN5@AesInitKey:

; 126  : 
; 127  : 		Ctx->Key[ i ] = Ctx->Key[ i - RijndaelKeyDwords ] ^ temp;

  0007f	44 2b cf	 sub	 r9d, edi
  00082	49 63 c1	 movsxd	 rax, r9d
  00085	44 33 04 83	 xor	 r8d, DWORD PTR [rbx+rax*4]
  00089	41 0f b6 c2	 movzx	 eax, r10b
  0008d	41 fe c2	 inc	 r10b
  00090	45 0f b6 ca	 movzx	 r9d, r10b
  00094	44 89 04 83	 mov	 DWORD PTR [rbx+rax*4], r8d
  00098	0f b6 83 c0 00
	00 00		 movzx	 eax, BYTE PTR [rbx+192]
  0009f	8d 04 85 04 00
	00 00		 lea	 eax, DWORD PTR [rax*4+4]
  000a6	44 3b c8	 cmp	 r9d, eax
  000a9	72 9c		 jb	 SHORT $LL4@AesInitKey
$LN3@AesInitKey:

; 128  : 	}
; 129  : 
; 130  : 	if ( IsV6 )

  000ab	40 84 f6	 test	 sil, sil
  000ae	74 0f		 je	 SHORT $LN6@AesInitKey

; 131  : 	{
; 132  : 		BYTE *_p = (BYTE *)Ctx->Key;
; 133  : 
; 134  : 		_p[ 4 * 16 ] ^= 0x73;

  000b0	80 73 40 73	 xor	 BYTE PTR [rbx+64], 115	; 00000073H

; 135  : 		_p[ 6 * 16 ] ^= 0x09;

  000b4	80 73 60 09	 xor	 BYTE PTR [rbx+96], 9

; 136  : 		_p[ 8 * 16 ] ^= 0xE4;

  000b8	80 b3 80 00 00
	00 e4		 xor	 BYTE PTR [rbx+128], 228	; 000000e4H
$LN6@AesInitKey:

; 137  : 	}
; 138  : }

  000bf	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c4	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000c9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cd	5f		 pop	 rdi
  000ce	c3		 ret	 0
AesInitKey ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\crypto.c
;	COMDAT SubBytes
_TEXT	SEGMENT
block$ = 8
SubBytes PROC						; COMDAT

; 144  : 	uint_fast8_t i;
; 145  : 
; 146  : 	for (i = 0; i < AES_BLOCK_BYTES; i++)

  00000	ba 10 00 00 00	 mov	 edx, 16
$LL4@SubBytes:

; 147  : 		block[i] = SBox[ block[i] ];

  00005	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00008	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:SBox
  0000f	42 8a 04 00	 mov	 al, BYTE PTR [rax+r8]
  00013	88 01		 mov	 BYTE PTR [rcx], al
  00015	48 ff c1	 inc	 rcx
  00018	48 83 ea 01	 sub	 rdx, 1
  0001c	75 e7		 jne	 SHORT $LL4@SubBytes

; 148  : }

  0001e	c3		 ret	 0
SubBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\crypto.c
;	COMDAT ShiftRows
_TEXT	SEGMENT
bIn$ = 0
state$ = 32
ShiftRows PROC						; COMDAT

; 152  : {

  00000	48 83 ec 18	 sub	 rsp, 24

; 153  : 	BYTE bIn[AES_BLOCK_BYTES];
; 154  : 	uint_fast8_t i;
; 155  : 
; 156  : 	memcpy(bIn, state, AES_BLOCK_BYTES);

  00004	0f 10 01	 movups	 xmm0, XMMWORD PTR [rcx]

; 157  : 	for (i = 0; i < AES_BLOCK_BYTES; i++)

  00007	45 32 c0	 xor	 r8b, r8b
  0000a	f3 0f 7f 04 24	 movdqu	 XMMWORD PTR bIn$[rsp], xmm0
$LL4@ShiftRows:

; 158  : 	{
; 159  : 		state[i] = bIn[(i + ((i & 3) << 2)) & 0xf];

  0000f	41 0f b6 c0	 movzx	 eax, r8b
  00013	41 fe c0	 inc	 r8b
  00016	8d 14 80	 lea	 edx, DWORD PTR [rax+rax*4]
  00019	83 e2 0f	 and	 edx, 15
  0001c	8a 04 14	 mov	 al, BYTE PTR bIn$[rsp+rdx]
  0001f	88 01		 mov	 BYTE PTR [rcx], al
  00021	48 ff c1	 inc	 rcx
  00024	41 80 f8 10	 cmp	 r8b, 16
  00028	72 e5		 jb	 SHORT $LL4@ShiftRows

; 160  : 	}
; 161  : };

  0002a	48 83 c4 18	 add	 rsp, 24
  0002e	c3		 ret	 0
ShiftRows ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\crypto.c
;	COMDAT MixColumns
_TEXT	SEGMENT
state$ = 8
MixColumns PROC						; COMDAT

; 165  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi
  0000a	48 8b d9	 mov	 rbx, rcx

; 166  : 	uint_fast8_t i = 0;

  0000d	bf 04 00 00 00	 mov	 edi, 4
$LL4@MixColumns:

; 167  : 	for (; i < AES_BLOCK_WORDS; i++)
; 168  : 	{
; 169  : 		DWORD word = LE32(((DWORD *) state)[i]);

  00012	44 8b 1b	 mov	 r11d, DWORD PTR [rbx]

; 170  : 		((DWORD *) state)[i] = LE32(Mul2(word) ^ ROR32(Mul3(word), 8) ^ ROR32(word, 16) ^ ROR32(word, 24));

  00015	41 8b d3	 mov	 edx, r11d
  00018	c1 ea 07	 shr	 edx, 7
  0001b	45 8b d3	 mov	 r10d, r11d
  0001e	41 c1 c2 10	 rol	 r10d, 16
  00022	8b c2		 mov	 eax, edx
  00024	25 01 01 01 01	 and	 eax, 16843009		; 01010101H
  00029	83 e2 01	 and	 edx, 1
  0002c	44 6b c8 1b	 imul	 r9d, eax, 27
  00030	47 8d 04 1b	 lea	 r8d, DWORD PTR [r11+r11]
  00034	45 33 c3	 xor	 r8d, r11d
  00037	41 8b c3	 mov	 eax, r11d
  0003a	c1 c0 08	 rol	 eax, 8
  0003d	44 33 d0	 xor	 r10d, eax
  00040	41 c1 e0 18	 shl	 r8d, 24
  00044	69 c2 00 00 00
	1b		 imul	 eax, edx, 452984832	; 1b000000H
  0004a	41 8b c9	 mov	 ecx, r9d
  0004d	41 33 cb	 xor	 ecx, r11d
  00050	d1 e9		 shr	 ecx, 1
  00052	44 33 c0	 xor	 r8d, eax
  00055	41 8b c3	 mov	 eax, r11d
  00058	25 00 7f 7f 7f	 and	 eax, 2139062016		; 7f7f7f00H
  0005d	41 81 e3 7f 7f
	7f ff		 and	 r11d, -8421505		; ff7f7f7fH
  00064	33 c8		 xor	 ecx, eax
  00066	45 03 db	 add	 r11d, r11d
  00069	c1 e9 07	 shr	 ecx, 7
  0006c	44 0b c1	 or	 r8d, ecx
  0006f	45 33 d0	 xor	 r10d, r8d
  00072	45 33 d3	 xor	 r10d, r11d
  00075	45 33 d1	 xor	 r10d, r9d
  00078	44 89 13	 mov	 DWORD PTR [rbx], r10d
  0007b	48 8d 5b 04	 lea	 rbx, QWORD PTR [rbx+4]
  0007f	48 83 ef 01	 sub	 rdi, 1
  00083	75 8d		 jne	 SHORT $LL4@MixColumns

; 171  : 	}
; 172  : }

  00085	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0008a	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
  0008f	c3		 ret	 0
MixColumns ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\crypto.c
;	COMDAT AesEncryptBlock
_TEXT	SEGMENT
Ctx$ = 48
block$ = 56
AesEncryptBlock PROC					; COMDAT

; 176  : {

$LN40:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	0f b6 a9 c0 00
	00 00		 movzx	 ebp, BYTE PTR [rcx+192]
  00020	48 8b da	 mov	 rbx, rdx
  00023	48 8b f1	 mov	 rsi, rcx

; 177  : 	uint_fast8_t  i;
; 178  : 
; 179  : 	for ( i = 0 ;; i += 4 )

  00026	40 32 ff	 xor	 dil, dil
  00029	44 8d 34 ad fc
	ff ff ff	 lea	 r14d, DWORD PTR [rbp*4-4]
$LL4@AesEncrypt:

; 46   : 	for (i = 0; i < AES_BLOCK_WORDS; i++)

  00031	44 0f b6 c7	 movzx	 r8d, dil
  00035	48 8b d3	 mov	 rdx, rbx
  00038	49 c1 e0 02	 shl	 r8, 2
  0003c	b9 04 00 00 00	 mov	 ecx, 4
  00041	4c 2b c3	 sub	 r8, rbx
  00044	4c 03 c6	 add	 r8, rsi
$LL10@AesEncrypt:

; 47   : 	{
; 48   : 		((DWORD*)out)[i] ^= ((DWORD*)in)[i];

  00047	41 8b 04 10	 mov	 eax, DWORD PTR [r8+rdx]
  0004b	31 02		 xor	 DWORD PTR [rdx], eax
  0004d	48 8d 52 04	 lea	 rdx, QWORD PTR [rdx+4]
  00051	48 83 e9 01	 sub	 rcx, 1
  00055	75 f0		 jne	 SHORT $LL10@AesEncrypt

; 146  : 	for (i = 0; i < AES_BLOCK_BYTES; i++)

  00057	48 8b cb	 mov	 rcx, rbx
  0005a	ba 10 00 00 00	 mov	 edx, 16
$LL15@AesEncrypt:

; 147  : 		block[i] = SBox[ block[i] ];

  0005f	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00062	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:SBox
  00069	42 8a 04 00	 mov	 al, BYTE PTR [rax+r8]
  0006d	88 01		 mov	 BYTE PTR [rcx], al
  0006f	48 ff c1	 inc	 rcx
  00072	48 83 ea 01	 sub	 rdx, 1
  00076	75 e7		 jne	 SHORT $LL15@AesEncrypt

; 180  : 	{
; 181  : 		AddRoundKey(block, &Ctx->Key[ i ]);
; 182  : 		SubBytes(block);
; 183  : 		ShiftRows(block);

  00078	48 8b cb	 mov	 rcx, rbx
  0007b	e8 00 00 00 00	 call	 ShiftRows

; 184  : 
; 185  : 		if ( i >= ( Ctx->rounds - 1 ) << 2 ) break;

  00080	44 0f b6 cf	 movzx	 r9d, dil
  00084	45 3b ce	 cmp	 r9d, r14d
  00087	7d 0e		 jge	 SHORT $LN27@AesEncrypt

; 186  : 
; 187  : 		MixColumns(block);

  00089	48 8b cb	 mov	 rcx, rbx
  0008c	e8 00 00 00 00	 call	 MixColumns
  00091	40 80 c7 04	 add	 dil, 4
  00095	eb 9a		 jmp	 SHORT $LL4@AesEncrypt
$LN27@AesEncrypt:

; 188  : 	}
; 189  : 
; 190  : 	AddRoundKey(block, &Ctx->Key[ Ctx->rounds << 2 ]);

  00097	8d 04 ad 00 00
	00 00		 lea	 eax, DWORD PTR [rbp*4]
  0009e	b9 04 00 00 00	 mov	 ecx, 4
  000a3	48 8d 14 86	 lea	 rdx, QWORD PTR [rsi+rax*4]
  000a7	48 2b d3	 sub	 rdx, rbx
$LL20@AesEncrypt:

; 48   : 		((DWORD*)out)[i] ^= ((DWORD*)in)[i];

  000aa	8b 04 1a	 mov	 eax, DWORD PTR [rdx+rbx]
  000ad	31 03		 xor	 DWORD PTR [rbx], eax
  000af	48 8d 5b 04	 lea	 rbx, QWORD PTR [rbx+4]
  000b3	48 83 e9 01	 sub	 rcx, 1
  000b7	75 f1		 jne	 SHORT $LL20@AesEncrypt

; 191  : }

  000b9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000be	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000c3	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000c8	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000cd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d1	41 5e		 pop	 r14
  000d3	c3		 ret	 0
AesEncryptBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\crypto.c
;	COMDAT AesCmacV4
_TEXT	SEGMENT
mac$ = 32
Ctx$ = 48
Message$ = 272
MessageSize$ = 280
MacOut$ = 288
AesCmacV4 PROC						; COMDAT

; 195  : {

$LN20:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H
  00017	49 8b e8	 mov	 rbp, r8
  0001a	48 8b f2	 mov	 rsi, rdx
  0001d	48 8b f9	 mov	 rdi, rcx

; 196  :     size_t i;
; 197  :     BYTE mac[AES_BLOCK_BYTES];
; 198  :     AesCtx Ctx;
; 199  : 
; 200  :     AesInitKey(&Ctx, AesKeyV4, FALSE, V4_KEY_BYTES);

  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:AesKeyV4
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR Ctx$[rsp]
  0002f	41 b9 14 00 00
	00		 mov	 r9d, 20
  00035	e8 00 00 00 00	 call	 AesInitKey
  0003a	0f 57 c9	 xorps	 xmm1, xmm1
  0003d	48 8d 44 24 20	 lea	 rax, QWORD PTR mac$[rsp]

; 201  : 
; 202  :     memset(mac, 0, sizeof(mac));
; 203  :     memset(Message + MessageSize, 0, AES_BLOCK_BYTES);

  00042	0f 11 0c 37	 movups	 XMMWORD PTR [rdi+rsi], xmm1

; 204  :     Message[MessageSize] = 0x80;

  00046	c6 04 37 80	 mov	 BYTE PTR [rdi+rsi], 128	; 00000080H
  0004a	33 db		 xor	 ebx, ebx
  0004c	0f 57 c0	 xorps	 xmm0, xmm0
  0004f	48 2b f8	 sub	 rdi, rax
  00052	0f 11 44 24 20	 movups	 XMMWORD PTR mac$[rsp], xmm0
$LL4@AesCmacV4:

; 46   : 	for (i = 0; i < AES_BLOCK_WORDS; i++)

  00057	48 8d 4c 24 20	 lea	 rcx, QWORD PTR mac$[rsp]
  0005c	ba 04 00 00 00	 mov	 edx, 4
  00061	4c 8d 04 1f	 lea	 r8, QWORD PTR [rdi+rbx]
$LL9@AesCmacV4:

; 47   : 	{
; 48   : 		((DWORD*)out)[i] ^= ((DWORD*)in)[i];

  00065	41 8b 04 08	 mov	 eax, DWORD PTR [r8+rcx]
  00069	31 01		 xor	 DWORD PTR [rcx], eax
  0006b	48 8d 49 04	 lea	 rcx, QWORD PTR [rcx+4]
  0006f	48 83 ea 01	 sub	 rdx, 1
  00073	75 f0		 jne	 SHORT $LL9@AesCmacV4

; 205  : 
; 206  :     for (i = 0; i <= MessageSize; i += AES_BLOCK_BYTES)
; 207  :     {
; 208  :         XorBlock(Message + i, mac);
; 209  :         AesEncryptBlock(&Ctx, mac);

  00075	48 8d 54 24 20	 lea	 rdx, QWORD PTR mac$[rsp]
  0007a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR Ctx$[rsp]
  0007f	e8 00 00 00 00	 call	 AesEncryptBlock
  00084	48 83 c3 10	 add	 rbx, 16
  00088	48 3b de	 cmp	 rbx, rsi
  0008b	76 ca		 jbe	 SHORT $LL4@AesCmacV4

; 210  :     }
; 211  : 
; 212  :     memcpy(MacOut, mac, AES_BLOCK_BYTES);

  0008d	0f 10 44 24 20	 movups	 xmm0, XMMWORD PTR mac$[rsp]

; 213  : }

  00092	4c 8d 9c 24 00
	01 00 00	 lea	 r11, QWORD PTR [rsp+256]
  0009a	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  0009e	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  000a2	f3 0f 7f 45 00	 movdqu	 XMMWORD PTR [rbp], xmm0
  000a7	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  000ab	49 8b e3	 mov	 rsp, r11
  000ae	5f		 pop	 rdi
  000af	c3		 ret	 0
AesCmacV4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\crypto.c
;	COMDAT ShiftRowsR
_TEXT	SEGMENT
b$ = 0
state$ = 32
ShiftRowsR PROC						; COMDAT

; 259  : {

  00000	48 83 ec 18	 sub	 rsp, 24

; 260  : 	BYTE b[AES_BLOCK_BYTES];
; 261  : 	uint_fast8_t i;
; 262  : 
; 263  : 	memcpy(b, state, AES_BLOCK_BYTES);

  00004	0f 10 01	 movups	 xmm0, XMMWORD PTR [rcx]

; 264  : 
; 265  : 	for (i = 0; i < AES_BLOCK_BYTES; i++)

  00007	45 32 c9	 xor	 r9b, r9b
  0000a	f3 0f 7f 04 24	 movdqu	 XMMWORD PTR b$[rsp], xmm0
$LL4@ShiftRowsR:

; 266  : 		state[i] = b[(i - ((i & 0x3) << 2)) & 0xf];

  0000f	45 0f b6 c1	 movzx	 r8d, r9b
  00013	41 fe c1	 inc	 r9b
  00016	41 8b d0	 mov	 edx, r8d
  00019	83 e2 03	 and	 edx, 3
  0001c	c1 e2 02	 shl	 edx, 2
  0001f	4c 2b c2	 sub	 r8, rdx
  00022	41 83 e0 0f	 and	 r8d, 15
  00026	42 8a 04 04	 mov	 al, BYTE PTR b$[rsp+r8]
  0002a	88 01		 mov	 BYTE PTR [rcx], al
  0002c	48 ff c1	 inc	 rcx
  0002f	41 80 f9 10	 cmp	 r9b, 16
  00033	72 da		 jb	 SHORT $LL4@ShiftRowsR

; 267  : }

  00035	48 83 c4 18	 add	 rsp, 24
  00039	c3		 ret	 0
ShiftRowsR ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\crypto.c
;	COMDAT SubBytesR
_TEXT	SEGMENT
block$ = 8
SubBytesR PROC						; COMDAT

; 272  : 	uint_fast8_t i;
; 273  : 
; 274  : 	for (i = 0; i < AES_BLOCK_BYTES; i++)

  00000	ba 10 00 00 00	 mov	 edx, 16
$LL4@SubBytesR:

; 275  : 	{
; 276  : 		block[i] = GetSBoxR( block[i] );

  00005	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00008	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:SBoxR
  0000f	42 8a 04 00	 mov	 al, BYTE PTR [rax+r8]
  00013	88 01		 mov	 BYTE PTR [rcx], al
  00015	48 ff c1	 inc	 rcx
  00018	48 83 ea 01	 sub	 rdx, 1
  0001c	75 e7		 jne	 SHORT $LL4@SubBytesR

; 277  : 	}
; 278  : }

  0001e	c3		 ret	 0
SubBytesR ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\crypto.c
;	COMDAT AesEncryptCbc
_TEXT	SEGMENT
Ctx$ = 64
iv$ = 72
data$ = 80
len$ = 88
AesEncryptCbc PROC					; COMDAT

; 282  : {

$LN30:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 283  : 	// Pad up to blocksize inclusive
; 284  : 	size_t i;
; 285  : 	uint_fast8_t pad = (~*len & (AES_BLOCK_BYTES - 1)) + 1;

  00018	41 8a 01	 mov	 al, BYTE PTR [r9]
  0001b	4c 8b f9	 mov	 r15, rcx

; 286  : 
; 287  : 	#if defined(__GNUC__) && (__GNUC__ == 4 && __GNUC_MINOR__ == 8) // gcc 4.8 memset bug https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56977
; 288  : 		for (i = 0; i < pad; i++) data[*len + i] = pad;
; 289  : 	#else
; 290  : 		memset(data + *len, pad, pad);

  0001e	49 8b 19	 mov	 rbx, QWORD PTR [r9]
  00021	f6 d0		 not	 al
  00023	24 0f		 and	 al, 15
  00025	49 8b e8	 mov	 rbp, r8
  00028	fe c0		 inc	 al
  0002a	4c 8b f2	 mov	 r14, rdx
  0002d	0f b6 f8	 movzx	 edi, al
  00030	49 8b f1	 mov	 rsi, r9
  00033	4a 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+r8]
  00037	0f b6 d0	 movzx	 edx, al
  0003a	44 8b c7	 mov	 r8d, edi
  0003d	e8 00 00 00 00	 call	 memset

; 291  : 	#endif
; 292  : 	*len += pad;

  00042	48 03 df	 add	 rbx, rdi

; 293  : 
; 294  : 	if ( iv ) XorBlock(iv, data);

  00045	bf 04 00 00 00	 mov	 edi, 4
  0004a	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  0004d	4d 85 f6	 test	 r14, r14
  00050	74 17		 je	 SHORT $LN14@AesEncrypt

; 46   : 	for (i = 0; i < AES_BLOCK_WORDS; i++)

  00052	48 8b cd	 mov	 rcx, rbp
  00055	4c 2b f5	 sub	 r14, rbp
  00058	8b d7		 mov	 edx, edi
$LL15@AesEncrypt:

; 47   : 	{
; 48   : 		((DWORD*)out)[i] ^= ((DWORD*)in)[i];

  0005a	41 8b 04 0e	 mov	 eax, DWORD PTR [r14+rcx]
  0005e	31 01		 xor	 DWORD PTR [rcx], eax
  00060	48 03 cf	 add	 rcx, rdi
  00063	48 83 ea 01	 sub	 rdx, 1
  00067	75 f1		 jne	 SHORT $LL15@AesEncrypt
$LN14@AesEncrypt:

; 295  : 	AesEncryptBlock(Ctx, data);

  00069	48 8b d5	 mov	 rdx, rbp
  0006c	49 8b cf	 mov	 rcx, r15
  0006f	e8 00 00 00 00	 call	 AesEncryptBlock

; 296  : 
; 297  : 	for (i = *len - AES_BLOCK_BYTES; i; i -= AES_BLOCK_BYTES)

  00074	48 83 c3 f0	 add	 rbx, -16
  00078	74 29		 je	 SHORT $LN3@AesEncrypt
$LL4@AesEncrypt:

; 298  : 	{
; 299  : 		XorBlock(data, data + AES_BLOCK_BYTES);

  0007a	48 8d 4d 10	 lea	 rcx, QWORD PTR [rbp+16]
  0007e	48 8b d7	 mov	 rdx, rdi
  00081	48 8b e9	 mov	 rbp, rcx
$LL10@AesEncrypt:

; 48   : 		((DWORD*)out)[i] ^= ((DWORD*)in)[i];

  00084	8b 41 f0	 mov	 eax, DWORD PTR [rcx-16]
  00087	31 01		 xor	 DWORD PTR [rcx], eax
  00089	48 03 cf	 add	 rcx, rdi
  0008c	48 83 ea 01	 sub	 rdx, 1
  00090	75 f2		 jne	 SHORT $LL10@AesEncrypt

; 300  : 		data += AES_BLOCK_BYTES;
; 301  : 		AesEncryptBlock(Ctx, data);

  00092	48 8b d5	 mov	 rdx, rbp
  00095	49 8b cf	 mov	 rcx, r15
  00098	e8 00 00 00 00	 call	 AesEncryptBlock
  0009d	48 83 eb 10	 sub	 rbx, 16
  000a1	75 d7		 jne	 SHORT $LL4@AesEncrypt
$LN3@AesEncrypt:

; 302  : 	}
; 303  : }

  000a3	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a8	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000ad	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000b2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b6	41 5f		 pop	 r15
  000b8	41 5e		 pop	 r14
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
AesEncryptCbc ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\crypto.c
;	COMDAT AesDecryptBlock
_TEXT	SEGMENT
Ctx$ = 48
block$ = 56
AesDecryptBlock PROC					; COMDAT

; 307  : {

$LN40:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 308  : 	uint_fast8_t  i;
; 309  : 
; 310  : 	AddRoundKey(block, &Ctx->Key[ Ctx->rounds << 2 ]);

  0000f	44 0f b6 81 c0
	00 00 00	 movzx	 r8d, BYTE PTR [rcx+192]
  00017	48 8b fa	 mov	 rdi, rdx
  0001a	49 c1 e0 04	 shl	 r8, 4
  0001e	48 8b f1	 mov	 rsi, rcx
  00021	4c 03 c1	 add	 r8, rcx
  00024	41 b9 04 00 00
	00		 mov	 r9d, 4
  0002a	4c 2b c2	 sub	 r8, rdx
$LL20@AesDecrypt:

; 48   : 		((DWORD*)out)[i] ^= ((DWORD*)in)[i];

  0002d	41 8b 04 10	 mov	 eax, DWORD PTR [r8+rdx]
  00031	31 02		 xor	 DWORD PTR [rdx], eax
  00033	48 8d 52 04	 lea	 rdx, QWORD PTR [rdx+4]
  00037	49 83 e9 01	 sub	 r9, 1
  0003b	75 f0		 jne	 SHORT $LL20@AesDecrypt

; 311  : 
; 312  : 	for ( i = ( Ctx->rounds - 1 ) << 2 ;; i -= 4 )

  0003d	8a 99 c0 00 00
	00		 mov	 bl, BYTE PTR [rcx+192]
  00043	fe cb		 dec	 bl
  00045	c0 e3 02	 shl	 bl, 2
$LL4@AesDecrypt:

; 313  : 	{
; 314  : 		ShiftRowsR(block);

  00048	48 8b cf	 mov	 rcx, rdi
  0004b	e8 00 00 00 00	 call	 ShiftRowsR
  00050	b9 10 00 00 00	 mov	 ecx, 16
  00055	4c 8b d7	 mov	 r10, rdi
$LL10@AesDecrypt:

; 276  : 		block[i] = GetSBoxR( block[i] );

  00058	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:SBoxR
  00063	8a 04 10	 mov	 al, BYTE PTR [rax+rdx]
  00066	41 88 02	 mov	 BYTE PTR [r10], al
  00069	49 ff c2	 inc	 r10
  0006c	48 83 e9 01	 sub	 rcx, 1
  00070	75 e6		 jne	 SHORT $LL10@AesDecrypt

; 46   : 	for (i = 0; i < AES_BLOCK_WORDS; i++)

  00072	44 0f b6 c3	 movzx	 r8d, bl
  00076	48 8b cf	 mov	 rcx, rdi
  00079	49 c1 e0 02	 shl	 r8, 2
  0007d	ba 04 00 00 00	 mov	 edx, 4
  00082	4c 2b c7	 sub	 r8, rdi
  00085	4c 03 c6	 add	 r8, rsi
$LL15@AesDecrypt:

; 47   : 	{
; 48   : 		((DWORD*)out)[i] ^= ((DWORD*)in)[i];

  00088	41 8b 04 08	 mov	 eax, DWORD PTR [r8+rcx]
  0008c	31 01		 xor	 DWORD PTR [rcx], eax
  0008e	48 8d 49 04	 lea	 rcx, QWORD PTR [rcx+4]
  00092	48 83 ea 01	 sub	 rdx, 1
  00096	75 f0		 jne	 SHORT $LL15@AesDecrypt

; 315  : 		SubBytesR(block);
; 316  : 		AddRoundKey(block, &Ctx->Key[ i ]);
; 317  : 
; 318  : 		if ( i == 0 ) break;

  00098	84 db		 test	 bl, bl
  0009a	74 0d		 je	 SHORT $LN27@AesDecrypt

; 319  : 
; 320  : 		MixColumnsR(block);

  0009c	48 8b cf	 mov	 rcx, rdi
  0009f	e8 00 00 00 00	 call	 MixColumnsR
  000a4	80 c3 fc	 add	 bl, 252			; 000000fcH
  000a7	eb 9f		 jmp	 SHORT $LL4@AesDecrypt
$LN27@AesDecrypt:

; 321  : 	}
; 322  : }

  000a9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ae	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
AesDecryptBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\crypto.c
;	COMDAT AesDecryptCbc
_TEXT	SEGMENT
Ctx$ = 48
iv$dead$ = 56
data$ = 64
len$ = 72
AesDecryptCbc PROC					; COMDAT

; 326  : {

$LN30:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 327  : 	BYTE  *cc;
; 328  : 
; 329  : 	for (cc = data + len - AES_BLOCK_BYTES; cc > data; cc -= AES_BLOCK_BYTES)

  0000f	49 8d 59 f0	 lea	 rbx, QWORD PTR [r9-16]
  00013	49 8b f8	 mov	 rdi, r8
  00016	49 03 d8	 add	 rbx, r8
  00019	48 8b f1	 mov	 rsi, rcx
  0001c	49 3b d8	 cmp	 rbx, r8
  0001f	76 2c		 jbe	 SHORT $LN3@AesDecrypt
$LL4@AesDecrypt:

; 330  : 	{
; 331  : 		AesDecryptBlock(Ctx, cc);

  00021	48 8b d3	 mov	 rdx, rbx
  00024	48 8b ce	 mov	 rcx, rsi
  00027	e8 00 00 00 00	 call	 AesDecryptBlock
  0002c	48 8b d3	 mov	 rdx, rbx
  0002f	41 b8 04 00 00
	00		 mov	 r8d, 4
$LL10@AesDecrypt:

; 48   : 		((DWORD*)out)[i] ^= ((DWORD*)in)[i];

  00035	8b 42 f0	 mov	 eax, DWORD PTR [rdx-16]
  00038	31 02		 xor	 DWORD PTR [rdx], eax
  0003a	48 8d 52 04	 lea	 rdx, QWORD PTR [rdx+4]
  0003e	49 83 e8 01	 sub	 r8, 1
  00042	75 f1		 jne	 SHORT $LL10@AesDecrypt

; 327  : 	BYTE  *cc;
; 328  : 
; 329  : 	for (cc = data + len - AES_BLOCK_BYTES; cc > data; cc -= AES_BLOCK_BYTES)

  00044	48 83 eb 10	 sub	 rbx, 16
  00048	48 3b df	 cmp	 rbx, rdi
  0004b	77 d4		 ja	 SHORT $LL4@AesDecrypt
$LN3@AesDecrypt:

; 332  : 		XorBlock(cc - AES_BLOCK_BYTES, cc);
; 333  : 	}
; 334  : 
; 335  : 	AesDecryptBlock(Ctx, cc);

  0004d	48 8b d3	 mov	 rdx, rbx
  00050	48 8b ce	 mov	 rcx, rsi

; 336  : 	if ( iv ) XorBlock(iv, cc);
; 337  : }

  00053	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00058	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5f		 pop	 rdi

; 332  : 		XorBlock(cc - AES_BLOCK_BYTES, cc);
; 333  : 	}
; 334  : 
; 335  : 	AesDecryptBlock(Ctx, cc);

  00062	e9 00 00 00 00	 jmp	 AesDecryptBlock
AesDecryptCbc ENDP
_TEXT	ENDS
END
