; Listing generated by Microsoft (R) Optimizing Compiler Version 19.32.31332.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0M@EKADLLOH@DNS?5timeout@			; `string'
PUBLIC	??_C@_06BPNCNPOK@dns_cb@			; `string'
PUBLIC	??_C@_0DD@NDGBJGCA@C?3?2Users?2dev?2source?2repos?2alpin@ ; `string'
PUBLIC	??_C@_0BJ@COKDKGDG@Unexpected?5DNS?5response?3@	; `string'
PUBLIC	??_C@_0N@NMEECLIA@?$CFlu?5?$CFs?5is?5?$CFM@	; `string'
PUBLIC	??_C@_0BF@BIFAMDJJ@?$CFs?5DNS?5lookup?5failed@	; `string'
PUBLIC	??_C@_0BF@ICMAECGD@?$CFlu?5already?5resolved@	; `string'
PUBLIC	??_C@_0BA@NIPDPKGJ@stray?5DNS?5reply@		; `string'
PUBLIC	??_C@_09MNPPPHEH@DNS?5error@			; `string'
PUBLIC	??_C@_05OPJKAIHI@?$AA?$AA?$AB?$AA?$AB@		; `string'
PUBLIC	??_C@_0CL@JCHAOBLG@DNS?5server?5URL?5is?5NULL?4?5Call?5mg@ ; `string'
PUBLIC	??_C@_08DKAJKOFH@resolver@			; `string'
PUBLIC	??_C@_0M@JPBODOLJ@resolve?5OOM@			; `string'
PUBLIC	??_C@_0N@IKEIFCGJ@mg_sendnsreq@			; `string'
PUBLIC	??_C@_0CD@BHFHEJIF@?$CFlu?5resolving?5?$CF?4?$CKs?5?$EA?5?$CFs?0?5txnid?5@ ; `string'
PUBLIC	??_C@_08ECFMEKDO@DNS?5send@			; `string'
PUBLIC	??_C@_08PPPGGPGG@mg_error@			; `string'
PUBLIC	??_C@_0L@PPINGECD@?$CFlu?5?$CFld?5?$CFs@	; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_03OJHLLCGB@inf@				; `string'
PUBLIC	??_C@_04DHEMHBNF@?9inf@				; `string'
PUBLIC	??_C@_03LHCJEHON@nan@				; `string'
PUBLIC	??_C@_04EBNJJJJI@?$CF?4?$CKs@			; `string'
PUBLIC	??_C@_0BB@JCEFLFJE@0123456789abcdef@		; `string'
PUBLIC	??_C@_02MDDDDAID@0x@				; `string'
PUBLIC	??_C@_06HDKLCKBF@?$CFs?4?4?$CFd@		; `string'
PUBLIC	??_C@_15JJPIMNBO@?$AAr?$AAb@			; `string'
PUBLIC	??_C@_15PKPONJIK@?$AA?2?$AA?$CK@		; `string'
PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
PUBLIC	??_C@_02DJGKEECL@?4?4@				; `string'
PUBLIC	??_C@_03DOPCBAKB@a?$CLb@			; `string'
PUBLIC	??_C@_0BE@LMOOGHBG@Content?9Disposition@	; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_08BABJIOEM@filename@			; `string'
PUBLIC	??_C@_0BG@EPHDEOFO@Authorization?3?5Basic?5@	; `string'
PUBLIC	??_C@_02PCIJFNDE@?$AN?6@			; `string'
PUBLIC	??_C@_0O@KKGICJJI@mg_http_bauth@		; `string'
PUBLIC	??_C@_0BA@LNKDPIGG@?$CFlu?5oom?5?$CFd?9?$DO?$CFd?5@ ; `string'
PUBLIC	??_C@_0P@HOJGPHBA@Content?9Length@		; `string'
PUBLIC	??_C@_05FKGKDBHO@HTTP?1@			; `string'
PUBLIC	??_C@_03KBBGFLEK@PUT@				; `string'
PUBLIC	??_C@_04HCJEIHPL@POST@				; `string'
PUBLIC	??_C@_03BLNIAGKO@204@				; `string'
PUBLIC	??_C@_0L@HNOLOFKI@?5?5?5?5?5?5?5?5?$AN?6@	; `string'
PUBLIC	??_C@_05CLMJGDKL@?$CF08lx@			; `string'
PUBLIC	??_C@_05BJCCKDDP@?$CFlx?$AN?6@			; `string'
PUBLIC	??_C@_08LJHDLOLO@Continue@			; `string'
PUBLIC	??_C@_0BE@FGMIEJDD@Switching?5Protocols@	; `string'
PUBLIC	??_C@_0L@HFFAKEO@Processing@			; `string'
PUBLIC	??_C@_02GIPFHKNO@OK@				; `string'
PUBLIC	??_C@_07BBIDHECN@Created@			; `string'
PUBLIC	??_C@_08DOBOODLA@Accepted@			; `string'
PUBLIC	??_C@_0BO@FFMKBPKJ@Non?9authoritative?5Information@ ; `string'
PUBLIC	??_C@_0L@FDPJCNGK@No?5Content@			; `string'
PUBLIC	??_C@_0O@BFFLKCLE@Reset?5Content@		; `string'
PUBLIC	??_C@_0BA@NNLNHGMN@Partial?5Content@		; `string'
PUBLIC	??_C@_0N@BFLFIKGM@Multi?9Status@		; `string'
PUBLIC	??_C@_0BB@BPJDMGEO@Already?5Reported@		; `string'
PUBLIC	??_C@_07EIILAAHO@IM?5Used@			; `string'
PUBLIC	??_C@_0BB@HLFEHKPE@Multiple?5Choices@		; `string'
PUBLIC	??_C@_0BC@BPBCNFPI@Moved?5Permanently@		; `string'
PUBLIC	??_C@_05JDGHEPJG@Found@				; `string'
PUBLIC	??_C@_09FAMPMKIP@See?5Other@			; `string'
PUBLIC	??_C@_0N@IFEFAIJB@Not?5Modified@		; `string'
PUBLIC	??_C@_09JFBGBFIM@Use?5Proxy@			; `string'
PUBLIC	??_C@_0BD@PJMNAMDM@Temporary?5Redirect@		; `string'
PUBLIC	??_C@_0BD@INBAOFGJ@Permanent?5Redirect@		; `string'
PUBLIC	??_C@_0M@LNAIDEEG@Bad?5Request@			; `string'
PUBLIC	??_C@_0N@OOAPMOJA@Unauthorized@			; `string'
PUBLIC	??_C@_0BB@LMPIHCBH@Payment?5Required@		; `string'
PUBLIC	??_C@_09LMDIMFJD@Forbidden@			; `string'
PUBLIC	??_C@_09CFCBFJND@Not?5Found@			; `string'
PUBLIC	??_C@_0BD@CCIPIALO@Method?5Not?5Allowed@	; `string'
PUBLIC	??_C@_0P@HHIDFAOI@Not?5Acceptable@		; `string'
PUBLIC	??_C@_0BO@ONPAAOGI@Proxy?5Authentication?5Required@ ; `string'
PUBLIC	??_C@_0BA@HALFGGF@Request?5Timeout@		; `string'
PUBLIC	??_C@_08OJCIFGDF@Conflict@			; `string'
PUBLIC	??_C@_04OKIIBCCG@Gone@				; `string'
PUBLIC	??_C@_0BA@JCKHPIPI@Length?5Required@		; `string'
PUBLIC	??_C@_0BE@BBDBJOM@Precondition?5Failed@		; `string'
PUBLIC	??_C@_0BC@OEAEGMJF@Payload?5Too?5Large@		; `string'
PUBLIC	??_C@_0BF@IHICNLJ@Request?9URI?5Too?5Long@	; `string'
PUBLIC	??_C@_0BH@HLJJIAEN@Unsupported?5Media?5Type@	; `string'
PUBLIC	??_C@_0CA@CBAMGINK@Requested?5Range?5Not?5Satisfiable@ ; `string'
PUBLIC	??_C@_0BD@NDMHPAED@Expectation?5Failed@		; `string'
PUBLIC	??_C@_0N@EHOCJLEI@I?8m?5a?5teapot@		; `string'
PUBLIC	??_C@_0BE@GGAHKOMD@Misdirected?5Request@	; `string'
PUBLIC	??_C@_0BF@BHJGKCEF@Unprocessable?5Entity@	; `string'
PUBLIC	??_C@_06GFKCFIPE@Locked@			; `string'
PUBLIC	??_C@_0BC@KKPOPIFM@Failed?5Dependency@		; `string'
PUBLIC	??_C@_0BB@NMNIKHMI@Upgrade?5Required@		; `string'
PUBLIC	??_C@_0BG@GMCBMLGE@Precondition?5Required@	; `string'
PUBLIC	??_C@_0BC@JPBLCMB@Too?5Many?5Requests@		; `string'
PUBLIC	??_C@_0CA@IOEEABLM@Request?5Header?5Fields?5Too?5Large@ ; `string'
PUBLIC	??_C@_0CD@CBAJJADO@Connection?5Closed?5Without?5Respo@ ; `string'
PUBLIC	??_C@_0BO@BDFIKLNJ@Unavailable?5For?5Legal?5Reasons@ ; `string'
PUBLIC	??_C@_0BG@NOEDODFP@Client?5Closed?5Request@	; `string'
PUBLIC	??_C@_0BG@NJGANGCC@Internal?5Server?5Error@	; `string'
PUBLIC	??_C@_0BA@JGKGKAME@Not?5Implemented@		; `string'
PUBLIC	??_C@_0M@BNCNLPGM@Bad?5Gateway@			; `string'
PUBLIC	??_C@_0BE@NGHLFKBN@Service?5Unavailable@	; `string'
PUBLIC	??_C@_0BA@MCOKJNOA@Gateway?5Timeout@		; `string'
PUBLIC	??_C@_0BL@ODCMNOHA@HTTP?5Version?5Not?5Supported@ ; `string'
PUBLIC	??_C@_0BI@PDOLHBJO@Variant?5Also?5Negotiates@	; `string'
PUBLIC	??_C@_0BF@GDOFGFPB@Insufficient?5Storage@	; `string'
PUBLIC	??_C@_0O@KJBLEGOO@Loop?5Detected@		; `string'
PUBLIC	??_C@_0N@JKOFFNBC@Not?5Extended@		; `string'
PUBLIC	??_C@_0CA@JCJMCNEH@Network?5Authentication?5Required@ ; `string'
PUBLIC	??_C@_0BO@OINGLCPC@Network?5Connect?5Timeout?5Error@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0DC@GEFECBIH@HTTP?11?41?5?$CFd?5?$CFs?$AN?6?$CFsContent?9Lengt@ ; `string'
PUBLIC	??_C@_06DLMLPGDC@?$CF?910lu@			; `string'
PUBLIC	??_C@_0M@KPHLEGAC@?$CC?$CFlld?4?$CFlld?$CC@	; `string'
PUBLIC	??_C@_04PNIFHPHN@html@				; `string'
PUBLIC	??_C@_0BJ@CDMHJEKP@text?1html?$DL?5charset?$DNutf?98@ ; `string'
PUBLIC	??_C@_03KDICCKGJ@htm@				; `string'
PUBLIC	??_C@_03KFINIEDC@css@				; `string'
PUBLIC	??_C@_0BI@MKFMEPPC@text?1css?$DL?5charset?$DNutf?98@ ; `string'
PUBLIC	??_C@_02EBOMECCO@js@				; `string'
PUBLIC	??_C@_0BP@IBHNJOOI@text?1javascript?$DL?5charset?$DNutf?98@ ; `string'
PUBLIC	??_C@_03MOLNDNH@gif@				; `string'
PUBLIC	??_C@_09HADNJIG@image?1gif@			; `string'
PUBLIC	??_C@_03NNHBJLDF@png@				; `string'
PUBLIC	??_C@_09NGJJJBGE@image?1png@			; `string'
PUBLIC	??_C@_03PEGNKCLE@jpg@				; `string'
PUBLIC	??_C@_0L@PJKHLKFB@image?1jpeg@			; `string'
PUBLIC	??_C@_04OFMADDDJ@jpeg@				; `string'
PUBLIC	??_C@_04GOJHKINL@woff@				; `string'
PUBLIC	??_C@_09DPKAPMKA@font?1woff@			; `string'
PUBLIC	??_C@_03FKLJBLIF@ttf@				; `string'
PUBLIC	??_C@_08LDONFKLE@font?1ttf@			; `string'
PUBLIC	??_C@_03NNPBMGBD@svg@				; `string'
PUBLIC	??_C@_0O@MMMFMLNF@image?1svg?$CLxml@		; `string'
PUBLIC	??_C@_03CLFHJCDC@txt@				; `string'
PUBLIC	??_C@_0BK@LKDCPLNF@text?1plain?$DL?5charset?$DNutf?98@ ; `string'
PUBLIC	??_C@_03LJGCHEIJ@avi@				; `string'
PUBLIC	??_C@_0BA@DDNKOHJP@video?1x?9msvideo@		; `string'
PUBLIC	??_C@_03NIPKHAHH@csv@				; `string'
PUBLIC	??_C@_08CGFGOOIN@text?1csv@			; `string'
PUBLIC	??_C@_03GHKEPEMO@doc@				; `string'
PUBLIC	??_C@_0BD@DMPJCPHP@application?1msword@		; `string'
PUBLIC	??_C@_03JACLIBNI@exe@				; `string'
PUBLIC	??_C@_0BJ@JDCJMJCJ@application?1octet?9stream@	; `string'
PUBLIC	??_C@_02JIPGGKDE@gz@				; `string'
PUBLIC	??_C@_0BB@JGMCIAKF@application?1gzip@		; `string'
PUBLIC	??_C@_03DAGBJKHL@ico@				; `string'
PUBLIC	??_C@_0N@DKCCOJIM@image?1x?9icon@		; `string'
PUBLIC	??_C@_04CLCAKCEI@json@				; `string'
PUBLIC	??_C@_0BB@MDJGEIPD@application?1json@		; `string'
PUBLIC	??_C@_03CNBJFNFA@mov@				; `string'
PUBLIC	??_C@_0BA@MEHPJOJG@video?1quicktime@		; `string'
PUBLIC	??_C@_03LHGNACFN@mp3@				; `string'
PUBLIC	??_C@_0L@DOFAEOCL@audio?1mpeg@			; `string'
PUBLIC	??_C@_03PICMJEJK@mp4@				; `string'
PUBLIC	??_C@_09GGJCJIJ@video?1mp4@			; `string'
PUBLIC	??_C@_04FHOAOPCJ@mpeg@				; `string'
PUBLIC	??_C@_0L@NDKAOLEK@video?1mpeg@			; `string'
PUBLIC	??_C@_03MJPNCPKC@pdf@				; `string'
PUBLIC	??_C@_0BA@MHMDKHOF@application?1pdf@		; `string'
PUBLIC	??_C@_05HNDFGKM@shtml@				; `string'
PUBLIC	??_C@_03KCKOFLPB@tgz@				; `string'
PUBLIC	??_C@_0BD@LHPABEHA@application?1tar?9gz@	; `string'
PUBLIC	??_C@_03BICDMHKB@wav@				; `string'
PUBLIC	??_C@_09KOEADLDC@audio?1wav@			; `string'
PUBLIC	??_C@_04BKLLFFLE@webp@				; `string'
PUBLIC	??_C@_0L@GNMNMNM@image?1webp@			; `string'
PUBLIC	??_C@_03LCAAOJEC@zip@				; `string'
PUBLIC	??_C@_0BA@LMDOGBAF@application?1zip@		; `string'
PUBLIC	??_C@_03FOICNDPP@3gp@				; `string'
PUBLIC	??_C@_0L@IGCDBAML@video?13gpp@			; `string'
PUBLIC	??_C@_06GOGCPOMN@bytes?$DN@			; `string'
PUBLIC	??_C@_0BA@KDJCHKHJ@Accept?9Encoding@		; `string'
PUBLIC	??_C@_04HOHEGKBO@gzip@				; `string'
PUBLIC	??_C@_05HPILMEBC@?$CFs?4gz@			; `string'
PUBLIC	??_C@_0L@CKKNHDCB@Not?5found?6@			; `string'
PUBLIC	??_C@_0O@PLENHEOP@If?9None?9Match@		; `string'
PUBLIC	??_C@_05CFMCGLCK@Range@				; `string'
PUBLIC	??_C@_0BO@IKDCAKCB@Content?9Range?3?5bytes?5?$CK?1?$CFlld?$AN?6@ ; `string'
PUBLIC	??_C@_0CG@JKKKPNMP@Content?9Range?3?5bytes?5?$CFllu?9?$CFllu?1@ ; `string'
PUBLIC	??_C@_0BJ@MBGLAIMM@Content?9Encoding?3?5gzip?$AN?6@ ; `string'
PUBLIC	??_C@_0EN@DLMBNGCO@HTTP?11?41?5?$CFd?5?$CFs?$AN?6Content?9Type?3?5?$CF@ ; `string'
PUBLIC	??_C@_04BINJNOJD@HEAD@				; `string'
PUBLIC	??_C@_06GIIGBPHC@?$CFs?$CFc?$CFs@		; `string'
PUBLIC	??_C@_0O@NAEKIGEC@printdirentry@		; `string'
PUBLIC	??_C@_0N@BELOEIBP@?$CFs?5truncated@		; `string'
PUBLIC	??_C@_0BB@MFGDKDCP@?$CFlu?5stat?$CI?$CFs?$CJ?3?5?$CFd@ ; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_05DDGJGJB@?$FLDIR?$FN@			; `string'
PUBLIC	??_C@_04BFAHMMK@?$CFlld@			; `string'
PUBLIC	??_C@_03FKNCMABI@?$CFlu@			; `string'
PUBLIC	??_C@_0FI@IPGJIOJD@?5?5?$DMtr?$DO?$DMtd?$DO?$DMa?5href?$DN?$CC?$CF?4?$CKs?$CFs?$CC?$DO?$CFs?$CFs@ ; `string'
PUBLIC	??_C@_0BMF@KFFEPKPH@?$DMscript?$DOfunction?5srt?$CItb?0?5sc?0?5so@ ; `string'
PUBLIC	??_C@_0BME@DCNGJJJ@for?5?$CIvar?5i?5?$DN?50?$DL?5i?5?$DM?5tr?4length?$DL?5@ ; `string'
PUBLIC	??_C@_0FI@EOBPCODB@HTTP?11?41?5200?5OK?$AN?6Content?9Type?3?5@ ; `string'
PUBLIC	??_C@_0BII@BEKFAOHG@?$DM?$CBDOCTYPE?5html?$DO?$DMhtml?$DO?$DMhead?$DO?$DMtit@ ; `string'
PUBLIC	??_C@_0FA@IECPBOOL@?5?5?$DMtr?$DO?$DMtd?$DO?$DMa?5href?$DN?$CC?4?4?$CC?$DO?4?4?$DM?1a?$DO?$DM?1@ ; `string'
PUBLIC	??_C@_04KCOIGPKP@7?412@				; `string'
PUBLIC	??_C@_0HB@HMGLNPND@?$DM?1tbody?$DO?$DMtfoot?$DO?$DMtr?$DO?$DMtd?5colspan?$DN@ ; `string'
PUBLIC	??_C@_0BD@CCPJKDLJ@Exceeded?5path?5size@	; `string'
PUBLIC	??_C@_0N@KKHAJPLM@Invalid?5path@		; `string'
PUBLIC	??_C@_0N@GNCHAPHH@uri_to_path2@			; `string'
PUBLIC	??_C@_0BC@GKOJEFML@?$CFlu?5?$CF?4?$CKs?5?9?$DO?5?$CFs?5?$CFd@ ; `string'
PUBLIC	??_C@_0DL@NDIFMFHG@HTTP?11?41?5301?5Moved?$AN?6Location?3?5?$CF@ ; `string'
PUBLIC	??_C@_0M@LFMFBCIF@?1index?4html@		; `string'
PUBLIC	??_C@_0N@LEPNGMOP@?1index?4shtml@		; `string'
PUBLIC	??_C@_0P@KMKBALOG@?1index?4html?4gz@		; `string'
PUBLIC	??_C@_0O@NAFGPKMI@Authorization@		; `string'
PUBLIC	??_C@_06FFOGOLGD@Basic?5@			; `string'
PUBLIC	??_C@_07KGFIHGLJ@Bearer?5@			; `string'
PUBLIC	??_C@_06EGBLANDJ@Cookie@			; `string'
PUBLIC	??_C@_0N@GOCCFLMF@access_token@			; `string'
PUBLIC	??_C@_06KLHHMIGM@offset@			; `string'
PUBLIC	??_C@_03JALODAI@?$CFld@				; `string'
PUBLIC	??_C@_0P@HACFLAGA@mg_http_upload@		; `string'
PUBLIC	??_C@_0BF@OCKNFKIO@?$CFs?5?9?$DO?5?$CFd?5bytes?5?$EA?5?$CFld@ ; `string'
PUBLIC	??_C@_0BA@ELGKPKEI@offset?5required@		; `string'
PUBLIC	??_C@_0BE@OMMGLANF@?$CFs?3?5offset?5mismatch@	; `string'
PUBLIC	??_C@_0BJ@IDGNCELE@?$CFs?3?5over?5max?5size?5of?5?$CFlu@ ; `string'
PUBLIC	??_C@_0N@BCMHMOCL@open?$CI?$CFs?$CJ?3?5?$CFd@	; `string'
PUBLIC	??_C@_0BG@HFEJOELF@HTTP?5parse?0?5?$CFlu?5bytes@ ; `string'
PUBLIC	??_C@_0BC@ELHLFCNH@Transfer?9Encoding@		; `string'
PUBLIC	??_C@_07KCKHAHHI@chunked@			; `string'
PUBLIC	??_C@_0BK@LOOLINP@Invalid?5Transfer?9Encoding@	; `string'
PUBLIC	??_C@_0O@HABHDEMH@Invalid?5chunk@		; `string'
PUBLIC	??_C@_05CMMBDMDD@?1quit@			; `string'
PUBLIC	??_C@_03DJDALPN@ok?6@				; `string'
PUBLIC	??_C@_06HAHILENG@?1debug@			; `string'
PUBLIC	??_C@_07JPIHOLMH@$?4level@			; `string'
PUBLIC	??_C@_0BH@JNCLOPOB@Debug?5level?5set?5to?5?$CFd?6@ ; `string'
PUBLIC	??_C@_03JNMAOHCK@hi?6@				; `string'
PUBLIC	??_C@_0BA@HJJGBKFB@mg_iobuf_resize@		; `string'
PUBLIC	??_C@_0L@OOAJBPCA@?$CFlld?9?$DO?$CFlld@		; `string'
PUBLIC	??_C@_07GIIPGIPO@?$AI?$AM?6?$AN?7?2?$CC@	; `string'
PUBLIC	??_C@_07HHNAIFDF@bfnrt?2?$CC@			; `string'
PUBLIC	??_C@_01EPMOAMKG@$@				; `string'
PUBLIC	??_C@_04MLLLIHIP@null@				; `string'
PUBLIC	??_C@_0BD@KJILOAFG@?$CF?96llx?5?$CFd?5?$CFs?3?$CFd?3?$CFs@ ; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5@				; `string'
PUBLIC	??_C@_03NDEAONJP@?5?5?5@			; `string'
PUBLIC	??_C@_02JDJKNLJP@?$AA?$PP@			; `string'
PUBLIC	??_C@_0M@JCOIBNAC@mg_mqtt_pub@			; `string'
PUBLIC	??_C@_0BF@LDABDMHN@?$CFlu?5?$FL?$CF?4?$CKs?$FN?5?9?$DO?5?$FL?$CF?4?$CKs?$FN@ ; `string'
PUBLIC	??_C@_07IJPJCEBD@mqtt_cb@			; `string'
PUBLIC	??_C@_0BL@MPELNGON@?$CFlu?5MQTT?5malformed?5message@ ; `string'
PUBLIC	??_C@_0BO@KABHPGHA@?$CFlu?5MQTT?5CMD?5?$CFd?5len?5?$CFd?5?$FL?$CF?4?$CKs?$FN@ ; `string'
PUBLIC	??_C@_0O@MHLPOCL@?$CFlu?5Connected@		; `string'
PUBLIC	??_C@_0BO@FOKBBNGE@?$CFlu?5MQTT?5auth?5failed?0?5code?5?$CFd@ ; `string'
PUBLIC	??_C@_09IPAEKDAI@localhost@			; `string'
PUBLIC	??_C@_0O@KLFCDPFL@mg_close_conn@		; `string'
PUBLIC	??_C@_0P@KGEINCCM@?$CFlu?5?$CFld?5closed@	; `string'
PUBLIC	??_C@_0L@KLLEPGGK@mg_connect@			; `string'
PUBLIC	??_C@_08FJNKCABM@null?5url@			; `string'
PUBLIC	??_C@_03CDNNJDDN@OOM@				; `string'
PUBLIC	??_C@_04MNPDLBCA@udp?3@				; `string'
PUBLIC	??_C@_09MIIPHL@mg_listen@			; `string'
PUBLIC	??_C@_06BEBLAAFA@OOM?5?$CFs@			; `string'
PUBLIC	??_C@_0BF@LPNPPMDI@Failed?3?5?$CFs?0?5errno?5?$CFd@ ; `string'
PUBLIC	??_C@_0M@HDNIMCKK@mg_mgr_free@			; `string'
PUBLIC	??_C@_0BH@JCIDLGBI@All?5connections?5closed@	; `string'
PUBLIC	??_C@_0BB@OGCNOFJ@udp?3?1?18?48?48?48?353@	; `string'
PUBLIC	??_C@_0CA@BFGPOJEH@udp?3?1?1?$FL2001?34860?34860?3?38888?$FN?353@ ; `string'
PUBLIC	??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd@	; `string'
PUBLIC	??_C@_0BK@HMDKCEIC@?$FL?$CFx?3?$CFx?3?$CFx?3?$CFx?3?$CFx?3?$CFx?3?$CFx?3?$CFx?$FN@ ; `string'
PUBLIC	??_C@_06CECBMHAI@?$CFM?3?$CFhu@			; `string'
PUBLIC	??_C@_0BO@ONJEFEPB@?$CF02x?3?$CF02x?3?$CF02x?3?$CF02x?3?$CF02x?3?$CF02x@ ; `string'
PUBLIC	??_C@_0EB@NFPJKBDG@ABCDEFGHIJKLMNOPQRSTUVWXYZabcde@ ; `string'
PUBLIC	??_C@_0BB@KBBHFJEB@?$CC?$CF?4?$CKs?5not?5found?$CC@ ; `string'
PUBLIC	??_C@_08CIJFEAAL@$?4method@			; `string'
PUBLIC	??_C@_08OBNEFDHG@$?4result@			; `string'
PUBLIC	??_C@_07DMPMNMMD@$?4error@			; `string'
PUBLIC	??_C@_02OOGLLHAM@?$CFm@				; `string'
PUBLIC	??_C@_04LOGAHCH@$?4id@				; `string'
PUBLIC	??_C@_06KJFADLGN@result@			; `string'
PUBLIC	??_C@_02EGCJHIOB@id@				; `string'
PUBLIC	??_C@_0N@PNCPKKEK@?$HL?$CFm?3?$CF?4?$CKs?0?$CFm?3@ ; `string'
PUBLIC	??_C@_01CELHOKLL@?$HN@				; `string'
PUBLIC	??_C@_01HCONENDN@?$HL@				; `string'
PUBLIC	??_C@_08BPPEJENG@?$CFm?3?$CF?4?$CKs?0@		; `string'
PUBLIC	??_C@_07ONPBMBOP@message@			; `string'
PUBLIC	??_C@_04NDFOBODE@code@				; `string'
PUBLIC	??_C@_05KKCIMGE@error@				; `string'
PUBLIC	??_C@_0O@OFIPIANJ@?$CFm?3?$HL?$CFm?3?$CFd?0?$CFm?3@ ; `string'
PUBLIC	??_C@_02MGAGNKFF@?$HN?$HN@			; `string'
PUBLIC	??_C@_01IHBHIGKO@?0@				; `string'
PUBLIC	??_C@_04KHKDDGAF@?$CFs?$CFm@			; `string'
PUBLIC	??_C@_04JGKFJELO@?$FL?$CFM?$FN@			; `string'
PUBLIC	??_C@_0O@HEBLIINH@mg_sntp_parse@		; `string'
PUBLIC	??_C@_0P@IGMAHBCN@corrupt?5packet@		; `string'
PUBLIC	??_C@_0BD@ODENNIKF@not?5a?5server?5reply@	; `string'
PUBLIC	??_C@_0BM@DMBHJOKM@server?5sent?5a?5kiss?5of?5death@ ; `string'
PUBLIC	??_C@_0BP@BOHGPAAD@?$CFlld?5?$CFlld?5?$CFlld?5?$CFlld?5delta?3?$CFlld@ ; `string'
PUBLIC	??_C@_0BH@HEKJPPM@unexpected?5version?3?5?$CFd@	; `string'
PUBLIC	??_C@_07IENOENON@sntp_cb@			; `string'
PUBLIC	??_C@_0CB@NMDLDFPE@?$CFlu?5got?5time?3?5?$CFlld?5ms?5from?5epoc@ ; `string'
PUBLIC	??_C@_05EENHEND@?$CFu?4?$CFu@			; `string'
PUBLIC	??_C@_0BA@IPEAOCEK@mg_sntp_request@		; `string'
PUBLIC	??_C@_0BI@GABKECNF@?$CFlu?5wait?5until?5resolved@ ; `string'
PUBLIC	??_C@_0BK@GMHACAIO@udp?3?1?1time?4google?4com?3123@ ; `string'
PUBLIC	??_C@_05GCGDNJJE@iolog@				; `string'
PUBLIC	??_C@_02NOFGAPG@?$DM?9@				; `string'
PUBLIC	??_C@_02HBOOOICD@?9?$DO@			; `string'
PUBLIC	??_C@_0BF@EEHNBJP@?6?9?9?5?$CFlu?5?$CFM?5?$CFs?5?$CFM?5?$CFld@ ; `string'
PUBLIC	??_C@_07JDKIIIBC@mg_send@			; `string'
PUBLIC	??_C@_0BJ@PDGMPLOC@?$CFlu?5?$CFld?5?$CFd?3?$CFd?5?$CFld?5err?5?$CFd@ ; `string'
PUBLIC	??_C@_0BB@DCONLCEI@mg_open_listener@		; `string'
PUBLIC	??_C@_0BK@JOJCJPAN@invalid?5listening?5URL?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0L@GLCCNLE@socket?3?5?$CFd@		; `string'
PUBLIC	??_C@_0CH@MDOFAPIK@setsockopt?$CISO_EXCLUSIVEADDRUSE?$CJ@ ; `string'
PUBLIC	??_C@_08JIJPKGKG@bind?3?5?$CFd@			; `string'
PUBLIC	??_C@_0L@JNLECNPF@listen?3?5?$CFd@		; `string'
PUBLIC	??_C@_0BB@HBLGCKAG@MG_MAX_RECV_SIZE@		; `string'
PUBLIC	??_C@_09GCLNDOPN@read_conn@			; `string'
PUBLIC	??_C@_0CM@HEALIOMK@?$CFlu?5?$CFp?5snd?5?$CFld?1?$CFld?5rcv?5?$CFld?1?$CFld?5@ ; `string'
PUBLIC	??_C@_0L@EJLBGHPI@write_conn@			; `string'
PUBLIC	??_C@_0CN@BLHHFBGP@?$CFlu?5?$CFld?5snd?5?$CFld?1?$CFld?5rcv?5?$CFld?1?$CFld@ ; `string'
PUBLIC	??_C@_0N@PIIOOFNF@socket?5error@		; `string'
PUBLIC	??_C@_0N@NLOJAIMF@socket?$CI?$CJ?3?5?$CFd@	; `string'
PUBLIC	??_C@_0BE@CANALBHN@mg_connect_resolved@		; `string'
PUBLIC	??_C@_0BD@BGCIPAPF@?$CFlu?5?$CFld?5?9?$DO?5?$CFM?5pend@ ; `string'
PUBLIC	??_C@_0M@IFBHBJKC@connect?3?5?$CFd@		; `string'
PUBLIC	??_C@_0M@JPIAAHBH@accept_conn@			; `string'
PUBLIC	??_C@_0BM@MOEFGJHP@?$CFlu?5accept?5failed?0?5errno?5?$CFd@ ; `string'
PUBLIC	??_C@_07BFGKJN@?$CFlu?5OOM@			; `string'
PUBLIC	??_C@_0BK@FOFCOHME@?$CFlu?5?$CFld?5accepted?5?$CFM?5?9?$DO?5?$CFM@ ; `string'
PUBLIC	??_C@_0P@BJADDKBJ@mg_wakeup_init@		; `string'
PUBLIC	??_C@_0BK@NGAOEDDO@Cannot?5create?5socket?5pair@ ; `string'
PUBLIC	??_C@_0BA@FLEIGMKI@?$CFlu?5?$CFp?5pipe?5?$CFlu@	; `string'
PUBLIC	??_C@_0M@OABIKPAM@mg_mgr_poll@			; `string'
PUBLIC	??_C@_0BE@INNKIICP@?$CFlu?5?$CFc?$CFc?5?$CFc?$CFc?$CFc?$CFc?$CFc@ ; `string'
PUBLIC	??_C@_0BA@BDBJPBPM@SSI?5not?5enabled@		; `string'
PUBLIC	??_C@_0BD@JJGECGC@TLS?5is?5not?5enabled@	; `string'
PUBLIC	??_C@_04HILLDDDP@wss?3@				; `string'
PUBLIC	??_C@_06FOAKIDDH@https?3@			; `string'
PUBLIC	??_C@_06NDJNKKHE@mqtts?3@			; `string'
PUBLIC	??_C@_04JKEBHBLC@ssl?3@				; `string'
PUBLIC	??_C@_04DHGBAOCG@tls?3@				; `string'
PUBLIC	??_C@_05BIDNLEPK@tcps?3@			; `string'
PUBLIC	??_C@_05DDMNBEIG@http?3@			; `string'
PUBLIC	??_C@_03FLENLALG@ws?3@				; `string'
PUBLIC	??_C@_05KMOJKCJJ@mqtt?3@			; `string'
PUBLIC	??_C@_0BB@DHKKPGMP@?$CFd?4?$CFd?4?$CFd?4?$CFd?1?$CFd?$CFn@ ; `string'
PUBLIC	??_C@_0O@LGGJJEIN@?$CFd?4?$CFd?4?$CFd?4?$CFd?$CFn@ ; `string'
PUBLIC	??_C@_0CF@DPPCDNJI@258EAFA5?9E914?947DA?995CA?9C5AB0DC@ ; `string'
PUBLIC	??_C@_0GG@POFBIFLO@HTTP?11?41?5101?5Switching?5Protocol@ ; `string'
PUBLIC	??_C@_0BP@DMDNHPGD@Sec?9WebSocket?9Protocol?3?5?$CF?4?$CKs?$AN?6@ ; `string'
PUBLIC	??_C@_0L@OGHHDJDI@mg_ws_send@			; `string'
PUBLIC	??_C@_0BC@FGABKOKF@WS?5out?3?5?$CFd?5?$FL?$CF?4?$CKs?$FN@ ; `string'
PUBLIC	??_C@_08KKMPEAED@not?5http@			; `string'
PUBLIC	??_C@_03HEBKFNAF@101@				; `string'
PUBLIC	??_C@_0BD@GICIJAKK@ws?5handshake?5error@	; `string'
PUBLIC	??_C@_08JNAIHJJA@mg_ws_cb@			; `string'
PUBLIC	??_C@_07OOPHNCPN@WS?5PONG@			; `string'
PUBLIC	??_C@_0N@IFMBNCDN@?$CFlu?5WS?5CLOSE@		; `string'
PUBLIC	??_C@_0BB@MNJJIOAL@unknown?5WS?5op?5?$CFd@	; `string'
PUBLIC	??_C@_0HJ@GLCKOEAJ@GET?5?$CFs?5HTTP?11?41?$AN?6Upgrade?3?5webso@ ; `string'
PUBLIC	??_C@_0BC@DFHBMDHG@Sec?9WebSocket?9Key@		; `string'
PUBLIC	??_C@_0BF@MMCLFHAA@WS?5upgrade?5expected?6@	; `string'
PUBLIC	??_C@_0BH@JBAMIGCM@Sec?9WebSocket?9Protocol@	; `string'
PUBLIC	mg_fs_packed
PUBLIC	mg_fs_posix
PUBLIC	mg_log_level
EXTRN	__imp___WSAFDIsSet:PROC
EXTRN	__imp_accept:PROC
EXTRN	__imp_bind:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp_closesocket:PROC
EXTRN	__imp_select:PROC
EXTRN	__imp__mkdir:PROC
EXTRN	__imp_listen:PROC
EXTRN	__imp_WideCharToMultiByte:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_strtol:PROC
EXTRN	__imp__wfopen:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp_putchar:PROC
EXTRN	__imp_WSAStartup:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	__imp_getpeername:PROC
EXTRN	__imp_rename:PROC
EXTRN	__imp_getsockname:PROC
EXTRN	__imp_Sleep:PROC
EXTRN	__imp_MultiByteToWideChar:PROC
EXTRN	__imp_send:PROC
EXTRN	__imp_socket:PROC
EXTRN	__imp_connect:PROC
EXTRN	__imp_GetFileAttributesW:PROC
EXTRN	__imp_FindClose:PROC
EXTRN	__imp_remove:PROC
EXTRN	__imp_recvfrom:PROC
EXTRN	__imp_recv:PROC
EXTRN	__imp_FindNextFileW:PROC
EXTRN	__imp__wstat64:PROC
EXTRN	__imp_SetLastError:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_sendto:PROC
EXTRN	__imp_FindFirstFileW:PROC
EXTRN	__imp_ioctlsocket:PROC
EXTRN	__imp_setsockopt:PROC
EXTRN	__imp_WSAGetLastError:PROC
;	COMDAT ??_C@_0BH@JBAMIGCM@Sec?9WebSocket?9Protocol@
CONST	SEGMENT
??_C@_0BH@JBAMIGCM@Sec?9WebSocket?9Protocol@ DB 'Sec-WebSocket-Protocol', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MMCLFHAA@WS?5upgrade?5expected?6@
CONST	SEGMENT
??_C@_0BF@MMCLFHAA@WS?5upgrade?5expected?6@ DB 'WS upgrade expected', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DFHBMDHG@Sec?9WebSocket?9Key@
CONST	SEGMENT
??_C@_0BC@DFHBMDHG@Sec?9WebSocket?9Key@ DB 'Sec-WebSocket-Key', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HJ@GLCKOEAJ@GET?5?$CFs?5HTTP?11?41?$AN?6Upgrade?3?5webso@
CONST	SEGMENT
??_C@_0HJ@GLCKOEAJ@GET?5?$CFs?5HTTP?11?41?$AN?6Upgrade?3?5webso@ DB 'GET '
	DB	'%s HTTP/1.1', 0dH, 0aH, 'Upgrade: websocket', 0dH, 0aH, 'Host'
	DB	': %.*s', 0dH, 0aH, 'Connection: Upgrade', 0dH, 0aH, 'Sec-WebS'
	DB	'ocket-Version: 13', 0dH, 0aH, 'Sec-WebSocket-Key: %s', 0dH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MNJJIOAL@unknown?5WS?5op?5?$CFd@
CONST	SEGMENT
??_C@_0BB@MNJJIOAL@unknown?5WS?5op?5?$CFd@ DB 'unknown WS op %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IFMBNCDN@?$CFlu?5WS?5CLOSE@
CONST	SEGMENT
??_C@_0N@IFMBNCDN@?$CFlu?5WS?5CLOSE@ DB '%lu WS CLOSE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07OOPHNCPN@WS?5PONG@
CONST	SEGMENT
??_C@_07OOPHNCPN@WS?5PONG@ DB 'WS PONG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JNAIHJJA@mg_ws_cb@
CONST	SEGMENT
??_C@_08JNAIHJJA@mg_ws_cb@ DB 'mg_ws_cb', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GICIJAKK@ws?5handshake?5error@
CONST	SEGMENT
??_C@_0BD@GICIJAKK@ws?5handshake?5error@ DB 'ws handshake error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HEBKFNAF@101@
CONST	SEGMENT
??_C@_03HEBKFNAF@101@ DB '101', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08KKMPEAED@not?5http@
CONST	SEGMENT
??_C@_08KKMPEAED@not?5http@ DB 'not http', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FGABKOKF@WS?5out?3?5?$CFd?5?$FL?$CF?4?$CKs?$FN@
CONST	SEGMENT
??_C@_0BC@FGABKOKF@WS?5out?3?5?$CFd?5?$FL?$CF?4?$CKs?$FN@ DB 'WS out: %d '
	DB	'[%.*s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OGHHDJDI@mg_ws_send@
CONST	SEGMENT
??_C@_0L@OGHHDJDI@mg_ws_send@ DB 'mg_ws_send', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DMDNHPGD@Sec?9WebSocket?9Protocol?3?5?$CF?4?$CKs?$AN?6@
CONST	SEGMENT
??_C@_0BP@DMDNHPGD@Sec?9WebSocket?9Protocol?3?5?$CF?4?$CKs?$AN?6@ DB 'Sec'
	DB	'-WebSocket-Protocol: %.*s', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@POFBIFLO@HTTP?11?41?5101?5Switching?5Protocol@
CONST	SEGMENT
??_C@_0GG@POFBIFLO@HTTP?11?41?5101?5Switching?5Protocol@ DB 'HTTP/1.1 101'
	DB	' Switching Protocols', 0dH, 0aH, 'Upgrade: websocket', 0dH, 0aH
	DB	'Connection: Upgrade', 0dH, 0aH, 'Sec-WebSocket-Accept: %s', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DPPCDNJI@258EAFA5?9E914?947DA?995CA?9C5AB0DC@
CONST	SEGMENT
??_C@_0CF@DPPCDNJI@258EAFA5?9E914?947DA?995CA?9C5AB0DC@ DB '258EAFA5-E914'
	DB	'-47DA-95CA-C5AB0DC85B11', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LGGJJEIN@?$CFd?4?$CFd?4?$CFd?4?$CFd?$CFn@
CONST	SEGMENT
??_C@_0O@LGGJJEIN@?$CFd?4?$CFd?4?$CFd?4?$CFd?$CFn@ DB '%d.%d.%d.%d%n', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DHKKPGMP@?$CFd?4?$CFd?4?$CFd?4?$CFd?1?$CFd?$CFn@
CONST	SEGMENT
??_C@_0BB@DHKKPGMP@?$CFd?4?$CFd?4?$CFd?4?$CFd?1?$CFd?$CFn@ DB '%d.%d.%d.%'
	DB	'd/%d%n', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05KMOJKCJJ@mqtt?3@
CONST	SEGMENT
??_C@_05KMOJKCJJ@mqtt?3@ DB 'mqtt:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FLENLALG@ws?3@
CONST	SEGMENT
??_C@_03FLENLALG@ws?3@ DB 'ws:', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DDMNBEIG@http?3@
CONST	SEGMENT
??_C@_05DDMNBEIG@http?3@ DB 'http:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BIDNLEPK@tcps?3@
CONST	SEGMENT
??_C@_05BIDNLEPK@tcps?3@ DB 'tcps:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DHGBAOCG@tls?3@
CONST	SEGMENT
??_C@_04DHGBAOCG@tls?3@ DB 'tls:', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JKEBHBLC@ssl?3@
CONST	SEGMENT
??_C@_04JKEBHBLC@ssl?3@ DB 'ssl:', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NDJNKKHE@mqtts?3@
CONST	SEGMENT
??_C@_06NDJNKKHE@mqtts?3@ DB 'mqtts:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FOAKIDDH@https?3@
CONST	SEGMENT
??_C@_06FOAKIDDH@https?3@ DB 'https:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HILLDDDP@wss?3@
CONST	SEGMENT
??_C@_04HILLDDDP@wss?3@ DB 'wss:', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JJGECGC@TLS?5is?5not?5enabled@
CONST	SEGMENT
??_C@_0BD@JJGECGC@TLS?5is?5not?5enabled@ DB 'TLS is not enabled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BDBJPBPM@SSI?5not?5enabled@
CONST	SEGMENT
??_C@_0BA@BDBJPBPM@SSI?5not?5enabled@ DB 'SSI not enabled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@INNKIICP@?$CFlu?5?$CFc?$CFc?5?$CFc?$CFc?$CFc?$CFc?$CFc@
CONST	SEGMENT
??_C@_0BE@INNKIICP@?$CFlu?5?$CFc?$CFc?5?$CFc?$CFc?$CFc?$CFc?$CFc@ DB '%lu'
	DB	' %c%c %c%c%c%c%c', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OABIKPAM@mg_mgr_poll@
CONST	SEGMENT
??_C@_0M@OABIKPAM@mg_mgr_poll@ DB 'mg_mgr_poll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FLEIGMKI@?$CFlu?5?$CFp?5pipe?5?$CFlu@
CONST	SEGMENT
??_C@_0BA@FLEIGMKI@?$CFlu?5?$CFp?5pipe?5?$CFlu@ DB '%lu %p pipe %lu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NGAOEDDO@Cannot?5create?5socket?5pair@
CONST	SEGMENT
??_C@_0BK@NGAOEDDO@Cannot?5create?5socket?5pair@ DB 'Cannot create socket'
	DB	' pair', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BJADDKBJ@mg_wakeup_init@
CONST	SEGMENT
??_C@_0P@BJADDKBJ@mg_wakeup_init@ DB 'mg_wakeup_init', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FOFCOHME@?$CFlu?5?$CFld?5accepted?5?$CFM?5?9?$DO?5?$CFM@
CONST	SEGMENT
??_C@_0BK@FOFCOHME@?$CFlu?5?$CFld?5accepted?5?$CFM?5?9?$DO?5?$CFM@ DB '%l'
	DB	'u %ld accepted %M -> %M', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BFGKJN@?$CFlu?5OOM@
CONST	SEGMENT
??_C@_07BFGKJN@?$CFlu?5OOM@ DB '%lu OOM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MOEFGJHP@?$CFlu?5accept?5failed?0?5errno?5?$CFd@
CONST	SEGMENT
??_C@_0BM@MOEFGJHP@?$CFlu?5accept?5failed?0?5errno?5?$CFd@ DB '%lu accept'
	DB	' failed, errno %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JPIAAHBH@accept_conn@
CONST	SEGMENT
??_C@_0M@JPIAAHBH@accept_conn@ DB 'accept_conn', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IFBHBJKC@connect?3?5?$CFd@
CONST	SEGMENT
??_C@_0M@IFBHBJKC@connect?3?5?$CFd@ DB 'connect: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BGCIPAPF@?$CFlu?5?$CFld?5?9?$DO?5?$CFM?5pend@
CONST	SEGMENT
??_C@_0BD@BGCIPAPF@?$CFlu?5?$CFld?5?9?$DO?5?$CFM?5pend@ DB '%lu %ld -> %M'
	DB	' pend', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CANALBHN@mg_connect_resolved@
CONST	SEGMENT
??_C@_0BE@CANALBHN@mg_connect_resolved@ DB 'mg_connect_resolved', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NLOJAIMF@socket?$CI?$CJ?3?5?$CFd@
CONST	SEGMENT
??_C@_0N@NLOJAIMF@socket?$CI?$CJ?3?5?$CFd@ DB 'socket(): %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PIIOOFNF@socket?5error@
CONST	SEGMENT
??_C@_0N@PIIOOFNF@socket?5error@ DB 'socket error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BLHHFBGP@?$CFlu?5?$CFld?5snd?5?$CFld?1?$CFld?5rcv?5?$CFld?1?$CFld@
CONST	SEGMENT
??_C@_0CN@BLHHFBGP@?$CFlu?5?$CFld?5snd?5?$CFld?1?$CFld?5rcv?5?$CFld?1?$CFld@ DB '%'
	DB	'lu %ld snd %ld/%ld rcv %ld/%ld n=%ld err=%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EJLBGHPI@write_conn@
CONST	SEGMENT
??_C@_0L@EJLBGHPI@write_conn@ DB 'write_conn', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HEALIOMK@?$CFlu?5?$CFp?5snd?5?$CFld?1?$CFld?5rcv?5?$CFld?1?$CFld?5@
CONST	SEGMENT
??_C@_0CM@HEALIOMK@?$CFlu?5?$CFp?5snd?5?$CFld?1?$CFld?5rcv?5?$CFld?1?$CFld?5@ DB '%'
	DB	'lu %p snd %ld/%ld rcv %ld/%ld n=%ld err=%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GCLNDOPN@read_conn@
CONST	SEGMENT
??_C@_09GCLNDOPN@read_conn@ DB 'read_conn', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HBLGCKAG@MG_MAX_RECV_SIZE@
CONST	SEGMENT
??_C@_0BB@HBLGCKAG@MG_MAX_RECV_SIZE@ DB 'MG_MAX_RECV_SIZE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JNLECNPF@listen?3?5?$CFd@
CONST	SEGMENT
??_C@_0L@JNLECNPF@listen?3?5?$CFd@ DB 'listen: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JIJPKGKG@bind?3?5?$CFd@
CONST	SEGMENT
??_C@_08JIJPKGKG@bind?3?5?$CFd@ DB 'bind: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MDOFAPIK@setsockopt?$CISO_EXCLUSIVEADDRUSE?$CJ@
CONST	SEGMENT
??_C@_0CH@MDOFAPIK@setsockopt?$CISO_EXCLUSIVEADDRUSE?$CJ@ DB 'setsockopt('
	DB	'SO_EXCLUSIVEADDRUSE): %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GLCCNLE@socket?3?5?$CFd@
CONST	SEGMENT
??_C@_0L@GLCCNLE@socket?3?5?$CFd@ DB 'socket: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JOJCJPAN@invalid?5listening?5URL?3?5?$CFs@
CONST	SEGMENT
??_C@_0BK@JOJCJPAN@invalid?5listening?5URL?3?5?$CFs@ DB 'invalid listenin'
	DB	'g URL: %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DCONLCEI@mg_open_listener@
CONST	SEGMENT
??_C@_0BB@DCONLCEI@mg_open_listener@ DB 'mg_open_listener', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PDGMPLOC@?$CFlu?5?$CFld?5?$CFd?3?$CFd?5?$CFld?5err?5?$CFd@
CONST	SEGMENT
??_C@_0BJ@PDGMPLOC@?$CFlu?5?$CFld?5?$CFd?3?$CFd?5?$CFld?5err?5?$CFd@ DB '%'
	DB	'lu %ld %d:%d %ld err %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JDKIIIBC@mg_send@
CONST	SEGMENT
??_C@_07JDKIIIBC@mg_send@ DB 'mg_send', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EEHNBJP@?6?9?9?5?$CFlu?5?$CFM?5?$CFs?5?$CFM?5?$CFld@
CONST	SEGMENT
??_C@_0BF@EEHNBJP@?6?9?9?5?$CFlu?5?$CFM?5?$CFs?5?$CFM?5?$CFld@ DB 0aH, '-'
	DB	'- %lu %M %s %M %ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HBOOOICD@?9?$DO@
CONST	SEGMENT
??_C@_02HBOOOICD@?9?$DO@ DB '->', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NOFGAPG@?$DM?9@
CONST	SEGMENT
??_C@_02NOFGAPG@?$DM?9@ DB '<-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GCGDNJJE@iolog@
CONST	SEGMENT
??_C@_05GCGDNJJE@iolog@ DB 'iolog', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GMHACAIO@udp?3?1?1time?4google?4com?3123@
CONST	SEGMENT
??_C@_0BK@GMHACAIO@udp?3?1?1time?4google?4com?3123@ DB 'udp://time.google'
	DB	'.com:123', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GABKECNF@?$CFlu?5wait?5until?5resolved@
CONST	SEGMENT
??_C@_0BI@GABKECNF@?$CFlu?5wait?5until?5resolved@ DB '%lu wait until reso'
	DB	'lved', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IPEAOCEK@mg_sntp_request@
CONST	SEGMENT
??_C@_0BA@IPEAOCEK@mg_sntp_request@ DB 'mg_sntp_request', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05EENHEND@?$CFu?4?$CFu@
CONST	SEGMENT
??_C@_05EENHEND@?$CFu?4?$CFu@ DB '%u.%u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NMDLDFPE@?$CFlu?5got?5time?3?5?$CFlld?5ms?5from?5epoc@
CONST	SEGMENT
??_C@_0CB@NMDLDFPE@?$CFlu?5got?5time?3?5?$CFlld?5ms?5from?5epoc@ DB '%lu '
	DB	'got time: %lld ms from epoch', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IENOENON@sntp_cb@
CONST	SEGMENT
??_C@_07IENOENON@sntp_cb@ DB 'sntp_cb', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HEKJPPM@unexpected?5version?3?5?$CFd@
CONST	SEGMENT
??_C@_0BH@HEKJPPM@unexpected?5version?3?5?$CFd@ DB 'unexpected version: %'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BOHGPAAD@?$CFlld?5?$CFlld?5?$CFlld?5?$CFlld?5delta?3?$CFlld@
CONST	SEGMENT
??_C@_0BP@BOHGPAAD@?$CFlld?5?$CFlld?5?$CFlld?5?$CFlld?5delta?3?$CFlld@ DB '%'
	DB	'lld %lld %lld %lld delta:%lld', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DMBHJOKM@server?5sent?5a?5kiss?5of?5death@
CONST	SEGMENT
??_C@_0BM@DMBHJOKM@server?5sent?5a?5kiss?5of?5death@ DB 'server sent a ki'
	DB	'ss of death', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ODENNIKF@not?5a?5server?5reply@
CONST	SEGMENT
??_C@_0BD@ODENNIKF@not?5a?5server?5reply@ DB 'not a server reply', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IGMAHBCN@corrupt?5packet@
CONST	SEGMENT
??_C@_0P@IGMAHBCN@corrupt?5packet@ DB 'corrupt packet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HEBLIINH@mg_sntp_parse@
CONST	SEGMENT
??_C@_0O@HEBLIINH@mg_sntp_parse@ DB 'mg_sntp_parse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JGKFJELO@?$FL?$CFM?$FN@
CONST	SEGMENT
??_C@_04JGKFJELO@?$FL?$CFM?$FN@ DB '[%M]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KHKDDGAF@?$CFs?$CFm@
CONST	SEGMENT
??_C@_04KHKDDGAF@?$CFs?$CFm@ DB '%s%m', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MGAGNKFF@?$HN?$HN@
CONST	SEGMENT
??_C@_02MGAGNKFF@?$HN?$HN@ DB '}}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OFIPIANJ@?$CFm?3?$HL?$CFm?3?$CFd?0?$CFm?3@
CONST	SEGMENT
??_C@_0O@OFIPIANJ@?$CFm?3?$HL?$CFm?3?$CFd?0?$CFm?3@ DB '%m:{%m:%d,%m:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KKCIMGE@error@
CONST	SEGMENT
??_C@_05KKCIMGE@error@ DB 'error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NDFOBODE@code@
CONST	SEGMENT
??_C@_04NDFOBODE@code@ DB 'code', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07ONPBMBOP@message@
CONST	SEGMENT
??_C@_07ONPBMBOP@message@ DB 'message', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BPPEJENG@?$CFm?3?$CF?4?$CKs?0@
CONST	SEGMENT
??_C@_08BPPEJENG@?$CFm?3?$CF?4?$CKs?0@ DB '%m:%.*s,', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01HCONENDN@?$HL@
CONST	SEGMENT
??_C@_01HCONENDN@?$HL@ DB '{', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN@ DB '}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PNCPKKEK@?$HL?$CFm?3?$CF?4?$CKs?0?$CFm?3@
CONST	SEGMENT
??_C@_0N@PNCPKKEK@?$HL?$CFm?3?$CF?4?$CKs?0?$CFm?3@ DB '{%m:%.*s,%m:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGCJHIOB@id@
CONST	SEGMENT
??_C@_02EGCJHIOB@id@ DB 'id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KJFADLGN@result@
CONST	SEGMENT
??_C@_06KJFADLGN@result@ DB 'result', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOGAHCH@$?4id@
CONST	SEGMENT
??_C@_04LOGAHCH@$?4id@ DB '$.id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OOGLLHAM@?$CFm@
CONST	SEGMENT
??_C@_02OOGLLHAM@?$CFm@ DB '%m', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DMPMNMMD@$?4error@
CONST	SEGMENT
??_C@_07DMPMNMMD@$?4error@ DB '$.error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OBNEFDHG@$?4result@
CONST	SEGMENT
??_C@_08OBNEFDHG@$?4result@ DB '$.result', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CIJFEAAL@$?4method@
CONST	SEGMENT
??_C@_08CIJFEAAL@$?4method@ DB '$.method', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KBBHFJEB@?$CC?$CF?4?$CKs?5not?5found?$CC@
CONST	SEGMENT
??_C@_0BB@KBBHFJEB@?$CC?$CF?4?$CKs?5not?5found?$CC@ DB '"%.*s not found"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@NFPJKBDG@ABCDEFGHIJKLMNOPQRSTUVWXYZabcde@
CONST	SEGMENT
??_C@_0EB@NFPJKBDG@ABCDEFGHIJKLMNOPQRSTUVWXYZabcde@ DB 'ABCDEFGHIJKLMNOPQ'
	DB	'RSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ONJEFEPB@?$CF02x?3?$CF02x?3?$CF02x?3?$CF02x?3?$CF02x?3?$CF02x@
CONST	SEGMENT
??_C@_0BO@ONJEFEPB@?$CF02x?3?$CF02x?3?$CF02x?3?$CF02x?3?$CF02x?3?$CF02x@ DB '%'
	DB	'02x:%02x:%02x:%02x:%02x:%02x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CECBMHAI@?$CFM?3?$CFhu@
CONST	SEGMENT
??_C@_06CECBMHAI@?$CFM?3?$CFhu@ DB '%M:%hu', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HMDKCEIC@?$FL?$CFx?3?$CFx?3?$CFx?3?$CFx?3?$CFx?3?$CFx?3?$CFx?3?$CFx?$FN@
CONST	SEGMENT
??_C@_0BK@HMDKCEIC@?$FL?$CFx?3?$CFx?3?$CFx?3?$CFx?3?$CFx?3?$CFx?3?$CFx?3?$CFx?$FN@ DB '['
	DB	'%x:%x:%x:%x:%x:%x:%x:%x]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd@
CONST	SEGMENT
??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd@ DB '%d.%d.%d.%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BFGPOJEH@udp?3?1?1?$FL2001?34860?34860?3?38888?$FN?353@
CONST	SEGMENT
??_C@_0CA@BFGPOJEH@udp?3?1?1?$FL2001?34860?34860?3?38888?$FN?353@ DB 'udp'
	DB	'://[2001:4860:4860::8888]:53', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OGCNOFJ@udp?3?1?18?48?48?48?353@
CONST	SEGMENT
??_C@_0BB@OGCNOFJ@udp?3?1?18?48?48?48?353@ DB 'udp://8.8.8.8:53', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JCIDLGBI@All?5connections?5closed@
CONST	SEGMENT
??_C@_0BH@JCIDLGBI@All?5connections?5closed@ DB 'All connections closed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HDNIMCKK@mg_mgr_free@
CONST	SEGMENT
??_C@_0M@HDNIMCKK@mg_mgr_free@ DB 'mg_mgr_free', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LPNPPMDI@Failed?3?5?$CFs?0?5errno?5?$CFd@
CONST	SEGMENT
??_C@_0BF@LPNPPMDI@Failed?3?5?$CFs?0?5errno?5?$CFd@ DB 'Failed: %s, errno'
	DB	' %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06BEBLAAFA@OOM?5?$CFs@
CONST	SEGMENT
??_C@_06BEBLAAFA@OOM?5?$CFs@ DB 'OOM %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MIIPHL@mg_listen@
CONST	SEGMENT
??_C@_09MIIPHL@mg_listen@ DB 'mg_listen', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MNPDLBCA@udp?3@
CONST	SEGMENT
??_C@_04MNPDLBCA@udp?3@ DB 'udp:', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CDNNJDDN@OOM@
CONST	SEGMENT
??_C@_03CDNNJDDN@OOM@ DB 'OOM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08FJNKCABM@null?5url@
CONST	SEGMENT
??_C@_08FJNKCABM@null?5url@ DB 'null url', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KLLEPGGK@mg_connect@
CONST	SEGMENT
??_C@_0L@KLLEPGGK@mg_connect@ DB 'mg_connect', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KGEINCCM@?$CFlu?5?$CFld?5closed@
CONST	SEGMENT
??_C@_0P@KGEINCCM@?$CFlu?5?$CFld?5closed@ DB '%lu %ld closed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KLFCDPFL@mg_close_conn@
CONST	SEGMENT
??_C@_0O@KLFCDPFL@mg_close_conn@ DB 'mg_close_conn', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IPAEKDAI@localhost@
CONST	SEGMENT
??_C@_09IPAEKDAI@localhost@ DB 'localhost', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FOKBBNGE@?$CFlu?5MQTT?5auth?5failed?0?5code?5?$CFd@
CONST	SEGMENT
??_C@_0BO@FOKBBNGE@?$CFlu?5MQTT?5auth?5failed?0?5code?5?$CFd@ DB '%lu MQT'
	DB	'T auth failed, code %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MHLPOCL@?$CFlu?5Connected@
CONST	SEGMENT
??_C@_0O@MHLPOCL@?$CFlu?5Connected@ DB '%lu Connected', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KABHPGHA@?$CFlu?5MQTT?5CMD?5?$CFd?5len?5?$CFd?5?$FL?$CF?4?$CKs?$FN@
CONST	SEGMENT
??_C@_0BO@KABHPGHA@?$CFlu?5MQTT?5CMD?5?$CFd?5len?5?$CFd?5?$FL?$CF?4?$CKs?$FN@ DB '%'
	DB	'lu MQTT CMD %d len %d [%.*s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MPELNGON@?$CFlu?5MQTT?5malformed?5message@
CONST	SEGMENT
??_C@_0BL@MPELNGON@?$CFlu?5MQTT?5malformed?5message@ DB '%lu MQTT malform'
	DB	'ed message', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07IJPJCEBD@mqtt_cb@
CONST	SEGMENT
??_C@_07IJPJCEBD@mqtt_cb@ DB 'mqtt_cb', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LDABDMHN@?$CFlu?5?$FL?$CF?4?$CKs?$FN?5?9?$DO?5?$FL?$CF?4?$CKs?$FN@
CONST	SEGMENT
??_C@_0BF@LDABDMHN@?$CFlu?5?$FL?$CF?4?$CKs?$FN?5?9?$DO?5?$FL?$CF?4?$CKs?$FN@ DB '%'
	DB	'lu [%.*s] -> [%.*s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JCOIBNAC@mg_mqtt_pub@
CONST	SEGMENT
??_C@_0M@JCOIBNAC@mg_mqtt_pub@ DB 'mg_mqtt_pub', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDJKNLJP@?$AA?$PP@
CONST	SEGMENT
??_C@_02JDJKNLJP@?$AA?$PP@ DB 00H, 0ffH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NDEAONJP@?5?5?5@
CONST	SEGMENT
??_C@_03NDEAONJP@?5?5?5@ DB '   ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KJILOAFG@?$CF?96llx?5?$CFd?5?$CFs?3?$CFd?3?$CFs@
CONST	SEGMENT
??_C@_0BD@KJILOAFG@?$CF?96llx?5?$CFd?5?$CFs?3?$CFd?3?$CFs@ DB '%-6llx %d '
	DB	'%s:%d:%s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLLLIHIP@null@
CONST	SEGMENT
??_C@_04MLLLIHIP@null@ DB 'null', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EPMOAMKG@$@
CONST	SEGMENT
??_C@_01EPMOAMKG@$@ DB '$', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07HHNAIFDF@bfnrt?2?$CC@
CONST	SEGMENT
??_C@_07HHNAIFDF@bfnrt?2?$CC@ DB 'bfnrt\"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GIIPGIPO@?$AI?$AM?6?$AN?7?2?$CC@
CONST	SEGMENT
??_C@_07GIIPGIPO@?$AI?$AM?6?$AN?7?2?$CC@ DB 08H, 0cH, 0aH, 0dH, 09H, '\"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OOAJBPCA@?$CFlld?9?$DO?$CFlld@
CONST	SEGMENT
??_C@_0L@OOAJBPCA@?$CFlld?9?$DO?$CFlld@ DB '%lld->%lld', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HJJGBKFB@mg_iobuf_resize@
CONST	SEGMENT
??_C@_0BA@HJJGBKFB@mg_iobuf_resize@ DB 'mg_iobuf_resize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JNMAOHCK@hi?6@
CONST	SEGMENT
??_C@_03JNMAOHCK@hi?6@ DB 'hi', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JNCLOPOB@Debug?5level?5set?5to?5?$CFd?6@
CONST	SEGMENT
??_C@_0BH@JNCLOPOB@Debug?5level?5set?5to?5?$CFd?6@ DB 'Debug level set to'
	DB	' %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07JPIHOLMH@$?4level@
CONST	SEGMENT
??_C@_07JPIHOLMH@$?4level@ DB '$.level', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HAHILENG@?1debug@
CONST	SEGMENT
??_C@_06HAHILENG@?1debug@ DB '/debug', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DJDALPN@ok?6@
CONST	SEGMENT
??_C@_03DJDALPN@ok?6@ DB 'ok', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CMMBDMDD@?1quit@
CONST	SEGMENT
??_C@_05CMMBDMDD@?1quit@ DB '/quit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HABHDEMH@Invalid?5chunk@
CONST	SEGMENT
??_C@_0O@HABHDEMH@Invalid?5chunk@ DB 'Invalid chunk', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LOOLINP@Invalid?5Transfer?9Encoding@
CONST	SEGMENT
??_C@_0BK@LOOLINP@Invalid?5Transfer?9Encoding@ DB 'Invalid Transfer-Encod'
	DB	'ing', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07KCKHAHHI@chunked@
CONST	SEGMENT
??_C@_07KCKHAHHI@chunked@ DB 'chunked', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ELHLFCNH@Transfer?9Encoding@
CONST	SEGMENT
??_C@_0BC@ELHLFCNH@Transfer?9Encoding@ DB 'Transfer-Encoding', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HFEJOELF@HTTP?5parse?0?5?$CFlu?5bytes@
CONST	SEGMENT
??_C@_0BG@HFEJOELF@HTTP?5parse?0?5?$CFlu?5bytes@ DB 'HTTP parse, %lu byte'
	DB	's', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BCMHMOCL@open?$CI?$CFs?$CJ?3?5?$CFd@
CONST	SEGMENT
??_C@_0N@BCMHMOCL@open?$CI?$CFs?$CJ?3?5?$CFd@ DB 'open(%s): %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IDGNCELE@?$CFs?3?5over?5max?5size?5of?5?$CFlu@
CONST	SEGMENT
??_C@_0BJ@IDGNCELE@?$CFs?3?5over?5max?5size?5of?5?$CFlu@ DB '%s: over max'
	DB	' size of %lu', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OMMGLANF@?$CFs?3?5offset?5mismatch@
CONST	SEGMENT
??_C@_0BE@OMMGLANF@?$CFs?3?5offset?5mismatch@ DB '%s: offset mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ELGKPKEI@offset?5required@
CONST	SEGMENT
??_C@_0BA@ELGKPKEI@offset?5required@ DB 'offset required', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OCKNFKIO@?$CFs?5?9?$DO?5?$CFd?5bytes?5?$EA?5?$CFld@
CONST	SEGMENT
??_C@_0BF@OCKNFKIO@?$CFs?5?9?$DO?5?$CFd?5bytes?5?$EA?5?$CFld@ DB '%s -> %'
	DB	'd bytes @ %ld', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HACFLAGA@mg_http_upload@
CONST	SEGMENT
??_C@_0P@HACFLAGA@mg_http_upload@ DB 'mg_http_upload', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JALODAI@?$CFld@
CONST	SEGMENT
??_C@_03JALODAI@?$CFld@ DB '%ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KLHHMIGM@offset@
CONST	SEGMENT
??_C@_06KLHHMIGM@offset@ DB 'offset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GOCCFLMF@access_token@
CONST	SEGMENT
??_C@_0N@GOCCFLMF@access_token@ DB 'access_token', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06EGBLANDJ@Cookie@
CONST	SEGMENT
??_C@_06EGBLANDJ@Cookie@ DB 'Cookie', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KGFIHGLJ@Bearer?5@
CONST	SEGMENT
??_C@_07KGFIHGLJ@Bearer?5@ DB 'Bearer ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFOGOLGD@Basic?5@
CONST	SEGMENT
??_C@_06FFOGOLGD@Basic?5@ DB 'Basic ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NAFGPKMI@Authorization@
CONST	SEGMENT
??_C@_0O@NAFGPKMI@Authorization@ DB 'Authorization', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KMKBALOG@?1index?4html?4gz@
CONST	SEGMENT
??_C@_0P@KMKBALOG@?1index?4html?4gz@ DB '/index.html.gz', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LEPNGMOP@?1index?4shtml@
CONST	SEGMENT
??_C@_0N@LEPNGMOP@?1index?4shtml@ DB '/index.shtml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LFMFBCIF@?1index?4html@
CONST	SEGMENT
??_C@_0M@LFMFBCIF@?1index?4html@ DB '/index.html', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@NDIFMFHG@HTTP?11?41?5301?5Moved?$AN?6Location?3?5?$CF@
CONST	SEGMENT
??_C@_0DL@NDIFMFHG@HTTP?11?41?5301?5Moved?$AN?6Location?3?5?$CF@ DB 'HTTP'
	DB	'/1.1 301 Moved', 0dH, 0aH, 'Location: %.*s/', 0dH, 0aH, 'Cont'
	DB	'ent-Length: 0', 0dH, 0aH, 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GKOJEFML@?$CFlu?5?$CF?4?$CKs?5?9?$DO?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0BC@GKOJEFML@?$CFlu?5?$CF?4?$CKs?5?9?$DO?5?$CFs?5?$CFd@ DB '%lu %.*'
	DB	's -> %s %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GNCHAPHH@uri_to_path2@
CONST	SEGMENT
??_C@_0N@GNCHAPHH@uri_to_path2@ DB 'uri_to_path2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KKHAJPLM@Invalid?5path@
CONST	SEGMENT
??_C@_0N@KKHAJPLM@Invalid?5path@ DB 'Invalid path', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CCPJKDLJ@Exceeded?5path?5size@
CONST	SEGMENT
??_C@_0BD@CCPJKDLJ@Exceeded?5path?5size@ DB 'Exceeded path size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HB@HMGLNPND@?$DM?1tbody?$DO?$DMtfoot?$DO?$DMtr?$DO?$DMtd?5colspan?$DN@
CONST	SEGMENT
??_C@_0HB@HMGLNPND@?$DM?1tbody?$DO?$DMtfoot?$DO?$DMtr?$DO?$DMtd?5colspan?$DN@ DB '<'
	DB	'/tbody><tfoot><tr><td colspan="3"><hr></td></tr></tfoot></tab'
	DB	'le><address>Mongoose v.%s</address></body></html>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04KCOIGPKP@7?412@
CONST	SEGMENT
??_C@_04KCOIGPKP@7?412@ DB '7.12', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@IECPBOOL@?5?5?$DMtr?$DO?$DMtd?$DO?$DMa?5href?$DN?$CC?4?4?$CC?$DO?4?4?$DM?1a?$DO?$DM?1@
CONST	SEGMENT
??_C@_0FA@IECPBOOL@?5?5?$DMtr?$DO?$DMtd?$DO?$DMa?5href?$DN?$CC?4?4?$CC?$DO?4?4?$DM?1a?$DO?$DM?1@ DB ' '
	DB	' <tr><td><a href="..">..</a></td><td name=-1></td><td name=-1'
	DB	'>[DIR]</td></tr>', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BII@BEKFAOHG@?$DM?$CBDOCTYPE?5html?$DO?$DMhtml?$DO?$DMhead?$DO?$DMtit@
CONST	SEGMENT
??_C@_0BII@BEKFAOHG@?$DM?$CBDOCTYPE?5html?$DO?$DMhtml?$DO?$DMhead?$DO?$DMtit@ DB '<'
	DB	'!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s<st'
	DB	'yle>th,td {text-align: left; padding-right: 1em; font-family:'
	DB	' monospace; }</style></head><body><h1>Index of %.*s</h1><tabl'
	DB	'e cellpadding="0"><thead><tr><th><a href="#" rel="0">Name</a>'
	DB	'</th><th><a href="#" rel="1">Modified</a></th><th><a href="#"'
	DB	' rel="2">Size</a></th></tr><tr><td colspan="3"><hr></td></tr>'
	DB	'</thead><tbody id="tb">', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@EOBPCODB@HTTP?11?41?5200?5OK?$AN?6Content?9Type?3?5@
CONST	SEGMENT
??_C@_0FI@EOBPCODB@HTTP?11?41?5200?5OK?$AN?6Content?9Type?3?5@ DB 'HTTP/1'
	DB	'.1 200 OK', 0dH, 0aH, 'Content-Type: text/html; charset=utf-8'
	DB	0dH, 0aH, '%sContent-Length:         ', 0dH, 0aH, 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BME@DCNGJJJ@for?5?$CIvar?5i?5?$DN?50?$DL?5i?5?$DM?5tr?4length?$DL?5@
CONST	SEGMENT
??_C@_0BME@DCNGJJJ@for?5?$CIvar?5i?5?$DN?50?$DL?5i?5?$DM?5tr?4length?$DL?5@ DB 'f'
	DB	'or (var i = 0; i < tr.length; i++) tb.appendChild(tr[i]); if '
	DB	'(!d) window.location.hash = (''sc='' + sc + ''&so='' + so); }'
	DB	';window.onload = function() {var tb = document.getElementById'
	DB	'(''tb'');var m = /sc=([012]).so=(1|-1)/.exec(window.location.'
	DB	'hash) || [0, 2, 1];var sc = m[1], so = m[2]; document.onclick'
	DB	' = function(ev) { var c = ev.target.rel; if (c) {if (c == sc)'
	DB	' so *= -1; srt(tb, c, so); sc = c; ev.preventDefault();}};srt'
	DB	'(tb, sc, so, true);}</script>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BMF@KFFEPKPH@?$DMscript?$DOfunction?5srt?$CItb?0?5sc?0?5so@
CONST	SEGMENT
??_C@_0BMF@KFFEPKPH@?$DMscript?$DOfunction?5srt?$CItb?0?5sc?0?5so@ DB '<s'
	DB	'cript>function srt(tb, sc, so, d) {var tr = Array.prototype.s'
	DB	'lice.call(tb.rows, 0),tr = tr.sort(function (a, b) { var c1 ='
	DB	' a.cells[sc], c2 = b.cells[sc],n1 = c1.getAttribute(''name'')'
	DB	', n2 = c2.getAttribute(''name''), t1 = a.cells[2].getAttribut'
	DB	'e(''name''), t2 = b.cells[2].getAttribute(''name''); return s'
	DB	'o * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : n1 ? pa'
	DB	'rseInt(n2) - parseInt(n1) : c1.textContent.trim().localeCompa'
	DB	're(c2.textContent.trim())); });', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@IPGJIOJD@?5?5?$DMtr?$DO?$DMtd?$DO?$DMa?5href?$DN?$CC?$CF?4?$CKs?$CFs?$CC?$DO?$CFs?$CFs@
CONST	SEGMENT
??_C@_0FI@IPGJIOJD@?5?5?$DMtr?$DO?$DMtd?$DO?$DMa?5href?$DN?$CC?$CF?4?$CKs?$CFs?$CC?$DO?$CFs?$CFs@ DB ' '
	DB	' <tr><td><a href="%.*s%s">%s%s</a></td><td name=%lu>%s</td><t'
	DB	'd name=%lld>%s</td></tr>', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FKNCMABI@?$CFlu@
CONST	SEGMENT
??_C@_03FKNCMABI@?$CFlu@ DB '%lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BFAHMMK@?$CFlld@
CONST	SEGMENT
??_C@_04BFAHMMK@?$CFlld@ DB '%lld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DDGJGJB@?$FLDIR?$FN@
CONST	SEGMENT
??_C@_05DDGJGJB@?$FLDIR?$FN@ DB '[DIR]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MFGDKDCP@?$CFlu?5stat?$CI?$CFs?$CJ?3?5?$CFd@
CONST	SEGMENT
??_C@_0BB@MFGDKDCP@?$CFlu?5stat?$CI?$CFs?$CJ?3?5?$CFd@ DB '%lu stat(%s): '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BELOEIBP@?$CFs?5truncated@
CONST	SEGMENT
??_C@_0N@BELOEIBP@?$CFs?5truncated@ DB '%s truncated', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NAEKIGEC@printdirentry@
CONST	SEGMENT
??_C@_0O@NAEKIGEC@printdirentry@ DB 'printdirentry', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GIIGBPHC@?$CFs?$CFc?$CFs@
CONST	SEGMENT
??_C@_06GIIGBPHC@?$CFs?$CFc?$CFs@ DB '%s%c%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BINJNOJD@HEAD@
CONST	SEGMENT
??_C@_04BINJNOJD@HEAD@ DB 'HEAD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@DLMBNGCO@HTTP?11?41?5?$CFd?5?$CFs?$AN?6Content?9Type?3?5?$CF@
CONST	SEGMENT
??_C@_0EN@DLMBNGCO@HTTP?11?41?5?$CFd?5?$CFs?$AN?6Content?9Type?3?5?$CF@ DB 'H'
	DB	'TTP/1.1 %d %s', 0dH, 0aH, 'Content-Type: %.*s', 0dH, 0aH, 'Et'
	DB	'ag: %s', 0dH, 0aH, 'Content-Length: %llu', 0dH, 0aH, '%s%s%s', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MBGLAIMM@Content?9Encoding?3?5gzip?$AN?6@
CONST	SEGMENT
??_C@_0BJ@MBGLAIMM@Content?9Encoding?3?5gzip?$AN?6@ DB 'Content-Encoding:'
	DB	' gzip', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JKKKPNMP@Content?9Range?3?5bytes?5?$CFllu?9?$CFllu?1@
CONST	SEGMENT
??_C@_0CG@JKKKPNMP@Content?9Range?3?5bytes?5?$CFllu?9?$CFllu?1@ DB 'Conte'
	DB	'nt-Range: bytes %llu-%llu/%llu', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IKDCAKCB@Content?9Range?3?5bytes?5?$CK?1?$CFlld?$AN?6@
CONST	SEGMENT
??_C@_0BO@IKDCAKCB@Content?9Range?3?5bytes?5?$CK?1?$CFlld?$AN?6@ DB 'Cont'
	DB	'ent-Range: bytes */%lld', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFMCGLCK@Range@
CONST	SEGMENT
??_C@_05CFMCGLCK@Range@ DB 'Range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PLENHEOP@If?9None?9Match@
CONST	SEGMENT
??_C@_0O@PLENHEOP@If?9None?9Match@ DB 'If-None-Match', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CKKNHDCB@Not?5found?6@
CONST	SEGMENT
??_C@_0L@CKKNHDCB@Not?5found?6@ DB 'Not found', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05HPILMEBC@?$CFs?4gz@
CONST	SEGMENT
??_C@_05HPILMEBC@?$CFs?4gz@ DB '%s.gz', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HOHEGKBO@gzip@
CONST	SEGMENT
??_C@_04HOHEGKBO@gzip@ DB 'gzip', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KDJCHKHJ@Accept?9Encoding@
CONST	SEGMENT
??_C@_0BA@KDJCHKHJ@Accept?9Encoding@ DB 'Accept-Encoding', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GOGCPOMN@bytes?$DN@
CONST	SEGMENT
??_C@_06GOGCPOMN@bytes?$DN@ DB 'bytes=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IGCDBAML@video?13gpp@
CONST	SEGMENT
??_C@_0L@IGCDBAML@video?13gpp@ DB 'video/3gpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03FOICNDPP@3gp@
CONST	SEGMENT
??_C@_03FOICNDPP@3gp@ DB '3gp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LMDOGBAF@application?1zip@
CONST	SEGMENT
??_C@_0BA@LMDOGBAF@application?1zip@ DB 'application/zip', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LCAAOJEC@zip@
CONST	SEGMENT
??_C@_03LCAAOJEC@zip@ DB 'zip', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GNMNMNM@image?1webp@
CONST	SEGMENT
??_C@_0L@GNMNMNM@image?1webp@ DB 'image/webp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKLLFFLE@webp@
CONST	SEGMENT
??_C@_04BKLLFFLE@webp@ DB 'webp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09KOEADLDC@audio?1wav@
CONST	SEGMENT
??_C@_09KOEADLDC@audio?1wav@ DB 'audio/wav', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03BICDMHKB@wav@
CONST	SEGMENT
??_C@_03BICDMHKB@wav@ DB 'wav', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LHPABEHA@application?1tar?9gz@
CONST	SEGMENT
??_C@_0BD@LHPABEHA@application?1tar?9gz@ DB 'application/tar-gz', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03KCKOFLPB@tgz@
CONST	SEGMENT
??_C@_03KCKOFLPB@tgz@ DB 'tgz', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05HNDFGKM@shtml@
CONST	SEGMENT
??_C@_05HNDFGKM@shtml@ DB 'shtml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MHMDKHOF@application?1pdf@
CONST	SEGMENT
??_C@_0BA@MHMDKHOF@application?1pdf@ DB 'application/pdf', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03MJPNCPKC@pdf@
CONST	SEGMENT
??_C@_03MJPNCPKC@pdf@ DB 'pdf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NDKAOLEK@video?1mpeg@
CONST	SEGMENT
??_C@_0L@NDKAOLEK@video?1mpeg@ DB 'video/mpeg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04FHOAOPCJ@mpeg@
CONST	SEGMENT
??_C@_04FHOAOPCJ@mpeg@ DB 'mpeg', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09GGJCJIJ@video?1mp4@
CONST	SEGMENT
??_C@_09GGJCJIJ@video?1mp4@ DB 'video/mp4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PICMJEJK@mp4@
CONST	SEGMENT
??_C@_03PICMJEJK@mp4@ DB 'mp4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DOFAEOCL@audio?1mpeg@
CONST	SEGMENT
??_C@_0L@DOFAEOCL@audio?1mpeg@ DB 'audio/mpeg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03LHGNACFN@mp3@
CONST	SEGMENT
??_C@_03LHGNACFN@mp3@ DB 'mp3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MEHPJOJG@video?1quicktime@
CONST	SEGMENT
??_C@_0BA@MEHPJOJG@video?1quicktime@ DB 'video/quicktime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03CNBJFNFA@mov@
CONST	SEGMENT
??_C@_03CNBJFNFA@mov@ DB 'mov', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MDJGEIPD@application?1json@
CONST	SEGMENT
??_C@_0BB@MDJGEIPD@application?1json@ DB 'application/json', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLCAKCEI@json@
CONST	SEGMENT
??_C@_04CLCAKCEI@json@ DB 'json', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DKCCOJIM@image?1x?9icon@
CONST	SEGMENT
??_C@_0N@DKCCOJIM@image?1x?9icon@ DB 'image/x-icon', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03DAGBJKHL@ico@
CONST	SEGMENT
??_C@_03DAGBJKHL@ico@ DB 'ico', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JGMCIAKF@application?1gzip@
CONST	SEGMENT
??_C@_0BB@JGMCIAKF@application?1gzip@ DB 'application/gzip', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JIPGGKDE@gz@
CONST	SEGMENT
??_C@_02JIPGGKDE@gz@ DB 'gz', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JDCJMJCJ@application?1octet?9stream@
CONST	SEGMENT
??_C@_0BJ@JDCJMJCJ@application?1octet?9stream@ DB 'application/octet-stre'
	DB	'am', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03JACLIBNI@exe@
CONST	SEGMENT
??_C@_03JACLIBNI@exe@ DB 'exe', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DMPJCPHP@application?1msword@
CONST	SEGMENT
??_C@_0BD@DMPJCPHP@application?1msword@ DB 'application/msword', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03GHKEPEMO@doc@
CONST	SEGMENT
??_C@_03GHKEPEMO@doc@ DB 'doc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08CGFGOOIN@text?1csv@
CONST	SEGMENT
??_C@_08CGFGOOIN@text?1csv@ DB 'text/csv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NIPKHAHH@csv@
CONST	SEGMENT
??_C@_03NIPKHAHH@csv@ DB 'csv', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DDNKOHJP@video?1x?9msvideo@
CONST	SEGMENT
??_C@_0BA@DDNKOHJP@video?1x?9msvideo@ DB 'video/x-msvideo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LJGCHEIJ@avi@
CONST	SEGMENT
??_C@_03LJGCHEIJ@avi@ DB 'avi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LKDCPLNF@text?1plain?$DL?5charset?$DNutf?98@
CONST	SEGMENT
??_C@_0BK@LKDCPLNF@text?1plain?$DL?5charset?$DNutf?98@ DB 'text/plain; ch'
	DB	'arset=utf-8', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03CLFHJCDC@txt@
CONST	SEGMENT
??_C@_03CLFHJCDC@txt@ DB 'txt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MMMFMLNF@image?1svg?$CLxml@
CONST	SEGMENT
??_C@_0O@MMMFMLNF@image?1svg?$CLxml@ DB 'image/svg+xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03NNPBMGBD@svg@
CONST	SEGMENT
??_C@_03NNPBMGBD@svg@ DB 'svg', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08LDONFKLE@font?1ttf@
CONST	SEGMENT
??_C@_08LDONFKLE@font?1ttf@ DB 'font/ttf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FKLJBLIF@ttf@
CONST	SEGMENT
??_C@_03FKLJBLIF@ttf@ DB 'ttf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DPKAPMKA@font?1woff@
CONST	SEGMENT
??_C@_09DPKAPMKA@font?1woff@ DB 'font/woff', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04GOJHKINL@woff@
CONST	SEGMENT
??_C@_04GOJHKINL@woff@ DB 'woff', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OFMADDDJ@jpeg@
CONST	SEGMENT
??_C@_04OFMADDDJ@jpeg@ DB 'jpeg', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PJKHLKFB@image?1jpeg@
CONST	SEGMENT
??_C@_0L@PJKHLKFB@image?1jpeg@ DB 'image/jpeg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03PEGNKCLE@jpg@
CONST	SEGMENT
??_C@_03PEGNKCLE@jpg@ DB 'jpg', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09NGJJJBGE@image?1png@
CONST	SEGMENT
??_C@_09NGJJJBGE@image?1png@ DB 'image/png', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03NNHBJLDF@png@
CONST	SEGMENT
??_C@_03NNHBJLDF@png@ DB 'png', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09HADNJIG@image?1gif@
CONST	SEGMENT
??_C@_09HADNJIG@image?1gif@ DB 'image/gif', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MOLNDNH@gif@
CONST	SEGMENT
??_C@_03MOLNDNH@gif@ DB 'gif', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IBHNJOOI@text?1javascript?$DL?5charset?$DNutf?98@
CONST	SEGMENT
??_C@_0BP@IBHNJOOI@text?1javascript?$DL?5charset?$DNutf?98@ DB 'text/java'
	DB	'script; charset=utf-8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EBOMECCO@js@
CONST	SEGMENT
??_C@_02EBOMECCO@js@ DB 'js', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MKFMEPPC@text?1css?$DL?5charset?$DNutf?98@
CONST	SEGMENT
??_C@_0BI@MKFMEPPC@text?1css?$DL?5charset?$DNutf?98@ DB 'text/css; charse'
	DB	't=utf-8', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03KFINIEDC@css@
CONST	SEGMENT
??_C@_03KFINIEDC@css@ DB 'css', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KDICCKGJ@htm@
CONST	SEGMENT
??_C@_03KDICCKGJ@htm@ DB 'htm', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CDMHJEKP@text?1html?$DL?5charset?$DNutf?98@
CONST	SEGMENT
??_C@_0BJ@CDMHJEKP@text?1html?$DL?5charset?$DNutf?98@ DB 'text/html; char'
	DB	'set=utf-8', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNIFHPHN@html@
CONST	SEGMENT
??_C@_04PNIFHPHN@html@ DB 'html', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KPHLEGAC@?$CC?$CFlld?4?$CFlld?$CC@
CONST	SEGMENT
??_C@_0M@KPHLEGAC@?$CC?$CFlld?4?$CFlld?$CC@ DB '"%lld.%lld"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DLMLPGDC@?$CF?910lu@
CONST	SEGMENT
??_C@_06DLMLPGDC@?$CF?910lu@ DB '%-10lu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@GEFECBIH@HTTP?11?41?5?$CFd?5?$CFs?$AN?6?$CFsContent?9Lengt@
CONST	SEGMENT
??_C@_0DC@GEFECBIH@HTTP?11?41?5?$CFd?5?$CFs?$AN?6?$CFsContent?9Lengt@ DB 'H'
	DB	'TTP/1.1 %d %s', 0dH, 0aH, '%sContent-Length:            ', 0dH
	DB	0aH, 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OINGLCPC@Network?5Connect?5Timeout?5Error@
CONST	SEGMENT
??_C@_0BO@OINGLCPC@Network?5Connect?5Timeout?5Error@ DB 'Network Connect '
	DB	'Timeout Error', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JCJMCNEH@Network?5Authentication?5Required@
CONST	SEGMENT
??_C@_0CA@JCJMCNEH@Network?5Authentication?5Required@ DB 'Network Authent'
	DB	'ication Required', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JKOFFNBC@Not?5Extended@
CONST	SEGMENT
??_C@_0N@JKOFFNBC@Not?5Extended@ DB 'Not Extended', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KJBLEGOO@Loop?5Detected@
CONST	SEGMENT
??_C@_0O@KJBLEGOO@Loop?5Detected@ DB 'Loop Detected', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GDOFGFPB@Insufficient?5Storage@
CONST	SEGMENT
??_C@_0BF@GDOFGFPB@Insufficient?5Storage@ DB 'Insufficient Storage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PDOLHBJO@Variant?5Also?5Negotiates@
CONST	SEGMENT
??_C@_0BI@PDOLHBJO@Variant?5Also?5Negotiates@ DB 'Variant Also Negotiates'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ODCMNOHA@HTTP?5Version?5Not?5Supported@
CONST	SEGMENT
??_C@_0BL@ODCMNOHA@HTTP?5Version?5Not?5Supported@ DB 'HTTP Version Not Su'
	DB	'pported', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MCOKJNOA@Gateway?5Timeout@
CONST	SEGMENT
??_C@_0BA@MCOKJNOA@Gateway?5Timeout@ DB 'Gateway Timeout', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NGHLFKBN@Service?5Unavailable@
CONST	SEGMENT
??_C@_0BE@NGHLFKBN@Service?5Unavailable@ DB 'Service Unavailable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BNCNLPGM@Bad?5Gateway@
CONST	SEGMENT
??_C@_0M@BNCNLPGM@Bad?5Gateway@ DB 'Bad Gateway', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JGKGKAME@Not?5Implemented@
CONST	SEGMENT
??_C@_0BA@JGKGKAME@Not?5Implemented@ DB 'Not Implemented', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NJGANGCC@Internal?5Server?5Error@
CONST	SEGMENT
??_C@_0BG@NJGANGCC@Internal?5Server?5Error@ DB 'Internal Server Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NOEDODFP@Client?5Closed?5Request@
CONST	SEGMENT
??_C@_0BG@NOEDODFP@Client?5Closed?5Request@ DB 'Client Closed Request', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BDFIKLNJ@Unavailable?5For?5Legal?5Reasons@
CONST	SEGMENT
??_C@_0BO@BDFIKLNJ@Unavailable?5For?5Legal?5Reasons@ DB 'Unavailable For '
	DB	'Legal Reasons', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CBAJJADO@Connection?5Closed?5Without?5Respo@
CONST	SEGMENT
??_C@_0CD@CBAJJADO@Connection?5Closed?5Without?5Respo@ DB 'Connection Clo'
	DB	'sed Without Response', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IOEEABLM@Request?5Header?5Fields?5Too?5Large@
CONST	SEGMENT
??_C@_0CA@IOEEABLM@Request?5Header?5Fields?5Too?5Large@ DB 'Request Heade'
	DB	'r Fields Too Large', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JPBLCMB@Too?5Many?5Requests@
CONST	SEGMENT
??_C@_0BC@JPBLCMB@Too?5Many?5Requests@ DB 'Too Many Requests', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMCBMLGE@Precondition?5Required@
CONST	SEGMENT
??_C@_0BG@GMCBMLGE@Precondition?5Required@ DB 'Precondition Required', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NMNIKHMI@Upgrade?5Required@
CONST	SEGMENT
??_C@_0BB@NMNIKHMI@Upgrade?5Required@ DB 'Upgrade Required', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KKPOPIFM@Failed?5Dependency@
CONST	SEGMENT
??_C@_0BC@KKPOPIFM@Failed?5Dependency@ DB 'Failed Dependency', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GFKCFIPE@Locked@
CONST	SEGMENT
??_C@_06GFKCFIPE@Locked@ DB 'Locked', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BHJGKCEF@Unprocessable?5Entity@
CONST	SEGMENT
??_C@_0BF@BHJGKCEF@Unprocessable?5Entity@ DB 'Unprocessable Entity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GGAHKOMD@Misdirected?5Request@
CONST	SEGMENT
??_C@_0BE@GGAHKOMD@Misdirected?5Request@ DB 'Misdirected Request', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EHOCJLEI@I?8m?5a?5teapot@
CONST	SEGMENT
??_C@_0N@EHOCJLEI@I?8m?5a?5teapot@ DB 'I''m a teapot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NDMHPAED@Expectation?5Failed@
CONST	SEGMENT
??_C@_0BD@NDMHPAED@Expectation?5Failed@ DB 'Expectation Failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CBAMGINK@Requested?5Range?5Not?5Satisfiable@
CONST	SEGMENT
??_C@_0CA@CBAMGINK@Requested?5Range?5Not?5Satisfiable@ DB 'Requested Rang'
	DB	'e Not Satisfiable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HLJJIAEN@Unsupported?5Media?5Type@
CONST	SEGMENT
??_C@_0BH@HLJJIAEN@Unsupported?5Media?5Type@ DB 'Unsupported Media Type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IHICNLJ@Request?9URI?5Too?5Long@
CONST	SEGMENT
??_C@_0BF@IHICNLJ@Request?9URI?5Too?5Long@ DB 'Request-URI Too Long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OEAEGMJF@Payload?5Too?5Large@
CONST	SEGMENT
??_C@_0BC@OEAEGMJF@Payload?5Too?5Large@ DB 'Payload Too Large', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BBDBJOM@Precondition?5Failed@
CONST	SEGMENT
??_C@_0BE@BBDBJOM@Precondition?5Failed@ DB 'Precondition Failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JCKHPIPI@Length?5Required@
CONST	SEGMENT
??_C@_0BA@JCKHPIPI@Length?5Required@ DB 'Length Required', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04OKIIBCCG@Gone@
CONST	SEGMENT
??_C@_04OKIIBCCG@Gone@ DB 'Gone', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08OJCIFGDF@Conflict@
CONST	SEGMENT
??_C@_08OJCIFGDF@Conflict@ DB 'Conflict', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HALFGGF@Request?5Timeout@
CONST	SEGMENT
??_C@_0BA@HALFGGF@Request?5Timeout@ DB 'Request Timeout', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ONPAAOGI@Proxy?5Authentication?5Required@
CONST	SEGMENT
??_C@_0BO@ONPAAOGI@Proxy?5Authentication?5Required@ DB 'Proxy Authenticat'
	DB	'ion Required', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HHIDFAOI@Not?5Acceptable@
CONST	SEGMENT
??_C@_0P@HHIDFAOI@Not?5Acceptable@ DB 'Not Acceptable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CCIPIALO@Method?5Not?5Allowed@
CONST	SEGMENT
??_C@_0BD@CCIPIALO@Method?5Not?5Allowed@ DB 'Method Not Allowed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CFCBFJND@Not?5Found@
CONST	SEGMENT
??_C@_09CFCBFJND@Not?5Found@ DB 'Not Found', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LMDIMFJD@Forbidden@
CONST	SEGMENT
??_C@_09LMDIMFJD@Forbidden@ DB 'Forbidden', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LMPIHCBH@Payment?5Required@
CONST	SEGMENT
??_C@_0BB@LMPIHCBH@Payment?5Required@ DB 'Payment Required', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OOAPMOJA@Unauthorized@
CONST	SEGMENT
??_C@_0N@OOAPMOJA@Unauthorized@ DB 'Unauthorized', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LNAIDEEG@Bad?5Request@
CONST	SEGMENT
??_C@_0M@LNAIDEEG@Bad?5Request@ DB 'Bad Request', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@INBAOFGJ@Permanent?5Redirect@
CONST	SEGMENT
??_C@_0BD@INBAOFGJ@Permanent?5Redirect@ DB 'Permanent Redirect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJMNAMDM@Temporary?5Redirect@
CONST	SEGMENT
??_C@_0BD@PJMNAMDM@Temporary?5Redirect@ DB 'Temporary Redirect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JFBGBFIM@Use?5Proxy@
CONST	SEGMENT
??_C@_09JFBGBFIM@Use?5Proxy@ DB 'Use Proxy', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IFEFAIJB@Not?5Modified@
CONST	SEGMENT
??_C@_0N@IFEFAIJB@Not?5Modified@ DB 'Not Modified', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FAMPMKIP@See?5Other@
CONST	SEGMENT
??_C@_09FAMPMKIP@See?5Other@ DB 'See Other', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JDGHEPJG@Found@
CONST	SEGMENT
??_C@_05JDGHEPJG@Found@ DB 'Found', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BPBCNFPI@Moved?5Permanently@
CONST	SEGMENT
??_C@_0BC@BPBCNFPI@Moved?5Permanently@ DB 'Moved Permanently', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HLFEHKPE@Multiple?5Choices@
CONST	SEGMENT
??_C@_0BB@HLFEHKPE@Multiple?5Choices@ DB 'Multiple Choices', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EIILAAHO@IM?5Used@
CONST	SEGMENT
??_C@_07EIILAAHO@IM?5Used@ DB 'IM Used', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BPJDMGEO@Already?5Reported@
CONST	SEGMENT
??_C@_0BB@BPJDMGEO@Already?5Reported@ DB 'Already Reported', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BFLFIKGM@Multi?9Status@
CONST	SEGMENT
??_C@_0N@BFLFIKGM@Multi?9Status@ DB 'Multi-Status', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NNLNHGMN@Partial?5Content@
CONST	SEGMENT
??_C@_0BA@NNLNHGMN@Partial?5Content@ DB 'Partial Content', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BFFLKCLE@Reset?5Content@
CONST	SEGMENT
??_C@_0O@BFFLKCLE@Reset?5Content@ DB 'Reset Content', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FDPJCNGK@No?5Content@
CONST	SEGMENT
??_C@_0L@FDPJCNGK@No?5Content@ DB 'No Content', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FFMKBPKJ@Non?9authoritative?5Information@
CONST	SEGMENT
??_C@_0BO@FFMKBPKJ@Non?9authoritative?5Information@ DB 'Non-authoritative'
	DB	' Information', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08DOBOODLA@Accepted@
CONST	SEGMENT
??_C@_08DOBOODLA@Accepted@ DB 'Accepted', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BBIDHECN@Created@
CONST	SEGMENT
??_C@_07BBIDHECN@Created@ DB 'Created', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GIPFHKNO@OK@
CONST	SEGMENT
??_C@_02GIPFHKNO@OK@ DB 'OK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HFFAKEO@Processing@
CONST	SEGMENT
??_C@_0L@HFFAKEO@Processing@ DB 'Processing', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FGMIEJDD@Switching?5Protocols@
CONST	SEGMENT
??_C@_0BE@FGMIEJDD@Switching?5Protocols@ DB 'Switching Protocols', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LJHDLOLO@Continue@
CONST	SEGMENT
??_C@_08LJHDLOLO@Continue@ DB 'Continue', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BJCCKDDP@?$CFlx?$AN?6@
CONST	SEGMENT
??_C@_05BJCCKDDP@?$CFlx?$AN?6@ DB '%lx', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05CLMJGDKL@?$CF08lx@
CONST	SEGMENT
??_C@_05CLMJGDKL@?$CF08lx@ DB '%08lx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HNOLOFKI@?5?5?5?5?5?5?5?5?$AN?6@
CONST	SEGMENT
??_C@_0L@HNOLOFKI@?5?5?5?5?5?5?5?5?$AN?6@ DB '        ', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BLNIAGKO@204@
CONST	SEGMENT
??_C@_03BLNIAGKO@204@ DB '204', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HCJEIHPL@POST@
CONST	SEGMENT
??_C@_04HCJEIHPL@POST@ DB 'POST', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KBBGFLEK@PUT@
CONST	SEGMENT
??_C@_03KBBGFLEK@PUT@ DB 'PUT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKGKDBHO@HTTP?1@
CONST	SEGMENT
??_C@_05FKGKDBHO@HTTP?1@ DB 'HTTP/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HOJGPHBA@Content?9Length@
CONST	SEGMENT
??_C@_0P@HOJGPHBA@Content?9Length@ DB 'Content-Length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LNKDPIGG@?$CFlu?5oom?5?$CFd?9?$DO?$CFd?5@
CONST	SEGMENT
??_C@_0BA@LNKDPIGG@?$CFlu?5oom?5?$CFd?9?$DO?$CFd?5@ DB '%lu oom %d->%d ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KKGICJJI@mg_http_bauth@
CONST	SEGMENT
??_C@_0O@KKGICJJI@mg_http_bauth@ DB 'mg_http_bauth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EPHDEOFO@Authorization?3?5Basic?5@
CONST	SEGMENT
??_C@_0BG@EPHDEOFO@Authorization?3?5Basic?5@ DB 'Authorization: Basic ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BABJIOEM@filename@
CONST	SEGMENT
??_C@_08BABJIOEM@filename@ DB 'filename', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LMOOGHBG@Content?9Disposition@
CONST	SEGMENT
??_C@_0BE@LMOOGHBG@Content?9Disposition@ DB 'Content-Disposition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03DOPCBAKB@a?$CLb@
CONST	SEGMENT
??_C@_03DOPCBAKB@a?$CLb@ DB 'a+b', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DJGKEECL@?4?4@
CONST	SEGMENT
??_C@_02DJGKEECL@?4?4@ DB '..', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15PKPONJIK@?$AA?2?$AA?$CK@
CONST	SEGMENT
??_C@_15PKPONJIK@?$AA?2?$AA?$CK@ DB '\', 00H, '*', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15JJPIMNBO@?$AAr?$AAb@
CONST	SEGMENT
??_C@_15JJPIMNBO@?$AAr?$AAb@ DB 'r', 00H, 'b', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HDKLCKBF@?$CFs?4?4?$CFd@
CONST	SEGMENT
??_C@_06HDKLCKBF@?$CFs?4?4?$CFd@ DB '%s..%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDDDDAID@0x@
CONST	SEGMENT
??_C@_02MDDDDAID@0x@ DB '0x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JCEFLFJE@0123456789abcdef@
CONST	SEGMENT
??_C@_0BB@JCEFLFJE@0123456789abcdef@ DB '0123456789abcdef', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBNJJJJI@?$CF?4?$CKs@
CONST	SEGMENT
??_C@_04EBNJJJJI@?$CF?4?$CKs@ DB '%.*s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LHCJEHON@nan@
CONST	SEGMENT
??_C@_03LHCJEHON@nan@ DB 'nan', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DHEMHBNF@?9inf@
CONST	SEGMENT
??_C@_04DHEMHBNF@?9inf@ DB '-inf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OJHLLCGB@inf@
CONST	SEGMENT
??_C@_03OJHLLCGB@inf@ DB 'inf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PPINGECD@?$CFlu?5?$CFld?5?$CFs@
CONST	SEGMENT
??_C@_0L@PPINGECD@?$CFlu?5?$CFld?5?$CFs@ DB '%lu %ld %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PPPGGPGG@mg_error@
CONST	SEGMENT
??_C@_08PPPGGPGG@mg_error@ DB 'mg_error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08ECFMEKDO@DNS?5send@
CONST	SEGMENT
??_C@_08ECFMEKDO@DNS?5send@ DB 'DNS send', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BHFHEJIF@?$CFlu?5resolving?5?$CF?4?$CKs?5?$EA?5?$CFs?0?5txnid?5@
CONST	SEGMENT
??_C@_0CD@BHFHEJIF@?$CFlu?5resolving?5?$CF?4?$CKs?5?$EA?5?$CFs?0?5txnid?5@ DB '%'
	DB	'lu resolving %.*s @ %s, txnid %hu', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IKEIFCGJ@mg_sendnsreq@
CONST	SEGMENT
??_C@_0N@IKEIFCGJ@mg_sendnsreq@ DB 'mg_sendnsreq', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JPBODOLJ@resolve?5OOM@
CONST	SEGMENT
??_C@_0M@JPBODOLJ@resolve?5OOM@ DB 'resolve OOM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DKAJKOFH@resolver@
CONST	SEGMENT
??_C@_08DKAJKOFH@resolver@ DB 'resolver', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JCHAOBLG@DNS?5server?5URL?5is?5NULL?4?5Call?5mg@
CONST	SEGMENT
??_C@_0CL@JCHAOBLG@DNS?5server?5URL?5is?5NULL?4?5Call?5mg@ DB 'DNS server'
	DB	' URL is NULL. Call mg_mgr_init()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05OPJKAIHI@?$AA?$AA?$AB?$AA?$AB@
CONST	SEGMENT
??_C@_05OPJKAIHI@?$AA?$AA?$AB?$AA?$AB@ DB 00H, 00H, 01H, 00H, 01H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MNPPPHEH@DNS?5error@
CONST	SEGMENT
??_C@_09MNPPPHEH@DNS?5error@ DB 'DNS error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NIPDPKGJ@stray?5DNS?5reply@
CONST	SEGMENT
??_C@_0BA@NIPDPKGJ@stray?5DNS?5reply@ DB 'stray DNS reply', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ICMAECGD@?$CFlu?5already?5resolved@
CONST	SEGMENT
??_C@_0BF@ICMAECGD@?$CFlu?5already?5resolved@ DB '%lu already resolved', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BIFAMDJJ@?$CFs?5DNS?5lookup?5failed@
CONST	SEGMENT
??_C@_0BF@BIFAMDJJ@?$CFs?5DNS?5lookup?5failed@ DB '%s DNS lookup failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NMEECLIA@?$CFlu?5?$CFs?5is?5?$CFM@
CONST	SEGMENT
??_C@_0N@NMEECLIA@?$CFlu?5?$CFs?5is?5?$CFM@ DB '%lu %s is %M', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@COKDKGDG@Unexpected?5DNS?5response?3@
CONST	SEGMENT
??_C@_0BJ@COKDKGDG@Unexpected?5DNS?5response?3@ DB 'Unexpected DNS respon'
	DB	'se:', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@NDGBJGCA@C?3?2Users?2dev?2source?2repos?2alpin@
CONST	SEGMENT
??_C@_0DD@NDGBJGCA@C?3?2Users?2dev?2source?2repos?2alpin@ DB 'C:\Users\de'
	DB	'v\source\repos\alpinevms\src\mongoose.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BPNCNPOK@dns_cb@
CONST	SEGMENT
??_C@_06BPNCNPOK@dns_cb@ DB 'dns_cb', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EKADLLOH@DNS?5timeout@
CONST	SEGMENT
??_C@_0M@EKADLLOH@DNS?5timeout@ DB 'DNS timeout', 00H	; `string'
mg_log_level DD	02H
mg_fs_posix DQ	FLAT:p_stat
	DQ	FLAT:p_list
	DQ	FLAT:p_open
	DQ	FLAT:p_close
	DQ	FLAT:p_read
	DQ	FLAT:p_write
	DQ	FLAT:p_seek
	DQ	FLAT:p_rename
	DQ	FLAT:p_remove
	DQ	FLAT:p_mkdir
mg_fs_packed DQ	FLAT:packed_stat
	DQ	FLAT:packed_list
	DQ	FLAT:packed_open
	DQ	FLAT:packed_close
	DQ	FLAT:packed_read
	DQ	FLAT:packed_write
	DQ	FLAT:packed_seek
	DQ	FLAT:packed_rename
	DQ	FLAT:packed_remove
	DQ	FLAT:packed_mkdir
?crclut@?1??mg_crc32@@9@9 DD 00H			; `mg_crc32'::`2'::crclut
	DD	01db71064H
	DD	03b6e20c8H
	DD	026d930acH
	DD	076dc4190H
	DD	06b6b51f4H
	DD	04db26158H
	DD	05005713cH
	DD	0edb88320H
	DD	0f00f9344H
	DD	0d6d6a3e8H
	DD	0cb61b38cH
	DD	09b64c2b0H
	DD	086d3d2d4H
	DD	0a00ae278H
	DD	0bdbdf21cH
s_prop_map DB	01H
	DB	00H
	DB	02H
	DB	05H
	DB	03H
	DB	01H
	DB	08H
	DB	01H
	DB	09H
	DB	03H
	DB	0bH
	DB	04H
	DB	011H
	DB	05H
	DB	012H
	DB	01H
	DB	013H
	DB	06H
	DB	015H
	DB	01H
	DB	016H
	DB	03H
	DB	017H
	DB	00H
	DB	018H
	DB	05H
	DB	019H
	DB	00H
	DB	01aH
	DB	01H
	DB	01cH
	DB	01H
	DB	01fH
	DB	01H
	DB	021H
	DB	06H
	DB	022H
	DB	06H
	DB	023H
	DB	06H
	DB	024H
	DB	00H
	DB	025H
	DB	00H
	DB	026H
	DB	02H
	DB	027H
	DB	05H
	DB	028H
	DB	00H
	DB	029H
	DB	00H
	DB	02aH
	DB	00H
mg_sha256_k DD	0428a2f98H
	DD	071374491H
	DD	0b5c0fbcfH
	DD	0e9b5dba5H
	DD	03956c25bH
	DD	059f111f1H
	DD	0923f82a4H
	DD	0ab1c5ed5H
	DD	0d807aa98H
	DD	012835b01H
	DD	0243185beH
	DD	0550c7dc3H
	DD	072be5d74H
	DD	080deb1feH
	DD	09bdc06a7H
	DD	0c19bf174H
	DD	0e49b69c1H
	DD	0efbe4786H
	DD	0fc19dc6H
	DD	0240ca1ccH
	DD	02de92c6fH
	DD	04a7484aaH
	DD	05cb0a9dcH
	DD	076f988daH
	DD	0983e5152H
	DD	0a831c66dH
	DD	0b00327c8H
	DD	0bf597fc7H
	DD	0c6e00bf3H
	DD	0d5a79147H
	DD	06ca6351H
	DD	014292967H
	DD	027b70a85H
	DD	02e1b2138H
	DD	04d2c6dfcH
	DD	053380d13H
	DD	0650a7354H
	DD	0766a0abbH
	DD	081c2c92eH
	DD	092722c85H
	DD	0a2bfe8a1H
	DD	0a81a664bH
	DD	0c24b8b70H
	DD	0c76c51a3H
	DD	0d192e819H
	DD	0d6990624H
	DD	0f40e3585H
	DD	0106aa070H
	DD	019a4c116H
	DD	01e376c08H
	DD	02748774cH
	DD	034b0bcb5H
	DD	0391c0cb3H
	DD	04ed8aa4aH
	DD	05b9cca4fH
	DD	0682e6ff3H
	DD	0748f82eeH
	DD	078a5636fH
	DD	084c87814H
	DD	08cc70208H
	DD	090befffaH
	DD	0a4506cebH
	DD	0bef9a3f7H
	DD	0c67178f2H
PUBLIC	mg_ws_wrap
PUBLIC	mg_ws_upgrade
PUBLIC	mg_ws_connect
PUBLIC	mg_ws_send
PUBLIC	mg_ws_printf
PUBLIC	mg_ws_vprintf
PUBLIC	mg_millis
PUBLIC	mg_check_ip_acl
PUBLIC	mg_crc32
PUBLIC	mg_ntohs
PUBLIC	mg_ntohl
PUBLIC	mg_random_str
PUBLIC	mg_random
PUBLIC	mg_bzero
PUBLIC	mg_url_pass
PUBLIC	mg_url_user
PUBLIC	mg_url_port
PUBLIC	mg_url_uri
PUBLIC	mg_url_host
PUBLIC	mg_url_is_ssl
PUBLIC	mg_tls_ctx_free
PUBLIC	mg_tls_ctx_init
PUBLIC	mg_tls_pending
PUBLIC	mg_tls_send
PUBLIC	mg_tls_recv
PUBLIC	mg_tls_free
PUBLIC	mg_tls_handshake
PUBLIC	mg_tls_init
PUBLIC	mg_timer_poll
PUBLIC	mg_timer_expired
PUBLIC	mg_timer_free
PUBLIC	mg_timer_init
PUBLIC	mg_path_is_sane
PUBLIC	mg_unhex
PUBLIC	mg_unhexn
PUBLIC	mg_hex
PUBLIC	mg_commalist
PUBLIC	mg_split
PUBLIC	mg_globmatch
PUBLIC	mg_match
PUBLIC	mg_strstrip
PUBLIC	mg_strstr
PUBLIC	mg_strcmp
PUBLIC	mg_strdup
PUBLIC	mg_vcasecmp
PUBLIC	mg_vcmp
PUBLIC	mg_casecmp
PUBLIC	mg_ncasecmp
PUBLIC	mg_lower
PUBLIC	mg_str_n
PUBLIC	mg_str_s
PUBLIC	mg_http_serve_ssi
PUBLIC	mg_mgr_poll
PUBLIC	mg_wakeup
PUBLIC	mg_wakeup_init
PUBLIC	mg_connect_resolved
PUBLIC	mg_open_listener
PUBLIC	mg_send
PUBLIC	mg_io_send
PUBLIC	mg_sntp_connect
PUBLIC	mg_sntp_request
PUBLIC	mg_sntp_parse
PUBLIC	mg_hmac_sha256
PUBLIC	mg_sha256_final
PUBLIC	mg_sha256_update
PUBLIC	mg_sha256_init
PUBLIC	mg_sha1_final
PUBLIC	mg_sha1_update
PUBLIC	mg_sha1_init
PUBLIC	mg_rpc_list
PUBLIC	mg_rpc_err
PUBLIC	mg_rpc_verr
PUBLIC	mg_rpc_ok
PUBLIC	mg_rpc_vok
PUBLIC	mg_rpc_process
PUBLIC	mg_rpc_del
PUBLIC	mg_rpc_add
PUBLIC	mg_queue_del
PUBLIC	mg_queue_add
PUBLIC	mg_queue_next
PUBLIC	mg_queue_book
PUBLIC	mg_queue_init
PUBLIC	mg_print_esc
PUBLIC	mg_print_base64
PUBLIC	mg_print_hex
PUBLIC	mg_print_mac
PUBLIC	mg_print_ip_port
PUBLIC	mg_print_ip
PUBLIC	mg_print_ip6
PUBLIC	mg_print_ip4
PUBLIC	mg_pfn_stdout
PUBLIC	mg_mprintf
PUBLIC	mg_vmprintf
PUBLIC	mg_snprintf
PUBLIC	mg_vsnprintf
PUBLIC	mg_pfn_iobuf
PUBLIC	mg_queue_printf
PUBLIC	mg_queue_vprintf
PUBLIC	mg_ota_boot
PUBLIC	mg_ota_size
PUBLIC	mg_ota_timestamp
PUBLIC	mg_ota_crc32
PUBLIC	mg_ota_status
PUBLIC	mg_ota_rollback
PUBLIC	mg_ota_commit
PUBLIC	mg_ota_end
PUBLIC	mg_ota_write
PUBLIC	mg_ota_begin
PUBLIC	mg_mgr_init
PUBLIC	mg_mgr_free
PUBLIC	mg_io_recv
PUBLIC	mg_timer_add
PUBLIC	mg_wrapfd
PUBLIC	mg_listen
PUBLIC	mg_connect
PUBLIC	mg_close_conn
PUBLIC	mg_alloc_conn
PUBLIC	mg_aton
PUBLIC	mg_printf
PUBLIC	mg_vprintf
PUBLIC	mg_mqtt_listen
PUBLIC	mg_mqtt_connect
PUBLIC	mg_mqtt_disconnect
PUBLIC	mg_mqtt_pong
PUBLIC	mg_mqtt_ping
PUBLIC	mg_mqtt_parse
PUBLIC	mg_mqtt_sub
PUBLIC	mg_mqtt_pub
PUBLIC	mg_mqtt_login
PUBLIC	mg_mqtt_next_prop
PUBLIC	mg_mqtt_send_header
PUBLIC	mg_md5_final
PUBLIC	mg_md5_update
PUBLIC	mg_md5_init
PUBLIC	mg_hexdump
PUBLIC	mg_log
PUBLIC	mg_log_prefix
PUBLIC	mg_log_set_fn
PUBLIC	mg_json_get_long
PUBLIC	mg_json_get_hex
PUBLIC	mg_json_get_b64
PUBLIC	mg_json_get_str
PUBLIC	mg_json_unescape
PUBLIC	mg_json_get_bool
PUBLIC	mg_json_get_num
PUBLIC	mg_json_get
PUBLIC	mg_json_next
PUBLIC	mg_iobuf_free
PUBLIC	mg_iobuf_del
PUBLIC	mg_iobuf_add
PUBLIC	mg_iobuf_init
PUBLIC	mg_iobuf_resize
PUBLIC	mg_http_listen
PUBLIC	mg_http_connect
PUBLIC	mg_hello
PUBLIC	mg_http_status
PUBLIC	mg_http_upload
PUBLIC	mg_http_match_uri
PUBLIC	mg_http_get_header_var
PUBLIC	mg_http_creds
PUBLIC	mg_url_encode
PUBLIC	mg_http_serve_dir
PUBLIC	mg_http_serve_file
PUBLIC	mg_http_etag
PUBLIC	mg_http_reply
PUBLIC	mg_http_write_chunk
PUBLIC	mg_http_printf_chunk
PUBLIC	mg_http_parse
PUBLIC	mg_http_get_header
PUBLIC	mg_http_get_request_len
PUBLIC	mg_url_decode
PUBLIC	mg_http_get_var
PUBLIC	mg_http_var
PUBLIC	mg_http_bauth
PUBLIC	mg_http_next_multipart
PUBLIC	mg_to_size_t
PUBLIC	readdir
PUBLIC	closedir
PUBLIC	opendir
PUBLIC	mg_unpacked
PUBLIC	mg_unlist
PUBLIC	mg_unpack
PUBLIC	mg_file_printf
PUBLIC	mg_file_write
PUBLIC	mg_file_read
PUBLIC	mg_fs_close
PUBLIC	mg_fs_open
PUBLIC	mg_vxprintf
PUBLIC	mg_xprintf
PUBLIC	mg_error
PUBLIC	mg_call
PUBLIC	mg_resolve
PUBLIC	mg_dns_parse
PUBLIC	mg_dns_parse_rr
PUBLIC	mg_resolve_cancel
PUBLIC	mg_flash_load
PUBLIC	mg_flash_save
PUBLIC	mg_device_reset
PUBLIC	mg_flash_write
PUBLIC	mg_flash_swap_bank
PUBLIC	mg_flash_erase
PUBLIC	mg_flash_bank
PUBLIC	mg_flash_write_align
PUBLIC	mg_flash_sector_size
PUBLIC	mg_flash_size
PUBLIC	mg_flash_start
PUBLIC	mg_base64_decode
PUBLIC	mg_base64_encode
PUBLIC	mg_base64_final
PUBLIC	mg_base64_update
PUBLIC	sscanf
PUBLIC	_vsscanf_l
PUBLIC	__local_stdio_scanf_options
s_log_func_param DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_ws_wrap DD imagerel $LN4
	DD	imagerel $LN4+160
	DD	imagerel $unwind$mg_ws_wrap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_ws_upgrade DD imagerel $LN6
	DD	imagerel $LN6+215
	DD	imagerel $unwind$mg_ws_upgrade
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_ws_connect DD imagerel $LN14
	DD	imagerel $LN14+273
	DD	imagerel $unwind$mg_ws_connect
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_ws_cb DD imagerel mg_ws_cb
	DD	imagerel mg_ws_cb+627
	DD	imagerel $unwind$mg_ws_cb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_ws_client_handshake DD imagerel mg_ws_client_handshake
	DD	imagerel mg_ws_client_handshake+194
	DD	imagerel $unwind$mg_ws_client_handshake
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_ws_send DD imagerel $LN8
	DD	imagerel $LN8+183
	DD	imagerel $unwind$mg_ws_send
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mkhdr DD	imagerel mkhdr
	DD	imagerel mkhdr+274
	DD	imagerel $unwind$mkhdr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ws_process DD imagerel ws_process
	DD	imagerel ws_process+315
	DD	imagerel $unwind$ws_process
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ws_handshake DD imagerel ws_handshake
	DD	imagerel ws_handshake+284
	DD	imagerel $unwind$ws_handshake
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_ws_printf DD imagerel $LN4
	DD	imagerel $LN4+37
	DD	imagerel $unwind$mg_ws_printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_ws_vprintf DD imagerel $LN4
	DD	imagerel $LN4+90
	DD	imagerel $unwind$mg_ws_vprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_millis DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$mg_millis
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_check_ip_acl DD imagerel $LN26
	DD	imagerel $LN26+210
	DD	imagerel $unwind$mg_check_ip_acl
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$parse_net DD imagerel parse_net
	DD	imagerel parse_net+266
	DD	imagerel $unwind$parse_net
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_random_str DD imagerel $LN13
	DD	imagerel $LN13+131
	DD	imagerel $unwind$mg_random_str
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_random DD imagerel $LN10
	DD	imagerel $LN10+51
	DD	imagerel $unwind$mg_random
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_url_pass DD imagerel $LN9
	DD	imagerel $LN9+124
	DD	imagerel $unwind$mg_url_pass
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_url_user DD imagerel $LN12
	DD	imagerel $LN12+155
	DD	imagerel $unwind$mg_url_user
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_url_port DD imagerel $LN11
	DD	imagerel $LN11+267
	DD	imagerel $unwind$mg_url_port
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_url_uri DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$mg_url_uri
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_url_host DD imagerel $LN6
	DD	imagerel $LN6+129
	DD	imagerel $unwind$mg_url_host
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_url_is_ssl DD imagerel $LN6
	DD	imagerel $LN6+186
	DD	imagerel $unwind$mg_url_is_ssl
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_timer_poll DD imagerel $LN20
	DD	imagerel $LN20+129
	DD	imagerel $unwind$mg_timer_poll
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_unhex DD imagerel $LN12
	DD	imagerel $LN12+86
	DD	imagerel $unwind$mg_unhex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_split DD imagerel $LN14
	DD	imagerel $LN14+217
	DD	imagerel $unwind$mg_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_globmatch DD imagerel $LN8
	DD	imagerel $LN8+41
	DD	imagerel $unwind$mg_globmatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_match DD imagerel $LN40
	DD	imagerel $LN40+358
	DD	imagerel $unwind$mg_match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_strstr DD imagerel $LN16
	DD	imagerel $LN16+118
	DD	imagerel $unwind$mg_strstr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_strdup DD imagerel $LN6
	DD	imagerel $LN6+125
	DD	imagerel $unwind$mg_strdup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_vcasecmp DD imagerel $LN6
	DD	imagerel $LN6+64
	DD	imagerel $unwind$mg_vcasecmp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_vcmp DD imagerel $LN5
	DD	imagerel $LN5+52
	DD	imagerel $unwind$mg_vcmp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_ncasecmp DD imagerel $LN18
	DD	imagerel $LN18+84
	DD	imagerel $unwind$mg_ncasecmp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_mgr_poll DD imagerel $LN32
	DD	imagerel $LN32+499
	DD	imagerel $unwind$mg_mgr_poll
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_wakeup DD imagerel $LN6
	DD	imagerel $LN6+146
	DD	imagerel $unwind$mg_wakeup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_wakeup_init DD imagerel $LN19
	DD	imagerel $LN19+253
	DD	imagerel $unwind$mg_wakeup_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wufn DD	imagerel wufn
	DD	imagerel wufn+153
	DD	imagerel $unwind$wufn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_socketpair DD imagerel mg_socketpair
	DD	imagerel mg_socketpair+336
	DD	imagerel $unwind$mg_socketpair
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_iotest DD imagerel mg_iotest
	DD	imagerel mg_iotest+673
	DD	imagerel $unwind$mg_iotest
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$accept_conn DD imagerel accept_conn
	DD	imagerel accept_conn+492
	DD	imagerel $unwind$accept_conn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$raccept DD imagerel raccept
	DD	imagerel raccept+94
	DD	imagerel $unwind$raccept
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_connect_resolved DD imagerel $LN24
	DD	imagerel $LN24+401
	DD	imagerel $unwind$mg_connect_resolved
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setsockopts DD imagerel setsockopts
	DD	imagerel setsockopts+87
	DD	imagerel $unwind$setsockopts
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$connect_conn DD imagerel connect_conn
	DD	imagerel connect_conn+82
	DD	imagerel $unwind$connect_conn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$close_conn DD imagerel close_conn
	DD	imagerel close_conn+38
	DD	imagerel $unwind$close_conn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$write_conn DD imagerel write_conn
	DD	imagerel write_conn+203
	DD	imagerel $unwind$write_conn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$read_conn DD imagerel read_conn
	DD	imagerel read_conn+351
	DD	imagerel $unwind$read_conn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ioalloc DD imagerel ioalloc
	DD	imagerel ioalloc+98
	DD	imagerel $unwind$ioalloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$recv_raw DD imagerel recv_raw
	DD	imagerel recv_raw+218
	DD	imagerel $unwind$recv_raw
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_open_listener DD imagerel $LN47
	DD	imagerel $LN47+682
	DD	imagerel $unwind$mg_open_listener
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_set_non_blocking_mode DD imagerel mg_set_non_blocking_mode
	DD	imagerel mg_set_non_blocking_mode+33
	DD	imagerel $unwind$mg_set_non_blocking_mode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_send DD imagerel $LN12
	DD	imagerel $LN12+188
	DD	imagerel $unwind$mg_send
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_io_send DD imagerel $LN14
	DD	imagerel $LN14+211
	DD	imagerel $unwind$mg_io_send
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$iolog DD	imagerel iolog
	DD	imagerel iolog+303
	DD	imagerel $unwind$iolog
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setlocaddr DD imagerel setlocaddr
	DD	imagerel setlocaddr+69
	DD	imagerel $unwind$setlocaddr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_sntp_connect DD imagerel $LN6
	DD	imagerel $LN6+50
	DD	imagerel $unwind$mg_sntp_connect
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_sntp_request DD imagerel $LN16
	DD	imagerel $LN16+299
	DD	imagerel $unwind$mg_sntp_request
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sntp_cb DD imagerel sntp_cb
	DD	imagerel sntp_cb+241
	DD	imagerel $unwind$sntp_cb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_sntp_parse DD imagerel $LN44
	DD	imagerel $LN44+438
	DD	imagerel $unwind$mg_sntp_parse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_hmac_sha256 DD imagerel $LN23
	DD	imagerel $LN23+541
	DD	imagerel $unwind$mg_hmac_sha256
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_sha256_final DD imagerel $LN25
	DD	imagerel $LN25+299
	DD	imagerel $unwind$mg_sha256_final
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_sha256_update DD imagerel $LN13
	DD	imagerel $LN13+106
	DD	imagerel $unwind$mg_sha256_update
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_sha256_chunk DD imagerel mg_sha256_chunk
	DD	imagerel mg_sha256_chunk+410
	DD	imagerel $unwind$mg_sha256_chunk
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_sha1_final DD imagerel $LN26
	DD	imagerel $LN26+211
	DD	imagerel $unwind$mg_sha1_final
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_sha1_update DD imagerel $LN17
	DD	imagerel $LN17+205
	DD	imagerel $unwind$mg_sha1_update
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_sha1_transform DD imagerel mg_sha1_transform
	DD	imagerel mg_sha1_transform+4869
	DD	imagerel $unwind$mg_sha1_transform
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$print_methods DD imagerel print_methods
	DD	imagerel print_methods+166
	DD	imagerel $unwind$print_methods
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_rpc_err DD imagerel $LN4
	DD	imagerel $LN4+37
	DD	imagerel $unwind$mg_rpc_err
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_rpc_verr DD imagerel $LN5
	DD	imagerel $LN5+339
	DD	imagerel $unwind$mg_rpc_verr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_rpc_ok DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$mg_rpc_ok
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_rpc_vok DD imagerel $LN5
	DD	imagerel $LN5+223
	DD	imagerel $unwind$mg_rpc_vok
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_rpc_process DD imagerel $LN18
	DD	imagerel $LN18+238
	DD	imagerel $unwind$mg_rpc_process
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_rpc_call DD imagerel mg_rpc_call
	DD	imagerel mg_rpc_call+137
	DD	imagerel $unwind$mg_rpc_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_rpc_del DD imagerel $LN13
	DD	imagerel $LN13+91
	DD	imagerel $unwind$mg_rpc_del
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_rpc_add DD imagerel $LN5
	DD	imagerel $LN5+136
	DD	imagerel $unwind$mg_rpc_add
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_queue_book DD imagerel $LN11
	DD	imagerel $LN11+169
	DD	imagerel $unwind$mg_queue_book
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_print_hex DD imagerel $LN11
	DD	imagerel $LN11+139
	DD	imagerel $unwind$mg_print_hex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bcpy DD	imagerel bcpy
	DD	imagerel bcpy+333
	DD	imagerel $unwind$bcpy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$qcpy DD	imagerel qcpy
	DD	imagerel qcpy+140
	DD	imagerel $unwind$qcpy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_print_mac DD imagerel $LN4
	DD	imagerel $LN4+96
	DD	imagerel $unwind$mg_print_mac
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_print_ip_port DD imagerel $LN6
	DD	imagerel $LN6+75
	DD	imagerel $unwind$mg_print_ip_port
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$print_ip6 DD imagerel print_ip6
	DD	imagerel print_ip6+297
	DD	imagerel $unwind$print_ip6
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$print_ip4 DD imagerel print_ip4
	DD	imagerel print_ip4+54
	DD	imagerel $unwind$print_ip4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_mprintf DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$mg_mprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_vmprintf DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$mg_vmprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_snprintf DD imagerel $LN4
	DD	imagerel $LN4+37
	DD	imagerel $unwind$mg_snprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_vsnprintf DD imagerel $LN5
	DD	imagerel $LN5+72
	DD	imagerel $unwind$mg_vsnprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_pfn_iobuf_private DD imagerel mg_pfn_iobuf_private
	DD	imagerel mg_pfn_iobuf_private+109
	DD	imagerel $unwind$mg_pfn_iobuf_private
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_queue_printf DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$mg_queue_printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_queue_vprintf DD imagerel $LN11
	DD	imagerel $LN11+148
	DD	imagerel $unwind$mg_queue_vprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_mgr_init DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$mg_mgr_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_mgr_free DD imagerel $LN22
	DD	imagerel $LN22+130
	DD	imagerel $unwind$mg_mgr_free
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_io_recv DD imagerel $LN6
	DD	imagerel $LN6+89
	DD	imagerel $unwind$mg_io_recv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_timer_add DD imagerel $LN7
	DD	imagerel $LN7+127
	DD	imagerel $unwind$mg_timer_add
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_wrapfd DD imagerel $LN8
	DD	imagerel $LN8+103
	DD	imagerel $unwind$mg_wrapfd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_listen DD imagerel $LN24
	DD	imagerel $LN24+386
	DD	imagerel $unwind$mg_listen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_connect DD imagerel $LN25
	DD	imagerel $LN25+354
	DD	imagerel $unwind$mg_connect
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_close_conn DD imagerel $LN35
	DD	imagerel $LN35+212
	DD	imagerel $unwind$mg_close_conn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_alloc_conn DD imagerel $LN5
	DD	imagerel $LN5+78
	DD	imagerel $unwind$mg_alloc_conn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_aton DD imagerel $LN10
	DD	imagerel $LN10+144
	DD	imagerel $unwind$mg_aton
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_aton6 DD imagerel mg_aton6
	DD	imagerel mg_aton6+419
	DD	imagerel $unwind$mg_aton6
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_v4mapped DD imagerel mg_v4mapped
	DD	imagerel mg_v4mapped+122
	DD	imagerel $unwind$mg_v4mapped
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_atonl DD imagerel mg_atonl
	DD	imagerel mg_atonl+47
	DD	imagerel $unwind$mg_atonl
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_printf DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$mg_printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_vprintf DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$mg_vprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_mqtt_listen DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$mg_mqtt_listen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_mqtt_connect DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$mg_mqtt_connect
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_mqtt_disconnect DD imagerel $LN17
	DD	imagerel $LN17+158
	DD	imagerel $unwind$mg_mqtt_disconnect
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mqtt_cb DD imagerel mqtt_cb
	DD	imagerel mqtt_cb+707
	DD	imagerel $unwind$mqtt_cb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_mqtt_parse DD imagerel $LN51
	DD	imagerel $LN51+503
	DD	imagerel $unwind$mg_mqtt_parse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_mqtt_sub DD imagerel $LN26
	DD	imagerel $LN26+297
	DD	imagerel $unwind$mg_mqtt_sub
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_mqtt_pub DD imagerel $LN34
	DD	imagerel $LN34+408
	DD	imagerel $unwind$mg_mqtt_pub
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_mqtt_login DD imagerel $LN77
	DD	imagerel $LN77+889
	DD	imagerel $unwind$mg_mqtt_login
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_mqtt_next_prop DD imagerel $LN17
	DD	imagerel $LN17+366
	DD	imagerel $unwind$mg_mqtt_next_prop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_send_mqtt_properties DD imagerel mg_send_mqtt_properties
	DD	imagerel mg_send_mqtt_properties+440
	DD	imagerel $unwind$mg_send_mqtt_properties
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_props_size DD imagerel get_props_size
	DD	imagerel get_props_size+39
	DD	imagerel $unwind$get_props_size
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_properties_length DD imagerel get_properties_length
	DD	imagerel get_properties_length+152
	DD	imagerel $unwind$get_properties_length
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$decode_varint DD imagerel decode_varint
	DD	imagerel decode_varint+83
	DD	imagerel $unwind$decode_varint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_send_u32 DD imagerel mg_send_u32
	DD	imagerel mg_send_u32+29
	DD	imagerel $unwind$mg_send_u32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_send_u16 DD imagerel mg_send_u16
	DD	imagerel mg_send_u16+30
	DD	imagerel $unwind$mg_send_u16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_mqtt_send_header DD imagerel $LN13
	DD	imagerel $LN13+88
	DD	imagerel $unwind$mg_mqtt_send_header
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_md5_final DD imagerel $LN6
	DD	imagerel $LN6+180
	DD	imagerel $unwind$mg_md5_final
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_md5_update DD imagerel $LN17
	DD	imagerel $LN17+240
	DD	imagerel $unwind$mg_md5_update
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_md5_transform DD imagerel mg_md5_transform
	DD	imagerel mg_md5_transform+2020
	DD	imagerel $unwind$mg_md5_transform
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_hexdump DD imagerel $LN56
	DD	imagerel $LN56+459
	DD	imagerel $unwind$mg_hexdump
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_log DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$mg_log
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_log_prefix DD imagerel $LN15
	DD	imagerel $LN15+212
	DD	imagerel $unwind$mg_log_prefix
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$logs DD	imagerel logs
	DD	imagerel logs+68
	DD	imagerel $unwind$logs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_json_get_long DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$mg_json_get_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_json_get_hex DD imagerel $LN6
	DD	imagerel $LN6+168
	DD	imagerel $unwind$mg_json_get_hex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_json_get_b64 DD imagerel $LN6
	DD	imagerel $LN6+162
	DD	imagerel $unwind$mg_json_get_b64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_json_get_str DD imagerel $LN8
	DD	imagerel $LN8+170
	DD	imagerel $unwind$mg_json_get_str
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_json_unescape DD imagerel $LN24
	DD	imagerel $LN24+217
	DD	imagerel $unwind$mg_json_unescape
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_json_get_bool DD imagerel $LN7
	DD	imagerel $LN7+103
	DD	imagerel $unwind$mg_json_get_bool
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_json_get_num DD imagerel $LN7
	DD	imagerel $LN7+122
	DD	imagerel $unwind$mg_json_get_num
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_json_get DD imagerel $LN150
	DD	imagerel $LN150+1293
	DD	imagerel $unwind$mg_json_get
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_json_next DD imagerel $LN61
	DD	imagerel $LN61+513
	DD	imagerel $unwind$mg_json_next
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_atod DD imagerel mg_atod
	DD	imagerel mg_atod+412
	DD	imagerel $unwind$mg_atod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_pass_string DD imagerel mg_pass_string
	DD	imagerel mg_pass_string+133
	DD	imagerel $unwind$mg_pass_string
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_iobuf_del DD imagerel $LN19
	DD	imagerel $LN19+126
	DD	imagerel $unwind$mg_iobuf_del
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_iobuf_add DD imagerel $LN12
	DD	imagerel $LN12+185
	DD	imagerel $unwind$mg_iobuf_add
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_iobuf_resize DD imagerel $LN55
	DD	imagerel $LN55+307
	DD	imagerel $unwind$mg_iobuf_resize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_listen DD imagerel $LN5
	DD	imagerel $LN5+33
	DD	imagerel $unwind$mg_http_listen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_connect DD imagerel $LN5
	DD	imagerel $LN5+33
	DD	imagerel $unwind$mg_http_connect
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_hello DD imagerel $LN15
	DD	imagerel $LN15+141
	DD	imagerel $unwind$mg_hello
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_hfn DD imagerel mg_hfn
	DD	imagerel mg_hfn+236
	DD	imagerel $unwind$mg_hfn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$http_cb DD imagerel http_cb
	DD	imagerel http_cb+729
	DD	imagerel $unwind$http_cb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$skip_chunk DD imagerel skip_chunk
	DD	imagerel skip_chunk+212
	DD	imagerel $unwind$skip_chunk
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_upload DD imagerel $LN24
	DD	imagerel $LN24+548
	DD	imagerel $unwind$mg_http_upload
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_match_uri DD imagerel $LN9
	DD	imagerel $LN9+70
	DD	imagerel $unwind$mg_http_match_uri
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_get_header_var DD imagerel $LN44
	DD	imagerel $LN44+299
	DD	imagerel $unwind$mg_http_get_header_var
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stripquotes DD imagerel stripquotes
	DD	imagerel stripquotes+65
	DD	imagerel $unwind$stripquotes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_creds DD imagerel $LN17
	DD	imagerel $LN17+485
	DD	imagerel $unwind$mg_http_creds
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_url_encode DD imagerel $LN20
	DD	imagerel $LN20+164
	DD	imagerel $unwind$mg_url_encode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_serve_dir DD imagerel $LN20
	DD	imagerel $LN20+231
	DD	imagerel $unwind$mg_http_serve_dir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$uri_to_path DD imagerel uri_to_path
	DD	imagerel uri_to_path+381
	DD	imagerel $unwind$uri_to_path
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$uri_to_path2 DD imagerel uri_to_path2
	DD	imagerel uri_to_path2+618
	DD	imagerel $unwind$uri_to_path2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$listdir DD imagerel listdir
	DD	imagerel listdir+416
	DD	imagerel $unwind$listdir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printdirentry DD imagerel printdirentry
	DD	imagerel printdirentry+500
	DD	imagerel $unwind$printdirentry
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_serve_file DD imagerel $LN55
	DD	imagerel $LN55+1058
	DD	imagerel $unwind$mg_http_serve_file
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getrange DD imagerel getrange
	DD	imagerel getrange+257
	DD	imagerel $unwind$getrange
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$guess_content_type DD imagerel guess_content_type
	DD	imagerel guess_content_type+301
	DD	imagerel $unwind$guess_content_type
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$static_cb DD imagerel static_cb
	DD	imagerel static_cb+149
	DD	imagerel $unwind$static_cb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_etag DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$mg_http_etag
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$restore_http_cb DD imagerel restore_http_cb
	DD	imagerel restore_http_cb+85
	DD	imagerel $unwind$restore_http_cb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_reply DD imagerel $LN5
	DD	imagerel $LN5+179
	DD	imagerel $unwind$mg_http_reply
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_write_chunk DD imagerel $LN5
	DD	imagerel $LN5+100
	DD	imagerel $unwind$mg_http_write_chunk
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_printf_chunk DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$mg_http_printf_chunk
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_vprintf_chunk DD imagerel mg_http_vprintf_chunk
	DD	imagerel mg_http_vprintf_chunk+194
	DD	imagerel $unwind$mg_http_vprintf_chunk
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_parse DD imagerel $LN57
	DD	imagerel $LN57+574
	DD	imagerel $unwind$mg_http_parse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_parse_headers DD imagerel mg_http_parse_headers
	DD	imagerel mg_http_parse_headers+296
	DD	imagerel $unwind$mg_http_parse_headers
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_get_header DD imagerel $LN15
	DD	imagerel $LN15+125
	DD	imagerel $unwind$mg_http_get_header
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_url_decode DD imagerel $LN39
	DD	imagerel $LN39+270
	DD	imagerel $unwind$mg_url_decode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_get_var DD imagerel $LN18
	DD	imagerel $LN18+188
	DD	imagerel $unwind$mg_http_get_var
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_var DD imagerel $LN14
	DD	imagerel $LN14+126
	DD	imagerel $unwind$mg_http_var
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_bauth DD imagerel $LN38
	DD	imagerel $LN38+378
	DD	imagerel $unwind$mg_http_bauth
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_http_next_multipart DD imagerel $LN56
	DD	imagerel $LN56+613
	DD	imagerel $unwind$mg_http_next_multipart
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_to_size_t DD imagerel $LN40
	DD	imagerel $LN40+211
	DD	imagerel $unwind$mg_to_size_t
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$p_mkdir DD imagerel p_mkdir
	DD	imagerel p_mkdir+20
	DD	imagerel $unwind$p_mkdir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$p_remove DD imagerel p_remove
	DD	imagerel p_remove+20
	DD	imagerel $unwind$p_remove
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$p_rename DD imagerel p_rename
	DD	imagerel p_rename+20
	DD	imagerel $unwind$p_rename
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$p_seek DD imagerel p_seek
	DD	imagerel p_seek+35
	DD	imagerel $unwind$p_seek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$p_open DD imagerel p_open
	DD	imagerel p_open+130
	DD	imagerel $unwind$p_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$p_list DD imagerel p_list
	DD	imagerel p_list+109
	DD	imagerel $unwind$p_list
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$readdir DD imagerel $LN10
	DD	imagerel $LN10+172
	DD	imagerel $unwind$readdir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$closedir DD imagerel $LN7
	DD	imagerel $LN7+82
	DD	imagerel $unwind$closedir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$opendir DD imagerel $LN12
	DD	imagerel $LN12+205
	DD	imagerel $unwind$opendir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$to_wchar DD imagerel to_wchar
	DD	imagerel to_wchar+288
	DD	imagerel $unwind$to_wchar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$p_stat DD imagerel p_stat
	DD	imagerel p_stat+270
	DD	imagerel $unwind$p_stat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$packed_read DD imagerel packed_read
	DD	imagerel packed_read+75
	DD	imagerel $unwind$packed_read
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$packed_close DD imagerel packed_close
	DD	imagerel packed_close+20
	DD	imagerel $unwind$packed_close
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$is_dir_prefix DD imagerel is_dir_prefix
	DD	imagerel is_dir_prefix+98
	DD	imagerel $unwind$is_dir_prefix
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_file_printf DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$mg_file_printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_file_write DD imagerel $LN10
	DD	imagerel $LN10+209
	DD	imagerel $unwind$mg_file_write
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_file_read DD imagerel $LN12
	DD	imagerel $LN12+193
	DD	imagerel $unwind$mg_file_read
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_fs_close DD imagerel $LN6
	DD	imagerel $LN6+38
	DD	imagerel $unwind$mg_fs_close
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_fs_open DD imagerel $LN6
	DD	imagerel $LN6+106
	DD	imagerel $unwind$mg_fs_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_vxprintf DD imagerel $LN225
	DD	imagerel $LN225+1151
	DD	imagerel $unwind$mg_vxprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_xprintf DD imagerel $LN4
	DD	imagerel $LN4+37
	DD	imagerel $unwind$mg_xprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$scpy DD	imagerel scpy
	DD	imagerel scpy+95
	DD	imagerel $unwind$scpy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_lld DD imagerel mg_lld
	DD	imagerel mg_lld+232
	DD	imagerel $unwind$mg_lld
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_dtoa DD imagerel mg_dtoa
	DD	imagerel mg_dtoa+896
	DD	imagerel $unwind$mg_dtoa
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_error DD imagerel $LN8
	DD	imagerel $LN8+142
	DD	imagerel $unwind$mg_error
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_call DD imagerel $LN6
	DD	imagerel $LN6+75
	DD	imagerel $unwind$mg_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_resolve DD imagerel $LN10
	DD	imagerel $LN10+161
	DD	imagerel $unwind$mg_resolve
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_sendnsreq DD imagerel mg_sendnsreq
	DD	imagerel mg_sendnsreq+388
	DD	imagerel $unwind$mg_sendnsreq
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_dns_send DD imagerel mg_dns_send
	DD	imagerel mg_dns_send+240
	DD	imagerel $unwind$mg_dns_send
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dns_cb DD imagerel dns_cb
	DD	imagerel dns_cb+647
	DD	imagerel $unwind$dns_cb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_dns_parse DD imagerel $LN48
	DD	imagerel $LN48+503
	DD	imagerel $unwind$mg_dns_parse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_dns_parse_rr DD imagerel $LN22
	DD	imagerel $LN22+247
	DD	imagerel $unwind$mg_dns_parse_rr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_dns_parse_name DD imagerel mg_dns_parse_name
	DD	imagerel mg_dns_parse_name+35
	DD	imagerel $unwind$mg_dns_parse_name
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_dns_parse_name_depth DD imagerel mg_dns_parse_name_depth
	DD	imagerel mg_dns_parse_name_depth+346
	DD	imagerel $unwind$mg_dns_parse_name_depth
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_resolve_cancel DD imagerel $LN23
	DD	imagerel $LN23+100
	DD	imagerel $unwind$mg_resolve_cancel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_base64_decode DD imagerel $LN19
	DD	imagerel $LN19+289
	DD	imagerel $unwind$mg_base64_decode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_base64_encode DD imagerel $LN13
	DD	imagerel $LN13+148
	DD	imagerel $unwind$mg_base64_encode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_base64_final DD imagerel $LN13
	DD	imagerel $LN13+77
	DD	imagerel $unwind$mg_base64_final
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mg_base64_update DD imagerel $LN8
	DD	imagerel $LN8+178
	DD	imagerel $unwind$mg_base64_update
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN6
	DD	imagerel $LN6+75
	DD	imagerel $unwind$sscanf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN4
	DD	imagerel $LN4+75
	DD	imagerel $unwind$_vsscanf_l
s_log_func DQ	FLAT:mg_pfn_stdout
s_known_types DQ FLAT:??_C@_04PNIFHPHN@html@
	DQ	0000000000000004H
	DQ	FLAT:??_C@_0BJ@CDMHJEKP@text?1html?$DL?5charset?$DNutf?98@
	DQ	0000000000000018H
	DQ	FLAT:??_C@_03KDICCKGJ@htm@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_0BJ@CDMHJEKP@text?1html?$DL?5charset?$DNutf?98@
	DQ	0000000000000018H
	DQ	FLAT:??_C@_03KFINIEDC@css@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_0BI@MKFMEPPC@text?1css?$DL?5charset?$DNutf?98@
	DQ	0000000000000017H
	DQ	FLAT:??_C@_02EBOMECCO@js@
	DQ	0000000000000002H
	DQ	FLAT:??_C@_0BP@IBHNJOOI@text?1javascript?$DL?5charset?$DNutf?98@
	DQ	000000000000001eH
	DQ	FLAT:??_C@_03MOLNDNH@gif@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_09HADNJIG@image?1gif@
	DQ	0000000000000009H
	DQ	FLAT:??_C@_03NNHBJLDF@png@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_09NGJJJBGE@image?1png@
	DQ	0000000000000009H
	DQ	FLAT:??_C@_03PEGNKCLE@jpg@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_0L@PJKHLKFB@image?1jpeg@
	DQ	000000000000000aH
	DQ	FLAT:??_C@_04OFMADDDJ@jpeg@
	DQ	0000000000000004H
	DQ	FLAT:??_C@_0L@PJKHLKFB@image?1jpeg@
	DQ	000000000000000aH
	DQ	FLAT:??_C@_04GOJHKINL@woff@
	DQ	0000000000000004H
	DQ	FLAT:??_C@_09DPKAPMKA@font?1woff@
	DQ	0000000000000009H
	DQ	FLAT:??_C@_03FKLJBLIF@ttf@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_08LDONFKLE@font?1ttf@
	DQ	0000000000000008H
	DQ	FLAT:??_C@_03NNPBMGBD@svg@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_0O@MMMFMLNF@image?1svg?$CLxml@
	DQ	000000000000000dH
	DQ	FLAT:??_C@_03CLFHJCDC@txt@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_0BK@LKDCPLNF@text?1plain?$DL?5charset?$DNutf?98@
	DQ	0000000000000019H
	DQ	FLAT:??_C@_03LJGCHEIJ@avi@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_0BA@DDNKOHJP@video?1x?9msvideo@
	DQ	000000000000000fH
	DQ	FLAT:??_C@_03NIPKHAHH@csv@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_08CGFGOOIN@text?1csv@
	DQ	0000000000000008H
	DQ	FLAT:??_C@_03GHKEPEMO@doc@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_0BD@DMPJCPHP@application?1msword@
	DQ	0000000000000012H
	DQ	FLAT:??_C@_03JACLIBNI@exe@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_0BJ@JDCJMJCJ@application?1octet?9stream@
	DQ	0000000000000018H
	DQ	FLAT:??_C@_02JIPGGKDE@gz@
	DQ	0000000000000002H
	DQ	FLAT:??_C@_0BB@JGMCIAKF@application?1gzip@
	DQ	0000000000000010H
	DQ	FLAT:??_C@_03DAGBJKHL@ico@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_0N@DKCCOJIM@image?1x?9icon@
	DQ	000000000000000cH
	DQ	FLAT:??_C@_04CLCAKCEI@json@
	DQ	0000000000000004H
	DQ	FLAT:??_C@_0BB@MDJGEIPD@application?1json@
	DQ	0000000000000010H
	DQ	FLAT:??_C@_03CNBJFNFA@mov@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_0BA@MEHPJOJG@video?1quicktime@
	DQ	000000000000000fH
	DQ	FLAT:??_C@_03LHGNACFN@mp3@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_0L@DOFAEOCL@audio?1mpeg@
	DQ	000000000000000aH
	DQ	FLAT:??_C@_03PICMJEJK@mp4@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_09GGJCJIJ@video?1mp4@
	DQ	0000000000000009H
	DQ	FLAT:??_C@_04FHOAOPCJ@mpeg@
	DQ	0000000000000004H
	DQ	FLAT:??_C@_0L@NDKAOLEK@video?1mpeg@
	DQ	000000000000000aH
	DQ	FLAT:??_C@_03MJPNCPKC@pdf@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_0BA@MHMDKHOF@application?1pdf@
	DQ	000000000000000fH
	DQ	FLAT:??_C@_05HNDFGKM@shtml@
	DQ	0000000000000005H
	DQ	FLAT:??_C@_0BJ@CDMHJEKP@text?1html?$DL?5charset?$DNutf?98@
	DQ	0000000000000018H
	DQ	FLAT:??_C@_03KCKOFLPB@tgz@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_0BD@LHPABEHA@application?1tar?9gz@
	DQ	0000000000000012H
	DQ	FLAT:??_C@_03BICDMHKB@wav@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_09KOEADLDC@audio?1wav@
	DQ	0000000000000009H
	DQ	FLAT:??_C@_04BKLLFFLE@webp@
	DQ	0000000000000004H
	DQ	FLAT:??_C@_0L@GNMNMNM@image?1webp@
	DQ	000000000000000aH
	DQ	FLAT:??_C@_03LCAAOJEC@zip@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_0BA@LMDOGBAF@application?1zip@
	DQ	000000000000000fH
	DQ	FLAT:??_C@_03FOICNDPP@3gp@
	DQ	0000000000000003H
	DQ	FLAT:??_C@_0L@IGCDBAML@video?13gpp@
	DQ	000000000000000aH
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_base64_update DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_base64_final DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_base64_encode DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_base64_decode DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_resolve_cancel DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_dns_parse_name_depth DD 0c1c01H
	DD	010641cH
	DD	0f541cH
	DD	0e341cH
	DD	0f018721cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_dns_parse_name DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_dns_parse_rr DD 0a1901H
	DD	0d7419H
	DD	0c6419H
	DD	0b5419H
	DD	0a3419H
	DD	0e0157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_dns_parse DD 0c1c01H
	DD	011641cH
	DD	010541cH
	DD	0f341cH
	DD	0f018721cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dns_cb DD 0b1b01H
	DD	030641bH
	DD	02f541bH
	DD	02e341bH
	DD	02a011bH
	DD	0e012f014H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_dns_send DD 0b1b01H
	DD	02c641bH
	DD	02b541bH
	DD	02a341bH
	DD	026011bH
	DD	0e012f014H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_sendnsreq DD 0c1d01H
	DD	0d741dH
	DD	0c641dH
	DD	0b541dH
	DD	0a341dH
	DD	0f019521dH
	DD	0c015e017H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_resolve DD 061201H
	DD	056812H
	DD	0e340aH
	DD	07006b20aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_call DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_error DD 021401H
	DD	03010d214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_dtoa DD 081b01H
	DD	011e41bH
	DD	010741bH
	DD	0e641bH
	DD	05014b21bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_lld DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scpy DD	0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_xprintf DD 010f01H
	DD	0620fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_vxprintf DD 0a2501H
	DD	0173425H
	DD	0f01ed225H
	DD	0d01ae01cH
	DD	07016c018H
	DD	050146015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_fs_open DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_fs_close DD 020a01H
	DD	03006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_file_read DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_file_write DD 0b1b01H
	DD	02e641bH
	DD	02d541bH
	DD	02c341bH
	DD	028011bH
	DD	0e012f014H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_file_printf DD 041201H
	DD	0700e5212H
	DD	0300c600dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_dir_prefix DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$packed_close DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$packed_read DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$p_stat DD 071201H
	DD	0536412H
	DD	0523412H
	DD	0500112H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$to_wchar DD 071301H
	DD	08f7413H
	DD	08e3413H
	DD	08c0113H
	DD	0e00cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$opendir DD 071201H
	DD	0496412H
	DD	0483412H
	DD	0460112H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$closedir DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$readdir DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$p_list DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$p_open DD 030901H
	DD	04c0109H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$p_seek DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$p_rename DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$p_remove DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$p_mkdir DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_to_size_t DD 081301H
	DD	04e413H
	DD	03740fH
	DD	02640bH
	DD	013407H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_next_multipart DD 0a1a01H
	DD	01b341aH
	DD	0f010f21aH
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_bauth DD 0c2001H
	DD	0d6420H
	DD	0b5420H
	DD	0a3420H
	DD	0f01c3220H
	DD	0d018e01aH
	DD	07014c016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_var DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_get_var DD 040a01H
	DD	0e340aH
	DD	07006b20aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_url_decode DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_get_header DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_parse_headers DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_parse DD 0c1c01H
	DD	0e641cH
	DD	0d541cH
	DD	0c341cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_vprintf_chunk DD 0a1901H
	DD	09e419H
	DD	087419H
	DD	076419H
	DD	063419H
	DD	0f0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_printf_chunk DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_write_chunk DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_reply DD 040c01H
	DD	07008720cH
	DD	030066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$restore_http_cb DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_etag DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$static_cb DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$guess_content_type DD 061201H
	DD	0117412H
	DD	0103412H
	DD	0500bd212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getrange DD 0a1b01H
	DD	0de41bH
	DD	0c741bH
	DD	0b641bH
	DD	0a341bH
	DD	05014721bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_serve_file DD 0b2401H
	DD	0543424H
	DD	04c0124H
	DD	0e013f015H
	DD	0c00fd011H
	DD	0600c700dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printdirentry DD 091b01H
	DD	03e341bH
	DD	038011bH
	DD	0e00af00cH
	DD	060077008H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listdir DD 0f6f01H
	DD	019686fH
	DD	03bc426H
	DD	03a7426H
	DD	0396426H
	DD	0383426H
	DD	0340126H
	DD	0e016f018H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$uri_to_path2 DD 0c1c01H
	DD	0e641cH
	DD	0d541cH
	DD	0c341cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$uri_to_path DD 0114901H
	DD	0a8849H
	DD	0b7844H
	DD	0c683dH
	DD	020741fH
	DD	01f641fH
	DD	01e341fH
	DD	01a011fH
	DD	0c012e014H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_serve_dir DD 091701H
	DD	0306417H
	DD	02f5417H
	DD	02e3417H
	DD	02c0117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_url_encode DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_creds DD 0b1f01H
	DD	032741fH
	DD	031641fH
	DD	030341fH
	DD	02c011fH
	DD	0e012f014H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stripquotes DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_get_header_var DD 0c1c01H
	DD	011641cH
	DD	010541cH
	DD	0f341cH
	DD	0f018721cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_match_uri DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_upload DD 0a1601H
	DD	0125416H
	DD	0103416H
	DD	0f0129216H
	DD	0d00ee010H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$skip_chunk DD 0a1901H
	DD	09e419H
	DD	087419H
	DD	076419H
	DD	063419H
	DD	0f0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$http_cb DD 0b2701H
	DD	0983427H
	DD	08e0127H
	DD	0e017f019H
	DD	0c013d015H
	DD	060107011H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_hfn DD 040a01H
	DD	0a340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_hello DD 030b01H
	DD	014010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_connect DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_http_listen DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	04fH
	DB	0c5H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_iobuf_resize DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_iobuf_add DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	060H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_iobuf_del DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_pass_string DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_atod DD 050b01H
	DD	05640bH
	DD	02340bH
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_json_next DD 0a1c01H
	DD	010341cH
	DD	0f015521cH
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_json_get DD 091501H
	DD	0f011a215H
	DD	0d00de00fH
	DD	07009c00bH
	DD	050076008H
	DD	03006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_json_get_num DD 061401H
	DD	0a6414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_json_get_bool DD 061001H
	DD	096410H
	DD	083410H
	DD	0700c5210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_json_unescape DD 0a1901H
	DD	09e419H
	DD	087419H
	DD	076419H
	DD	063419H
	DD	0f0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_json_get_str DD 081301H
	DD	0c5413H
	DD	0b3413H
	DD	0e00f5213H
	DD	0600c700dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_json_get_b64 DD 0a1801H
	DD	0d6418H
	DD	0c5418H
	DD	0b3418H
	DD	0f0145218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_json_get_hex DD 081301H
	DD	0c5413H
	DD	0b3413H
	DD	0e00f5213H
	DD	0600c700dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_json_get_long DD 020c01H
	DD	03008520cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$logs DD	061401H
	DD	076414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_log_prefix DD 0a1901H
	DD	0137419H
	DD	0126419H
	DD	0115419H
	DD	0103419H
	DD	0e015d219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_log DD 011701H
	DD	06217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_hexdump DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_md5_transform DD 091501H
	DD	0f0114215H
	DD	0d00de00fH
	DD	07009c00bH
	DD	050076008H
	DD	03006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_md5_update DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_md5_final DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_mqtt_send_header DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_send_u16 DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_send_u32 DD 010801H
	DD	04208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$decode_varint DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_properties_length DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_props_size DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_send_mqtt_properties DD 081301H
	DD	0c3413H
	DD	0e00c5213H
	DD	07008d00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_mqtt_next_prop DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_mqtt_login DD 0a1701H
	DD	0143417H
	DD	0f0109217H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_mqtt_pub DD 0a1601H
	DD	0e5416H
	DD	0d3416H
	DD	0f0125216H
	DD	0d00ee010H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_mqtt_sub DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_mqtt_parse DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mqtt_cb DD 082101H
	DD	0166421H
	DD	0143421H
	DD	0f017f221H
	DD	050147015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_mqtt_disconnect DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_mqtt_connect DD 050d01H
	DD	016340dH
	DD	014010dH
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_mqtt_listen DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_vprintf DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_printf DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_atonl DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_v4mapped DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_aton6 DD 0c1c01H
	DD	0e641cH
	DD	0d541cH
	DD	0c341cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_aton DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_alloc_conn DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0b9H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_close_conn DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_connect DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_listen DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_wrapfd DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_timer_add DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_io_recv DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_mgr_free DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_mgr_init DD 030901H
	DD	0380109H
	DD	03002H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05dH
	DB	067H
	DB	06cH
	DB	077H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_queue_vprintf DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_queue_printf DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_pfn_iobuf_private DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_vsnprintf DD 040c01H
	DD	0a340cH
	DD	07008720cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_snprintf DD 010f01H
	DD	0620fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_vmprintf DD 010701H
	DD	08207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_mprintf DD 011701H
	DD	06217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$print_ip4 DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$print_ip6 DD 0a1e01H
	DD	016341eH
	DD	0f01ab21eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_print_ip_port DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_print_mac DD 040a01H
	DD	0c340aH
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$qcpy DD	0c1d01H
	DD	0b741dH
	DD	0a641dH
	DD	09541dH
	DD	08341dH
	DD	0f019321dH
	DD	0c015e017H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bcpy DD	0a1901H
	DD	0f3419H
	DD	0f0155219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_print_hex DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	07H
	DB	0fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	0bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05H
	DB	0cH
	DB	01dH
	DB	031H
	DB	041H
	DB	045H
	DB	04eH
	DB	058H
	DB	062H
	DB	066H
	DB	06aH
	DB	06eH
	DB	07eH
	DB	082H
	DB	092H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_queue_book DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	07H
	DB	018H
	DB	01cH
	DB	02cH
	DB	030H
	DB	034H
	DB	03dH
	DB	041H
	DB	051H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	0bH
	DB	010H
	DB	01bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	0bH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_rpc_add DD 0a1901H
	DD	0d7419H
	DD	0c6419H
	DD	0b5419H
	DD	0a3419H
	DD	0e0157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_rpc_del DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_rpc_call DD 060f01H
	DD	0d640fH
	DD	0c340fH
	DD	0700b920fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_rpc_process DD 040d01H
	DD	0b340dH
	DD	05006720dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_rpc_vok DD 061001H
	DD	0126410H
	DD	0113410H
	DD	0700cd210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_rpc_ok DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_rpc_verr DD 0a1b01H
	DD	017641bH
	DD	016541bH
	DD	015341bH
	DD	0e014f21bH
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_rpc_err DD 010f01H
	DD	0620fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$print_methods DD 0a1901H
	DD	0d7419H
	DD	0c6419H
	DD	0b5419H
	DD	0a3419H
	DD	0e0157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_sha1_transform DD 091501H
	DD	0f0118215H
	DD	0d00de00fH
	DD	07009c00bH
	DD	050076008H
	DD	03006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_sha1_update DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_sha1_final DD 060c01H
	DD	08340cH
	DD	07008320cH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_sha256_chunk DD 0a1401H
	DD	0230114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_sha256_update DD 081901H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	070153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_sha256_final DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_hmac_sha256 DD 0b1f01H
	DD	030741fH
	DD	02f641fH
	DD	02e341fH
	DD	02a011fH
	DD	0c012e014H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_sntp_parse DD 0a1901H
	DD	0b7419H
	DD	0a6419H
	DD	095419H
	DD	083419H
	DD	0e0155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sntp_cb DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_sntp_request DD 020601H
	DD	030029206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_sntp_connect DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setlocaddr DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iolog DD 061e01H
	DD	0f641eH
	DD	0e341eH
	DD	0701ab21eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_io_send DD 040c01H
	DD	0a340cH
	DD	07008720cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_send DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_set_non_blocking_mode DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_open_listener DD 0c1c01H
	DD	013641cH
	DD	012541cH
	DD	011341cH
	DD	0f018921cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recv_raw DD 020801H
	DD	030047208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ioalloc DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$read_conn DD 0a1901H
	DD	0f7419H
	DD	0e6419H
	DD	0d5419H
	DD	0c3419H
	DD	0e0159219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$write_conn DD 081401H
	DD	0e6414H
	DD	0d5414H
	DD	0c3414H
	DD	070109214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$close_conn DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$connect_conn DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setsockopts DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_connect_resolved DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$raccept DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$accept_conn DD 081401H
	DD	0106414H
	DD	0e3414H
	DD	0f0109214H
	DD	0700ce00eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_iotest DD 091d01H
	DD	0d2641dH
	DD	0d1341dH
	DD	0cc011dH
	DD	0700ce00eH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_socketpair DD 0a1801H
	DD	0b6418H
	DD	0a5418H
	DD	093418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wufn DD	060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_wakeup_init DD 061001H
	DD	0d6410H
	DD	0c3410H
	DD	0700c9210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_wakeup DD 025091f01H
	DD	08741fH
	DD	076418H
	DD	063414H
	DD	03206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_mgr_poll DD 060c01H
	DD	0f340cH
	DD	07008920cH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_ncasecmp DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_vcmp DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_vcasecmp DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_strdup DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_strstr DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_match DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_globmatch DD 010701H
	DD	08207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_split DD 081701H
	DD	0117417H
	DD	0106417H
	DD	0f3417H
	DD	05010b217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_unhex DD 081901H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	070153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_timer_poll DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_url_is_ssl DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_url_host DD 030901H
	DD	0120109H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_url_uri DD 020701H
	DD	0130107H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_url_port DD 071201H
	DD	0156412H
	DD	0143412H
	DD	0120112H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_url_user DD 030901H
	DD	0140109H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_url_pass DD 030901H
	DD	0140109H
	DD	03002H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0aH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_random DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_random_str DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parse_net DD 0a1b01H
	DD	012741bH
	DD	011641bH
	DD	010341bH
	DD	0f014b21bH
	DD	05010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_check_ip_acl DD 081201H
	DD	0f5412H
	DD	0e3412H
	DD	0e00e7212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_millis DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_ws_vprintf DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_ws_printf DD 010f01H
	DD	0620fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ws_handshake DD 0b1f01H
	DD	01de41fH
	DD	01c741fH
	DD	01b641fH
	DD	01a341fH
	DD	018011fH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ws_process DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mkhdr DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_ws_send DD 081501H
	DD	0a7415H
	DD	096415H
	DD	083415H
	DD	0e0115215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_ws_client_handshake DD 091801H
	DD	08e7418H
	DD	08d6418H
	DD	08c3418H
	DD	08a0118H
	DD	0e011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_ws_cb DD 0a2001H
	DD	0143420H
	DD	0f0199220H
	DD	0d015e017H
	DD	07011c013H
	DD	0500f6010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_ws_connect DD 060c01H
	DD	011010cH
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_ws_upgrade DD 051201H
	DD	0700e8212H
	DD	0500c600dH
	DD	0300bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mg_ws_wrap DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 83   :     static unsigned __int64 _OptionsStorage;
; 84   :     return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 85   : }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$dead$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2166 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	49 8b d9	 mov	 rbx, r9
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b f1	 mov	 rsi, rcx

; 2167 :     return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx
  00022	4c 8b cf	 mov	 r9, rdi
  00025	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0002b	49 83 c8 ff	 or	 r8, -1
  0002f	48 8b d6	 mov	 rdx, rsi
  00032	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2168 :         _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2169 :         _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2170 : }

  0003b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00040	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00045	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00049	5f		 pop	 rdi
  0004a	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Buffer$ = 80
_Format$ = 88
sscanf	PROC						; COMDAT

; 2261 : {

$LN6:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  00007	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000b	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  0000f	53		 push	 rbx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00016	48 8b da	 mov	 rbx, rdx

; 2262 :     int _Result;
; 2263 :     va_list _ArgList;
; 2264 :     __crt_va_start(_ArgList, _Format);

  00019	48 8d 70 18	 lea	 rsi, QWORD PTR [rax+24]
  0001d	48 8b f9	 mov	 rdi, rcx

; 2167 :     return __stdio_common_vsscanf(

  00020	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  00025	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  0002a	4c 8b cb	 mov	 r9, rbx
  0002d	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00033	49 83 c8 ff	 or	 r8, -1
  00037	48 8b d7	 mov	 rdx, rdi
  0003a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2265 :     _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);
; 2266 :     __crt_va_end(_ArgList);
; 2267 :     return _Result;
; 2268 : }

  00043	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00047	5f		 pop	 rdi
  00048	5e		 pop	 rsi
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_base64_encode_single
_TEXT	SEGMENT
c$ = 8
mg_base64_encode_single PROC				; COMDAT

; 28   :   if (c < 26) {

  00000	83 f9 1a	 cmp	 ecx, 26
  00003	7d 04		 jge	 SHORT $LN2@mg_base64_

; 29   :     return c + 'A';

  00005	8d 41 41	 lea	 eax, DWORD PTR [rcx+65]

; 36   :   }
; 37   : }

  00008	c3		 ret	 0
$LN2@mg_base64_:

; 30   :   } else if (c < 52) {

  00009	83 f9 34	 cmp	 ecx, 52			; 00000034H
  0000c	7d 04		 jge	 SHORT $LN4@mg_base64_

; 31   :     return c - 26 + 'a';

  0000e	8d 41 47	 lea	 eax, DWORD PTR [rcx+71]

; 36   :   }
; 37   : }

  00011	c3		 ret	 0
$LN4@mg_base64_:

; 32   :   } else if (c < 62) {

  00012	83 f9 3e	 cmp	 ecx, 62			; 0000003eH
  00015	7d 04		 jge	 SHORT $LN6@mg_base64_

; 33   :     return c - 52 + '0';

  00017	8d 41 fc	 lea	 eax, DWORD PTR [rcx-4]

; 36   :   }
; 37   : }

  0001a	c3		 ret	 0
$LN6@mg_base64_:

; 34   :   } else {
; 35   :     return c == 62 ? '+' : '/';

  0001b	b8 2f 00 00 00	 mov	 eax, 47			; 0000002fH
  00020	8d 50 fc	 lea	 edx, QWORD PTR [rax-4]
  00023	0f 44 c2	 cmove	 eax, edx

; 36   :   }
; 37   : }

  00026	c3		 ret	 0
mg_base64_encode_single ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_base64_decode_single
_TEXT	SEGMENT
c$ = 8
mg_base64_decode_single PROC				; COMDAT

; 40   :   if (c >= 'A' && c <= 'Z') {

  00000	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  00003	83 f8 19	 cmp	 eax, 25
  00006	76 36		 jbe	 SHORT $LN13@mg_base64_

; 41   :     return c - 'A';
; 42   :   } else if (c >= 'a' && c <= 'z') {

  00008	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  0000b	83 f8 19	 cmp	 eax, 25
  0000e	77 04		 ja	 SHORT $LN4@mg_base64_

; 43   :     return c + 26 - 'a';

  00010	8d 41 b9	 lea	 eax, DWORD PTR [rcx-71]

; 51   :     return 64;
; 52   :   } else {
; 53   :     return -1;
; 54   :   }
; 55   : }

  00013	c3		 ret	 0
$LN4@mg_base64_:

; 44   :   } else if (c >= '0' && c <= '9') {

  00014	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  00017	83 f8 09	 cmp	 eax, 9
  0001a	77 04		 ja	 SHORT $LN6@mg_base64_

; 45   :     return c + 52 - '0';

  0001c	8d 41 04	 lea	 eax, DWORD PTR [rcx+4]

; 51   :     return 64;
; 52   :   } else {
; 53   :     return -1;
; 54   :   }
; 55   : }

  0001f	c3		 ret	 0
$LN6@mg_base64_:

; 46   :   } else if (c == '+') {

  00020	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  00023	75 04		 jne	 SHORT $LN8@mg_base64_

; 47   :     return 62;

  00025	8d 41 13	 lea	 eax, QWORD PTR [rcx+19]

; 51   :     return 64;
; 52   :   } else {
; 53   :     return -1;
; 54   :   }
; 55   : }

  00028	c3		 ret	 0
$LN8@mg_base64_:

; 48   :   } else if (c == '/') {

  00029	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  0002c	75 04		 jne	 SHORT $LN10@mg_base64_

; 49   :     return 63;

  0002e	8d 41 10	 lea	 eax, QWORD PTR [rcx+16]

; 51   :     return 64;
; 52   :   } else {
; 53   :     return -1;
; 54   :   }
; 55   : }

  00031	c3		 ret	 0
$LN10@mg_base64_:

; 50   :   } else if (c == '=') {

  00032	83 c8 ff	 or	 eax, -1
  00035	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  00038	8d 50 41	 lea	 edx, QWORD PTR [rax+65]
  0003b	0f 44 c2	 cmove	 eax, edx
$LN13@mg_base64_:

; 51   :     return 64;
; 52   :   } else {
; 53   :     return -1;
; 54   :   }
; 55   : }

  0003e	c3		 ret	 0
mg_base64_decode_single ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_base64_update
_TEXT	SEGMENT
ch$ = 48
to$ = 56
n$ = 64
mg_base64_update PROC					; COMDAT

; 57   : size_t mg_base64_update(unsigned char ch, char *to, size_t n) {

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	44 0f b6 c9	 movzx	 r9d, cl
  0000a	4c 8b d2	 mov	 r10, rdx

; 58   :   unsigned long rem = (n & 3) % 3;

  0000d	49 8b c8	 mov	 rcx, r8
  00010	4d 8b d8	 mov	 r11, r8
  00013	83 e1 03	 and	 ecx, 3
  00016	48 b8 ab aa aa
	aa aa aa aa aa	 mov	 rax, -6148914691236517205 ; aaaaaaaaaaaaaaabH
  00020	48 f7 e1	 mul	 rcx
  00023	45 8b c1	 mov	 r8d, r9d
  00026	49 8d 5b 01	 lea	 rbx, QWORD PTR [r11+1]
  0002a	48 d1 ea	 shr	 rdx, 1
  0002d	48 8d 04 52	 lea	 rax, QWORD PTR [rdx+rdx*2]
  00031	48 2b c8	 sub	 rcx, rax

; 59   :   if (rem == 0) {

  00034	85 c9		 test	 ecx, ecx
  00036	75 1d		 jne	 SHORT $LN2@mg_base64_

; 60   :     to[n] = (char) mg_base64_encode_single(ch >> 2);

  00038	41 c1 e8 02	 shr	 r8d, 2
  0003c	41 8b c8	 mov	 ecx, r8d
  0003f	e8 00 00 00 00	 call	 mg_base64_encode_single

; 61   :     to[++n] = (char) ((ch & 3) << 4);

  00044	41 80 e1 03	 and	 r9b, 3
  00048	43 88 04 1a	 mov	 BYTE PTR [r10+r11], al
  0004c	4c 8b db	 mov	 r11, rbx
  0004f	41 c0 e1 04	 shl	 r9b, 4
  00053	eb 50		 jmp	 SHORT $LN5@mg_base64_
$LN2@mg_base64_:

; 62   :   } else if (rem == 1) {

  00055	83 f9 01	 cmp	 ecx, 1
  00058	75 22		 jne	 SHORT $LN4@mg_base64_

; 63   :     to[n] = (char) mg_base64_encode_single(to[n] | (ch >> 4));

  0005a	43 0f be 0c 1a	 movsx	 ecx, BYTE PTR [r10+r11]
  0005f	41 c1 e8 04	 shr	 r8d, 4
  00063	41 0b c8	 or	 ecx, r8d
  00066	e8 00 00 00 00	 call	 mg_base64_encode_single

; 64   :     to[++n] = (char) ((ch & 15) << 2);

  0006b	41 80 e1 0f	 and	 r9b, 15
  0006f	43 88 04 1a	 mov	 BYTE PTR [r10+r11], al
  00073	4c 8b db	 mov	 r11, rbx
  00076	41 c0 e1 02	 shl	 r9b, 2

; 65   :   } else {

  0007a	eb 29		 jmp	 SHORT $LN5@mg_base64_
$LN4@mg_base64_:

; 66   :     to[n] = (char) mg_base64_encode_single(to[n] | (ch >> 6));

  0007c	43 0f be 04 1a	 movsx	 eax, BYTE PTR [r10+r11]
  00081	41 8b c8	 mov	 ecx, r8d
  00084	c1 e9 06	 shr	 ecx, 6
  00087	0b c8		 or	 ecx, eax
  00089	e8 00 00 00 00	 call	 mg_base64_encode_single

; 67   :     to[++n] = (char) mg_base64_encode_single(ch & 63);

  0008e	41 83 e0 3f	 and	 r8d, 63			; 0000003fH
  00092	43 88 04 1a	 mov	 BYTE PTR [r10+r11], al
  00096	41 8b c8	 mov	 ecx, r8d

; 68   :     n++;

  00099	4c 8d 5b 01	 lea	 r11, QWORD PTR [rbx+1]
  0009d	e8 00 00 00 00	 call	 mg_base64_encode_single
  000a2	44 8b c8	 mov	 r9d, eax
$LN5@mg_base64_:

; 69   :   }
; 70   :   return n;

  000a5	46 88 0c 13	 mov	 BYTE PTR [rbx+r10], r9b
  000a9	49 8b c3	 mov	 rax, r11

; 71   : }

  000ac	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b0	5b		 pop	 rbx
  000b1	c3		 ret	 0
mg_base64_update ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_base64_final
_TEXT	SEGMENT
to$ = 48
n$ = 56
mg_base64_final PROC					; COMDAT

; 73   : size_t mg_base64_final(char *to, size_t n) {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 74   :   size_t saved = n;
; 75   :   // printf("---[%.*s]\n", n, to);
; 76   :   if (n & 3) n = mg_base64_update(0, to, n);

  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	83 e7 03	 and	 edi, 3
  00013	74 10		 je	 SHORT $LN4@mg_base64_
  00015	4c 8b c2	 mov	 r8, rdx
  00018	48 8b d1	 mov	 rdx, rcx
  0001b	33 c9		 xor	 ecx, ecx
  0001d	e8 00 00 00 00	 call	 mg_base64_update
  00022	48 8b d0	 mov	 rdx, rax
$LN4@mg_base64_:

; 77   :   if ((saved & 3) == 2) n--;
; 78   :   // printf("    %d[%.*s]\n", n, n, to);
; 79   :   while (n & 3) to[n++] = '=';

  00025	48 83 ff 02	 cmp	 rdi, 2
  00029	48 8d 42 ff	 lea	 rax, QWORD PTR [rdx-1]
  0002d	48 0f 45 c2	 cmovne	 rax, rdx
  00031	eb 07		 jmp	 SHORT $LN11@mg_base64_
$LL2@mg_base64_:
  00033	c6 04 03 3d	 mov	 BYTE PTR [rbx+rax], 61	; 0000003dH
  00037	48 ff c0	 inc	 rax
$LN11@mg_base64_:
  0003a	a8 03		 test	 al, 3
  0003c	75 f5		 jne	 SHORT $LL2@mg_base64_

; 80   :   to[n] = '\0';

  0003e	c6 04 03 00	 mov	 BYTE PTR [rbx+rax], 0

; 81   :   return n;
; 82   : }

  00042	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
mg_base64_final ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_base64_encode
_TEXT	SEGMENT
p$ = 48
n$ = 56
to$ = 64
dl$dead$ = 72
mg_base64_encode PROC					; COMDAT

; 84   : size_t mg_base64_encode(const unsigned char *p, size_t n, char *to, size_t dl) {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fa	 mov	 rdi, rdx
  00017	49 8b f0	 mov	 rsi, r8

; 85   :   size_t i, len = 0;

  0001a	45 33 c0	 xor	 r8d, r8d

; 86   :   if (dl > 0) to[0] = '\0';
; 87   :   if (dl < ((n / 3) + (n % 3 ? 1 : 0)) * 4 + 1) return 0;

  0001d	48 b8 ab aa aa
	aa aa aa aa aa	 mov	 rax, -6148914691236517205 ; aaaaaaaaaaaaaaabH
  00027	48 f7 e2	 mul	 rdx
  0002a	45 8b c8	 mov	 r9d, r8d
  0002d	48 8b e9	 mov	 rbp, rcx
  00030	44 88 06	 mov	 BYTE PTR [rsi], r8b
  00033	48 d1 ea	 shr	 rdx, 1
  00036	48 8d 04 52	 lea	 rax, QWORD PTR [rdx+rdx*2]
  0003a	48 3b f8	 cmp	 rdi, rax
  0003d	41 0f 95 c1	 setne	 r9b
  00041	4c 03 ca	 add	 r9, rdx
  00044	4a 8d 04 8d 01
	00 00 00	 lea	 rax, QWORD PTR [r9*4+1]
  0004c	48 83 f8 1e	 cmp	 rax, 30
  00050	76 04		 jbe	 SHORT $LN6@mg_base64_
  00052	33 c0		 xor	 eax, eax
  00054	eb 29		 jmp	 SHORT $LN1@mg_base64_
$LN6@mg_base64_:

; 88   :   for (i = 0; i < n; i++) len = mg_base64_update(p[i], to, len);

  00056	49 8b d8	 mov	 rbx, r8
  00059	48 85 ff	 test	 rdi, rdi
  0005c	74 16		 je	 SHORT $LN3@mg_base64_
$LL4@mg_base64_:
  0005e	8a 0c 2b	 mov	 cl, BYTE PTR [rbx+rbp]
  00061	48 8b d6	 mov	 rdx, rsi
  00064	e8 00 00 00 00	 call	 mg_base64_update
  00069	48 ff c3	 inc	 rbx
  0006c	4c 8b c0	 mov	 r8, rax
  0006f	48 3b df	 cmp	 rbx, rdi
  00072	72 ea		 jb	 SHORT $LL4@mg_base64_
$LN3@mg_base64_:

; 89   :   len = mg_base64_final(to, len);

  00074	49 8b d0	 mov	 rdx, r8
  00077	48 8b ce	 mov	 rcx, rsi
  0007a	e8 00 00 00 00	 call	 mg_base64_final
$LN1@mg_base64_:

; 90   :   return len;
; 91   : }

  0007f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00084	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00089	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0008e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00092	5f		 pop	 rdi
  00093	c3		 ret	 0
mg_base64_encode ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_base64_decode
_TEXT	SEGMENT
src$ = 48
n$ = 56
dst$ = 64
dl$ = 72
mg_base64_decode PROC					; COMDAT

; 93   : size_t mg_base64_decode(const char *src, size_t n, char *dst, size_t dl) {

$LN19:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 94   :   const char *end = src == NULL ? NULL : src + n;  // Cannot add to NULL

  00014	4c 8d 14 11	 lea	 r10, QWORD PTR [rcx+rdx]
  00018	48 8b c1	 mov	 rax, rcx
  0001b	48 f7 d8	 neg	 rax
  0001e	49 8b e9	 mov	 rbp, r9
  00021	4d 8b d8	 mov	 r11, r8
  00024	48 1b f6	 sbb	 rsi, rsi

; 95   :   size_t len = 0;
; 96   :   if (dl < n / 4 * 3 + 1) goto fail;

  00027	48 c1 ea 02	 shr	 rdx, 2
  0002b	49 23 f2	 and	 rsi, r10
  0002e	45 33 d2	 xor	 r10d, r10d
  00031	48 8d 04 55 01
	00 00 00	 lea	 rax, QWORD PTR [rdx*2+1]
  00039	48 03 c2	 add	 rax, rdx
  0003c	4c 3b c8	 cmp	 r9, rax
  0003f	0f 82 bc 00 00
	00		 jb	 $fail$20

; 97   :   while (src != NULL && src + 3 < end) {

  00045	48 85 c9	 test	 rcx, rcx
  00048	0f 84 a9 00 00
	00		 je	 $LN3@mg_base64_
  0004e	4c 8d 41 03	 lea	 r8, QWORD PTR [rcx+3]
$LL2@mg_base64_:
  00052	4c 3b c6	 cmp	 r8, rsi
  00055	0f 83 9c 00 00
	00		 jae	 $LN3@mg_base64_

; 98   :     int a = mg_base64_decode_single(src[0]),

  0005b	41 0f be 48 fd	 movsx	 ecx, BYTE PTR [r8-3]
  00060	e8 00 00 00 00	 call	 mg_base64_decode_single

; 99   :         b = mg_base64_decode_single(src[1]),

  00065	41 0f be 48 fe	 movsx	 ecx, BYTE PTR [r8-2]
  0006a	8b f8		 mov	 edi, eax
  0006c	e8 00 00 00 00	 call	 mg_base64_decode_single

; 100  :         c = mg_base64_decode_single(src[2]),

  00071	41 0f be 48 ff	 movsx	 ecx, BYTE PTR [r8-1]
  00076	8b d8		 mov	 ebx, eax
  00078	e8 00 00 00 00	 call	 mg_base64_decode_single

; 101  :         d = mg_base64_decode_single(src[3]);

  0007d	41 0f be 08	 movsx	 ecx, BYTE PTR [r8]
  00081	44 8b c8	 mov	 r9d, eax
  00084	e8 00 00 00 00	 call	 mg_base64_decode_single
  00089	8b c8		 mov	 ecx, eax

; 102  :     if (a == 64 || a < 0 || b == 64 || b < 0 || c < 0 || d < 0) {

  0008b	85 ff		 test	 edi, edi
  0008d	78 72		 js	 SHORT $fail$20
  0008f	83 ff 40	 cmp	 edi, 64			; 00000040H
  00092	74 6d		 je	 SHORT $fail$20
  00094	85 db		 test	 ebx, ebx
  00096	78 69		 js	 SHORT $fail$20
  00098	83 fb 40	 cmp	 ebx, 64			; 00000040H
  0009b	74 64		 je	 SHORT $fail$20
  0009d	45 85 c9	 test	 r9d, r9d
  000a0	78 5f		 js	 SHORT $fail$20
  000a2	85 c0		 test	 eax, eax
  000a4	78 5b		 js	 SHORT $fail$20

; 103  :       goto fail;
; 104  :     }
; 105  :     dst[len++] = (char) ((a << 2) | (b >> 4));

  000a6	40 c0 e7 02	 shl	 dil, 2
  000aa	8b c3		 mov	 eax, ebx
  000ac	c1 f8 04	 sar	 eax, 4
  000af	40 0a c7	 or	 al, dil
  000b2	43 88 04 1a	 mov	 BYTE PTR [r10+r11], al
  000b6	49 ff c2	 inc	 r10

; 106  :     if (src[2] != '=') {

  000b9	41 80 78 ff 3d	 cmp	 BYTE PTR [r8-1], 61	; 0000003dH
  000be	74 26		 je	 SHORT $LN8@mg_base64_

; 107  :       dst[len++] = (char) ((b << 4) | (c >> 2));

  000c0	c0 e3 04	 shl	 bl, 4
  000c3	41 8b c1	 mov	 eax, r9d
  000c6	c1 f8 02	 sar	 eax, 2
  000c9	0a c3		 or	 al, bl
  000cb	43 88 04 1a	 mov	 BYTE PTR [r10+r11], al
  000cf	49 ff c2	 inc	 r10

; 108  :       if (src[3] != '=') dst[len++] = (char) ((c << 6) | d);

  000d2	41 80 38 3d	 cmp	 BYTE PTR [r8], 61	; 0000003dH
  000d6	74 0e		 je	 SHORT $LN8@mg_base64_
  000d8	41 c0 e1 06	 shl	 r9b, 6
  000dc	44 0a c9	 or	 r9b, cl
  000df	47 88 0c 1a	 mov	 BYTE PTR [r10+r11], r9b
  000e3	49 ff c2	 inc	 r10
$LN8@mg_base64_:

; 109  :     }
; 110  :     src += 4;

  000e6	49 83 c0 04	 add	 r8, 4
  000ea	49 8d 48 fd	 lea	 rcx, QWORD PTR [r8-3]
  000ee	48 85 c9	 test	 rcx, rcx
  000f1	0f 85 5b ff ff
	ff		 jne	 $LL2@mg_base64_
$LN3@mg_base64_:

; 111  :   }
; 112  :   dst[len] = '\0';

  000f7	43 c6 04 1a 00	 mov	 BYTE PTR [r10+r11], 0

; 113  :   return len;

  000fc	49 8b c2	 mov	 rax, r10
  000ff	eb 0b		 jmp	 SHORT $LN1@mg_base64_
$fail$20:

; 114  : fail:
; 115  :   if (dl > 0) dst[0] = '\0';

  00101	48 85 ed	 test	 rbp, rbp
  00104	74 04		 je	 SHORT $LN9@mg_base64_
  00106	41 c6 03 00	 mov	 BYTE PTR [r11], 0
$LN9@mg_base64_:

; 116  :   return 0;

  0010a	33 c0		 xor	 eax, eax
$LN1@mg_base64_:

; 117  : }

  0010c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00111	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00116	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0011b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011f	5f		 pop	 rdi
  00120	c3		 ret	 0
mg_base64_decode ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_flash_start
_TEXT	SEGMENT
mg_flash_start PROC					; COMDAT

; 208  :   return NULL;

  00000	33 c0		 xor	 eax, eax

; 209  : }

  00002	c3		 ret	 0
mg_flash_start ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_flash_size
_TEXT	SEGMENT
mg_flash_size PROC					; COMDAT

; 211  :   return 0;

  00000	33 c0		 xor	 eax, eax

; 212  : }

  00002	c3		 ret	 0
mg_flash_size ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_flash_sector_size
_TEXT	SEGMENT
mg_flash_sector_size PROC				; COMDAT

; 214  :   return 0;

  00000	33 c0		 xor	 eax, eax

; 215  : }

  00002	c3		 ret	 0
mg_flash_sector_size ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_flash_write_align
_TEXT	SEGMENT
mg_flash_write_align PROC				; COMDAT

; 217  :   return 0;

  00000	33 c0		 xor	 eax, eax

; 218  : }

  00002	c3		 ret	 0
mg_flash_write_align ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_flash_bank
_TEXT	SEGMENT
mg_flash_bank PROC					; COMDAT

; 220  :   return 0;

  00000	33 c0		 xor	 eax, eax

; 221  : }

  00002	c3		 ret	 0
mg_flash_bank ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_flash_erase
_TEXT	SEGMENT
location$dead$ = 8
mg_flash_erase PROC					; COMDAT

; 223  :   (void) location;
; 224  :   return false;

  00000	32 c0		 xor	 al, al

; 225  : }

  00002	c3		 ret	 0
mg_flash_erase ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_flash_swap_bank
_TEXT	SEGMENT
mg_flash_swap_bank PROC					; COMDAT

; 227  :   return true;

  00000	b0 01		 mov	 al, 1

; 228  : }

  00002	c3		 ret	 0
mg_flash_swap_bank ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_flash_write
_TEXT	SEGMENT
addr$dead$ = 8
buf$dead$ = 16
len$dead$ = 24
mg_flash_write PROC					; COMDAT

; 230  :   (void) addr, (void) buf, (void) len;
; 231  :   return false;

  00000	32 c0		 xor	 al, al

; 232  : }

  00002	c3		 ret	 0
mg_flash_write ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_device_reset
_TEXT	SEGMENT
mg_device_reset PROC					; COMDAT

; 234  : }

  00000	c2 00 00	 ret	 0
mg_device_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_flash_save
_TEXT	SEGMENT
sector$dead$ = 8
key$dead$ = 16
buf$dead$ = 24
len$dead$ = 32
mg_flash_save PROC					; COMDAT

; 404  :   (void) sector, (void) key, (void) buf, (void) len;
; 405  :   return false;

  00000	32 c0		 xor	 al, al

; 406  : }

  00002	c3		 ret	 0
mg_flash_save ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_flash_load
_TEXT	SEGMENT
sector$dead$ = 8
key$dead$ = 16
buf$dead$ = 24
len$dead$ = 32
mg_flash_load PROC					; COMDAT

; 408  :   (void) sector, (void) key, (void) buf, (void) len;
; 409  :   return false;

  00000	32 c0		 xor	 al, al

; 410  : }

  00002	c3		 ret	 0
mg_flash_load ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_dns_free
_TEXT	SEGMENT
head$ = 8
d$ = 16
mg_dns_free PROC					; COMDAT

; 1082 :   LIST_DELETE(struct dns_data, head, d);

  00000	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00003	4c 3b c2	 cmp	 r8, rdx
  00006	74 0e		 je	 SHORT $LN6@mg_dns_fre
$LL5@mg_dns_fre:
  00008	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0000b	49 8b c8	 mov	 rcx, r8
  0000e	4c 8b c0	 mov	 r8, rax
  00011	48 3b c2	 cmp	 rax, rdx
  00014	75 f2		 jne	 SHORT $LL5@mg_dns_fre
$LN6@mg_dns_fre:
  00016	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00019	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1083 :   free(d);

  0001c	48 8b ca	 mov	 rcx, rdx
  0001f	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_free
mg_dns_free ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_resolve_cancel
_TEXT	SEGMENT
c$ = 48
mg_resolve_cancel PROC					; COMDAT

; 1086 : void mg_resolve_cancel(struct mg_connection *c) {

$LN23:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1087 :   struct dns_data *tmp, *d;
; 1088 :   struct dns_data **head = (struct dns_data **) &c->mgr->active_dns_requests;

  0000f	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  00013	48 8b f1	 mov	 rsi, rcx

; 1089 :   for (d = *head; d != NULL; d = tmp) {

  00016	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  0001a	48 85 c9	 test	 rcx, rcx
  0001d	74 35		 je	 SHORT $LN3@mg_resolve
$LL4@mg_resolve:

; 1090 :     tmp = d->next;

  0001f	48 8b 39	 mov	 rdi, QWORD PTR [rcx]

; 1091 :     if (d->c == c) mg_dns_free(head, d);

  00022	48 39 71 08	 cmp	 QWORD PTR [rcx+8], rsi
  00026	75 24		 jne	 SHORT $LN2@mg_resolve

; 1082 :   LIST_DELETE(struct dns_data, head, d);

  00028	48 8b 53 50	 mov	 rdx, QWORD PTR [rbx+80]
  0002c	4c 8d 43 50	 lea	 r8, QWORD PTR [rbx+80]
  00030	48 3b d1	 cmp	 rdx, rcx
  00033	74 0e		 je	 SHORT $LN12@mg_resolve
$LL11@mg_resolve:
  00035	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00038	4c 8b c2	 mov	 r8, rdx
  0003b	48 8b d0	 mov	 rdx, rax
  0003e	48 3b c1	 cmp	 rax, rcx
  00041	75 f2		 jne	 SHORT $LL11@mg_resolve
$LN12@mg_resolve:
  00043	49 89 38	 mov	 QWORD PTR [r8], rdi

; 1083 :   free(d);

  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@mg_resolve:

; 1089 :   for (d = *head; d != NULL; d = tmp) {

  0004c	48 8b cf	 mov	 rcx, rdi
  0004f	48 85 ff	 test	 rdi, rdi
  00052	75 cb		 jne	 SHORT $LL4@mg_resolve
$LN3@mg_resolve:

; 1092 :   }
; 1093 : }

  00054	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00059	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5f		 pop	 rdi
  00063	c3		 ret	 0
mg_resolve_cancel ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_dns_parse_name_depth
_TEXT	SEGMENT
s$ = 112
len$ = 120
ofs$ = 128
to$ = 136
tolen$ = 144
j$ = 152
depth$ = 160
mg_dns_parse_name_depth PROC				; COMDAT

; 1097 :                                       int depth) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1098 :   size_t i = 0;
; 1099 :   if (tolen > 0 && depth == 0) to[0] = '\0';

  0001c	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR tolen$[rsp]
  00024	33 db		 xor	 ebx, ebx
  00026	44 8b bc 24 a0
	00 00 00	 mov	 r15d, DWORD PTR depth$[rsp]
  0002e	49 8b f1	 mov	 rsi, r9
  00031	49 8b e8	 mov	 rbp, r8
  00034	4c 8b f2	 mov	 r14, rdx
  00037	4c 8b e1	 mov	 r12, rcx
  0003a	48 85 ff	 test	 rdi, rdi
  0003d	74 0a		 je	 SHORT $LN4@mg_dns_par
  0003f	45 85 ff	 test	 r15d, r15d
  00042	75 05		 jne	 SHORT $LN4@mg_dns_par
  00044	41 88 19	 mov	 BYTE PTR [r9], bl

; 1121 :     }
; 1122 :     if (j + n < tolen) memcpy(&to[j], &s[ofs + i + 1], n);

  00047	eb 0a		 jmp	 SHORT $LN16@mg_dns_par
$LN4@mg_dns_par:

; 1100 :   if (depth > 5) return 0;

  00049	41 83 ff 05	 cmp	 r15d, 5
  0004d	0f 8f e7 00 00
	00		 jg	 $LN19@mg_dns_par
$LN16@mg_dns_par:

; 1101 :   // MG_INFO(("ofs %lx %x %x", (unsigned long) ofs, s[ofs], s[ofs + 1]));
; 1102 :   while (ofs + i + 1 < len) {

  00053	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]
  00057	49 3b c6	 cmp	 rax, r14
  0005a	0f 83 cb 00 00
	00		 jae	 $LN3@mg_dns_par
  00060	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
$LL2@mg_dns_par:

; 1103 :     size_t n = s[ofs + i];

  00068	4a 8d 14 23	 lea	 rdx, QWORD PTR [rbx+r12]
  0006c	44 0f b6 04 2a	 movzx	 r8d, BYTE PTR [rdx+rbp]

; 1104 :     if (n == 0) {

  00071	4d 85 c0	 test	 r8, r8
  00074	0f 84 ae 00 00
	00		 je	 $LN17@mg_dns_par

; 1106 :       break;
; 1107 :     }
; 1108 :     if (n & 0xc0) {

  0007a	41 f6 c0 c0	 test	 r8b, 192		; 000000c0H
  0007e	75 5a		 jne	 SHORT $LN18@mg_dns_par

; 1116 :     }
; 1117 :     if (ofs + i + n + 1 >= len) return 0;

  00080	4d 8d 2c 18	 lea	 r13, QWORD PTR [r8+rbx]
  00084	48 8d 45 01	 lea	 rax, QWORD PTR [rbp+1]
  00088	49 03 c5	 add	 rax, r13
  0008b	49 3b c6	 cmp	 rax, r14
  0008e	0f 83 a6 00 00
	00		 jae	 $LN19@mg_dns_par

; 1118 :     if (j > 0) {

  00094	48 85 c9	 test	 rcx, rcx
  00097	74 0c		 je	 SHORT $LN10@mg_dns_par

; 1119 :       if (j < tolen) to[j] = '.';

  00099	48 3b cf	 cmp	 rcx, rdi
  0009c	73 04		 jae	 SHORT $LN11@mg_dns_par
  0009e	c6 04 0e 2e	 mov	 BYTE PTR [rsi+rcx], 46	; 0000002eH
$LN11@mg_dns_par:

; 1120 :       j++;

  000a2	48 ff c1	 inc	 rcx
$LN10@mg_dns_par:

; 1121 :     }
; 1122 :     if (j + n < tolen) memcpy(&to[j], &s[ofs + i + 1], n);

  000a5	49 8d 1c 08	 lea	 rbx, QWORD PTR [r8+rcx]
  000a9	48 3b df	 cmp	 rbx, rdi
  000ac	73 0e		 jae	 SHORT $LN22@mg_dns_par
  000ae	48 ff c2	 inc	 rdx
  000b1	48 03 ce	 add	 rcx, rsi
  000b4	48 03 d5	 add	 rdx, rbp
  000b7	e8 00 00 00 00	 call	 memcpy
$LN22@mg_dns_par:

; 1123 :     j += n;

  000bc	48 8b cb	 mov	 rcx, rbx

; 1124 :     i += n + 1;

  000bf	49 8d 5d 01	 lea	 rbx, QWORD PTR [r13+1]

; 1125 :     if (j < tolen) to[j] = '\0';  // Zero-terminate this chunk

  000c3	48 3b cf	 cmp	 rcx, rdi
  000c6	73 04		 jae	 SHORT $LN13@mg_dns_par
  000c8	c6 04 0e 00	 mov	 BYTE PTR [rsi+rcx], 0
$LN13@mg_dns_par:

; 1101 :   // MG_INFO(("ofs %lx %x %x", (unsigned long) ofs, s[ofs], s[ofs + 1]));
; 1102 :   while (ofs + i + 1 < len) {

  000cc	48 8d 45 01	 lea	 rax, QWORD PTR [rbp+1]
  000d0	48 03 c3	 add	 rax, rbx
  000d3	49 3b c6	 cmp	 rax, r14
  000d6	72 90		 jb	 SHORT $LL2@mg_dns_par

; 1116 :     }
; 1117 :     if (ofs + i + n + 1 >= len) return 0;

  000d8	eb 51		 jmp	 SHORT $LN3@mg_dns_par
$LN18@mg_dns_par:

; 1109 :       size_t ptr = (((n & 0x3f) << 8) | s[ofs + i + 1]);  // 12 is hdr len

  000da	0f b6 54 2a 01	 movzx	 edx, BYTE PTR [rdx+rbp+1]
  000df	41 83 e0 3f	 and	 r8d, 63			; 0000003fH
  000e3	49 c1 e0 08	 shl	 r8, 8
  000e7	49 0b d0	 or	 rdx, r8

; 1110 :       // MG_INFO(("PTR %lx", (unsigned long) ptr));
; 1111 :       if (ptr + 1 < len && (s[ptr] & 0xc0) == 0 &&

  000ea	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  000ee	49 3b c6	 cmp	 rax, r14
  000f1	73 2f		 jae	 SHORT $LN8@mg_dns_par
  000f3	42 f6 04 22 c0	 test	 BYTE PTR [rdx+r12], 192	; 000000c0H
  000f8	75 28		 jne	 SHORT $LN8@mg_dns_par
  000fa	41 8d 47 01	 lea	 eax, DWORD PTR [r15+1]
  000fe	4c 8b c2	 mov	 r8, rdx
  00101	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00105	4c 8b ce	 mov	 r9, rsi
  00108	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010d	49 8b d6	 mov	 rdx, r14
  00110	49 8b cc	 mov	 rcx, r12
  00113	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00118	e8 00 00 00 00	 call	 mg_dns_parse_name_depth
  0011d	48 85 c0	 test	 rax, rax
  00120	74 18		 je	 SHORT $LN19@mg_dns_par
$LN8@mg_dns_par:

; 1112 :           mg_dns_parse_name_depth(s, len, ptr, to, tolen, j, depth + 1) == 0)
; 1113 :         return 0;
; 1114 :       i += 2;

  00122	48 83 c3 02	 add	 rbx, 2

; 1115 :       break;

  00126	eb 03		 jmp	 SHORT $LN3@mg_dns_par
$LN17@mg_dns_par:

; 1105 :       i++;

  00128	48 ff c3	 inc	 rbx
$LN3@mg_dns_par:

; 1126 :     // MG_INFO(("--> [%s]", to));
; 1127 :   }
; 1128 :   if (tolen > 0) to[tolen - 1] = '\0';  // Make sure make sure it is nul-term

  0012b	48 85 ff	 test	 rdi, rdi
  0012e	74 05		 je	 SHORT $LN14@mg_dns_par
  00130	c6 44 3e ff 00	 mov	 BYTE PTR [rsi+rdi-1], 0
$LN14@mg_dns_par:

; 1129 :   return i;

  00135	48 8b c3	 mov	 rax, rbx
  00138	eb 02		 jmp	 SHORT $LN1@mg_dns_par
$LN19@mg_dns_par:

; 1116 :     }
; 1117 :     if (ofs + i + n + 1 >= len) return 0;

  0013a	33 c0		 xor	 eax, eax
$LN1@mg_dns_par:

; 1130 : }

  0013c	4c 8d 5c 24 40	 lea	 r11, QWORD PTR [rsp+64]
  00141	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  00145	49 8b 6b 38	 mov	 rbp, QWORD PTR [r11+56]
  00149	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  0014d	49 8b e3	 mov	 rsp, r11
  00150	41 5f		 pop	 r15
  00152	41 5e		 pop	 r14
  00154	41 5d		 pop	 r13
  00156	41 5c		 pop	 r12
  00158	5f		 pop	 rdi
  00159	c3		 ret	 0
mg_dns_parse_name_depth ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_dns_parse_name
_TEXT	SEGMENT
s$ = 80
n$ = 88
ofs$ = 96
dst$ = 104
dstlen$ = 112
mg_dns_parse_name PROC					; COMDAT

; 1133 :                                 char *dst, size_t dstlen) {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1134 :   return mg_dns_parse_name_depth(s, n, ofs, dst, dstlen, 0, 0);

  00004	83 64 24 30 00	 and	 DWORD PTR [rsp+48], 0
  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR dstlen$[rsp]
  0000e	48 83 64 24 28
	00		 and	 QWORD PTR [rsp+40], 0
  00014	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00019	e8 00 00 00 00	 call	 mg_dns_parse_name_depth

; 1135 : }

  0001e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00022	c3		 ret	 0
mg_dns_parse_name ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_dns_parse_rr
_TEXT	SEGMENT
buf$ = 80
len$ = 88
ofs$ = 96
is_question$ = 104
rr$ = 112
mg_dns_parse_rr PROC					; COMDAT

; 1138 :                        bool is_question, struct mg_dns_rr *rr) {

$LN22:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  00007	49 89 6b 10	 mov	 QWORD PTR [r11+16], rbp
  0000b	49 89 73 18	 mov	 QWORD PTR [r11+24], rsi
  0000f	49 89 7b 20	 mov	 QWORD PTR [r11+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1139 :   const uint8_t *s = buf + ofs, *e = &buf[len];
; 1140 : 
; 1141 :   memset(rr, 0, sizeof(*rr));

  00019	48 8b 74 24 70	 mov	 rsi, QWORD PTR rr$[rsp]
  0001e	4a 8d 1c 01	 lea	 rbx, QWORD PTR [rcx+r8]
  00022	33 c0		 xor	 eax, eax
  00024	48 8d 3c 11	 lea	 rdi, QWORD PTR [rcx+rdx]
  00028	41 8a e9	 mov	 bpl, r9b
  0002b	48 89 06	 mov	 QWORD PTR [rsi], rax

; 1142 :   if (len < sizeof(struct mg_dns_header)) return 0;  // Too small

  0002e	48 8d 42 f4	 lea	 rax, QWORD PTR [rdx-12]
  00032	48 3d f4 01 00
	00		 cmp	 rax, 500		; 000001f4H
  00038	0f 87 9c 00 00
	00		 ja	 $LN13@mg_dns_par

; 1143 :   if (len > 512) return 0;  //  Too large, we don't expect that
; 1144 :   if (s >= e) return 0;     //  Overflow

  0003e	48 3b df	 cmp	 rbx, rdi
  00041	0f 83 93 00 00
	00		 jae	 $LN13@mg_dns_par

; 1134 :   return mg_dns_parse_name_depth(s, n, ofs, dst, dstlen, 0, 0);

  00047	45 33 f6	 xor	 r14d, r14d
  0004a	45 33 c9	 xor	 r9d, r9d
  0004d	45 89 73 e8	 mov	 DWORD PTR [r11-24], r14d
  00051	4d 89 73 e0	 mov	 QWORD PTR [r11-32], r14
  00055	4d 89 73 d8	 mov	 QWORD PTR [r11-40], r14
  00059	e8 00 00 00 00	 call	 mg_dns_parse_name_depth
  0005e	4c 8b c0	 mov	 r8, rax

; 1145 : 
; 1146 :   if ((rr->nlen = (uint16_t) mg_dns_parse_name(buf, len, ofs, NULL, 0)) == 0)

  00061	66 44 89 06	 mov	 WORD PTR [rsi], r8w
  00065	66 85 c0	 test	 ax, ax
  00068	74 70		 je	 SHORT $LN13@mg_dns_par

; 1147 :     return 0;
; 1148 :   s += rr->nlen + 4;

  0006a	41 0f b7 c0	 movzx	 eax, r8w
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 03 d8	 add	 rbx, rax

; 1149 :   if (s > e) return 0;

  00075	48 3b df	 cmp	 rbx, rdi
  00078	77 60		 ja	 SHORT $LN13@mg_dns_par

; 1150 :   rr->atype = (uint16_t) (((uint16_t) s[-4] << 8) | s[-3]);

  0007a	0f b6 53 fc	 movzx	 edx, BYTE PTR [rbx-4]
  0007e	0f b6 4b fd	 movzx	 ecx, BYTE PTR [rbx-3]
  00082	66 c1 e2 08	 shl	 dx, 8
  00086	66 0b d1	 or	 dx, cx

; 1151 :   rr->aclass = (uint16_t) (((uint16_t) s[-2] << 8) | s[-1]);

  00089	0f b6 4b ff	 movzx	 ecx, BYTE PTR [rbx-1]
  0008d	66 89 56 02	 mov	 WORD PTR [rsi+2], dx
  00091	0f b6 53 fe	 movzx	 edx, BYTE PTR [rbx-2]
  00095	66 c1 e2 08	 shl	 dx, 8
  00099	66 0b d1	 or	 dx, cx
  0009c	66 89 56 04	 mov	 WORD PTR [rsi+4], dx

; 1152 :   if (is_question) return (size_t) (rr->nlen + 4);

  000a0	40 84 ed	 test	 bpl, bpl
  000a3	75 37		 jne	 SHORT $LN1@mg_dns_par

; 1153 : 
; 1154 :   s += 6;

  000a5	48 83 c3 06	 add	 rbx, 6

; 1155 :   if (s > e) return 0;

  000a9	48 3b df	 cmp	 rbx, rdi
  000ac	77 2c		 ja	 SHORT $LN13@mg_dns_par

; 1156 :   rr->alen = (uint16_t) (((uint16_t) s[-2] << 8) | s[-1]);

  000ae	0f b6 43 ff	 movzx	 eax, BYTE PTR [rbx-1]
  000b2	0f b6 4b fe	 movzx	 ecx, BYTE PTR [rbx-2]
  000b6	66 c1 e1 08	 shl	 cx, 8
  000ba	66 0b c8	 or	 cx, ax
  000bd	0f b7 d1	 movzx	 edx, cx
  000c0	66 89 56 06	 mov	 WORD PTR [rsi+6], dx

; 1157 :   if (s + rr->alen > e) return 0;

  000c4	48 8d 04 1a	 lea	 rax, QWORD PTR [rdx+rbx]
  000c8	48 3b c7	 cmp	 rax, rdi
  000cb	77 0d		 ja	 SHORT $LN13@mg_dns_par

; 1158 :   return (size_t) (rr->nlen + rr->alen + 10);

  000cd	41 0f b7 c0	 movzx	 eax, r8w
  000d1	48 83 c0 0a	 add	 rax, 10
  000d5	48 03 c2	 add	 rax, rdx
  000d8	eb 02		 jmp	 SHORT $LN1@mg_dns_par
$LN13@mg_dns_par:

; 1157 :   if (s + rr->alen > e) return 0;

  000da	33 c0		 xor	 eax, eax
$LN1@mg_dns_par:

; 1159 : }

  000dc	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000e1	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000e6	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000eb	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  000f0	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000f4	41 5e		 pop	 r14
  000f6	c3		 ret	 0
mg_dns_parse_rr ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_dns_parse
_TEXT	SEGMENT
rr$ = 112
buf$ = 112
len$ = 120
dm$ = 128
mg_dns_parse PROC					; COMDAT

; 1161 : bool mg_dns_parse(const uint8_t *buf, size_t len, struct mg_dns_message *dm) {

$LN48:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0001c	49 8b d8	 mov	 rbx, r8
  0001f	4c 8b f2	 mov	 r14, rdx
  00022	48 8b f9	 mov	 rdi, rcx

; 1162 :   const struct mg_dns_header *h = (struct mg_dns_header *) buf;
; 1163 :   struct mg_dns_rr rr;
; 1164 :   size_t i, n, ofs = sizeof(*h);
; 1165 :   memset(dm, 0, sizeof(*dm));

  00025	33 d2		 xor	 edx, edx
  00027	48 8b cb	 mov	 rcx, rbx
  0002a	41 b8 18 01 00
	00		 mov	 r8d, 280		; 00000118H
  00030	be 0c 00 00 00	 mov	 esi, 12
  00035	e8 00 00 00 00	 call	 memset

; 1166 : 
; 1167 :   if (len < sizeof(*h)) return 0;                // Too small, headers dont fit

  0003a	4c 3b f6	 cmp	 r14, rsi
  0003d	0f 82 94 01 00
	00		 jb	 $LN32@mg_dns_par

; 13806:   memcpy(&data, &net, sizeof(data));

  00043	0f b7 47 04	 movzx	 eax, WORD PTR [rdi+4]

; 1168 :   if (mg_ntohs(h->num_questions) > 1) return 0;  // Sanity

  00047	44 8d 66 f5	 lea	 r12d, QWORD PTR [rsi-11]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  0004b	0f b6 c8	 movzx	 ecx, al
  0004e	66 c1 e1 08	 shl	 cx, 8
  00052	66 c1 e8 08	 shr	 ax, 8
  00056	66 0b c8	 or	 cx, ax

; 1168 :   if (mg_ntohs(h->num_questions) > 1) return 0;  // Sanity

  00059	66 41 3b cc	 cmp	 cx, r12w
  0005d	0f 87 74 01 00
	00		 ja	 $LN32@mg_dns_par

; 13806:   memcpy(&data, &net, sizeof(data));

  00063	0f b7 4f 06	 movzx	 ecx, WORD PTR [rdi+6]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00067	0f b6 c1	 movzx	 eax, cl
  0006a	66 c1 e0 08	 shl	 ax, 8
  0006e	66 c1 e9 08	 shr	 cx, 8
  00072	66 0b c1	 or	 ax, cx

; 1169 :   if (mg_ntohs(h->num_answers) > 15) return 0;   // Sanity

  00075	66 83 f8 0f	 cmp	 ax, 15
  00079	0f 87 58 01 00
	00		 ja	 $LN32@mg_dns_par

; 13806:   memcpy(&data, &net, sizeof(data));

  0007f	0f b7 07	 movzx	 eax, WORD PTR [rdi]

; 1171 : 
; 1172 :   for (i = 0; i < mg_ntohs(h->num_questions); i++) {

  00082	45 33 ed	 xor	 r13d, r13d

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00085	0f b6 c8	 movzx	 ecx, al

; 1171 : 
; 1172 :   for (i = 0; i < mg_ntohs(h->num_questions); i++) {

  00088	41 8b ed	 mov	 ebp, r13d

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  0008b	66 c1 e1 08	 shl	 cx, 8
  0008f	66 c1 e8 08	 shr	 ax, 8
  00093	66 0b c8	 or	 cx, ax

; 1170 :   dm->txnid = mg_ntohs(h->txnid);

  00096	66 89 0b	 mov	 WORD PTR [rbx], cx

; 13806:   memcpy(&data, &net, sizeof(data));

  00099	0f b7 47 04	 movzx	 eax, WORD PTR [rdi+4]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  0009d	0f b6 c8	 movzx	 ecx, al
  000a0	66 c1 e1 08	 shl	 cx, 8
  000a4	66 c1 e8 08	 shr	 ax, 8
  000a8	66 0b c8	 or	 cx, ax

; 1171 : 
; 1172 :   for (i = 0; i < mg_ntohs(h->num_questions); i++) {

  000ab	66 44 3b e9	 cmp	 r13w, cx
  000af	73 44		 jae	 SHORT $LN3@mg_dns_par
$LL4@mg_dns_par:

; 1173 :     if ((n = mg_dns_parse_rr(buf, len, ofs, true, &rr)) == 0) return false;

  000b1	48 8d 44 24 70	 lea	 rax, QWORD PTR rr$[rsp]
  000b6	45 8a cc	 mov	 r9b, r12b
  000b9	4c 8b c6	 mov	 r8, rsi
  000bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c1	49 8b d6	 mov	 rdx, r14
  000c4	48 8b cf	 mov	 rcx, rdi
  000c7	e8 00 00 00 00	 call	 mg_dns_parse_rr
  000cc	48 85 c0	 test	 rax, rax
  000cf	0f 84 02 01 00
	00		 je	 $LN32@mg_dns_par

; 13806:   memcpy(&data, &net, sizeof(data));

  000d5	0f b7 57 04	 movzx	 edx, WORD PTR [rdi+4]

; 1174 :     // MG_INFO(("Q %lu %lu %hu/%hu", ofs, n, rr.atype, rr.aclass));
; 1175 :     ofs += n;

  000d9	48 03 f0	 add	 rsi, rax

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  000dc	0f b6 c2	 movzx	 eax, dl

; 1171 : 
; 1172 :   for (i = 0; i < mg_ntohs(h->num_questions); i++) {

  000df	49 03 ec	 add	 rbp, r12

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  000e2	66 c1 e0 08	 shl	 ax, 8
  000e6	48 c1 ea 08	 shr	 rdx, 8
  000ea	0f b7 c8	 movzx	 ecx, ax
  000ed	48 0b ca	 or	 rcx, rdx

; 1171 : 
; 1172 :   for (i = 0; i < mg_ntohs(h->num_questions); i++) {

  000f0	48 3b e9	 cmp	 rbp, rcx
  000f3	72 bc		 jb	 SHORT $LL4@mg_dns_par
$LN3@mg_dns_par:

; 13806:   memcpy(&data, &net, sizeof(data));

  000f5	0f b7 47 06	 movzx	 eax, WORD PTR [rdi+6]

; 1176 :   }
; 1177 :   for (i = 0; i < mg_ntohs(h->num_answers); i++) {

  000f9	49 8b ed	 mov	 rbp, r13

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  000fc	0f b6 c8	 movzx	 ecx, al
  000ff	66 c1 e1 08	 shl	 cx, 8
  00103	66 c1 e8 08	 shr	 ax, 8
  00107	66 0b c8	 or	 cx, ax

; 1176 :   }
; 1177 :   for (i = 0; i < mg_ntohs(h->num_answers); i++) {

  0010a	66 44 3b e9	 cmp	 r13w, cx
$LN45@mg_dns_par:

; 1178 :     if ((n = mg_dns_parse_rr(buf, len, ofs, false, &rr)) == 0) return false;

  0010e	0f 83 be 00 00
	00		 jae	 $LN44@mg_dns_par
  00114	48 8d 44 24 70	 lea	 rax, QWORD PTR rr$[rsp]
  00119	45 33 c9	 xor	 r9d, r9d
  0011c	4c 8b c6	 mov	 r8, rsi
  0011f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00124	49 8b d6	 mov	 rdx, r14
  00127	48 8b cf	 mov	 rcx, rdi
  0012a	e8 00 00 00 00	 call	 mg_dns_parse_rr
  0012f	4c 8b f8	 mov	 r15, rax
  00132	48 85 c0	 test	 rax, rax
  00135	0f 84 9c 00 00
	00		 je	 $LN32@mg_dns_par

; 1134 :   return mg_dns_parse_name_depth(s, n, ofs, dst, dstlen, 0, 0);

  0013b	44 89 6c 24 30	 mov	 DWORD PTR [rsp+48], r13d

; 1179 :     // MG_INFO(("A -- %lu %lu %hu/%hu %s", ofs, n, rr.atype, rr.aclass,
; 1180 :     // dm->name));
; 1181 :     mg_dns_parse_name(buf, len, ofs, dm->name, sizeof(dm->name));

  00140	4c 8d 4b 18	 lea	 r9, QWORD PTR [rbx+24]

; 1134 :   return mg_dns_parse_name_depth(s, n, ofs, dst, dstlen, 0, 0);

  00144	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  00149	4c 8b c6	 mov	 r8, rsi
  0014c	49 8b d6	 mov	 rdx, r14
  0014f	48 c7 44 24 20
	00 01 00 00	 mov	 QWORD PTR [rsp+32], 256	; 00000100H
  00158	48 8b cf	 mov	 rcx, rdi
  0015b	e8 00 00 00 00	 call	 mg_dns_parse_name_depth

; 1182 :     ofs += n;

  00160	49 03 f7	 add	 rsi, r15

; 1183 : 
; 1184 :     if (rr.alen == 4 && rr.atype == 1 && rr.aclass == 1) {

  00163	66 83 7c 24 76
	04		 cmp	 WORD PTR rr$[rsp+6], 4
  00169	75 10		 jne	 SHORT $LN13@mg_dns_par
  0016b	66 44 39 64 24
	72		 cmp	 WORD PTR rr$[rsp+2], r12w
  00171	75 20		 jne	 SHORT $LN5@mg_dns_par
  00173	66 44 39 64 24
	74		 cmp	 WORD PTR rr$[rsp+4], r12w
  00179	74 38		 je	 SHORT $LN33@mg_dns_par
$LN13@mg_dns_par:

; 1189 :     } else if (rr.alen == 16 && rr.atype == 28 && rr.aclass == 1) {

  0017b	66 83 7c 24 76
	10		 cmp	 WORD PTR rr$[rsp+6], 16
  00181	75 10		 jne	 SHORT $LN5@mg_dns_par
  00183	66 83 7c 24 72
	1c		 cmp	 WORD PTR rr$[rsp+2], 28
  00189	75 08		 jne	 SHORT $LN5@mg_dns_par
  0018b	66 44 39 64 24
	74		 cmp	 WORD PTR rr$[rsp+4], r12w
  00191	74 2d		 je	 SHORT $LN34@mg_dns_par
$LN5@mg_dns_par:

; 13806:   memcpy(&data, &net, sizeof(data));

  00193	0f b7 57 06	 movzx	 edx, WORD PTR [rdi+6]

; 1176 :   }
; 1177 :   for (i = 0; i < mg_ntohs(h->num_answers); i++) {

  00197	49 03 ec	 add	 rbp, r12

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  0019a	0f b6 c2	 movzx	 eax, dl
  0019d	66 c1 e0 08	 shl	 ax, 8
  001a1	48 c1 ea 08	 shr	 rdx, 8
  001a5	0f b7 c8	 movzx	 ecx, ax
  001a8	48 0b ca	 or	 rcx, rdx

; 1176 :   }
; 1177 :   for (i = 0; i < mg_ntohs(h->num_answers); i++) {

  001ab	48 3b e9	 cmp	 rbp, rcx
  001ae	e9 5b ff ff ff	 jmp	 $LN45@mg_dns_par
$LN33@mg_dns_par:

; 1185 :       dm->addr.is_ip6 = false;

  001b3	44 88 6b 17	 mov	 BYTE PTR [rbx+23], r13b

; 1186 :       memcpy(&dm->addr.ip, &buf[ofs - 4], 4);

  001b7	8b 44 3e fc	 mov	 eax, DWORD PTR [rsi+rdi-4]
  001bb	89 43 04	 mov	 DWORD PTR [rbx+4], eax

; 1187 :       dm->resolved = true;
; 1188 :       break;  // Return success

  001be	eb 0e		 jmp	 SHORT $LN46@mg_dns_par
$LN34@mg_dns_par:

; 1190 :       dm->addr.is_ip6 = true;

  001c0	44 88 63 17	 mov	 BYTE PTR [rbx+23], r12b

; 1191 :       memcpy(&dm->addr.ip, &buf[ofs - 16], 16);

  001c4	0f 10 44 3e f0	 movups	 xmm0, XMMWORD PTR [rsi+rdi-16]
  001c9	f3 0f 7f 43 04	 movdqu	 XMMWORD PTR [rbx+4], xmm0
$LN46@mg_dns_par:

; 1192 :       dm->resolved = true;
; 1193 :       break;  // Return success
; 1194 :     }
; 1195 :   }
; 1196 :   return true;

  001ce	44 88 63 02	 mov	 BYTE PTR [rbx+2], r12b
$LN44@mg_dns_par:
  001d2	41 8a c4	 mov	 al, r12b
  001d5	eb 02		 jmp	 SHORT $LN1@mg_dns_par
$LN32@mg_dns_par:

; 1178 :     if ((n = mg_dns_parse_rr(buf, len, ofs, false, &rr)) == 0) return false;

  001d7	32 c0		 xor	 al, al
$LN1@mg_dns_par:

; 1197 : }

  001d9	4c 8d 5c 24 40	 lea	 r11, QWORD PTR [rsp+64]
  001de	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  001e2	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  001e6	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  001ea	49 8b e3	 mov	 rsp, r11
  001ed	41 5f		 pop	 r15
  001ef	41 5e		 pop	 r14
  001f1	41 5d		 pop	 r13
  001f3	41 5c		 pop	 r12
  001f5	5f		 pop	 rdi
  001f6	c3		 ret	 0
mg_dns_parse ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT dns_cb
_TEXT	SEGMENT
dm$1 = 48
c$ = 368
ev$ = 376
ev_data$ = 384
dns_cb	PROC						; COMDAT

; 1199 : static void dns_cb(struct mg_connection *c, int ev, void *ev_data) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H

; 1200 :   struct dns_data *d, *tmp;
; 1201 :   struct dns_data **head = (struct dns_data **) &c->mgr->active_dns_requests;

  0001b	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
  0001f	48 8b f1	 mov	 rsi, rcx

; 1202 :   if (ev == MG_EV_POLL) {

  00022	83 fa 02	 cmp	 edx, 2
  00025	75 36		 jne	 SHORT $LN23@dns_cb

; 1203 :     uint64_t now = *(uint64_t *) ev_data;
; 1204 :     for (d = *head; d != NULL; d = tmp) {

  00027	48 8b 4f 50	 mov	 rcx, QWORD PTR [rdi+80]
  0002b	49 8b 30	 mov	 rsi, QWORD PTR [r8]
  0002e	48 85 c9	 test	 rcx, rcx
  00031	0f 84 33 02 00
	00		 je	 $LN21@dns_cb
$LL4@dns_cb:

; 1205 :       tmp = d->next;

  00037	48 8b 19	 mov	 rbx, QWORD PTR [rcx]

; 1206 :       // MG_DEBUG ("%lu %lu dns poll", d->expire, now));
; 1207 :       if (now > d->expire) mg_error(d->c, "DNS timeout");

  0003a	48 3b 71 10	 cmp	 rsi, QWORD PTR [rcx+16]
  0003e	76 10		 jbe	 SHORT $LN2@dns_cb
  00040	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@EKADLLOH@DNS?5timeout@
  0004b	e8 00 00 00 00	 call	 mg_error
$LN2@dns_cb:

; 1203 :     uint64_t now = *(uint64_t *) ev_data;
; 1204 :     for (d = *head; d != NULL; d = tmp) {

  00050	48 8b cb	 mov	 rcx, rbx
  00053	48 85 db	 test	 rbx, rbx
  00056	75 df		 jne	 SHORT $LL4@dns_cb

; 1208 :     }
; 1209 :   } else if (ev == MG_EV_READ) {

  00058	e9 0d 02 00 00	 jmp	 $LN21@dns_cb
$LN23@dns_cb:
  0005d	83 fa 07	 cmp	 edx, 7
  00060	0f 85 b1 01 00
	00		 jne	 $LN26@dns_cb

; 1210 :     struct mg_dns_message dm;
; 1211 :     int resolved = 0;
; 1212 :     if (mg_dns_parse(c->recv.buf, c->recv.len, &dm) == false) {

  00066	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  0006a	4c 8d 44 24 30	 lea	 r8, QWORD PTR dm$1[rsp]
  0006f	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00073	33 ed		 xor	 ebp, ebp
  00075	e8 00 00 00 00	 call	 mg_dns_parse
  0007a	44 8d 7d 01	 lea	 r15d, QWORD PTR [rbp+1]
  0007e	84 c0		 test	 al, al
  00080	75 3c		 jne	 SHORT $LN28@dns_cb

; 1213 :       MG_ERROR(("Unexpected DNS response:"));

  00082	44 39 3d 00 00
	00 00		 cmp	 DWORD PTR mg_log_level, r15d
  00089	7c 21		 jl	 SHORT $LN5@dns_cb
  0008b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_06BPNCNPOK@dns_cb@
  00092	41 b8 bd 04 00
	00		 mov	 r8d, 1213		; 000004bdH
  00098	41 8b cf	 mov	 ecx, r15d
  0009b	e8 00 00 00 00	 call	 mg_log_prefix
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@COKDKGDG@Unexpected?5DNS?5response?3@
  000a7	e8 00 00 00 00	 call	 mg_log
$LN5@dns_cb:

; 1214 :       mg_hexdump(c->recv.buf, c->recv.len);

  000ac	48 8b 56 58	 mov	 rdx, QWORD PTR [rsi+88]
  000b0	48 8b 4e 48	 mov	 rcx, QWORD PTR [rsi+72]
  000b4	e8 00 00 00 00	 call	 mg_hexdump

; 1215 :     } else {

  000b9	e9 28 01 00 00	 jmp	 $LN76@dns_cb
$LN28@dns_cb:

; 1216 :       // MG_VERBOSE(("%s %d", dm.name, dm.resolved));
; 1217 :       for (d = *head; d != NULL; d = tmp) {

  000be	48 8b 5f 50	 mov	 rbx, QWORD PTR [rdi+80]
  000c2	48 85 db	 test	 rbx, rbx
  000c5	0f 84 1b 01 00
	00		 je	 $LN76@dns_cb
$LL10@dns_cb:

; 1218 :         tmp = d->next;
; 1219 :         // MG_INFO(("d %p %hu %hu", d, d->txnid, dm.txnid));
; 1220 :         if (dm.txnid != d->txnid) continue;

  000cb	0f b7 43 18	 movzx	 eax, WORD PTR [rbx+24]
  000cf	4c 8b 33	 mov	 r14, QWORD PTR [rbx]
  000d2	66 39 44 24 30	 cmp	 WORD PTR dm$1[rsp], ax
  000d7	0f 85 f9 00 00
	00		 jne	 $LN8@dns_cb

; 1221 :         if (d->c->is_resolving) {

  000dd	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  000e1	f6 81 10 01 00
	00 08		 test	 BYTE PTR [rcx+272], 8
  000e8	0f 84 8a 00 00
	00		 je	 $LN16@dns_cb

; 1222 :           if (dm.resolved) {

  000ee	80 7c 24 32 00	 cmp	 BYTE PTR dm$1[rsp+2], 0
  000f3	74 70		 je	 SHORT $LN34@dns_cb

; 1223 :             dm.addr.port = d->c->rem.port;  // Save port
; 1224 :             d->c->rem = dm.addr;            // Copy resolved address
; 1225 :             MG_DEBUG(

  000f5	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR mg_log_level, 3
  000fc	0f b7 41 34	 movzx	 eax, WORD PTR [rcx+52]
  00100	0f 10 44 24 34	 movups	 xmm0, XMMWORD PTR dm$1[rsp+4]
  00105	66 89 44 24 44	 mov	 WORD PTR dm$1[rsp+20], ax
  0010a	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0010e	0f 11 41 24	 movups	 XMMWORD PTR [rcx+36], xmm0
  00112	8b 44 24 44	 mov	 eax, DWORD PTR dm$1[rsp+20]
  00116	89 41 34	 mov	 DWORD PTR [rcx+52], eax
  00119	7c 3f		 jl	 SHORT $LN11@dns_cb
  0011b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_06BPNCNPOK@dns_cb@
  00122	b9 03 00 00 00	 mov	 ecx, 3
  00127	41 b8 ca 04 00
	00		 mov	 r8d, 1226		; 000004caH
  0012d	e8 00 00 00 00	 call	 mg_log_prefix
  00132	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00136	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:mg_print_ip
  0013d	4c 8d 44 24 48	 lea	 r8, QWORD PTR dm$1[rsp+24]
  00142	8b 51 40	 mov	 edx, DWORD PTR [rcx+64]
  00145	48 8d 41 24	 lea	 rax, QWORD PTR [rcx+36]
  00149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@NMEECLIA@?$CFlu?5?$CFs?5is?5?$CFM@
  00150	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00155	e8 00 00 00 00	 call	 mg_log
$LN11@dns_cb:

; 1226 :                 ("%lu %s is %M", d->c->id, dm.name, mg_print_ip, &d->c->rem));
; 1227 :             mg_connect_resolved(d->c);

  0015a	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0015e	e8 00 00 00 00	 call	 mg_connect_resolved

; 1228 : #if MG_ENABLE_IPV6
; 1229 :           } else if (dm.addr.is_ip6 == false && dm.name[0] != '\0' &&
; 1230 :                      c->mgr->use_dns6 == false) {
; 1231 :             struct mg_str x = mg_str(dm.name);
; 1232 :             mg_sendnsreq(d->c, &x, c->mgr->dnstimeout, &c->mgr->dns6, true);
; 1233 : #endif
; 1234 :           } else {

  00163	eb 44		 jmp	 SHORT $LN15@dns_cb
$LN34@dns_cb:

; 1235 :             mg_error(d->c, "%s DNS lookup failed", dm.name);

  00165	4c 8d 44 24 48	 lea	 r8, QWORD PTR dm$1[rsp+24]
  0016a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@BIFAMDJJ@?$CFs?5DNS?5lookup?5failed@
  00171	e8 00 00 00 00	 call	 mg_error

; 1236 :           }
; 1237 :         } else {

  00176	eb 31		 jmp	 SHORT $LN15@dns_cb
$LN16@dns_cb:

; 1238 :           MG_ERROR(("%lu already resolved", d->c->id));

  00178	44 39 3d 00 00
	00 00		 cmp	 DWORD PTR mg_log_level, r15d
  0017f	7c 28		 jl	 SHORT $LN15@dns_cb
  00181	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_06BPNCNPOK@dns_cb@
  00188	41 b8 d6 04 00
	00		 mov	 r8d, 1238		; 000004d6H
  0018e	41 8b cf	 mov	 ecx, r15d
  00191	e8 00 00 00 00	 call	 mg_log_prefix
  00196	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0019a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@ICMAECGD@?$CFlu?5already?5resolved@
  001a1	8b 50 40	 mov	 edx, DWORD PTR [rax+64]
  001a4	e8 00 00 00 00	 call	 mg_log
$LN15@dns_cb:

; 1082 :   LIST_DELETE(struct dns_data, head, d);

  001a9	48 8b 4f 50	 mov	 rcx, QWORD PTR [rdi+80]
  001ad	48 8d 57 50	 lea	 rdx, QWORD PTR [rdi+80]
  001b1	48 3b cb	 cmp	 rcx, rbx
  001b4	74 0e		 je	 SHORT $LN54@dns_cb
$LL53@dns_cb:
  001b6	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  001b9	48 8b d1	 mov	 rdx, rcx
  001bc	48 8b c8	 mov	 rcx, rax
  001bf	48 3b c3	 cmp	 rax, rbx
  001c2	75 f2		 jne	 SHORT $LL53@dns_cb
$LN54@dns_cb:
  001c4	48 8b 03	 mov	 rax, QWORD PTR [rbx]

; 1083 :   free(d);

  001c7	48 8b cb	 mov	 rcx, rbx
  001ca	48 89 02	 mov	 QWORD PTR [rdx], rax
  001cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1239 :         }
; 1240 :         mg_dns_free(head, d);
; 1241 :         resolved = 1;

  001d3	41 8b ef	 mov	 ebp, r15d
$LN8@dns_cb:

; 1216 :       // MG_VERBOSE(("%s %d", dm.name, dm.resolved));
; 1217 :       for (d = *head; d != NULL; d = tmp) {

  001d6	49 8b de	 mov	 rbx, r14
  001d9	4d 85 f6	 test	 r14, r14
  001dc	0f 85 e9 fe ff
	ff		 jne	 $LL10@dns_cb

; 1242 :       }
; 1243 :     }
; 1244 :     if (!resolved) MG_ERROR(("stray DNS reply"));

  001e2	85 ed		 test	 ebp, ebp
  001e4	75 2a		 jne	 SHORT $LN18@dns_cb
$LN76@dns_cb:
  001e6	44 39 3d 00 00
	00 00		 cmp	 DWORD PTR mg_log_level, r15d
  001ed	7c 21		 jl	 SHORT $LN18@dns_cb
  001ef	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_06BPNCNPOK@dns_cb@
  001f6	41 b8 dc 04 00
	00		 mov	 r8d, 1244		; 000004dcH
  001fc	41 8b cf	 mov	 ecx, r15d
  001ff	e8 00 00 00 00	 call	 mg_log_prefix
  00204	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@NIPDPKGJ@stray?5DNS?5reply@
  0020b	e8 00 00 00 00	 call	 mg_log
$LN18@dns_cb:

; 1245 :     c->recv.len = 0;

  00210	48 83 66 58 00	 and	 QWORD PTR [rsi+88], 0
  00215	eb 53		 jmp	 SHORT $LN21@dns_cb
$LN26@dns_cb:

; 1246 :   } else if (ev == MG_EV_CLOSE) {

  00217	83 fa 09	 cmp	 edx, 9
  0021a	75 4e		 jne	 SHORT $LN21@dns_cb

; 1247 :     for (d = *head; d != NULL; d = tmp) {

  0021c	48 8b 5f 50	 mov	 rbx, QWORD PTR [rdi+80]
  00220	48 85 db	 test	 rbx, rbx
  00223	74 45		 je	 SHORT $LN21@dns_cb
$LL22@dns_cb:

; 1248 :       tmp = d->next;
; 1249 :       mg_error(d->c, "DNS error");

  00225	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00229	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09MNPPPHEH@DNS?5error@
  00230	48 8b 33	 mov	 rsi, QWORD PTR [rbx]
  00233	e8 00 00 00 00	 call	 mg_error

; 1082 :   LIST_DELETE(struct dns_data, head, d);

  00238	48 8b 4f 50	 mov	 rcx, QWORD PTR [rdi+80]
  0023c	48 8d 57 50	 lea	 rdx, QWORD PTR [rdi+80]
  00240	48 3b cb	 cmp	 rcx, rbx
  00243	74 0e		 je	 SHORT $LN47@dns_cb
$LL46@dns_cb:
  00245	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00248	48 8b d1	 mov	 rdx, rcx
  0024b	48 8b c8	 mov	 rcx, rax
  0024e	48 3b c3	 cmp	 rax, rbx
  00251	75 f2		 jne	 SHORT $LL46@dns_cb
$LN47@dns_cb:
  00253	48 8b 03	 mov	 rax, QWORD PTR [rbx]

; 1083 :   free(d);

  00256	48 8b cb	 mov	 rcx, rbx
  00259	48 89 02	 mov	 QWORD PTR [rdx], rax
  0025c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1247 :     for (d = *head; d != NULL; d = tmp) {

  00262	48 8b de	 mov	 rbx, rsi
  00265	48 85 f6	 test	 rsi, rsi
  00268	75 bb		 jne	 SHORT $LL22@dns_cb
$LN21@dns_cb:

; 1250 :       mg_dns_free(head, d);
; 1251 :     }
; 1252 :   }
; 1253 : }

  0026a	4c 8d 9c 24 50
	01 00 00	 lea	 r11, QWORD PTR [rsp+336]
  00272	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  00276	49 8b 6b 28	 mov	 rbp, QWORD PTR [r11+40]
  0027a	49 8b 73 30	 mov	 rsi, QWORD PTR [r11+48]
  0027e	49 8b e3	 mov	 rsp, r11
  00281	41 5f		 pop	 r15
  00283	41 5e		 pop	 r14
  00285	5f		 pop	 rdi
  00286	c3		 ret	 0
dns_cb	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_dns_send
_TEXT	SEGMENT
pkt$ = 32
c$ = 336
name$ = 344
txnid$ = 352
ipv6$ = 360
mg_dns_send PROC					; COMDAT

; 1256 :                         uint16_t txnid, bool ipv6) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 81 ec 30 01
	00 00		 sub	 rsp, 304		; 00000130H
  0001b	41 0f b7 d8	 movzx	 ebx, r8w
  0001f	48 8b fa	 mov	 rdi, rdx
  00022	4c 8b f9	 mov	 r15, rcx

; 1257 :   struct {
; 1258 :     struct mg_dns_header header;
; 1259 :     uint8_t data[256];
; 1260 :   } pkt;
; 1261 :   size_t i, n;
; 1262 :   memset(&pkt, 0, sizeof(pkt));

  00025	33 d2		 xor	 edx, edx
  00027	41 b8 06 01 00
	00		 mov	 r8d, 262		; 00000106H
  0002d	48 8d 4c 24 26	 lea	 rcx, QWORD PTR pkt$[rsp+6]
  00032	41 8a e9	 mov	 bpl, r9b
  00035	e8 00 00 00 00	 call	 memset

; 1267 :     if (name->ptr[i] == '.' || i >= name->len) {

  0003a	4c 8b 37	 mov	 r14, QWORD PTR [rdi]
  0003d	33 c9		 xor	 ecx, ecx

; 1271 :     }
; 1272 :     if (i >= name->len) break;

  0003f	48 8b 77 08	 mov	 rsi, QWORD PTR [rdi+8]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00043	0f b6 c3	 movzx	 eax, bl
  00046	66 c1 e0 08	 shl	 ax, 8
  0004a	66 c1 eb 08	 shr	 bx, 8
  0004e	66 0b c3	 or	 ax, bx

; 1263 :   pkt.header.txnid = mg_htons(txnid);
; 1264 :   pkt.header.flags = mg_htons(0x100);

  00051	c7 44 24 22 01
	00 00 01	 mov	 DWORD PTR pkt$[rsp+2], 16777217 ; 01000001H
  00059	66 89 44 24 20	 mov	 WORD PTR pkt$[rsp], ax

; 1265 :   pkt.header.num_questions = mg_htons(1);
; 1266 :   for (i = n = 0; i < sizeof(pkt.data) - 5; i++) {

  0005e	33 db		 xor	 ebx, ebx
$LL4@mg_dns_sen:

; 1267 :     if (name->ptr[i] == '.' || i >= name->len) {

  00060	48 8d 7b 01	 lea	 rdi, QWORD PTR [rbx+1]
  00064	41 80 7c 3e ff
	2e		 cmp	 BYTE PTR [r14+rdi-1], 46 ; 0000002eH
  0006a	74 05		 je	 SHORT $LN6@mg_dns_sen
  0006c	48 3b de	 cmp	 rbx, rsi
  0006f	72 27		 jb	 SHORT $LN22@mg_dns_sen
$LN6@mg_dns_sen:

; 1268 :       pkt.data[n] = (uint8_t) (i - n);

  00071	8a c3		 mov	 al, bl

; 1269 :       memcpy(&pkt.data[n + 1], name->ptr + n, i - n);

  00073	49 8d 14 0e	 lea	 rdx, QWORD PTR [r14+rcx]
  00077	2a c1		 sub	 al, cl
  00079	4c 8b c3	 mov	 r8, rbx
  0007c	88 44 0c 2c	 mov	 BYTE PTR pkt$[rsp+rcx+12], al
  00080	4c 2b c1	 sub	 r8, rcx
  00083	48 8d 44 24 2d	 lea	 rax, QWORD PTR pkt$[rsp+13]
  00088	48 03 c8	 add	 rcx, rax
  0008b	e8 00 00 00 00	 call	 memcpy

; 1270 :       n = i + 1;

  00090	48 8b cf	 mov	 rcx, rdi

; 1271 :     }
; 1272 :     if (i >= name->len) break;

  00093	48 3b de	 cmp	 rbx, rsi
  00096	73 0c		 jae	 SHORT $LN17@mg_dns_sen
$LN22@mg_dns_sen:

; 1265 :   pkt.header.num_questions = mg_htons(1);
; 1266 :   for (i = n = 0; i < sizeof(pkt.data) - 5; i++) {

  00098	48 8b df	 mov	 rbx, rdi
  0009b	48 81 ff fb 00
	00 00		 cmp	 rdi, 251		; 000000fbH
  000a2	72 bc		 jb	 SHORT $LL4@mg_dns_sen
$LN17@mg_dns_sen:

; 1273 :   }
; 1274 :   memcpy(&pkt.data[n], "\x00\x00\x01\x00\x01", 5);  // A query

  000a4	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_05OPJKAIHI@?$AA?$AA?$AB?$AA?$AB@
  000aa	89 44 0c 2c	 mov	 DWORD PTR pkt$[rsp+rcx+12], eax
  000ae	8a 05 04 00 00
	00		 mov	 al, BYTE PTR ??_C@_05OPJKAIHI@?$AA?$AA?$AB?$AA?$AB@+4
  000b4	88 44 0c 30	 mov	 BYTE PTR pkt$[rsp+rcx+16], al

; 1275 :   n += 5;
; 1276 :   if (ipv6) pkt.data[n - 3] = 0x1c;  // AAAA query

  000b8	40 84 ed	 test	 bpl, bpl
  000bb	74 05		 je	 SHORT $LN8@mg_dns_sen
  000bd	c6 44 0c 2e 1c	 mov	 BYTE PTR pkt$[rsp+rcx+14], 28
$LN8@mg_dns_sen:

; 1277 :   // memcpy(&pkt.data[n], "\xc0\x0c\x00\x1c\x00\x01", 6);  // AAAA query
; 1278 :   // n += 6;
; 1279 :   return mg_send(c, &pkt, sizeof(pkt.header) + n);

  000c2	4c 8d 41 11	 lea	 r8, QWORD PTR [rcx+17]
  000c6	49 8b cf	 mov	 rcx, r15
  000c9	48 8d 54 24 20	 lea	 rdx, QWORD PTR pkt$[rsp]
  000ce	e8 00 00 00 00	 call	 mg_send

; 1280 : }

  000d3	4c 8d 9c 24 30
	01 00 00	 lea	 r11, QWORD PTR [rsp+304]
  000db	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  000df	49 8b 6b 28	 mov	 rbp, QWORD PTR [r11+40]
  000e3	49 8b 73 30	 mov	 rsi, QWORD PTR [r11+48]
  000e7	49 8b e3	 mov	 rsp, r11
  000ea	41 5f		 pop	 r15
  000ec	41 5e		 pop	 r14
  000ee	5f		 pop	 rdi
  000ef	c3		 ret	 0
mg_dns_send ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_sendnsreq
_TEXT	SEGMENT
c$ = 80
name$ = 88
ms$ = 96
dnsc$ = 104
ipv6$ = 112
mg_sendnsreq PROC					; COMDAT

; 1283 :                          struct mg_dns *dnsc, bool ipv6) {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	41 56		 push	 r14
  00017	41 57		 push	 r15
  00019	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001d	4c 8b fa	 mov	 r15, rdx
  00020	49 63 e8	 movsxd	 rbp, r8d

; 1284 :   struct dns_data *d = NULL;
; 1285 :   if (dnsc->url == NULL) {

  00023	49 8b 11	 mov	 rdx, QWORD PTR [r9]
  00026	4d 8b f1	 mov	 r14, r9
  00029	48 8b d9	 mov	 rbx, rcx
  0002c	48 85 d2	 test	 rdx, rdx
  0002f	75 12		 jne	 SHORT $LN5@mg_sendnsr

; 1286 :     mg_error(c, "DNS server URL is NULL. Call mg_mgr_init()");

  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@JCHAOBLG@DNS?5server?5URL?5is?5NULL?4?5Call?5mg@
  00038	e8 00 00 00 00	 call	 mg_error
  0003d	49 8d 7e 08	 lea	 rdi, QWORD PTR [r14+8]
  00041	eb 32		 jmp	 SHORT $LN8@mg_sendnsr
$LN5@mg_sendnsr:

; 1287 :   } else if (dnsc->c == NULL) {

  00043	49 8d 71 08	 lea	 rsi, QWORD PTR [r9+8]
  00047	48 83 3e 00	 cmp	 QWORD PTR [rsi], 0
  0004b	48 8b fe	 mov	 rdi, rsi
  0004e	75 25		 jne	 SHORT $LN8@mg_sendnsr

; 1288 :     dnsc->c = mg_connect(c->mgr, dnsc->url, NULL, NULL);

  00050	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00054	45 33 c9	 xor	 r9d, r9d
  00057	45 33 c0	 xor	 r8d, r8d
  0005a	e8 00 00 00 00	 call	 mg_connect
  0005f	48 89 06	 mov	 QWORD PTR [rsi], rax

; 1289 :     if (dnsc->c != NULL) {

  00062	48 85 c0	 test	 rax, rax
  00065	74 0e		 je	 SHORT $LN8@mg_sendnsr

; 1290 :       dnsc->c->pfn = dns_cb;

  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dns_cb
  0006e	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx
$LN8@mg_sendnsr:

; 1291 :       // dnsc->c->is_hexdumping = 1;
; 1292 :     }
; 1293 :   }
; 1294 :   if (dnsc->c == NULL) {

  00075	48 83 3f 00	 cmp	 QWORD PTR [rdi], 0
  00079	75 0f		 jne	 SHORT $LN9@mg_sendnsr

; 1295 :     mg_error(c, "resolver");

  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08DKAJKOFH@resolver@
$LN21@mg_sendnsr:

; 1310 :     }
; 1311 :   }
; 1312 : }

  00082	48 8b cb	 mov	 rcx, rbx
  00085	e9 d6 00 00 00	 jmp	 $LN20@mg_sendnsr
$LN9@mg_sendnsr:

; 1296 :   } else if ((d = (struct dns_data *) calloc(1, sizeof(*d))) == NULL) {

  0008a	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0008f	44 8d 62 e1	 lea	 r12d, QWORD PTR [rdx-31]
  00093	41 8b cc	 mov	 ecx, r12d
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0009c	48 8b f0	 mov	 rsi, rax
  0009f	48 85 c0	 test	 rax, rax
  000a2	75 09		 jne	 SHORT $LN11@mg_sendnsr

; 1297 :     mg_error(c, "resolve OOM");

  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@JPBODOLJ@resolve?5OOM@

; 1298 :   } else {

  000ab	eb d5		 jmp	 SHORT $LN21@mg_sendnsr
$LN11@mg_sendnsr:

; 1299 :     struct dns_data *reqs = (struct dns_data *) c->mgr->active_dns_requests;

  000ad	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  000b1	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]

; 1300 :     d->txnid = reqs ? (uint16_t) (reqs->txnid + 1) : 1;

  000b5	48 85 c9	 test	 rcx, rcx
  000b8	74 0a		 je	 SHORT $LN16@mg_sendnsr
  000ba	0f b7 41 18	 movzx	 eax, WORD PTR [rcx+24]
  000be	66 41 03 c4	 add	 ax, r12w
  000c2	eb 03		 jmp	 SHORT $LN17@mg_sendnsr
$LN16@mg_sendnsr:
  000c4	41 8b c4	 mov	 eax, r12d
$LN17@mg_sendnsr:
  000c7	66 89 46 18	 mov	 WORD PTR [rsi+24], ax

; 1301 :     d->next = (struct dns_data *) c->mgr->active_dns_requests;

  000cb	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  000cf	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  000d3	48 89 0e	 mov	 QWORD PTR [rsi], rcx

; 1302 :     c->mgr->active_dns_requests = d;

  000d6	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  000da	48 89 70 50	 mov	 QWORD PTR [rax+80], rsi

; 13865:   return GetTickCount();

  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  000e4	8b c8		 mov	 ecx, eax

; 1303 :     d->expire = mg_millis() + (uint64_t) ms;

  000e6	48 03 cd	 add	 rcx, rbp

; 1304 :     d->c = c;

  000e9	48 89 5e 08	 mov	 QWORD PTR [rsi+8], rbx
  000ed	48 89 4e 10	 mov	 QWORD PTR [rsi+16], rcx

; 1305 :     c->is_resolving = 1;
; 1306 :     MG_VERBOSE(("%lu resolving %.*s @ %s, txnid %hu", c->id, (int) name->len,

  000f1	b9 04 00 00 00	 mov	 ecx, 4
  000f6	83 8b 10 01 00
	00 08		 or	 DWORD PTR [rbx+272], 8
  000fd	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  00103	7c 38		 jl	 SHORT $LN2@mg_sendnsr
  00105	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0N@IKEIFCGJ@mg_sendnsreq@
  0010c	41 b8 1b 05 00
	00		 mov	 r8d, 1307		; 0000051bH
  00112	e8 00 00 00 00	 call	 mg_log_prefix
  00117	0f b7 46 18	 movzx	 eax, WORD PTR [rsi+24]
  0011b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@BHFHEJIF@?$CFlu?5resolving?5?$CF?4?$CKs?5?$EA?5?$CFs?0?5txnid?5@
  00122	4d 8b 0f	 mov	 r9, QWORD PTR [r15]
  00125	45 8b 47 08	 mov	 r8d, DWORD PTR [r15+8]
  00129	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  0012c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00130	49 8b 06	 mov	 rax, QWORD PTR [r14]
  00133	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00138	e8 00 00 00 00	 call	 mg_log
$LN2@mg_sendnsr:

; 1307 :                 name->ptr, dnsc->url, d->txnid));
; 1308 :     if (!mg_dns_send(dnsc->c, name, d->txnid, ipv6)) {

  0013d	44 8a 4c 24 70	 mov	 r9b, BYTE PTR ipv6$[rsp]
  00142	49 8b d7	 mov	 rdx, r15
  00145	44 0f b7 46 18	 movzx	 r8d, WORD PTR [rsi+24]
  0014a	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0014d	e8 00 00 00 00	 call	 mg_dns_send
  00152	84 c0		 test	 al, al
  00154	75 0f		 jne	 SHORT $LN14@mg_sendnsr

; 1309 :       mg_error(dnsc->c, "DNS send");

  00156	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00159	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08ECFMEKDO@DNS?5send@
$LN20@mg_sendnsr:

; 1310 :     }
; 1311 :   }
; 1312 : }

  00160	e8 00 00 00 00	 call	 mg_error
$LN14@mg_sendnsr:
  00165	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0016a	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  0016f	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00174	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  00179	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0017d	41 5f		 pop	 r15
  0017f	41 5e		 pop	 r14
  00181	41 5c		 pop	 r12
  00183	c3		 ret	 0
mg_sendnsreq ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_resolve
_TEXT	SEGMENT
$T1 = 48
$T2 = 64
host$ = 64
c$ = 112
url$ = 120
mg_resolve PROC						; COMDAT

; 1314 : void mg_resolve(struct mg_connection *c, const char *url) {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	0f 29 74 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm6

; 1315 :   struct mg_str host = mg_url_host(url);

  00012	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  00017	48 8b da	 mov	 rbx, rdx
  0001a	e8 00 00 00 00	 call	 mg_url_host

; 1316 :   c->rem.port = mg_htons(mg_url_port(url));

  0001f	48 8b cb	 mov	 rcx, rbx
  00022	0f 10 30	 movups	 xmm6, XMMWORD PTR [rax]
  00025	0f 29 74 24 40	 movaps	 XMMWORD PTR host$[rsp], xmm6
  0002a	e8 00 00 00 00	 call	 mg_url_port

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  0002f	0f b6 d0	 movzx	 edx, al

; 1317 :   if (mg_aton(host, &c->rem)) {

  00032	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00037	66 c1 e2 08	 shl	 dx, 8
  0003b	66 c1 e8 08	 shr	 ax, 8
  0003f	66 0b d0	 or	 dx, ax

; 1317 :   if (mg_aton(host, &c->rem)) {

  00042	66 0f 7f 74 24
	30		 movdqa	 XMMWORD PTR $T1[rsp], xmm6
  00048	66 89 57 34	 mov	 WORD PTR [rdi+52], dx
  0004c	48 8d 57 24	 lea	 rdx, QWORD PTR [rdi+36]
  00050	e8 00 00 00 00	 call	 mg_aton
  00055	84 c0		 test	 al, al
  00057	74 0a		 je	 SHORT $LN2@mg_resolve

; 1318 :     // host is an IP address, do not fire name resolution
; 1319 :     mg_connect_resolved(c);

  00059	48 8b cf	 mov	 rcx, rdi
  0005c	e8 00 00 00 00	 call	 mg_connect_resolved

; 1320 :   } else {

  00061	eb 2e		 jmp	 SHORT $LN3@mg_resolve
$LN2@mg_resolve:

; 1321 :     // host is not an IP, send DNS resolution request
; 1322 :     struct mg_dns *dns = c->mgr->use_dns6 ? &c->mgr->dns6 : &c->mgr->dns4;

  00063	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  00067	8a 4a 2c	 mov	 cl, BYTE PTR [rdx+44]

; 1323 :     mg_sendnsreq(c, &host, c->mgr->dnstimeout, dns, c->mgr->use_dns6);

  0006a	44 8b 42 28	 mov	 r8d, DWORD PTR [rdx+40]
  0006e	8a c1		 mov	 al, cl
  00070	f6 d8		 neg	 al
  00072	88 4c 24 20	 mov	 BYTE PTR [rsp+32], cl
  00076	48 8b cf	 mov	 rcx, rdi
  00079	4d 1b c9	 sbb	 r9, r9
  0007c	41 83 e1 10	 and	 r9d, 16
  00080	49 83 c1 08	 add	 r9, 8
  00084	4c 03 ca	 add	 r9, rdx
  00087	48 8d 54 24 40	 lea	 rdx, QWORD PTR host$[rsp]
  0008c	e8 00 00 00 00	 call	 mg_sendnsreq
$LN3@mg_resolve:

; 1324 :   }
; 1325 : }

  00091	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00096	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  0009b	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0009f	5f		 pop	 rdi
  000a0	c3		 ret	 0
mg_resolve ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_call
_TEXT	SEGMENT
c$ = 48
ev$ = 56
ev_data$ = 64
mg_call	PROC						; COMDAT

; 1336 : void mg_call(struct mg_connection *c, int ev, void *ev_data) {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1337 : #if MG_ENABLE_PROFILE
; 1338 :   const char *names[] = {
; 1339 :       "EV_ERROR",    "EV_OPEN",      "EV_POLL",      "EV_RESOLVE",
; 1340 :       "EV_CONNECT",  "EV_ACCEPT",    "EV_TLS_HS",    "EV_READ",
; 1341 :       "EV_WRITE",    "EV_CLOSE",     "EV_HTTP_MSG",  "EV_HTTP_CHUNK",
; 1342 :       "EV_WS_OPEN",  "EV_WS_MSG",    "EV_WS_CTL",    "EV_MQTT_CMD",
; 1343 :       "EV_MQTT_MSG", "EV_MQTT_OPEN", "EV_SNTP_TIME", "EV_USER"};
; 1344 :   if (ev != MG_EV_POLL && ev < (int) (sizeof(names) / sizeof(names[0]))) {
; 1345 :     MG_PROF_ADD(c, names[ev]);
; 1346 :   }
; 1347 : #endif
; 1348 :   // Fire protocol handler first, user handler second. See #2559
; 1349 :   if (c->pfn != NULL) c->pfn(c, ev, ev_data);

  0000f	48 8b 81 d8 00
	00 00		 mov	 rax, QWORD PTR [rcx+216]
  00016	49 8b f8	 mov	 rdi, r8
  00019	8b f2		 mov	 esi, edx
  0001b	48 8b d9	 mov	 rbx, rcx
  0001e	48 85 c0	 test	 rax, rax
  00021	74 02		 je	 SHORT $LN2@mg_call
  00023	ff d0		 call	 rax
$LN2@mg_call:

; 1350 :   if (c->fn != NULL) c->fn(c, ev, ev_data);

  00025	48 8b 83 c8 00
	00 00		 mov	 rax, QWORD PTR [rbx+200]
  0002c	48 85 c0	 test	 rax, rax
  0002f	74 0a		 je	 SHORT $LN3@mg_call
  00031	4c 8b c7	 mov	 r8, rdi
  00034	8b d6		 mov	 edx, esi
  00036	48 8b cb	 mov	 rcx, rbx
  00039	ff d0		 call	 rax
$LN3@mg_call:

; 1351 : }

  0003b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00040	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5f		 pop	 rdi
  0004a	c3		 ret	 0
mg_call	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_error
_TEXT	SEGMENT
ap$ = 32
buf$ = 48
c$ = 128
fmt$ = 136
mg_error PROC						; COMDAT

; 1353 : void mg_error(struct mg_connection *c, const char *fmt, ...) {

$LN8:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 53 10	 mov	 QWORD PTR [r11+16], rdx
  00007	4d 89 43 18	 mov	 QWORD PTR [r11+24], r8
  0000b	4d 89 4b 20	 mov	 QWORD PTR [r11+32], r9
  0000f	53		 push	 rbx
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8b d9	 mov	 rbx, rcx

; 1354 :   char buf[64];
; 1355 :   va_list ap;
; 1356 :   va_start(ap, fmt);

  00017	49 8d 43 18	 lea	 rax, QWORD PTR [r11+24]

; 1357 :   mg_vsnprintf(buf, sizeof(buf), fmt, &ap);

  0001b	4c 8b c2	 mov	 r8, rdx
  0001e	49 89 43 a8	 mov	 QWORD PTR [r11-88], rax
  00022	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00027	49 8d 4b b8	 lea	 rcx, QWORD PTR [r11-72]
  0002b	4d 8d 4b a8	 lea	 r9, QWORD PTR [r11-88]
  0002f	e8 00 00 00 00	 call	 mg_vsnprintf

; 1358 :   va_end(ap);

  00034	48 83 64 24 20
	00		 and	 QWORD PTR ap$[rsp], 0

; 1359 :   MG_ERROR(("%lu %ld %s", c->id, c->fd, buf));

  0003a	b9 01 00 00 00	 mov	 ecx, 1
  0003f	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  00045	7c 2a		 jl	 SHORT $LN2@mg_error
  00047	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_08PPPGGPGG@mg_error@
  0004e	41 b8 4f 05 00
	00		 mov	 r8d, 1359		; 0000054fH
  00054	e8 00 00 00 00	 call	 mg_log_prefix
  00059	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  0005d	4c 8d 4c 24 30	 lea	 r9, QWORD PTR buf$[rsp]
  00062	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@PPINGECD@?$CFlu?5?$CFld?5?$CFs@
  0006c	e8 00 00 00 00	 call	 mg_log
$LN2@mg_error:

; 1360 :   c->is_closing = 1;             // Set is_closing before sending MG_EV_CALL

  00071	0f ba ab 10 01
	00 00 0d	 bts	 DWORD PTR [rbx+272], 13

; 1361 :   mg_call(c, MG_EV_ERROR, buf);  // Let user handler override it

  00079	4c 8d 44 24 30	 lea	 r8, QWORD PTR buf$[rsp]
  0007e	33 d2		 xor	 edx, edx
  00080	48 8b cb	 mov	 rcx, rbx
  00083	e8 00 00 00 00	 call	 mg_call

; 1362 : }

  00088	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0008c	5b		 pop	 rbx
  0008d	c3		 ret	 0
mg_error ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT is_digit
_TEXT	SEGMENT
c$ = 8
is_digit PROC						; COMDAT

; 1372 :   return c >= '0' && c <= '9';

  00000	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  00003	83 f8 09	 cmp	 eax, 9
  00006	0f 96 c0	 setbe	 al

; 1373 : }

  00009	c3		 ret	 0
is_digit ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT addexp
_TEXT	SEGMENT
buf$ = 8
e$ = 16
sign$ = 24
addexp	PROC						; COMDAT

; 1376 :   int n = 0;
; 1377 :   buf[n++] = 'e';

  00000	c6 01 65	 mov	 BYTE PTR [rcx], 101	; 00000065H
  00003	44 8b ca	 mov	 r9d, edx

; 1378 :   buf[n++] = (char) sign;

  00006	44 88 41 01	 mov	 BYTE PTR [rcx+1], r8b
  0000a	4c 8b d1	 mov	 r10, rcx

; 1379 :   if (e > 400) return 0;

  0000d	81 fa 90 01 00
	00		 cmp	 edx, 400		; 00000190H
  00013	7e 03		 jle	 SHORT $LN2@addexp
  00015	33 c0		 xor	 eax, eax

; 1384 :   return n;
; 1385 : }

  00017	c3		 ret	 0
$LN2@addexp:

; 1380 :   if (e < 10) buf[n++] = '0';

  00018	41 83 f9 0a	 cmp	 r9d, 10
  0001c	7d 0c		 jge	 SHORT $LN3@addexp
  0001e	c6 41 02 30	 mov	 BYTE PTR [rcx+2], 48	; 00000030H
  00022	41 b8 03 00 00
	00		 mov	 r8d, 3
  00028	eb 54		 jmp	 SHORT $LN5@addexp
$LN3@addexp:

; 1381 :   if (e >= 100) buf[n++] = (char) (e / 100 + '0'), e -= 100 * (e / 100);

  0002a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00030	41 83 f9 64	 cmp	 r9d, 100		; 00000064H
  00034	7c 23		 jl	 SHORT $LN7@addexp
  00036	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0003b	41 b8 03 00 00
	00		 mov	 r8d, 3
  00041	41 f7 e1	 mul	 r9d
  00044	c1 ea 05	 shr	 edx, 5
  00047	8d 42 30	 lea	 eax, DWORD PTR [rdx+48]
  0004a	88 41 02	 mov	 BYTE PTR [rcx+2], al
  0004d	6b c2 9c	 imul	 eax, edx, -100		; ffffffffffffff9cH
  00050	44 03 c8	 add	 r9d, eax

; 1382 :   if (e >= 10) buf[n++] = (char) (e / 10 + '0'), e -= 10 * (e / 10);

  00053	41 83 f9 0a	 cmp	 r9d, 10
  00057	7c 25		 jl	 SHORT $LN5@addexp
$LN7@addexp:
  00059	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0005e	41 f7 e9	 imul	 r9d
  00061	c1 fa 02	 sar	 edx, 2
  00064	8b c2		 mov	 eax, edx
  00066	c1 e8 1f	 shr	 eax, 31
  00069	03 d0		 add	 edx, eax
  0006b	41 8b c0	 mov	 eax, r8d
  0006e	41 ff c0	 inc	 r8d
  00071	8d 4a 30	 lea	 ecx, DWORD PTR [rdx+48]
  00074	42 88 0c 10	 mov	 BYTE PTR [rax+r10], cl
  00078	6b c2 f6	 imul	 eax, edx, -10
  0007b	44 03 c8	 add	 r9d, eax
$LN5@addexp:

; 1383 :   buf[n++] = (char) (e + '0');

  0007e	41 8b c0	 mov	 eax, r8d
  00081	41 80 c1 30	 add	 r9b, 48			; 00000030H
  00085	46 88 0c 10	 mov	 BYTE PTR [rax+r10], r9b
  00089	41 8d 40 01	 lea	 eax, DWORD PTR [r8+1]

; 1384 :   return n;
; 1385 : }

  0008d	c3		 ret	 0
addexp	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT xisinf
_TEXT	SEGMENT
ieee754$ = 8
x$ = 8
xisinf	PROC						; COMDAT

; 1388 :   union {
; 1389 :     double f;
; 1390 :     uint64_t u;
; 1391 :   } ieee754 = {x};

  00000	f2 0f 11 44 24
	08		 movsd	 QWORD PTR ieee754$[rsp], xmm0

; 1392 :   return ((unsigned) (ieee754.u >> 32) & 0x7fffffff) == 0x7ff00000 &&

  00006	33 c9		 xor	 ecx, ecx
  00008	48 8b 44 24 08	 mov	 rax, QWORD PTR ieee754$[rsp]
  0000d	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00011	0f ba f0 1f	 btr	 eax, 31
  00015	3d 00 00 f0 7f	 cmp	 eax, 2146435072		; 7ff00000H
  0001a	75 0b		 jne	 SHORT $LN4@xisinf
  0001c	39 4c 24 08	 cmp	 DWORD PTR ieee754$[rsp], ecx
  00020	75 05		 jne	 SHORT $LN4@xisinf
  00022	b9 01 00 00 00	 mov	 ecx, 1
$LN4@xisinf:
  00027	8b c1		 mov	 eax, ecx

; 1393 :          ((unsigned) ieee754.u == 0);
; 1394 : }

  00029	c3		 ret	 0
xisinf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT xisnan
_TEXT	SEGMENT
ieee754$ = 8
x$ = 8
xisnan	PROC						; COMDAT

; 1397 :   union {
; 1398 :     double f;
; 1399 :     uint64_t u;
; 1400 :   } ieee754 = {x};
; 1401 :   return ((unsigned) (ieee754.u >> 32) & 0x7fffffff) +

  00000	33 c0		 xor	 eax, eax
  00002	f2 0f 11 44 24
	08		 movsd	 QWORD PTR ieee754$[rsp], xmm0
  00008	48 8b 54 24 08	 mov	 rdx, QWORD PTR ieee754$[rsp]
  0000d	8b c8		 mov	 ecx, eax
  0000f	48 c1 ea 20	 shr	 rdx, 32			; 00000020H
  00013	0f ba f2 1f	 btr	 edx, 31
  00017	39 44 24 08	 cmp	 DWORD PTR ieee754$[rsp], eax
  0001b	0f 95 c1	 setne	 cl
  0001e	03 d1		 add	 edx, ecx
  00020	81 fa 00 00 f0
	7f		 cmp	 edx, 2146435072		; 7ff00000H
  00026	0f 97 c0	 seta	 al

; 1402 :              ((unsigned) ieee754.u != 0) >
; 1403 :          0x7ff00000;
; 1404 : }

  00029	c3		 ret	 0
xisnan	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_dtoa
_TEXT	SEGMENT
buf$ = 48
dst$ = 112
dstlen$dead$ = 120
ieee754$1 = 120
d$ = 128
width$ = 136
tz$ = 144
mg_dtoa	PROC						; COMDAT

; 1406 : static size_t mg_dtoa(char *dst, size_t dstlen, double d, int width, bool tz) {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 70 08	 mov	 QWORD PTR [rax+8], rsi
  00007	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000b	4c 89 70 20	 mov	 QWORD PTR [rax+32], r14
  0000f	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  00013	55		 push	 rbp
  00014	48 8b ec	 mov	 rbp, rsp
  00017	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 1407 :   char buf[40];
; 1408 :   int i, s = 0, n = 0, e = 0;

  0001b	45 33 c0	 xor	 r8d, r8d
  0001e	33 f6		 xor	 esi, esi
  00020	0f 57 c9	 xorps	 xmm1, xmm1
  00023	4c 8b f1	 mov	 r14, rcx

; 1409 :   double t, mul, saved;
; 1410 :   if (d == 0.0) return mg_snprintf(dst, dstlen, "%s", "0");

  00026	66 0f 2e d1	 ucomisd xmm2, xmm1
  0002a	0f 28 da	 movaps	 xmm3, xmm2
  0002d	7a 0e		 jp	 SHORT $LN23@mg_dtoa
  0002f	75 0c		 jne	 SHORT $LN23@mg_dtoa
  00031	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01GBGANLPD@0@
  00038	e9 1c 03 00 00	 jmp	 $LN87@mg_dtoa
$LN23@mg_dtoa:

; 1411 :   if (xisinf(d)) return mg_snprintf(dst, dstlen, "%s", d > 0 ? "inf" : "-inf");

  0003d	0f 28 c2	 movaps	 xmm0, xmm2
  00040	e8 00 00 00 00	 call	 xisinf
  00045	85 c0		 test	 eax, eax
  00047	74 1b		 je	 SHORT $LN24@mg_dtoa
  00049	66 0f 2f d1	 comisd	 xmm2, xmm1
  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03OJHLLCGB@inf@
  00054	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_04DHEMHBNF@?9inf@
  0005b	4c 0f 47 c8	 cmova	 r9, rax
  0005f	e9 f2 02 00 00	 jmp	 $LN88@mg_dtoa
$LN24@mg_dtoa:

; 1401 :   return ((unsigned) (ieee754.u >> 32) & 0x7fffffff) +

  00064	33 c9		 xor	 ecx, ecx
  00066	f2 0f 11 55 18	 movsd	 QWORD PTR ieee754$1[rbp-96], xmm2
  0006b	48 8b 45 18	 mov	 rax, QWORD PTR ieee754$1[rbp-96]
  0006f	48 8b d0	 mov	 rdx, rax
  00072	48 c1 ea 20	 shr	 rdx, 32			; 00000020H
  00076	0f ba f2 1f	 btr	 edx, 31
  0007a	85 c0		 test	 eax, eax
  0007c	0f 95 c1	 setne	 cl
  0007f	03 d1		 add	 edx, ecx
  00081	81 fa 00 00 f0
	7f		 cmp	 edx, 2146435072		; 7ff00000H

; 1412 :   if (xisnan(d)) return mg_snprintf(dst, dstlen, "%s", "nan");

  00087	76 0c		 jbe	 SHORT $LN25@mg_dtoa
  00089	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_03LHCJEHON@nan@
  00090	e9 c1 02 00 00	 jmp	 $LN88@mg_dtoa
$LN25@mg_dtoa:

; 1413 :   if (d < 0.0) d = -d, buf[s++] = '-';

  00095	66 0f 2f ca	 comisd	 xmm1, xmm2
  00099	76 0b		 jbe	 SHORT $LN26@mg_dtoa
  0009b	0f 57 15 00 00
	00 00		 xorps	 xmm2, QWORD PTR __xmm@80000000000000008000000000000000
  000a2	c6 45 d0 2d	 mov	 BYTE PTR buf$[rbp-96], 45 ; 0000002dH
$LN26@mg_dtoa:

; 1414 : 
; 1415 :   // Round
; 1416 :   saved = d;
; 1417 :   mul = 1.0;

  000a6	f2 0f 10 25 00
	00 00 00	 movsd	 xmm4, QWORD PTR __real@3ff0000000000000
  000ae	33 ff		 xor	 edi, edi
  000b0	66 0f 2f cb	 comisd	 xmm1, xmm3

; 1418 :   while (d >= 10.0 && d / mul >= 10.0) mul *= 10.0;

  000b4	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@4024000000000000
  000bc	0f 28 ea	 movaps	 xmm5, xmm2
  000bf	0f 28 cc	 movaps	 xmm1, xmm4
  000c2	40 0f 97 c7	 seta	 dil
  000c6	66 0f 2f d3	 comisd	 xmm2, xmm3
  000ca	72 13		 jb	 SHORT $LN41@mg_dtoa
$LL2@mg_dtoa:
  000cc	0f 28 c2	 movaps	 xmm0, xmm2
  000cf	f2 0f 5e c1	 divsd	 xmm0, xmm1
  000d3	66 0f 2f c3	 comisd	 xmm0, xmm3
  000d7	72 06		 jb	 SHORT $LN41@mg_dtoa
  000d9	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  000dd	eb ed		 jmp	 SHORT $LL2@mg_dtoa
$LN41@mg_dtoa:

; 1419 :   while (d <= 1.0 && d / mul <= 1.0) mul /= 10.0;

  000df	66 0f 2f e2	 comisd	 xmm4, xmm2
  000e3	72 13		 jb	 SHORT $LN5@mg_dtoa
$LL4@mg_dtoa:
  000e5	0f 28 c2	 movaps	 xmm0, xmm2
  000e8	f2 0f 5e c1	 divsd	 xmm0, xmm1
  000ec	66 0f 2f e0	 comisd	 xmm4, xmm0
  000f0	72 06		 jb	 SHORT $LN5@mg_dtoa
  000f2	f2 0f 5e cb	 divsd	 xmm1, xmm3
  000f6	eb ed		 jmp	 SHORT $LL4@mg_dtoa
$LN5@mg_dtoa:

; 1420 :   for (i = 0, t = mul * 5; i < width; i++) t /= 10.0;

  000f8	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@4014000000000000
  00100	45 85 c9	 test	 r9d, r9d
  00103	7e 0d		 jle	 SHORT $LN7@mg_dtoa
  00105	41 8b c1	 mov	 eax, r9d
$LL58@mg_dtoa:
  00108	f2 0f 5e cb	 divsd	 xmm1, xmm3
  0010c	48 83 e8 01	 sub	 rax, 1
  00110	75 f6		 jne	 SHORT $LL58@mg_dtoa
$LN7@mg_dtoa:

; 1421 :   d += t;

  00112	f2 0f 58 d1	 addsd	 xmm2, xmm1

; 1422 :   // Calculate exponent, and 'mul' for scientific representation
; 1423 :   mul = 1.0;

  00116	0f 28 cc	 movaps	 xmm1, xmm4

; 1424 :   while (d >= 10.0 && d / mul >= 10.0) mul *= 10.0, e++;

  00119	66 0f 2f d3	 comisd	 xmm2, xmm3
  0011d	72 15		 jb	 SHORT $LN44@mg_dtoa
$LL9@mg_dtoa:
  0011f	0f 28 c2	 movaps	 xmm0, xmm2
  00122	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00126	66 0f 2f c3	 comisd	 xmm0, xmm3
  0012a	72 08		 jb	 SHORT $LN44@mg_dtoa
  0012c	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  00130	ff c6		 inc	 esi
  00132	eb eb		 jmp	 SHORT $LL9@mg_dtoa
$LN44@mg_dtoa:

; 1425 :   while (d < 1.0 && d / mul < 1.0) mul /= 10.0, e--;

  00134	66 0f 2f e2	 comisd	 xmm4, xmm2
  00138	76 15		 jbe	 SHORT $LN12@mg_dtoa
$LL11@mg_dtoa:
  0013a	0f 28 c2	 movaps	 xmm0, xmm2
  0013d	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00141	66 0f 2f e0	 comisd	 xmm4, xmm0
  00145	76 08		 jbe	 SHORT $LN12@mg_dtoa
  00147	f2 0f 5e cb	 divsd	 xmm1, xmm3
  0014b	ff ce		 dec	 esi
  0014d	eb eb		 jmp	 SHORT $LL11@mg_dtoa
$LN12@mg_dtoa:

; 1426 :   // printf(" --> %g %d %g %g\n", saved, e, t, mul);
; 1427 : 
; 1428 :   if (e >= width && width > 1) {

  0014f	41 3b f1	 cmp	 esi, r9d
  00152	7c 68		 jl	 SHORT $LN27@mg_dtoa
  00154	41 83 f9 01	 cmp	 r9d, 1
  00158	7e 62		 jle	 SHORT $LN27@mg_dtoa

; 1429 :     n = (int) mg_dtoa(buf, sizeof(buf), saved / mul, width, tz);

  0015a	8a 45 30	 mov	 al, BYTE PTR tz$[rbp-96]
  0015d	48 8d 4d d0	 lea	 rcx, QWORD PTR buf$[rbp-96]
  00161	f2 0f 5e e9	 divsd	 xmm5, xmm1
  00165	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0016a	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  0016e	0f 28 d5	 movaps	 xmm2, xmm5
  00171	e8 00 00 00 00	 call	 mg_dtoa

; 1430 :     // printf(" --> %.*g %d [%.*s]\n", 10, d / t, e, n, buf);
; 1431 :     n += addexp(buf + s + n, e, '+');

  00176	48 63 c8	 movsxd	 rcx, eax
  00179	4c 8b d8	 mov	 r11, rax
  0017c	44 8b c7	 mov	 r8d, edi
  0017f	4c 03 c1	 add	 r8, rcx
  00182	48 8d 4d d0	 lea	 rcx, QWORD PTR buf$[rbp-96]
  00186	49 03 c8	 add	 rcx, r8
  00189	41 b8 2b 00 00
	00		 mov	 r8d, 43			; 0000002bH
$LN89@mg_dtoa:

; 1463 : }

  0018f	8b d6		 mov	 edx, esi
  00191	e8 00 00 00 00	 call	 addexp
  00196	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04EBNJJJJI@?$CF?4?$CKs@
  0019d	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  001a2	49 8b ce	 mov	 rcx, r14
  001a5	46 8d 0c 18	 lea	 r9d, DWORD PTR [rax+r11]
  001a9	48 8d 45 d0	 lea	 rax, QWORD PTR buf$[rbp-96]
  001ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b2	e8 00 00 00 00	 call	 mg_snprintf
  001b7	e9 ae 01 00 00	 jmp	 $LN1@mg_dtoa
$LN27@mg_dtoa:

; 1432 :     return mg_snprintf(dst, dstlen, "%.*s", n, buf);
; 1433 :   } else if (e <= -width && width > 1) {

  001bc	41 8b c1	 mov	 eax, r9d
  001bf	f7 d8		 neg	 eax
  001c1	3b f0		 cmp	 esi, eax
  001c3	7f 3e		 jg	 SHORT $LN29@mg_dtoa
  001c5	41 83 f9 01	 cmp	 r9d, 1
  001c9	7e 38		 jle	 SHORT $LN29@mg_dtoa

; 1434 :     n = (int) mg_dtoa(buf, sizeof(buf), saved / mul, width, tz);

  001cb	8a 45 30	 mov	 al, BYTE PTR tz$[rbp-96]
  001ce	48 8d 4d d0	 lea	 rcx, QWORD PTR buf$[rbp-96]
  001d2	f2 0f 5e e9	 divsd	 xmm5, xmm1
  001d6	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  001db	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001df	0f 28 d5	 movaps	 xmm2, xmm5
  001e2	e8 00 00 00 00	 call	 mg_dtoa

; 1435 :     // printf(" --> %.*g %d [%.*s]\n", 10, d / mul, e, n, buf);
; 1436 :     n += addexp(buf + s + n, -e, '-');

  001e7	48 63 d0	 movsxd	 rdx, eax
  001ea	4c 8b d8	 mov	 r11, rax
  001ed	8b cf		 mov	 ecx, edi
  001ef	48 8d 45 d0	 lea	 rax, QWORD PTR buf$[rbp-96]
  001f3	48 03 ca	 add	 rcx, rdx
  001f6	f7 de		 neg	 esi
  001f8	48 03 c8	 add	 rcx, rax
  001fb	41 b8 2d 00 00
	00		 mov	 r8d, 45			; 0000002dH

; 1437 :     return mg_snprintf(dst, dstlen, "%.*s", n, buf);

  00201	eb 8c		 jmp	 SHORT $LN89@mg_dtoa
$LN29@mg_dtoa:

; 1438 :   } else {
; 1439 :     for (i = 0, t = mul; t >= 1.0 && s + n < (int) sizeof(buf); i++) {

  00203	66 0f 2f cc	 comisd	 xmm1, xmm4
  00207	44 8b df	 mov	 r11d, edi
  0020a	72 54		 jb	 SHORT $LN78@mg_dtoa
  0020c	33 c9		 xor	 ecx, ecx
  0020e	48 8d 75 d0	 lea	 rsi, QWORD PTR buf$[rbp-96]
  00212	49 03 f3	 add	 rsi, r11
  00215	44 8b d7	 mov	 r10d, edi
$LL15@mg_dtoa:
  00218	41 83 fa 28	 cmp	 r10d, 40		; 00000028H
  0021c	7d 3d		 jge	 SHORT $LN14@mg_dtoa

; 1440 :       int ch = (int) (d / t);

  0021e	0f 28 c2	 movaps	 xmm0, xmm2
  00221	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00225	f2 0f 2c d0	 cvttsd2si edx, xmm0

; 1441 :       if (n > 0 || ch > 0) buf[s + n++] = (char) (ch + '0');

  00229	48 85 c9	 test	 rcx, rcx
  0022c	7f 04		 jg	 SHORT $LN32@mg_dtoa
  0022e	85 d2		 test	 edx, edx
  00230	7e 0f		 jle	 SHORT $LN31@mg_dtoa
$LN32@mg_dtoa:
  00232	8d 42 30	 lea	 eax, DWORD PTR [rdx+48]
  00235	41 ff c0	 inc	 r8d
  00238	41 ff c2	 inc	 r10d
  0023b	88 04 0e	 mov	 BYTE PTR [rsi+rcx], al
  0023e	48 ff c1	 inc	 rcx
$LN31@mg_dtoa:

; 1442 :       d -= ch * t;

  00241	66 0f 6e c2	 movd	 xmm0, edx
  00245	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00249	f2 0f 59 c1	 mulsd	 xmm0, xmm1

; 1443 :       t /= 10.0;

  0024d	f2 0f 5e cb	 divsd	 xmm1, xmm3
  00251	f2 0f 5c d0	 subsd	 xmm2, xmm0
  00255	66 0f 2f cc	 comisd	 xmm1, xmm4
  00259	73 bd		 jae	 SHORT $LL15@mg_dtoa
$LN14@mg_dtoa:

; 1444 :     }
; 1445 :     // printf(" --> [%g] -> %g %g (%d) [%.*s]\n", saved, d, t, n, s + n, buf);
; 1446 :     if (n == 0) buf[s++] = '0';

  0025b	45 85 c0	 test	 r8d, r8d
  0025e	75 08		 jne	 SHORT $LN46@mg_dtoa
$LN78@mg_dtoa:
  00260	42 c6 44 1d d0
	30		 mov	 BYTE PTR buf$[rbp+r11-96], 48 ; 00000030H
  00266	ff c7		 inc	 edi
$LN46@mg_dtoa:

; 1447 :     while (t >= 1.0 && n + s < (int) sizeof(buf)) buf[n++] = '0', t /= 10.0;

  00268	66 0f 2f cc	 comisd	 xmm1, xmm4
  0026c	72 28		 jb	 SHORT $LN17@mg_dtoa
  0026e	49 63 c0	 movsxd	 rax, r8d
  00271	48 8d 4d d0	 lea	 rcx, QWORD PTR buf$[rbp-96]
  00275	48 03 c8	 add	 rcx, rax
  00278	41 8d 04 38	 lea	 eax, DWORD PTR [r8+rdi]
$LL16@mg_dtoa:
  0027c	83 f8 28	 cmp	 eax, 40			; 00000028H
  0027f	7d 15		 jge	 SHORT $LN17@mg_dtoa
  00281	f2 0f 5e cb	 divsd	 xmm1, xmm3
  00285	c6 01 30	 mov	 BYTE PTR [rcx], 48	; 00000030H
  00288	41 ff c0	 inc	 r8d
  0028b	ff c0		 inc	 eax
  0028d	48 ff c1	 inc	 rcx
  00290	66 0f 2f cc	 comisd	 xmm1, xmm4
  00294	73 e6		 jae	 SHORT $LL16@mg_dtoa
$LN17@mg_dtoa:

; 1448 :     if (s + n < (int) sizeof(buf)) buf[n + s++] = '.';

  00296	41 8d 04 38	 lea	 eax, DWORD PTR [r8+rdi]
  0029a	83 f8 28	 cmp	 eax, 40			; 00000028H
  0029d	7d 09		 jge	 SHORT $LN34@mg_dtoa
  0029f	48 98		 cdqe
  002a1	ff c7		 inc	 edi
  002a3	c6 44 05 d0 2e	 mov	 BYTE PTR buf$[rbp+rax-96], 46 ; 0000002eH
$LN34@mg_dtoa:

; 1449 :     // printf(" 1--> [%g] -> [%.*s]\n", saved, s + n, buf);
; 1450 :     for (i = 0, t = 0.1; s + n < (int) sizeof(buf) && n < width; i++) {

  002a8	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3fb999999999999a
  002b0	45 8d 14 38	 lea	 r10d, DWORD PTR [r8+rdi]
  002b4	44 8b df	 mov	 r11d, edi
  002b7	41 83 fa 28	 cmp	 r10d, 40		; 00000028H
  002bb	7d 46		 jge	 SHORT $LN48@mg_dtoa
  002bd	48 8d 75 d0	 lea	 rsi, QWORD PTR buf$[rbp-96]
  002c1	49 63 d0	 movsxd	 rdx, r8d
  002c4	49 03 f3	 add	 rsi, r11
  002c7	4d 63 c9	 movsxd	 r9, r9d
$LL20@mg_dtoa:
  002ca	49 3b d1	 cmp	 rdx, r9
  002cd	7d 34		 jge	 SHORT $LN48@mg_dtoa

; 1451 :       int ch = (int) (d / t);

  002cf	0f 28 c2	 movaps	 xmm0, xmm2

; 1452 :       buf[s + n++] = (char) (ch + '0');

  002d2	41 ff c0	 inc	 r8d
  002d5	f2 0f 5e c1	 divsd	 xmm0, xmm1
  002d9	41 ff c2	 inc	 r10d
  002dc	f2 0f 2c c8	 cvttsd2si ecx, xmm0
  002e0	66 0f 6e c1	 movd	 xmm0, ecx
  002e4	8d 41 30	 lea	 eax, DWORD PTR [rcx+48]

; 1453 :       d -= ch * t;

  002e7	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  002eb	88 04 16	 mov	 BYTE PTR [rsi+rdx], al
  002ee	48 ff c2	 inc	 rdx
  002f1	f2 0f 59 c1	 mulsd	 xmm0, xmm1

; 1454 :       t /= 10.0;

  002f5	f2 0f 5e cb	 divsd	 xmm1, xmm3
  002f9	f2 0f 5c d0	 subsd	 xmm2, xmm0
  002fd	41 83 fa 28	 cmp	 r10d, 40		; 00000028H
  00301	7c c7		 jl	 SHORT $LL20@mg_dtoa
$LN48@mg_dtoa:

; 1455 :     }
; 1456 :   }
; 1457 :   while (tz && n > 0 && buf[s + n - 1] == '0') n--;  // Trim trailing zeroes

  00303	80 7d 30 00	 cmp	 BYTE PTR tz$[rbp-96], 0
  00307	74 1b		 je	 SHORT $LN22@mg_dtoa
  00309	49 63 c0	 movsxd	 rax, r8d
  0030c	4a 8d 4c 1d cf	 lea	 rcx, QWORD PTR buf$[rbp+r11-97]
$LL21@mg_dtoa:
  00311	48 85 c0	 test	 rax, rax
  00314	7e 0e		 jle	 SHORT $LN22@mg_dtoa
  00316	80 3c 01 30	 cmp	 BYTE PTR [rcx+rax], 48	; 00000030H
  0031a	75 08		 jne	 SHORT $LN22@mg_dtoa
  0031c	41 ff c8	 dec	 r8d
  0031f	48 ff c8	 dec	 rax
  00322	eb ed		 jmp	 SHORT $LL21@mg_dtoa
$LN22@mg_dtoa:

; 1458 :   if (n > 0 && buf[s + n - 1] == '.') n--;           // Trim trailing dot

  00324	45 85 c0	 test	 r8d, r8d
  00327	7e 11		 jle	 SHORT $LN35@mg_dtoa
  00329	41 8d 04 38	 lea	 eax, DWORD PTR [r8+rdi]
  0032d	48 63 c8	 movsxd	 rcx, eax
  00330	80 7c 0d cf 2e	 cmp	 BYTE PTR buf$[rbp+rcx-97], 46 ; 0000002eH
  00335	75 03		 jne	 SHORT $LN35@mg_dtoa
  00337	41 ff c8	 dec	 r8d
$LN35@mg_dtoa:

; 1459 :   n += s;

  0033a	44 03 c7	 add	 r8d, edi

; 1460 :   if (n >= (int) sizeof(buf)) n = (int) sizeof(buf) - 1;
; 1461 :   buf[n] = '\0';
; 1462 :   return mg_snprintf(dst, dstlen, "%s", buf);

  0033d	4c 8d 4d d0	 lea	 r9, QWORD PTR buf$[rbp-96]
  00341	b8 27 00 00 00	 mov	 eax, 39			; 00000027H
  00346	41 83 f8 28	 cmp	 r8d, 40			; 00000028H
  0034a	44 0f 4d c0	 cmovge	 r8d, eax
  0034e	49 63 c0	 movsxd	 rax, r8d
  00351	c6 44 05 d0 00	 mov	 BYTE PTR buf$[rbp+rax-96], 0
$LN88@mg_dtoa:

; 1463 : }

  00356	49 8b ce	 mov	 rcx, r14
$LN87@mg_dtoa:
  00359	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00360	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00365	e8 00 00 00 00	 call	 mg_snprintf
$LN1@mg_dtoa:
  0036a	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  0036f	49 8b 73 10	 mov	 rsi, QWORD PTR [r11+16]
  00373	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  00377	4d 8b 73 28	 mov	 r14, QWORD PTR [r11+40]
  0037b	49 8b e3	 mov	 rsp, r11
  0037e	5d		 pop	 rbp
  0037f	c3		 ret	 0
mg_dtoa	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_lld
_TEXT	SEGMENT
buf$ = 8
val$ = 16
is_signed$ = 24
is_hex$ = 32
mg_lld	PROC						; COMDAT

; 1465 : static size_t mg_lld(char *buf, int64_t val, bool is_signed, bool is_hex) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi

; 1466 :   const char *letters = "0123456789abcdef";
; 1467 :   uint64_t v = (uint64_t) val;
; 1468 :   size_t s = 0, n, i;

  0000a	45 33 db	 xor	 r11d, r11d
  0000d	48 8b fa	 mov	 rdi, rdx
  00010	48 8b d9	 mov	 rbx, rcx
  00013	4c 8b d2	 mov	 r10, rdx

; 1469 :   if (is_signed && val < 0) buf[s++] = '-', v = (uint64_t) (-val);

  00016	45 84 c0	 test	 r8b, r8b
  00019	74 11		 je	 SHORT $LN11@mg_lld
  0001b	48 85 d2	 test	 rdx, rdx
  0001e	79 0c		 jns	 SHORT $LN11@mg_lld
  00020	c6 01 2d	 mov	 BYTE PTR [rcx], 45	; 0000002dH
  00023	41 bb 01 00 00
	00		 mov	 r11d, 1
  00029	49 f7 da	 neg	 r10
$LN11@mg_lld:

; 1470 :   // This loop prints a number in reverse order. I guess this is because we
; 1471 :   // write numbers from right to left: least significant digit comes last.
; 1472 :   // Maybe because we use Arabic numbers, and Arabs write RTL?
; 1473 :   if (is_hex) {

  0002c	45 33 c0	 xor	 r8d, r8d
  0002f	45 84 c9	 test	 r9b, r9b
  00032	74 2c		 je	 SHORT $LN12@mg_lld

; 1474 :     for (n = 0; v; v >>= 4) buf[s + n++] = letters[v & 15];

  00034	4d 85 d2	 test	 r10, r10
  00037	74 65		 je	 SHORT $LN6@mg_lld
  00039	49 03 cb	 add	 rcx, r11
  0003c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BB@JCEFLFJE@0123456789abcdef@
$LL4@mg_lld:
  00043	49 8b c2	 mov	 rax, r10
  00046	49 ff c0	 inc	 r8
  00049	83 e0 0f	 and	 eax, 15
  0004c	49 c1 ea 04	 shr	 r10, 4
  00050	42 8a 04 08	 mov	 al, BYTE PTR [rax+r9]
  00054	88 01		 mov	 BYTE PTR [rcx], al
  00056	48 ff c1	 inc	 rcx
  00059	4d 85 d2	 test	 r10, r10
  0005c	75 e5		 jne	 SHORT $LL4@mg_lld
  0005e	eb 3e		 jmp	 SHORT $LN6@mg_lld
$LN12@mg_lld:

; 1475 :   } else {
; 1476 :     for (n = 0; v; v /= 10) buf[s + n++] = letters[v % 10];

  00060	4d 85 d2	 test	 r10, r10
  00063	74 39		 je	 SHORT $LN6@mg_lld
  00065	49 03 cb	 add	 rcx, r11
  00068	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BB@JCEFLFJE@0123456789abcdef@
$LL7@mg_lld:
  0006f	48 b8 cd cc cc
	cc cc cc cc cc	 mov	 rax, -3689348814741910323 ; cccccccccccccccdH
  00079	49 ff c0	 inc	 r8
  0007c	49 f7 e2	 mul	 r10
  0007f	48 c1 ea 03	 shr	 rdx, 3
  00083	48 8d 04 92	 lea	 rax, QWORD PTR [rdx+rdx*4]
  00087	48 03 c0	 add	 rax, rax
  0008a	4c 2b d0	 sub	 r10, rax
  0008d	43 8a 04 0a	 mov	 al, BYTE PTR [r10+r9]
  00091	4c 8b d2	 mov	 r10, rdx
  00094	88 01		 mov	 BYTE PTR [rcx], al
  00096	48 ff c1	 inc	 rcx
  00099	48 85 d2	 test	 rdx, rdx
  0009c	75 d1		 jne	 SHORT $LL7@mg_lld
$LN6@mg_lld:

; 1477 :   }
; 1478 :   // Reverse a string
; 1479 :   for (i = 0; i < n / 2; i++) {

  0009e	49 8b d0	 mov	 rdx, r8
  000a1	48 d1 ea	 shr	 rdx, 1
  000a4	74 26		 je	 SHORT $LN9@mg_lld
  000a6	4d 8d 53 ff	 lea	 r10, QWORD PTR [r11-1]
  000aa	4d 03 d0	 add	 r10, r8
  000ad	4d 8d 0c 1b	 lea	 r9, QWORD PTR [r11+rbx]
  000b1	4c 03 d3	 add	 r10, rbx
$LL10@mg_lld:

; 1480 :     char t = buf[s + i];
; 1481 :     buf[s + i] = buf[s + n - i - 1], buf[s + n - i - 1] = t;

  000b4	41 8a 02	 mov	 al, BYTE PTR [r10]
  000b7	41 8a 09	 mov	 cl, BYTE PTR [r9]
  000ba	41 88 01	 mov	 BYTE PTR [r9], al
  000bd	49 ff c1	 inc	 r9
  000c0	41 88 0a	 mov	 BYTE PTR [r10], cl
  000c3	49 ff ca	 dec	 r10
  000c6	48 83 ea 01	 sub	 rdx, 1
  000ca	75 e8		 jne	 SHORT $LL10@mg_lld
$LN9@mg_lld:

; 1482 :   }
; 1483 :   if (val == 0) buf[n++] = '0';  // Handle special case

  000cc	48 85 ff	 test	 rdi, rdi
  000cf	75 08		 jne	 SHORT $LN14@mg_lld
  000d1	41 c6 04 18 30	 mov	 BYTE PTR [r8+rbx], 48	; 00000030H
  000d6	49 ff c0	 inc	 r8
$LN14@mg_lld:

; 1484 :   return n + s;
; 1485 : }

  000d9	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  000de	4b 8d 04 18	 lea	 rax, QWORD PTR [r8+r11]
  000e2	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
  000e7	c3		 ret	 0
mg_lld	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT scpy
_TEXT	SEGMENT
out$ = 48
ptr$ = 56
buf$ = 64
len$ = 72
scpy	PROC						; COMDAT

; 1488 :                           size_t len) {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1489 :   size_t i = 0;

  00019	33 db		 xor	 ebx, ebx
  0001b	49 8b f9	 mov	 rdi, r9
  0001e	49 8b f0	 mov	 rsi, r8
  00021	48 8b ea	 mov	 rbp, rdx
  00024	4c 8b f1	 mov	 r14, rcx

; 1490 :   while (i < len && buf[i] != '\0') out(buf[i++], ptr);

  00027	4d 85 c9	 test	 r9, r9
  0002a	74 15		 je	 SHORT $LN3@scpy
$LL2@scpy:
  0002c	8a 0c 33	 mov	 cl, BYTE PTR [rbx+rsi]
  0002f	84 c9		 test	 cl, cl
  00031	74 0e		 je	 SHORT $LN3@scpy
  00033	48 8b d5	 mov	 rdx, rbp
  00036	41 ff d6	 call	 r14
  00039	48 ff c3	 inc	 rbx
  0003c	48 3b df	 cmp	 rbx, rdi
  0003f	72 eb		 jb	 SHORT $LL2@scpy
$LN3@scpy:

; 1491 :   return i;
; 1492 : }

  00041	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00046	48 8b c3	 mov	 rax, rbx
  00049	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004e	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00053	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	41 5e		 pop	 r14
  0005e	c3		 ret	 0
scpy	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_xprintf
_TEXT	SEGMENT
out$ = 64
ptr$ = 72
fmt$ = 80
mg_xprintf PROC						; COMDAT

; 1494 : size_t mg_xprintf(void (*out)(char, void *), void *ptr, const char *fmt, ...) {

$LN4:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	4d 89 43 18	 mov	 QWORD PTR [r11+24], r8
  00007	4d 89 4b 20	 mov	 QWORD PTR [r11+32], r9
  0000b	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1495 :   size_t len = 0;
; 1496 :   va_list ap;
; 1497 :   va_start(ap, fmt);

  0000f	49 8d 43 20	 lea	 rax, QWORD PTR [r11+32]

; 1498 :   len = mg_vxprintf(out, ptr, fmt, &ap);

  00013	4d 8d 4b e8	 lea	 r9, QWORD PTR [r11-24]
  00017	49 89 43 e8	 mov	 QWORD PTR [r11-24], rax
  0001b	e8 00 00 00 00	 call	 mg_vxprintf

; 1499 :   va_end(ap);
; 1500 :   return len;
; 1501 : }

  00020	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00024	c3		 ret	 0
mg_xprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_vxprintf
_TEXT	SEGMENT
pad$1 = 48
pad$1$ = 49
minus$1$ = 50
p$1$ = 56
xl$1$ = 64
tmp$2 = 72
out$ = 176
param$ = 184
fmt$ = 192
ap$ = 200
mg_vxprintf PROC					; COMDAT

; 1504 :                    va_list *ap) {

$LN225:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00007	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  0000b	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00013	55		 push	 rbp
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	41 54		 push	 r12
  00018	41 55		 push	 r13
  0001a	41 56		 push	 r14
  0001c	41 57		 push	 r15
  0001e	48 8b ec	 mov	 rbp, rsp
  00021	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 1505 :   size_t i = 0, n = 0;

  00025	33 f6		 xor	 esi, esi
  00027	33 ff		 xor	 edi, edi
  00029	4d 8b d9	 mov	 r11, r9
  0002c	4d 8b c8	 mov	 r9, r8
  0002f	4c 8b ea	 mov	 r13, rdx
  00032	4c 8b f9	 mov	 r15, rcx

; 1506 :   while (fmt[i] != '\0') {

  00035	41 38 30	 cmp	 BYTE PTR [r8], sil
  00038	0f 84 26 04 00
	00		 je	 $LN3@mg_vxprint
  0003e	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
$LL2@mg_vxprint:

; 1507 :     if (fmt[i] == '%') {

  00043	42 8a 0c 0e	 mov	 cl, BYTE PTR [rsi+r9]
  00047	48 ff c6	 inc	 rsi
  0004a	80 f9 25	 cmp	 cl, 37			; 00000025H
  0004d	0f 85 f0 03 00
	00		 jne	 $LN28@mg_vxprint

; 1508 :       size_t j, k, x = 0, is_long = 0, w = 0 /* width */, pr = ~0U /* prec */;
; 1509 :       char pad = ' ', minus = 0, c = fmt[++i];

  00053	42 8a 1c 0e	 mov	 bl, BYTE PTR [rsi+r9]
  00057	45 32 d2	 xor	 r10b, r10b
  0005a	45 33 c0	 xor	 r8d, r8d
  0005d	44 88 55 c2	 mov	 BYTE PTR minus$1$[rbp-112], r10b
  00061	33 d2		 xor	 edx, edx
  00063	45 33 e4	 xor	 r12d, r12d
  00066	4c 8b f0	 mov	 r14, rax
  00069	b0 20		 mov	 al, 32			; 00000020H
  0006b	88 45 c1	 mov	 BYTE PTR pad$1$[rbp-112], al
  0006e	88 45 c0	 mov	 BYTE PTR pad$1[rbp-112], al

; 1510 :       if (c == '#') x++, c = fmt[++i];

  00071	80 fb 23	 cmp	 bl, 35			; 00000023H
  00074	75 0b		 jne	 SHORT $LN30@mg_vxprint
  00076	48 ff c6	 inc	 rsi
  00079	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]
  0007d	42 8a 1c 0e	 mov	 bl, BYTE PTR [rsi+r9]
$LN30@mg_vxprint:

; 1511 :       if (c == '-') minus++, c = fmt[++i];

  00081	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  00084	75 0e		 jne	 SHORT $LN31@mg_vxprint
  00086	48 ff c6	 inc	 rsi
  00089	41 b2 01	 mov	 r10b, 1
  0008c	44 88 55 c2	 mov	 BYTE PTR minus$1$[rbp-112], r10b
  00090	42 8a 1c 0e	 mov	 bl, BYTE PTR [rsi+r9]
$LN31@mg_vxprint:

; 1512 :       if (c == '0') pad = '0', c = fmt[++i];

  00094	80 fb 30	 cmp	 bl, 48			; 00000030H
  00097	75 0f		 jne	 SHORT $LL4@mg_vxprint
  00099	8a c3		 mov	 al, bl
  0009b	88 5d c1	 mov	 BYTE PTR pad$1$[rbp-112], bl
  0009e	88 5d c0	 mov	 BYTE PTR pad$1[rbp-112], bl
$LN217@mg_vxprint:

; 1513 :       while (is_digit(c)) w *= 10, w += (size_t) (c - '0'), c = fmt[++i];

  000a1	48 ff c6	 inc	 rsi
  000a4	42 8a 1c 0e	 mov	 bl, BYTE PTR [rsi+r9]
$LL4@mg_vxprint:

; 1372 :   return c >= '0' && c <= '9';

  000a8	8d 43 d0	 lea	 eax, DWORD PTR [rbx-48]

; 1513 :       while (is_digit(c)) w *= 10, w += (size_t) (c - '0'), c = fmt[++i];

  000ab	0f be cb	 movsx	 ecx, bl

; 1372 :   return c >= '0' && c <= '9';

  000ae	3c 09		 cmp	 al, 9
  000b0	77 10		 ja	 SHORT $LN5@mg_vxprint

; 1513 :       while (is_digit(c)) w *= 10, w += (size_t) (c - '0'), c = fmt[++i];

  000b2	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  000b5	48 63 c8	 movsxd	 rcx, eax
  000b8	4b 8d 04 a4	 lea	 rax, QWORD PTR [r12+r12*4]
  000bc	4c 8d 24 41	 lea	 r12, QWORD PTR [rcx+rax*2]
  000c0	eb df		 jmp	 SHORT $LN217@mg_vxprint
$LN5@mg_vxprint:

; 1514 :       if (c == '.') {

  000c2	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  000c5	75 20		 jne	 SHORT $LN218@mg_vxprint

; 1515 :         c = fmt[++i];

  000c7	48 ff c6	 inc	 rsi
  000ca	42 8a 1c 0e	 mov	 bl, BYTE PTR [rsi+r9]

; 1516 :         if (c == '*') {

  000ce	80 fb 2a	 cmp	 bl, 42			; 0000002aH
  000d1	75 76		 jne	 SHORT $LN34@mg_vxprint

; 1517 :           pr = (size_t) va_arg(*ap, int);

  000d3	49 8b 0b	 mov	 rcx, QWORD PTR [r11]
  000d6	48 8d 41 08	 lea	 rax, QWORD PTR [rcx+8]
  000da	49 89 03	 mov	 QWORD PTR [r11], rax
  000dd	4c 63 31	 movsxd	 r14, DWORD PTR [rcx]
$LL8@mg_vxprint:

; 1522 :         }
; 1523 :       }
; 1524 :       while (c == 'h') c = fmt[++i];  // Treat h and hh as int

  000e0	48 ff c6	 inc	 rsi
  000e3	42 8a 1c 0e	 mov	 bl, BYTE PTR [rsi+r9]
$LN218@mg_vxprint:
  000e7	80 fb 68	 cmp	 bl, 104			; 00000068H
  000ea	74 f4		 je	 SHORT $LL8@mg_vxprint

; 1525 :       if (c == 'l') {

  000ec	80 fb 6c	 cmp	 bl, 108			; 0000006cH
  000ef	75 1d		 jne	 SHORT $LN37@mg_vxprint

; 1526 :         is_long++, c = fmt[++i];

  000f1	48 ff c6	 inc	 rsi
  000f4	ba 01 00 00 00	 mov	 edx, 1
  000f9	42 8a 1c 0e	 mov	 bl, BYTE PTR [rsi+r9]

; 1527 :         if (c == 'l') is_long++, c = fmt[++i];

  000fd	80 fb 6c	 cmp	 bl, 108			; 0000006cH
  00100	75 0c		 jne	 SHORT $LN37@mg_vxprint
  00102	48 ff c6	 inc	 rsi
  00105	ba 02 00 00 00	 mov	 edx, 2
  0010a	42 8a 1c 0e	 mov	 bl, BYTE PTR [rsi+r9]
$LN37@mg_vxprint:

; 1528 :       }
; 1529 :       if (c == 'p') x = 1, is_long = 1;

  0010e	80 fb 70	 cmp	 bl, 112			; 00000070H
  00111	75 5a		 jne	 SHORT $LN38@mg_vxprint
  00113	ba 01 00 00 00	 mov	 edx, 1
  00118	44 8b c2	 mov	 r8d, edx
$LN41@mg_vxprint:

; 1532 :         bool s = (c == 'd'), h = (c == 'x' || c == 'X' || c == 'p');

  0011b	80 fb 64	 cmp	 bl, 100			; 00000064H
$LN219@mg_vxprint:
  0011e	8d 43 a8	 lea	 eax, DWORD PTR [rbx-88]
  00121	41 0f 94 c2	 sete	 r10b
  00125	3c 20		 cmp	 al, 32			; 00000020H
  00127	0f 87 a6 01 00
	00		 ja	 $LN169@mg_vxprint
  0012d	48 b9 01 00 00
	01 01 00 00 00	 mov	 rcx, 4311744513		; 0000000101000001H
  00137	48 0f a3 c1	 bt	 rcx, rax
  0013b	0f 83 92 01 00
	00		 jae	 $LN169@mg_vxprint
  00141	41 b1 01	 mov	 r9b, 1
  00144	e9 8d 01 00 00	 jmp	 $LN64@mg_vxprint
$LN34@mg_vxprint:

; 1518 :           c = fmt[++i];
; 1519 :         } else {
; 1520 :           pr = 0;

  00149	45 33 f6	 xor	 r14d, r14d
$LL6@mg_vxprint:

; 1372 :   return c >= '0' && c <= '9';

  0014c	8d 43 d0	 lea	 eax, DWORD PTR [rbx-48]

; 1521 :           while (is_digit(c)) pr *= 10, pr += (size_t) (c - '0'), c = fmt[++i];

  0014f	0f be cb	 movsx	 ecx, bl

; 1372 :   return c >= '0' && c <= '9';

  00152	3c 09		 cmp	 al, 9
  00154	77 91		 ja	 SHORT $LN218@mg_vxprint

; 1521 :           while (is_digit(c)) pr *= 10, pr += (size_t) (c - '0'), c = fmt[++i];

  00156	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  00159	48 ff c6	 inc	 rsi
  0015c	48 63 c8	 movsxd	 rcx, eax
  0015f	4b 8d 04 b6	 lea	 rax, QWORD PTR [r14+r14*4]
  00163	42 8a 1c 0e	 mov	 bl, BYTE PTR [rsi+r9]
  00167	4c 8d 34 41	 lea	 r14, QWORD PTR [rcx+rax*2]
  0016b	eb df		 jmp	 SHORT $LL6@mg_vxprint
$LN38@mg_vxprint:

; 1530 :       if (c == 'd' || c == 'u' || c == 'x' || c == 'X' || c == 'p' ||
; 1531 :           c == 'g' || c == 'f') {

  0016d	80 fb 64	 cmp	 bl, 100			; 00000064H
  00170	74 ac		 je	 SHORT $LN219@mg_vxprint
  00172	80 fb 75	 cmp	 bl, 117			; 00000075H
  00175	74 a4		 je	 SHORT $LN41@mg_vxprint
  00177	80 fb 78	 cmp	 bl, 120			; 00000078H
  0017a	74 9f		 je	 SHORT $LN41@mg_vxprint
  0017c	80 fb 58	 cmp	 bl, 88			; 00000058H
  0017f	74 9a		 je	 SHORT $LN41@mg_vxprint
  00181	80 fb 67	 cmp	 bl, 103			; 00000067H
  00184	74 95		 je	 SHORT $LN41@mg_vxprint
  00186	80 fb 66	 cmp	 bl, 102			; 00000066H
  00189	74 90		 je	 SHORT $LN41@mg_vxprint

; 1558 :       } else if (c == 'm' || c == 'M') {

  0018b	8d 43 b3	 lea	 eax, DWORD PTR [rbx-77]
  0018e	a8 df		 test	 al, 223			; 000000dfH
  00190	0f 84 fd 00 00
	00		 je	 $LN52@mg_vxprint

; 1563 :       } else if (c == 'c') {

  00196	80 fb 63	 cmp	 bl, 99			; 00000063H
  00199	75 17		 jne	 SHORT $LN55@mg_vxprint

; 1564 :         int ch = va_arg(*ap, int);

  0019b	49 8b 0b	 mov	 rcx, QWORD PTR [r11]

; 1565 :         out((char) ch, param);

  0019e	49 8b d5	 mov	 rdx, r13
  001a1	48 8d 41 08	 lea	 rax, QWORD PTR [rcx+8]
  001a5	49 89 03	 mov	 QWORD PTR [r11], rax
  001a8	8a 09		 mov	 cl, BYTE PTR [rcx]
  001aa	41 ff d7	 call	 r15

; 1566 :         n++;

  001ad	e9 c8 00 00 00	 jmp	 $LN222@mg_vxprint
$LN55@mg_vxprint:

; 1567 :       } else if (c == 's') {

  001b2	80 fb 73	 cmp	 bl, 115			; 00000073H
  001b5	0f 85 b2 00 00
	00		 jne	 $LN57@mg_vxprint

; 1568 :         char *p = va_arg(*ap, char *);

  001bb	49 8b 0b	 mov	 rcx, QWORD PTR [r11]

; 1569 :         if (pr == ~0U) pr = p == NULL ? 0 : strlen(p);

  001be	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  001c3	48 8d 41 08	 lea	 rax, QWORD PTR [rcx+8]
  001c7	49 89 03	 mov	 QWORD PTR [r11], rax
  001ca	4c 8b 39	 mov	 r15, QWORD PTR [rcx]
  001cd	4c 89 7d c8	 mov	 QWORD PTR p$1$[rbp-112], r15
  001d1	4c 3b f2	 cmp	 r14, rdx
  001d4	75 18		 jne	 SHORT $LN66@mg_vxprint
  001d6	4d 85 ff	 test	 r15, r15
  001d9	75 05		 jne	 SHORT $LN65@mg_vxprint
  001db	45 33 f6	 xor	 r14d, r14d
  001de	eb 0e		 jmp	 SHORT $LN66@mg_vxprint
$LN65@mg_vxprint:
  001e0	49 83 ce ff	 or	 r14, -1
$LL190@mg_vxprint:
  001e4	49 ff c6	 inc	 r14
  001e7	43 80 3c 37 00	 cmp	 BYTE PTR [r15+r14], 0
  001ec	75 f6		 jne	 SHORT $LL190@mg_vxprint
$LN66@mg_vxprint:

; 1570 :         for (j = 0; !minus && pr < w && j + pr < w; j++)

  001ee	45 84 d2	 test	 r10b, r10b
  001f1	75 32		 jne	 SHORT $LN23@mg_vxprint
  001f3	4c 8b 7d 40	 mov	 r15, QWORD PTR out$[rbp-112]
  001f7	49 8b de	 mov	 rbx, r14
$LL24@mg_vxprint:
  001fa	4d 3b f4	 cmp	 r14, r12
  001fd	73 22		 jae	 SHORT $LN212@mg_vxprint
  001ff	49 3b dc	 cmp	 rbx, r12
  00202	73 1d		 jae	 SHORT $LN212@mg_vxprint

; 1571 :           n += scpy(out, param, &pad, 1);

  00204	41 b9 01 00 00
	00		 mov	 r9d, 1
  0020a	4c 8d 45 c0	 lea	 r8, QWORD PTR pad$1[rbp-112]
  0020e	49 8b d5	 mov	 rdx, r13
  00211	49 8b cf	 mov	 rcx, r15
  00214	e8 00 00 00 00	 call	 scpy
  00219	48 03 f8	 add	 rdi, rax
  0021c	48 ff c3	 inc	 rbx
  0021f	eb d9		 jmp	 SHORT $LL24@mg_vxprint
$LN212@mg_vxprint:
  00221	4c 8b 7d c8	 mov	 r15, QWORD PTR p$1$[rbp-112]
$LN23@mg_vxprint:

; 1572 :         n += scpy(out, param, p, pr);

  00225	4d 8b c7	 mov	 r8, r15
  00228	4d 8b ce	 mov	 r9, r14
  0022b	4c 8b 7d 40	 mov	 r15, QWORD PTR out$[rbp-112]
  0022f	49 8b d5	 mov	 rdx, r13
  00232	49 8b cf	 mov	 rcx, r15
  00235	e8 00 00 00 00	 call	 scpy
  0023a	48 03 f8	 add	 rdi, rax

; 1573 :         for (j = 0; minus && pr < w && j + pr < w; j++)

  0023d	80 7d c2 00	 cmp	 BYTE PTR minus$1$[rbp-112], 0
  00241	74 3a		 je	 SHORT $LN20@mg_vxprint

; 1572 :         n += scpy(out, param, p, pr);

  00243	49 8b de	 mov	 rbx, r14
$LL27@mg_vxprint:

; 1573 :         for (j = 0; minus && pr < w && j + pr < w; j++)

  00246	4d 3b f4	 cmp	 r14, r12
  00249	73 32		 jae	 SHORT $LN20@mg_vxprint
  0024b	49 3b dc	 cmp	 rbx, r12
  0024e	73 2d		 jae	 SHORT $LN20@mg_vxprint

; 1574 :           n += scpy(out, param, &pad, 1);

  00250	41 b9 01 00 00
	00		 mov	 r9d, 1
  00256	4c 8d 45 c0	 lea	 r8, QWORD PTR pad$1[rbp-112]
  0025a	49 8b d5	 mov	 rdx, r13
  0025d	49 8b cf	 mov	 rcx, r15
  00260	e8 00 00 00 00	 call	 scpy
  00265	48 03 f8	 add	 rdi, rax
  00268	48 ff c3	 inc	 rbx
  0026b	eb d9		 jmp	 SHORT $LL27@mg_vxprint
$LN57@mg_vxprint:

; 1575 :       } else if (c == '%') {

  0026d	49 8b d5	 mov	 rdx, r13
  00270	b1 25		 mov	 cl, 37			; 00000025H
  00272	41 ff d7	 call	 r15
  00275	80 fb 25	 cmp	 bl, 37			; 00000025H
  00278	75 0b		 jne	 SHORT $LN60@mg_vxprint
$LN222@mg_vxprint:

; 1582 :       }
; 1583 :       i++;

  0027a	48 ff c7	 inc	 rdi
$LN20@mg_vxprint:
  0027d	48 ff c6	 inc	 rsi

; 1584 :     } else {

  00280	e9 c7 01 00 00	 jmp	 $LN29@mg_vxprint
$LN60@mg_vxprint:

; 1576 :         out('%', param);
; 1577 :         n++;
; 1578 :       } else {
; 1579 :         out('%', param);
; 1580 :         out(c, param);

  00285	49 8b d5	 mov	 rdx, r13
  00288	8a cb		 mov	 cl, bl
  0028a	41 ff d7	 call	 r15

; 1581 :         n += 2;

  0028d	48 83 c7 02	 add	 rdi, 2
  00291	eb ea		 jmp	 SHORT $LN20@mg_vxprint
$LN52@mg_vxprint:

; 1559 :         mg_pm_t f = va_arg(*ap, mg_pm_t);

  00293	49 8b 0b	 mov	 rcx, QWORD PTR [r11]
  00296	48 8d 41 08	 lea	 rax, QWORD PTR [rcx+8]
  0029a	49 89 03	 mov	 QWORD PTR [r11], rax
  0029d	4c 8b 31	 mov	 r14, QWORD PTR [rcx]

; 1560 :         if (c == 'm') out('"', param);

  002a0	80 fb 6d	 cmp	 bl, 109			; 0000006dH
  002a3	75 0c		 jne	 SHORT $LN53@mg_vxprint
  002a5	49 8b d5	 mov	 rdx, r13
  002a8	b1 22		 mov	 cl, 34			; 00000022H
  002aa	41 ff d7	 call	 r15
  002ad	4c 8b 5d 58	 mov	 r11, QWORD PTR ap$[rbp-112]
$LN53@mg_vxprint:

; 1561 :         n += f(out, param, ap);

  002b1	4d 8b c3	 mov	 r8, r11
  002b4	49 8b d5	 mov	 rdx, r13
  002b7	49 8b cf	 mov	 rcx, r15
  002ba	41 ff d6	 call	 r14
  002bd	48 03 f8	 add	 rdi, rax

; 1562 :         if (c == 'm') n += 2, out('"', param);

  002c0	80 fb 6d	 cmp	 bl, 109			; 0000006dH
  002c3	75 b8		 jne	 SHORT $LN20@mg_vxprint
  002c5	48 83 c7 02	 add	 rdi, 2
  002c9	49 8b d5	 mov	 rdx, r13
  002cc	b1 22		 mov	 cl, 34			; 00000022H
  002ce	41 ff d7	 call	 r15

; 1563 :       } else if (c == 'c') {

  002d1	eb aa		 jmp	 SHORT $LN20@mg_vxprint
$LN169@mg_vxprint:

; 1532 :         bool s = (c == 'd'), h = (c == 'x' || c == 'X' || c == 'p');

  002d3	45 32 c9	 xor	 r9b, r9b
$LN64@mg_vxprint:

; 1533 :         char tmp[40];
; 1534 :         size_t xl = x ? 2 : 0;
; 1535 :         if (c == 'g' || c == 'f') {

  002d6	49 8b 0b	 mov	 rcx, QWORD PTR [r11]
  002d9	8d 43 9a	 lea	 eax, DWORD PTR [rbx-102]
  002dc	3c 01		 cmp	 al, 1
  002de	4f 8d 3c 00	 lea	 r15, QWORD PTR [r8+r8]
  002e2	4c 89 7d d0	 mov	 QWORD PTR xl$1$[rbp-112], r15
  002e6	48 8d 41 08	 lea	 rax, QWORD PTR [rcx+8]
  002ea	49 89 03	 mov	 QWORD PTR [r11], rax
  002ed	76 2d		 jbe	 SHORT $LN44@mg_vxprint

; 1539 :         } else if (is_long == 2) {

  002ef	48 83 fa 02	 cmp	 rdx, 2
  002f3	75 11		 jne	 SHORT $LN46@mg_vxprint

; 1540 :           int64_t v = va_arg(*ap, int64_t);
; 1541 :           k = mg_lld(tmp, v, s, h);

  002f5	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
$LN223@mg_vxprint:

; 1543 :           long v = va_arg(*ap, long);
; 1544 :           k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned long) v, s, h);
; 1545 :         } else {
; 1546 :           int v = va_arg(*ap, int);
; 1547 :           k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned) v, s, h);
; 1548 :         }
; 1549 :         for (j = 0; j < xl && w > 0; j++) w--;

  002f8	48 8d 4d d8	 lea	 rcx, QWORD PTR tmp$2[rbp-112]
  002fc	45 8a c2	 mov	 r8b, r10b
  002ff	e8 00 00 00 00	 call	 mg_lld
  00304	eb 41		 jmp	 SHORT $LN220@mg_vxprint
$LN46@mg_vxprint:

; 1542 :         } else if (is_long == 1) {

  00306	44 8b 01	 mov	 r8d, DWORD PTR [rcx]
  00309	48 83 fa 01	 cmp	 rdx, 1

; 1543 :           long v = va_arg(*ap, long);
; 1544 :           k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned long) v, s, h);
; 1545 :         } else {
; 1546 :           int v = va_arg(*ap, int);
; 1547 :           k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned) v, s, h);
; 1548 :         }
; 1549 :         for (j = 0; j < xl && w > 0; j++) w--;

  0030d	80 fb 64	 cmp	 bl, 100			; 00000064H
  00310	49 63 c0	 movsxd	 rax, r8d
  00313	41 8b d0	 mov	 edx, r8d
  00316	48 0f 44 d0	 cmove	 rdx, rax
  0031a	eb dc		 jmp	 SHORT $LN223@mg_vxprint
$LN44@mg_vxprint:

; 1536 :           double v = va_arg(*ap, double);
; 1537 :           if (pr == ~0U) pr = 6;
; 1538 :           k = mg_dtoa(tmp, sizeof(tmp), v, (int) pr, c == 'g');

  0031c	f2 0f 10 11	 movsd	 xmm2, QWORD PTR [rcx]
  00320	b8 06 00 00 00	 mov	 eax, 6
  00325	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  0032a	48 8d 4d d8	 lea	 rcx, QWORD PTR tmp$2[rbp-112]
  0032e	4c 3b f2	 cmp	 r14, rdx
  00331	4c 0f 44 f0	 cmove	 r14, rax
  00335	80 fb 67	 cmp	 bl, 103			; 00000067H
  00338	45 8b ce	 mov	 r9d, r14d
  0033b	0f 94 c0	 sete	 al
  0033e	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00342	e8 00 00 00 00	 call	 mg_dtoa
$LN220@mg_vxprint:

; 1543 :           long v = va_arg(*ap, long);
; 1544 :           k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned long) v, s, h);
; 1545 :         } else {
; 1546 :           int v = va_arg(*ap, int);
; 1547 :           k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned) v, s, h);
; 1548 :         }
; 1549 :         for (j = 0; j < xl && w > 0; j++) w--;

  00347	48 8b d8	 mov	 rbx, rax
  0034a	33 c0		 xor	 eax, eax
  0034c	4d 85 ff	 test	 r15, r15
  0034f	74 10		 je	 SHORT $LN11@mg_vxprint
$LL12@mg_vxprint:
  00351	4d 85 e4	 test	 r12, r12
  00354	74 0b		 je	 SHORT $LN11@mg_vxprint
  00356	49 ff cc	 dec	 r12
  00359	48 ff c0	 inc	 rax
  0035c	49 3b c7	 cmp	 rax, r15
  0035f	72 f0		 jb	 SHORT $LL12@mg_vxprint
$LN11@mg_vxprint:

; 1550 :         for (j = 0; pad == ' ' && !minus && k < w && j + k < w; j++)

  00361	80 7d c1 20	 cmp	 BYTE PTR pad$1$[rbp-112], 32 ; 00000020H
  00365	75 38		 jne	 SHORT $LN14@mg_vxprint
  00367	80 7d c2 00	 cmp	 BYTE PTR minus$1$[rbp-112], 0
  0036b	75 32		 jne	 SHORT $LN14@mg_vxprint
  0036d	4c 8b f3	 mov	 r14, rbx
  00370	49 3b dc	 cmp	 rbx, r12
  00373	73 2a		 jae	 SHORT $LN14@mg_vxprint
  00375	4c 8b 7d 40	 mov	 r15, QWORD PTR out$[rbp-112]
$LL155@mg_vxprint:
  00379	4d 3b f4	 cmp	 r14, r12
  0037c	73 1d		 jae	 SHORT $LN214@mg_vxprint

; 1551 :           n += scpy(out, param, &pad, 1);

  0037e	41 b9 01 00 00
	00		 mov	 r9d, 1
  00384	4c 8d 45 c0	 lea	 r8, QWORD PTR pad$1[rbp-112]
  00388	49 8b d5	 mov	 rdx, r13
  0038b	49 8b cf	 mov	 rcx, r15
  0038e	e8 00 00 00 00	 call	 scpy
  00393	48 03 f8	 add	 rdi, rax
  00396	49 ff c6	 inc	 r14
  00399	eb de		 jmp	 SHORT $LL155@mg_vxprint
$LN214@mg_vxprint:
  0039b	4c 8b 7d d0	 mov	 r15, QWORD PTR xl$1$[rbp-112]
$LN14@mg_vxprint:

; 1552 :         n += scpy(out, param, (char *) "0x", xl);

  0039f	4d 8b cf	 mov	 r9, r15
  003a2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02MDDDDAID@0x@
  003a9	4c 8b 7d 40	 mov	 r15, QWORD PTR out$[rbp-112]
  003ad	49 8b d5	 mov	 rdx, r13
  003b0	49 8b cf	 mov	 rcx, r15
  003b3	e8 00 00 00 00	 call	 scpy
  003b8	48 03 f8	 add	 rdi, rax

; 1553 :         for (j = 0; pad == '0' && k < w && j + k < w; j++)

  003bb	80 7d c1 30	 cmp	 BYTE PTR pad$1$[rbp-112], 48 ; 00000030H
  003bf	75 2a		 jne	 SHORT $LN17@mg_vxprint
  003c1	4c 8b f3	 mov	 r14, rbx
  003c4	49 3b dc	 cmp	 rbx, r12
  003c7	73 22		 jae	 SHORT $LN17@mg_vxprint
$LL149@mg_vxprint:
  003c9	4d 3b f4	 cmp	 r14, r12
  003cc	73 1d		 jae	 SHORT $LN17@mg_vxprint

; 1554 :           n += scpy(out, param, &pad, 1);

  003ce	41 b9 01 00 00
	00		 mov	 r9d, 1
  003d4	4c 8d 45 c0	 lea	 r8, QWORD PTR pad$1[rbp-112]
  003d8	49 8b d5	 mov	 rdx, r13
  003db	49 8b cf	 mov	 rcx, r15
  003de	e8 00 00 00 00	 call	 scpy
  003e3	48 03 f8	 add	 rdi, rax
  003e6	49 ff c6	 inc	 r14
  003e9	eb de		 jmp	 SHORT $LL149@mg_vxprint
$LN17@mg_vxprint:

; 1555 :         n += scpy(out, param, tmp, k);

  003eb	4c 8b cb	 mov	 r9, rbx
  003ee	4c 8d 45 d8	 lea	 r8, QWORD PTR tmp$2[rbp-112]
  003f2	49 8b d5	 mov	 rdx, r13
  003f5	49 8b cf	 mov	 rcx, r15
  003f8	e8 00 00 00 00	 call	 scpy
  003fd	48 03 f8	 add	 rdi, rax

; 1556 :         for (j = 0; pad == ' ' && minus && k < w && j + k < w; j++)

  00400	80 7d c1 20	 cmp	 BYTE PTR pad$1$[rbp-112], 32 ; 00000020H
  00404	0f 85 73 fe ff
	ff		 jne	 $LN20@mg_vxprint
  0040a	80 7d c2 00	 cmp	 BYTE PTR minus$1$[rbp-112], 0
  0040e	0f 84 69 fe ff
	ff		 je	 $LN20@mg_vxprint
  00414	49 3b dc	 cmp	 rbx, r12
  00417	0f 83 60 fe ff
	ff		 jae	 $LN20@mg_vxprint
$LL154@mg_vxprint:
  0041d	49 3b dc	 cmp	 rbx, r12
  00420	0f 83 57 fe ff
	ff		 jae	 $LN20@mg_vxprint

; 1557 :           n += scpy(out, param, &pad, 1);

  00426	41 b9 01 00 00
	00		 mov	 r9d, 1
  0042c	4c 8d 45 c0	 lea	 r8, QWORD PTR pad$1[rbp-112]
  00430	49 8b d5	 mov	 rdx, r13
  00433	49 8b cf	 mov	 rcx, r15
  00436	e8 00 00 00 00	 call	 scpy
  0043b	48 03 f8	 add	 rdi, rax
  0043e	48 ff c3	 inc	 rbx
  00441	eb da		 jmp	 SHORT $LL154@mg_vxprint
$LN28@mg_vxprint:

; 1585 :       out(fmt[i], param), n++, i++;

  00443	49 8b d5	 mov	 rdx, r13
  00446	41 ff d7	 call	 r15
  00449	48 ff c7	 inc	 rdi
$LN29@mg_vxprint:

; 1506 :   while (fmt[i] != '\0') {

  0044c	4c 8b 4d 50	 mov	 r9, QWORD PTR fmt$[rbp-112]
  00450	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00455	4c 8b 5d 58	 mov	 r11, QWORD PTR ap$[rbp-112]
  00459	42 80 3c 0e 00	 cmp	 BYTE PTR [rsi+r9], 0
  0045e	0f 85 df fb ff
	ff		 jne	 $LL2@mg_vxprint
$LN3@mg_vxprint:

; 1586 :     }
; 1587 :   }
; 1588 :   return n;
; 1589 : }

  00464	48 8b 9c 24 b8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+184]
  0046c	48 8b c7	 mov	 rax, rdi
  0046f	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00473	41 5f		 pop	 r15
  00475	41 5e		 pop	 r14
  00477	41 5d		 pop	 r13
  00479	41 5c		 pop	 r12
  0047b	5f		 pop	 rdi
  0047c	5e		 pop	 rsi
  0047d	5d		 pop	 rbp
  0047e	c3		 ret	 0
mg_vxprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_fs_open
_TEXT	SEGMENT
fs$ = 48
path$ = 56
flags$ = 64
mg_fs_open PROC						; COMDAT

; 1597 : struct mg_fd *mg_fs_open(struct mg_fs *fs, const char *path, int flags) {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b ea	 mov	 rbp, rdx
  00017	48 8b f9	 mov	 rdi, rcx

; 1598 :   struct mg_fd *fd = (struct mg_fd *) calloc(1, sizeof(*fd));

  0001a	ba 10 00 00 00	 mov	 edx, 16
  0001f	41 8b f0	 mov	 esi, r8d
  00022	8d 4a f1	 lea	 ecx, QWORD PTR [rdx-15]
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0002b	48 8b d8	 mov	 rbx, rax

; 1599 :   if (fd != NULL) {

  0002e	48 85 c0	 test	 rax, rax
  00031	74 1f		 je	 SHORT $LN3@mg_fs_open

; 1600 :     fd->fd = fs->op(path, flags);

  00033	8b d6		 mov	 edx, esi
  00035	48 8b cd	 mov	 rcx, rbp
  00038	ff 57 10	 call	 QWORD PTR [rdi+16]
  0003b	48 89 03	 mov	 QWORD PTR [rbx], rax

; 1601 :     fd->fs = fs;

  0003e	48 89 7b 08	 mov	 QWORD PTR [rbx+8], rdi

; 1602 :     if (fd->fd == NULL) {

  00042	48 85 c0	 test	 rax, rax
  00045	75 0b		 jne	 SHORT $LN3@mg_fs_open

; 1603 :       free(fd);

  00047	48 8b cb	 mov	 rcx, rbx
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1604 :       fd = NULL;

  00050	33 db		 xor	 ebx, ebx
$LN3@mg_fs_open:

; 1605 :     }
; 1606 :   }
; 1607 :   return fd;
; 1608 : }

  00052	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00057	48 8b c3	 mov	 rax, rbx
  0005a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005f	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00064	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00068	5f		 pop	 rdi
  00069	c3		 ret	 0
mg_fs_open ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_fs_close
_TEXT	SEGMENT
fd$ = 48
mg_fs_close PROC					; COMDAT

; 1610 : void mg_fs_close(struct mg_fd *fd) {

$LN6:

; 1611 :   if (fd != NULL) {

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 20		 je	 SHORT $LN4@mg_fs_clos
  00005	53		 push	 rbx
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1612 :     fd->fs->cl(fd->fd);

  0000a	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00014	ff 50 18	 call	 QWORD PTR [rax+24]

; 1613 :     free(fd);

  00017	48 8b cb	 mov	 rcx, rbx
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1614 :   }
; 1615 : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
$LN4@mg_fs_clos:
  00025	c3		 ret	 0
mg_fs_close ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_file_read
_TEXT	SEGMENT
size$ = 48
fs$ = 48
path$ = 56
sizep$ = 64
mg_file_read PROC					; COMDAT

; 1617 : char *mg_file_read(struct mg_fs *fs, const char *path, size_t *sizep) {

$LN12:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00007	48 89 68 18	 mov	 QWORD PTR [rax+24], rbp
  0000b	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b da	 mov	 rbx, rdx
  00017	48 8b e9	 mov	 rbp, rcx
  0001a	49 8b f0	 mov	 rsi, r8

; 1618 :   struct mg_fd *fd;
; 1619 :   char *data = NULL;
; 1620 :   size_t size = 0;
; 1621 :   fs->st(path, &size, NULL);

  0001d	48 8d 50 08	 lea	 rdx, QWORD PTR [rax+8]
  00021	33 ff		 xor	 edi, edi
  00023	45 33 c0	 xor	 r8d, r8d
  00026	48 21 78 08	 and	 QWORD PTR [rax+8], rdi
  0002a	48 8b cb	 mov	 rcx, rbx
  0002d	ff 55 00	 call	 QWORD PTR [rbp]

; 1622 :   if ((fd = mg_fs_open(fs, path, MG_FS_READ)) != NULL) {

  00030	44 8d 47 01	 lea	 r8d, QWORD PTR [rdi+1]
  00034	48 8b d3	 mov	 rdx, rbx
  00037	48 8b cd	 mov	 rcx, rbp
  0003a	e8 00 00 00 00	 call	 mg_fs_open
  0003f	48 8b d8	 mov	 rbx, rax
  00042	48 85 c0	 test	 rax, rax
  00045	74 62		 je	 SHORT $LN9@mg_file_re

; 1623 :     data = (char *) calloc(1, size + 1);

  00047	48 8b 54 24 30	 mov	 rdx, QWORD PTR size$[rsp]
  0004c	8d 4f 01	 lea	 ecx, QWORD PTR [rdi+1]
  0004f	48 ff c2	 inc	 rdx
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00058	48 8b f8	 mov	 rdi, rax

; 1624 :     if (data != NULL) {

  0005b	48 85 c0	 test	 rax, rax
  0005e	74 36		 je	 SHORT $LN6@mg_file_re

; 1625 :       if (fs->rd(fd->fd, data, size) != size) {

  00060	4c 8b 44 24 30	 mov	 r8, QWORD PTR size$[rsp]
  00065	48 8b d0	 mov	 rdx, rax
  00068	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0006b	ff 55 20	 call	 QWORD PTR [rbp+32]
  0006e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR size$[rsp]
  00073	48 3b c1	 cmp	 rax, rcx
  00076	74 0d		 je	 SHORT $LN4@mg_file_re

; 1626 :         free(data);

  00078	48 8b cf	 mov	 rcx, rdi
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1627 :         data = NULL;

  00081	33 ff		 xor	 edi, edi

; 1628 :       } else {

  00083	eb 11		 jmp	 SHORT $LN6@mg_file_re
$LN4@mg_file_re:

; 1629 :         data[size] = '\0';

  00085	c6 04 39 00	 mov	 BYTE PTR [rcx+rdi], 0

; 1630 :         if (sizep != NULL) *sizep = size;

  00089	48 85 f6	 test	 rsi, rsi
  0008c	74 08		 je	 SHORT $LN6@mg_file_re
  0008e	48 8b 44 24 30	 mov	 rax, QWORD PTR size$[rsp]
  00093	48 89 06	 mov	 QWORD PTR [rsi], rax
$LN6@mg_file_re:

; 1612 :     fd->fs->cl(fd->fd);

  00096	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0009a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0009d	ff 50 18	 call	 QWORD PTR [rax+24]

; 1613 :     free(fd);

  000a0	48 8b cb	 mov	 rcx, rbx
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN9@mg_file_re:

; 1631 :       }
; 1632 :     }
; 1633 :     mg_fs_close(fd);
; 1634 :   }
; 1635 :   return data;
; 1636 : }

  000a9	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000ae	48 8b c7	 mov	 rax, rdi
  000b1	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000b6	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000bb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bf	5f		 pop	 rdi
  000c0	c3		 ret	 0
mg_file_read ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_file_write
_TEXT	SEGMENT
tmp$ = 48
fs$ = 352
path$ = 360
buf$ = 368
len$ = 376
mg_file_write PROC					; COMDAT

; 1639 :                    size_t len) {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  0001b	4d 8b f9	 mov	 r15, r9
  0001e	49 8b d8	 mov	 rbx, r8
  00021	48 8b ea	 mov	 rbp, rdx
  00024	48 8b f1	 mov	 rsi, rcx

; 1640 :   bool result = false;

  00027	45 33 f6	 xor	 r14d, r14d

; 1641 :   struct mg_fd *fd;
; 1642 :   char tmp[MG_PATH_MAX];
; 1643 :   mg_snprintf(tmp, sizeof(tmp), "%s..%d", path, rand());

  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00030	4c 8b cd	 mov	 r9, rbp
  00033	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06HDKLCKBF@?$CFs?4?4?$CFd@
  0003a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR tmp$[rsp]
  0003f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00043	ba 04 01 00 00	 mov	 edx, 260		; 00000104H
  00048	e8 00 00 00 00	 call	 mg_snprintf

; 1644 :   if ((fd = mg_fs_open(fs, tmp, MG_FS_WRITE)) != NULL) {

  0004d	45 8d 46 02	 lea	 r8d, QWORD PTR [r14+2]
  00051	48 8b ce	 mov	 rcx, rsi
  00054	48 8d 54 24 30	 lea	 rdx, QWORD PTR tmp$[rsp]
  00059	e8 00 00 00 00	 call	 mg_fs_open
  0005e	48 8b f8	 mov	 rdi, rax
  00061	48 85 c0	 test	 rax, rax
  00064	74 4b		 je	 SHORT $LN4@mg_file_wr

; 1645 :     result = fs->wr(fd->fd, buf, len) == len;

  00066	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00069	4d 8b c7	 mov	 r8, r15
  0006c	48 8b d3	 mov	 rdx, rbx
  0006f	ff 56 28	 call	 QWORD PTR [rsi+40]

; 1612 :     fd->fs->cl(fd->fd);

  00072	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]

; 1645 :     result = fs->wr(fd->fd, buf, len) == len;

  00076	49 3b c7	 cmp	 rax, r15

; 1612 :     fd->fs->cl(fd->fd);

  00079	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]

; 1645 :     result = fs->wr(fd->fd, buf, len) == len;

  0007c	48 8b d8	 mov	 rbx, rax
  0007f	41 0f 94 c6	 sete	 r14b

; 1612 :     fd->fs->cl(fd->fd);

  00083	ff 52 18	 call	 QWORD PTR [rdx+24]

; 1613 :     free(fd);

  00086	48 8b cf	 mov	 rcx, rdi
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1646 :     mg_fs_close(fd);
; 1647 :     if (result) {

  0008f	48 8b 46 40	 mov	 rax, QWORD PTR [rsi+64]
  00093	49 3b df	 cmp	 rbx, r15
  00096	75 12		 jne	 SHORT $LN3@mg_file_wr

; 1648 :       fs->rm(path);

  00098	48 8b cd	 mov	 rcx, rbp
  0009b	ff d0		 call	 rax

; 1649 :       fs->mv(tmp, path);

  0009d	48 8b d5	 mov	 rdx, rbp
  000a0	48 8d 4c 24 30	 lea	 rcx, QWORD PTR tmp$[rsp]
  000a5	ff 56 38	 call	 QWORD PTR [rsi+56]

; 1650 :     } else {

  000a8	eb 07		 jmp	 SHORT $LN4@mg_file_wr
$LN3@mg_file_wr:

; 1651 :       fs->rm(tmp);

  000aa	48 8d 4c 24 30	 lea	 rcx, QWORD PTR tmp$[rsp]
  000af	ff d0		 call	 rax
$LN4@mg_file_wr:

; 1652 :     }
; 1653 :   }
; 1654 :   return result;
; 1655 : }

  000b1	4c 8d 9c 24 40
	01 00 00	 lea	 r11, QWORD PTR [rsp+320]
  000b9	41 8a c6	 mov	 al, r14b
  000bc	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  000c0	49 8b 6b 28	 mov	 rbp, QWORD PTR [r11+40]
  000c4	49 8b 73 30	 mov	 rsi, QWORD PTR [r11+48]
  000c8	49 8b e3	 mov	 rsp, r11
  000cb	41 5f		 pop	 r15
  000cd	41 5e		 pop	 r14
  000cf	5f		 pop	 rdi
  000d0	c3		 ret	 0
mg_file_write ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_file_printf
_TEXT	SEGMENT
ap$ = 32
fs$ = 80
path$ = 88
fmt$ = 96
mg_file_printf PROC					; COMDAT

; 1657 : bool mg_file_printf(struct mg_fs *fs, const char *path, const char *fmt, ...) {

$LN5:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	4d 89 43 18	 mov	 QWORD PTR [r11+24], r8
  00007	4d 89 4b 20	 mov	 QWORD PTR [r11+32], r9
  0000b	53		 push	 rbx
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00012	48 8b da	 mov	 rbx, rdx

; 1658 :   va_list ap;
; 1659 :   char *data;
; 1660 :   bool result = false;
; 1661 :   va_start(ap, fmt);

  00015	49 8d 43 20	 lea	 rax, QWORD PTR [r11+32]
  00019	48 8b f1	 mov	 rsi, rcx
  0001c	49 89 43 d8	 mov	 QWORD PTR [r11-40], rax

; 1662 :   data = mg_vmprintf(fmt, &ap);

  00020	49 8d 53 d8	 lea	 rdx, QWORD PTR [r11-40]
  00024	49 8b c8	 mov	 rcx, r8
  00027	e8 00 00 00 00	 call	 mg_vmprintf

; 1663 :   va_end(ap);

  0002c	48 83 64 24 20
	00		 and	 QWORD PTR ap$[rsp], 0
  00032	48 8b f8	 mov	 rdi, rax

; 1664 :   result = mg_file_write(fs, path, data, strlen(data));

  00035	49 83 c9 ff	 or	 r9, -1
$LL3@mg_file_pr:
  00039	49 ff c1	 inc	 r9
  0003c	42 80 3c 08 00	 cmp	 BYTE PTR [rax+r9], 0
  00041	75 f6		 jne	 SHORT $LL3@mg_file_pr
  00043	4c 8b c7	 mov	 r8, rdi
  00046	48 8b d3	 mov	 rdx, rbx
  00049	48 8b ce	 mov	 rcx, rsi
  0004c	e8 00 00 00 00	 call	 mg_file_write

; 1665 :   free(data);

  00051	48 8b cf	 mov	 rcx, rdi
  00054	8a d8		 mov	 bl, al
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1666 :   return result;

  0005c	8a c3		 mov	 al, bl

; 1667 : }

  0005e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00062	5f		 pop	 rdi
  00063	5e		 pop	 rsi
  00064	5b		 pop	 rbx
  00065	c3		 ret	 0
mg_file_printf ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_unpack
_TEXT	SEGMENT
path$dead$ = 8
size$ = 16
mtime$ = 24
mg_unpack PROC						; COMDAT

; 1817 :   *size = 0, *mtime = 0;

  00000	48 83 22 00	 and	 QWORD PTR [rdx], 0

; 1818 :   (void) path;
; 1819 :   return NULL;

  00004	33 c0		 xor	 eax, eax
  00006	49 83 20 00	 and	 QWORD PTR [r8], 0

; 1820 : }

  0000a	c3		 ret	 0
mg_unpack ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_unlist
_TEXT	SEGMENT
no$dead$ = 8
mg_unlist PROC						; COMDAT

; 1822 :   (void) no;
; 1823 :   return NULL;

  00000	33 c0		 xor	 eax, eax

; 1824 : }

  00002	c3		 ret	 0
mg_unlist ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_unpacked
_TEXT	SEGMENT
__$ReturnAddress$ = 8
path$dead$ = 16
mg_unpacked PROC					; COMDAT

; 1817 :   *size = 0, *mtime = 0;

  00000	33 c0		 xor	 eax, eax
  00002	48 89 04 25 00
	00 00 00	 mov	 QWORD PTR ds:0, rax

; 1828 :   size_t len = 0;
; 1829 :   const char *buf = mg_unpack(path, &len, NULL);
; 1830 :   return mg_str_n(buf, len);

  0000a	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00011	48 8b c1	 mov	 rax, rcx

; 1831 : }

  00014	c3		 ret	 0
mg_unpacked ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT is_dir_prefix
_TEXT	SEGMENT
prefix$ = 48
n$ = 56
path$ = 64
is_dir_prefix PROC					; COMDAT

; 1833 : static int is_dir_prefix(const char *prefix, size_t n, const char *path) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1834 :   // MG_INFO(("[%.*s] [%s] %c", (int) n, prefix, path, path[n]));
; 1835 :   return n < strlen(path) && strncmp(prefix, path, n) == 0 &&

  0000f	48 83 c8 ff	 or	 rax, -1
  00013	49 8b f0	 mov	 rsi, r8
  00016	33 db		 xor	 ebx, ebx
  00018	48 8b fa	 mov	 rdi, rdx
$LL6@is_dir_pre:
  0001b	48 ff c0	 inc	 rax
  0001e	41 38 1c 00	 cmp	 BYTE PTR [r8+rax], bl
  00022	75 f7		 jne	 SHORT $LL6@is_dir_pre
  00024	48 3b f8	 cmp	 rdi, rax
  00027	73 27		 jae	 SHORT $LN5@is_dir_pre
  00029	4c 8b c7	 mov	 r8, rdi
  0002c	48 8b d6	 mov	 rdx, rsi
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00035	85 c0		 test	 eax, eax
  00037	75 17		 jne	 SHORT $LN5@is_dir_pre
  00039	48 85 ff	 test	 rdi, rdi
  0003c	74 0d		 je	 SHORT $LN4@is_dir_pre
  0003e	80 3c 37 2f	 cmp	 BYTE PTR [rdi+rsi], 47	; 0000002fH
  00042	74 07		 je	 SHORT $LN4@is_dir_pre
  00044	80 7c 37 ff 2f	 cmp	 BYTE PTR [rdi+rsi-1], 47 ; 0000002fH
  00049	75 05		 jne	 SHORT $LN5@is_dir_pre
$LN4@is_dir_pre:
  0004b	bb 01 00 00 00	 mov	 ebx, 1
$LN5@is_dir_pre:

; 1836 :          (n == 0 || path[n] == '/' || path[n - 1] == '/');
; 1837 : }

  00050	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00055	8b c3		 mov	 eax, ebx
  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5f		 pop	 rdi
  00061	c3		 ret	 0
is_dir_prefix ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT packed_stat
_TEXT	SEGMENT
path$ = 8
size$ = 16
mtime$ = 24
packed_stat PROC					; COMDAT

; 1817 :   *size = 0, *mtime = 0;

  00000	48 83 22 00	 and	 QWORD PTR [rdx], 0

; 1840 :   const char *p;
; 1841 :   size_t i, n = strlen(path);
; 1842 :   if (mg_unpack(path, size, mtime)) return MG_FS_READ;  // Regular file
; 1843 :   // Scan all files. If `path` is a dir prefix for any of them, it's a dir
; 1844 :   for (i = 0; (p = mg_unlist(i)) != NULL; i++) {
; 1845 :     if (is_dir_prefix(path, n, p)) return MG_FS_DIR;
; 1846 :   }
; 1847 :   return 0;

  00004	33 c0		 xor	 eax, eax

; 1817 :   *size = 0, *mtime = 0;

  00006	49 83 20 00	 and	 QWORD PTR [r8], 0

; 1848 : }

  0000a	c3		 ret	 0
packed_stat ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT packed_list
_TEXT	SEGMENT
dir$ = 8
fn$ = 16
userdata$ = 24
packed_list PROC					; COMDAT

; 1852 :   char buf[MG_PATH_MAX], tmp[sizeof(buf)];
; 1853 :   const char *path, *begin, *end;
; 1854 :   size_t i, n = strlen(dir);
; 1855 :   tmp[0] = '\0';  // Previously listed entry
; 1856 :   for (i = 0; (path = mg_unlist(i)) != NULL; i++) {
; 1857 :     if (!is_dir_prefix(dir, n, path)) continue;
; 1858 :     begin = &path[n + 1];
; 1859 :     end = strchr(begin, '/');
; 1860 :     if (end == NULL) end = begin + strlen(begin);
; 1861 :     mg_snprintf(buf, sizeof(buf), "%.*s", (int) (end - begin), begin);
; 1862 :     buf[sizeof(buf) - 1] = '\0';
; 1863 :     // If this entry has been already listed, skip
; 1864 :     // NOTE: we're assuming that file list is sorted alphabetically
; 1865 :     if (strcmp(buf, tmp) == 0) continue;
; 1866 :     fn(buf, userdata);  // Not yet listed, call user function
; 1867 :     strcpy(tmp, buf);   // And save this entry as listed
; 1868 :   }
; 1869 : }

  00000	c2 00 00	 ret	 0
packed_list ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT packed_open
_TEXT	SEGMENT
path$ = 8
flags$ = 16
packed_open PROC					; COMDAT

; 1817 :   *size = 0, *mtime = 0;

  00000	48 83 24 25 00
	00 00 00 00	 and	 QWORD PTR ds:0, 0

; 1872 :   size_t size = 0;
; 1873 :   const char *data = mg_unpack(path, &size, NULL);
; 1874 :   struct packed_file *fp = NULL;
; 1875 :   if (data == NULL) return NULL;

  00009	33 c0		 xor	 eax, eax

; 1876 :   if (flags & MG_FS_WRITE) return NULL;
; 1877 :   if ((fp = (struct packed_file *) calloc(1, sizeof(*fp))) != NULL) {
; 1878 :     fp->size = size;
; 1879 :     fp->data = data;
; 1880 :   }
; 1881 :   return (void *) fp;
; 1882 : }

  0000b	c3		 ret	 0
packed_open ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT packed_close
_TEXT	SEGMENT
fp$ = 48
packed_close PROC					; COMDAT

; 1884 : static void packed_close(void *fp) {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1885 :   if (fp != NULL) free(fp);

  00004	48 85 c9	 test	 rcx, rcx
  00007	74 06		 je	 SHORT $LN2@packed_clo
  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@packed_clo:

; 1886 : }

  0000f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00013	c3		 ret	 0
packed_close ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT packed_read
_TEXT	SEGMENT
fd$ = 48
buf$ = 56
len$ = 64
packed_read PROC					; COMDAT

; 1888 : static size_t packed_read(void *fd, void *buf, size_t len) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	49 8b d8	 mov	 rbx, r8

; 1889 :   struct packed_file *fp = (struct packed_file *) fd;
; 1890 :   if (fp->pos + len > fp->size) len = fp->size - fp->pos;

  00010	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00014	4c 8b ca	 mov	 r9, rdx
  00017	4a 8d 04 01	 lea	 rax, QWORD PTR [rcx+r8]
  0001b	48 3b 47 08	 cmp	 rax, QWORD PTR [rdi+8]
  0001f	76 07		 jbe	 SHORT $LN2@packed_rea
  00021	48 8b 5f 08	 mov	 rbx, QWORD PTR [rdi+8]
  00025	48 2b d9	 sub	 rbx, rcx
$LN2@packed_rea:

; 1891 :   memcpy(buf, &fp->data[fp->pos], len);

  00028	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  0002b	4c 8b c3	 mov	 r8, rbx
  0002e	48 03 d1	 add	 rdx, rcx
  00031	49 8b c9	 mov	 rcx, r9
  00034	e8 00 00 00 00	 call	 memcpy

; 1892 :   fp->pos += len;

  00039	48 01 5f 10	 add	 QWORD PTR [rdi+16], rbx

; 1893 :   return len;

  0003d	48 8b c3	 mov	 rax, rbx

; 1894 : }

  00040	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5f		 pop	 rdi
  0004a	c3		 ret	 0
packed_read ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT packed_write
_TEXT	SEGMENT
fd$ = 8
buf$ = 16
len$ = 24
packed_write PROC					; COMDAT

; 1897 :   (void) fd, (void) buf, (void) len;
; 1898 :   return 0;

  00000	33 c0		 xor	 eax, eax

; 1899 : }

  00002	c3		 ret	 0
packed_write ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT packed_seek
_TEXT	SEGMENT
fd$ = 8
offset$ = 16
packed_seek PROC					; COMDAT

; 1902 :   struct packed_file *fp = (struct packed_file *) fd;
; 1903 :   fp->pos = offset;
; 1904 :   if (fp->pos > fp->size) fp->pos = fp->size;

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00004	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx
  00008	48 3b d0	 cmp	 rdx, rax
  0000b	76 07		 jbe	 SHORT $LN2@packed_see
  0000d	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  00011	48 8b d0	 mov	 rdx, rax
$LN2@packed_see:

; 1905 :   return fp->pos;

  00014	48 8b c2	 mov	 rax, rdx

; 1906 : }

  00017	c3		 ret	 0
packed_seek ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT packed_rename
_TEXT	SEGMENT
from$ = 8
to$ = 16
packed_rename PROC					; COMDAT

; 1909 :   (void) from, (void) to;
; 1910 :   return false;

  00000	32 c0		 xor	 al, al

; 1911 : }

  00002	c3		 ret	 0
packed_rename ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT packed_remove
_TEXT	SEGMENT
path$ = 8
packed_remove PROC					; COMDAT

; 1914 :   (void) path;
; 1915 :   return false;

  00000	32 c0		 xor	 al, al

; 1916 : }

  00002	c3		 ret	 0
packed_remove ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT packed_mkdir
_TEXT	SEGMENT
path$ = 8
packed_mkdir PROC					; COMDAT

; 1919 :   (void) path;
; 1920 :   return false;

  00000	32 c0		 xor	 al, al

; 1921 : }

  00002	c3		 ret	 0
packed_mkdir ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT p_stat
_TEXT	SEGMENT
st$ = 48
tmp$ = 112
path$ = 656
size$ = 664
mtime$ = 672
p_stat	PROC						; COMDAT

; 1942 : static int p_stat(const char *path, size_t *size, time_t *mtime) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 80 02
	00 00		 sub	 rsp, 640		; 00000280H
  00012	49 8b f8	 mov	 rdi, r8

; 1943 : #if !defined(S_ISDIR)
; 1944 :   MG_ERROR(("stat() API is not supported. %p %p %p", path, size, mtime));
; 1945 :   return 0;
; 1946 : #else
; 1947 : #if MG_ARCH == MG_ARCH_WIN32
; 1948 :   struct _stati64 st;
; 1949 :   wchar_t tmp[MG_PATH_MAX];
; 1950 :   MultiByteToWideChar(CP_UTF8, 0, path, -1, tmp, sizeof(tmp) / sizeof(tmp[0]));

  00015	c7 44 24 28 04
	01 00 00	 mov	 DWORD PTR [rsp+40], 260	; 00000104H
  0001d	4c 8b c1	 mov	 r8, rcx
  00020	48 8d 44 24 70	 lea	 rax, QWORD PTR tmp$[rsp]
  00025	48 8b f2	 mov	 rsi, rdx
  00028	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002d	b9 e9 fd 00 00	 mov	 ecx, 65001		; 0000fde9H
  00032	41 83 c9 ff	 or	 r9d, -1
  00036	33 d2		 xor	 edx, edx
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MultiByteToWideChar

; 1951 :   if (_wstati64(tmp, &st) != 0) return 0;

  0003e	48 8d 54 24 30	 lea	 rdx, QWORD PTR st$[rsp]
  00043	48 8d 4c 24 70	 lea	 rcx, QWORD PTR tmp$[rsp]
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wstat64
  0004e	85 c0		 test	 eax, eax
  00050	74 07		 je	 SHORT $LN2@p_stat
  00052	33 c0		 xor	 eax, eax
  00054	e9 a0 00 00 00	 jmp	 $LN1@p_stat
$LN2@p_stat:

; 1952 :   // If path is a symlink, windows reports 0 in st.st_size.
; 1953 :   // Get a real file size by opening it and jumping to the end
; 1954 :   if (st.st_size == 0 && (st.st_mode & _S_IFREG)) {

  00059	48 83 7c 24 48
	00		 cmp	 QWORD PTR st$[rsp+24], 0
  0005f	75 5c		 jne	 SHORT $LN9@p_stat
  00061	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00066	66 85 44 24 36	 test	 WORD PTR st$[rsp+6], ax
  0006b	74 50		 je	 SHORT $LN9@p_stat

; 1955 :     FILE *fp = _wfopen(tmp, L"rb");

  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_15JJPIMNBO@?$AAr?$AAb@
  00074	48 8d 4c 24 70	 lea	 rcx, QWORD PTR tmp$[rsp]
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wfopen
  0007f	48 8b d8	 mov	 rbx, rax

; 1956 :     if (fp != NULL) {

  00082	48 85 c0	 test	 rax, rax
  00085	74 36		 je	 SHORT $LN9@p_stat

; 1957 :       fseek(fp, 0, SEEK_END);

  00087	33 d2		 xor	 edx, edx
  00089	48 8b c8	 mov	 rcx, rax
  0008c	44 8d 42 02	 lea	 r8d, QWORD PTR [rdx+2]
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek

; 1958 :       if (ftell(fp) > 0) st.st_size = ftell(fp);  // Use _ftelli64 on win10+

  00096	48 8b cb	 mov	 rcx, rbx
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ftell
  0009f	85 c0		 test	 eax, eax
  000a1	7e 11		 jle	 SHORT $LN5@p_stat
  000a3	48 8b cb	 mov	 rcx, rbx
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ftell
  000ac	48 63 c8	 movsxd	 rcx, eax
  000af	48 89 4c 24 48	 mov	 QWORD PTR st$[rsp+24], rcx
$LN5@p_stat:

; 1959 :       fclose(fp);

  000b4	48 8b cb	 mov	 rcx, rbx
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose
$LN9@p_stat:

; 1960 :     }
; 1961 :   }
; 1962 : #else
; 1963 :   struct MG_STAT_STRUCT st;
; 1964 :   if (MG_STAT_FUNC(path, &st) != 0) return 0;
; 1965 : #endif
; 1966 :   if (size) *size = (size_t) st.st_size;

  000bd	48 85 f6	 test	 rsi, rsi
  000c0	74 08		 je	 SHORT $LN6@p_stat
  000c2	48 8b 44 24 48	 mov	 rax, QWORD PTR st$[rsp+24]
  000c7	48 89 06	 mov	 QWORD PTR [rsi], rax
$LN6@p_stat:

; 1967 :   if (mtime) *mtime = st.st_mtime;

  000ca	48 85 ff	 test	 rdi, rdi
  000cd	74 08		 je	 SHORT $LN7@p_stat
  000cf	48 8b 44 24 58	 mov	 rax, QWORD PTR st$[rsp+40]
  000d4	48 89 07	 mov	 QWORD PTR [rdi], rax
$LN7@p_stat:

; 1968 :   return MG_FS_READ | MG_FS_WRITE | (S_ISDIR(st.st_mode) ? MG_FS_DIR : 0);

  000d7	0f b7 4c 24 36	 movzx	 ecx, WORD PTR st$[rsp+6]
  000dc	b8 00 f0 00 00	 mov	 eax, 61440		; 0000f000H
  000e1	66 23 c8	 and	 cx, ax
  000e4	41 b8 00 40 00
	00		 mov	 r8d, 16384		; 00004000H
  000ea	b8 03 00 00 00	 mov	 eax, 3
  000ef	66 41 3b c8	 cmp	 cx, r8w
  000f3	8d 50 04	 lea	 edx, QWORD PTR [rax+4]
  000f6	0f 44 c2	 cmove	 eax, edx
$LN1@p_stat:

; 1969 : #endif
; 1970 : }

  000f9	4c 8d 9c 24 80
	02 00 00	 lea	 r11, QWORD PTR [rsp+640]
  00101	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00105	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00109	49 8b e3	 mov	 rsp, r11
  0010c	5f		 pop	 rdi
  0010d	c3		 ret	 0
p_stat	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT to_wchar
_TEXT	SEGMENT
buf$ = 64
buf2$ = 592
path$ = 1136
wbuf$ = 1144
wbuf_len$dead$ = 1152
to_wchar PROC						; COMDAT

; 2003 : static int to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi
  0000a	41 56		 push	 r14
  0000c	48 81 ec 60 04
	00 00		 sub	 rsp, 1120		; 00000460H
  00013	48 8b fa	 mov	 rdi, rdx

; 2004 :   int ret;
; 2005 :   char buf[MAX_PATH * 2], buf2[MAX_PATH * 2], *p;
; 2006 :   strncpy(buf, path, sizeof(buf));

  00016	41 b8 08 02 00
	00		 mov	 r8d, 520		; 00000208H
  0001c	48 8b d1	 mov	 rdx, rcx
  0001f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$[rsp]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 2007 :   buf[sizeof(buf) - 1] = '\0';

  0002a	45 33 f6	 xor	 r14d, r14d

; 2008 :   // Trim trailing slashes. Leave backslash for paths like "X:\"
; 2009 :   p = buf + strlen(buf) - 1;

  0002d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$[rsp]
  00032	48 83 cb ff	 or	 rbx, -1
  00036	44 88 b4 24 47
	02 00 00	 mov	 BYTE PTR buf$[rsp+519], r14b
  0003e	48 8b c3	 mov	 rax, rbx
$LL13@to_wchar:
  00041	48 ff c0	 inc	 rax
  00044	44 38 34 01	 cmp	 BYTE PTR [rcx+rax], r14b
  00048	75 f7		 jne	 SHORT $LL13@to_wchar
  0004a	48 8d 44 04 3f	 lea	 rax, QWORD PTR buf$[rsp+rax-1]

; 2010 :   while (p > buf && p[-1] != ':' && (p[0] == '\\' || p[0] == '/')) *p-- = '\0';

  0004f	eb 16		 jmp	 SHORT $LN16@to_wchar
$LL2@to_wchar:
  00051	80 78 ff 3a	 cmp	 BYTE PTR [rax-1], 58	; 0000003aH
  00055	74 1a		 je	 SHORT $LN3@to_wchar
  00057	80 38 5c	 cmp	 BYTE PTR [rax], 92	; 0000005cH
  0005a	74 05		 je	 SHORT $LN4@to_wchar
  0005c	80 38 2f	 cmp	 BYTE PTR [rax], 47	; 0000002fH
  0005f	75 10		 jne	 SHORT $LN3@to_wchar
$LN4@to_wchar:
  00061	44 88 30	 mov	 BYTE PTR [rax], r14b
  00064	48 ff c8	 dec	 rax
$LN16@to_wchar:
  00067	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$[rsp]
  0006c	48 3b c1	 cmp	 rax, rcx
  0006f	77 e0		 ja	 SHORT $LL2@to_wchar
$LN3@to_wchar:

; 2011 :   memset(wbuf, 0, wbuf_len * sizeof(wchar_t));

  00071	33 d2		 xor	 edx, edx
  00073	41 b8 08 02 00
	00		 mov	 r8d, 520		; 00000208H
  00079	48 8b cf	 mov	 rcx, rdi
  0007c	e8 00 00 00 00	 call	 memset

; 2012 :   ret = MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);

  00081	44 8b cb	 mov	 r9d, ebx
  00084	c7 44 24 28 04
	01 00 00	 mov	 DWORD PTR [rsp+40], 260	; 00000104H
  0008c	4c 8d 44 24 40	 lea	 r8, QWORD PTR buf$[rsp]
  00091	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00096	33 d2		 xor	 edx, edx
  00098	b9 e9 fd 00 00	 mov	 ecx, 65001		; 0000fde9H
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MultiByteToWideChar

; 2013 :   // Convert back to Unicode. If doubly-converted string does not match the
; 2014 :   // original, something is fishy, reject.
; 2015 :   WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),

  000a3	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  000a8	41 b9 04 01 00
	00		 mov	 r9d, 260		; 00000104H
  000ae	8b d8		 mov	 ebx, eax
  000b0	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  000b5	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR buf2$[rsp]
  000bd	c7 44 24 28 08
	02 00 00	 mov	 DWORD PTR [rsp+40], 520	; 00000208H
  000c5	4c 8b c7	 mov	 r8, rdi
  000c8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000cd	33 d2		 xor	 edx, edx
  000cf	b9 e9 fd 00 00	 mov	 ecx, 65001		; 0000fde9H
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WideCharToMultiByte

; 2016 :                       NULL, NULL);
; 2017 :   if (strcmp(buf, buf2) != 0) {

  000da	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$[rsp]
  000df	4c 8d 84 24 50
	02 00 00	 lea	 r8, QWORD PTR buf2$[rsp]
  000e7	4c 2b c1	 sub	 r8, rcx
$LL11@to_wchar:
  000ea	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  000ed	42 0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+r8]
  000f2	2b c2		 sub	 eax, edx
  000f4	75 07		 jne	 SHORT $LN12@to_wchar
  000f6	48 ff c1	 inc	 rcx
  000f9	85 d2		 test	 edx, edx
  000fb	75 ed		 jne	 SHORT $LL11@to_wchar
$LN12@to_wchar:
  000fd	85 c0		 test	 eax, eax
  000ff	74 07		 je	 SHORT $LN5@to_wchar

; 2018 :     wbuf[0] = L'\0';

  00101	66 44 89 37	 mov	 WORD PTR [rdi], r14w

; 2019 :     ret = 0;

  00105	41 8b de	 mov	 ebx, r14d
$LN5@to_wchar:

; 2020 :   }
; 2021 :   return ret;
; 2022 : }

  00108	4c 8d 9c 24 60
	04 00 00	 lea	 r11, QWORD PTR [rsp+1120]
  00110	8b c3		 mov	 eax, ebx
  00112	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00116	49 8b 7b 18	 mov	 rdi, QWORD PTR [r11+24]
  0011a	49 8b e3	 mov	 rsp, r11
  0011d	41 5e		 pop	 r14
  0011f	c3		 ret	 0
to_wchar ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT opendir
_TEXT	SEGMENT
wpath$ = 32
name$ = 576
opendir	PROC						; COMDAT

; 2024 : DIR *opendir(const char *name) {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 30 02
	00 00		 sub	 rsp, 560		; 00000230H

; 2025 :   DIR *d = NULL;

  00012	33 f6		 xor	 esi, esi
  00014	48 8b f9	 mov	 rdi, rcx
  00017	8b de		 mov	 ebx, esi

; 2026 :   wchar_t wpath[MAX_PATH];
; 2027 :   DWORD attrs;
; 2028 : 
; 2029 :   if (name == NULL) {

  00019	48 85 c9	 test	 rcx, rcx
  0001c	75 07		 jne	 SHORT $LN2@opendir

; 2030 :     SetLastError(ERROR_BAD_ARGUMENTS);

  0001e	b9 a0 00 00 00	 mov	 ecx, 160		; 000000a0H
  00023	eb 1b		 jmp	 SHORT $LN10@opendir
$LN2@opendir:

; 2031 :   } else if ((d = (DIR *) calloc(1, sizeof(*d))) == NULL) {

  00025	ba 60 03 00 00	 mov	 edx, 864		; 00000360H
  0002a	b9 01 00 00 00	 mov	 ecx, 1
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00035	48 8b d8	 mov	 rbx, rax
  00038	48 85 c0	 test	 rax, rax
  0003b	75 0b		 jne	 SHORT $LN4@opendir

; 2032 :     SetLastError(ERROR_NOT_ENOUGH_MEMORY);

  0003d	8d 48 08	 lea	 ecx, QWORD PTR [rax+8]
$LN10@opendir:

; 2043 :     }
; 2044 :   }
; 2045 :   return d;

  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetLastError
  00046	eb 6d		 jmp	 SHORT $LN7@opendir
$LN4@opendir:

; 2033 :   } else {
; 2034 :     to_wchar(name, wpath, sizeof(wpath) / sizeof(wpath[0]));

  00048	48 8d 54 24 20	 lea	 rdx, QWORD PTR wpath$[rsp]
  0004d	48 8b cf	 mov	 rcx, rdi
  00050	e8 00 00 00 00	 call	 to_wchar

; 2035 :     attrs = GetFileAttributesW(wpath);

  00055	48 8d 4c 24 20	 lea	 rcx, QWORD PTR wpath$[rsp]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesW

; 2036 :     if (attrs != 0Xffffffff && (attrs & FILE_ATTRIBUTE_DIRECTORY)) {

  00060	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00063	74 44		 je	 SHORT $LN6@opendir
  00065	a8 10		 test	 al, 16
  00067	74 40		 je	 SHORT $LN6@opendir

; 2037 :       (void) wcscat(wpath, L"\\*");

  00069	48 8d 4c 24 20	 lea	 rcx, QWORD PTR wpath$[rsp]
  0006e	48 83 e9 02	 sub	 rcx, 2
$LL9@opendir:
  00072	48 8d 49 02	 lea	 rcx, QWORD PTR [rcx+2]
  00076	66 39 31	 cmp	 WORD PTR [rcx], si
  00079	75 f7		 jne	 SHORT $LL9@opendir
  0007b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_15PKPONJIK@?$AA?2?$AA?$CK@

; 2038 :       d->handle = FindFirstFileW(wpath, &d->info);

  00081	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]
  00085	89 01		 mov	 DWORD PTR [rcx], eax
  00087	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_15PKPONJIK@?$AA?2?$AA?$CK@+4
  0008e	66 89 41 04	 mov	 WORD PTR [rcx+4], ax
  00092	48 8d 4c 24 20	 lea	 rcx, QWORD PTR wpath$[rsp]
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindFirstFileW
  0009d	48 89 03	 mov	 QWORD PTR [rbx], rax

; 2039 :       d->result.d_name[0] = '\0';

  000a0	40 88 b3 58 02
	00 00		 mov	 BYTE PTR [rbx+600], sil

; 2040 :     } else {

  000a7	eb 0c		 jmp	 SHORT $LN7@opendir
$LN6@opendir:

; 2041 :       free(d);

  000a9	48 8b cb	 mov	 rcx, rbx
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2042 :       d = NULL;

  000b2	48 8b de	 mov	 rbx, rsi
$LN7@opendir:

; 2046 : }

  000b5	4c 8d 9c 24 30
	02 00 00	 lea	 r11, QWORD PTR [rsp+560]
  000bd	48 8b c3	 mov	 rax, rbx
  000c0	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000c4	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  000c8	49 8b e3	 mov	 rsp, r11
  000cb	5f		 pop	 rdi
  000cc	c3		 ret	 0
opendir	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT closedir
_TEXT	SEGMENT
d$ = 48
closedir PROC						; COMDAT

; 2048 : int closedir(DIR *d) {

$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2049 :   int result = 0;

  0000a	33 db		 xor	 ebx, ebx
  0000c	48 8b f9	 mov	 rdi, rcx

; 2050 :   if (d != NULL) {

  0000f	48 85 c9	 test	 rcx, rcx
  00012	74 23		 je	 SHORT $LN2@closedir

; 2051 :     if (d->handle != INVALID_HANDLE_VALUE)

  00014	48 83 39 ff	 cmp	 QWORD PTR [rcx], -1
  00018	74 12		 je	 SHORT $LN4@closedir

; 2052 :       result = FindClose(d->handle) ? 0 : -1;

  0001a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindClose
  00023	f7 d8		 neg	 eax
  00025	1b c9		 sbb	 ecx, ecx
  00027	f7 d9		 neg	 ecx
  00029	8d 59 ff	 lea	 ebx, DWORD PTR [rcx-1]
$LN4@closedir:

; 2053 :     free(d);

  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2054 :   } else {

  00035	eb 0e		 jmp	 SHORT $LN3@closedir
$LN2@closedir:

; 2055 :     result = -1;

  00037	83 cb ff	 or	 ebx, -1

; 2056 :     SetLastError(ERROR_BAD_ARGUMENTS);

  0003a	b9 a0 00 00 00	 mov	 ecx, 160		; 000000a0H
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetLastError
$LN3@closedir:

; 2057 :   }
; 2058 :   return result;

  00045	8b c3		 mov	 eax, ebx

; 2059 : }

  00047	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5f		 pop	 rdi
  00051	c3		 ret	 0
closedir ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT readdir
_TEXT	SEGMENT
d$ = 80
readdir	PROC						; COMDAT

; 2061 : struct dirent *readdir(DIR *d) {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 2062 :   struct dirent *result = NULL;

  0000f	33 ff		 xor	 edi, edi
  00011	48 8b d9	 mov	 rbx, rcx

; 2063 :   if (d != NULL) {

  00014	48 85 c9	 test	 rcx, rcx
  00017	74 75		 je	 SHORT $LN2@readdir

; 2064 :     memset(&d->result, 0, sizeof(d->result));

  00019	48 8d b1 58 02
	00 00		 lea	 rsi, QWORD PTR [rcx+600]
  00020	33 d2		 xor	 edx, edx
  00022	48 8b ce	 mov	 rcx, rsi
  00025	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0002b	e8 00 00 00 00	 call	 memset

; 2065 :     if (d->handle != INVALID_HANDLE_VALUE) {

  00030	48 83 3b ff	 cmp	 QWORD PTR [rbx], -1
  00034	74 51		 je	 SHORT $LN4@readdir

; 2066 :       result = &d->result;
; 2067 :       WideCharToMultiByte(CP_UTF8, 0, d->info.cFileName, -1, result->d_name,

  00036	48 83 64 24 38
	00		 and	 QWORD PTR [rsp+56], 0
  0003c	4c 8d 43 34	 lea	 r8, QWORD PTR [rbx+52]
  00040	48 83 64 24 30
	00		 and	 QWORD PTR [rsp+48], 0
  00046	41 83 c9 ff	 or	 r9d, -1
  0004a	c7 44 24 28 04
	01 00 00	 mov	 DWORD PTR [rsp+40], 260	; 00000104H
  00052	33 d2		 xor	 edx, edx
  00054	b9 e9 fd 00 00	 mov	 ecx, 65001		; 0000fde9H
  00059	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0005e	48 8b fe	 mov	 rdi, rsi
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WideCharToMultiByte

; 2068 :                           sizeof(result->d_name), NULL, NULL);
; 2069 :       if (!FindNextFileW(d->handle, &d->info)) {

  00067	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0006a	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindNextFileW
  00074	85 c0		 test	 eax, eax
  00076	75 21		 jne	 SHORT $LN3@readdir

; 2070 :         FindClose(d->handle);

  00078	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindClose

; 2071 :         d->handle = INVALID_HANDLE_VALUE;

  00081	48 83 0b ff	 or	 QWORD PTR [rbx], -1

; 2072 :       }
; 2073 :     } else {

  00085	eb 12		 jmp	 SHORT $LN3@readdir
$LN4@readdir:

; 2074 :       SetLastError(ERROR_FILE_NOT_FOUND);

  00087	b9 02 00 00 00	 mov	 ecx, 2

; 2075 :     }
; 2076 :   } else {

  0008c	eb 05		 jmp	 SHORT $LN8@readdir
$LN2@readdir:

; 2077 :     SetLastError(ERROR_BAD_ARGUMENTS);

  0008e	b9 a0 00 00 00	 mov	 ecx, 160		; 000000a0H
$LN8@readdir:

; 2078 :   }
; 2079 :   return result;

  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetLastError
$LN3@readdir:

; 2080 : }

  00099	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0009e	48 8b c7	 mov	 rax, rdi
  000a1	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  000a6	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
readdir	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT p_list
_TEXT	SEGMENT
dir$ = 48
fn$ = 56
userdata$ = 64
p_list	PROC						; COMDAT

; 2084 :                    void *userdata) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx

; 2085 : #if MG_ENABLE_DIRLIST
; 2086 :   struct dirent *dp;
; 2087 :   DIR *dirp;
; 2088 :   if ((dirp = (opendir(dir))) == NULL) return;

  00015	e8 00 00 00 00	 call	 opendir
  0001a	48 8b d8	 mov	 rbx, rax
  0001d	48 85 c0	 test	 rax, rax
  00020	74 3b		 je	 SHORT $LN1@p_list

; 2089 :   while ((dp = readdir(dirp)) != NULL) {

  00022	eb 24		 jmp	 SHORT $LN6@p_list
$LL2@p_list:

; 2090 :     if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, "..")) continue;

  00024	80 38 2e	 cmp	 BYTE PTR [rax], 46	; 0000002eH
  00027	75 17		 jne	 SHORT $LN12@p_list
  00029	80 78 01 00	 cmp	 BYTE PTR [rax+1], 0
  0002d	74 19		 je	 SHORT $LN6@p_list
  0002f	80 38 2e	 cmp	 BYTE PTR [rax], 46	; 0000002eH
  00032	75 0c		 jne	 SHORT $LN12@p_list
  00034	80 78 01 2e	 cmp	 BYTE PTR [rax+1], 46	; 0000002eH
  00038	75 06		 jne	 SHORT $LN12@p_list
  0003a	80 78 02 00	 cmp	 BYTE PTR [rax+2], 0
  0003e	74 08		 je	 SHORT $LN6@p_list
$LN12@p_list:

; 2091 :     fn(dp->d_name, userdata);

  00040	48 8b d7	 mov	 rdx, rdi
  00043	48 8b c8	 mov	 rcx, rax
  00046	ff d6		 call	 rsi
$LN6@p_list:

; 2089 :   while ((dp = readdir(dirp)) != NULL) {

  00048	48 8b cb	 mov	 rcx, rbx
  0004b	e8 00 00 00 00	 call	 readdir
  00050	48 85 c0	 test	 rax, rax
  00053	75 cf		 jne	 SHORT $LL2@p_list

; 2092 :   }
; 2093 :   closedir(dirp);

  00055	48 8b cb	 mov	 rcx, rbx
  00058	e8 00 00 00 00	 call	 closedir
$LN1@p_list:

; 2094 : #else
; 2095 :   (void) dir, (void) fn, (void) userdata;
; 2096 : #endif
; 2097 : }

  0005d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00062	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5f		 pop	 rdi
  0006c	c3		 ret	 0
p_list	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT p_open
_TEXT	SEGMENT
b2$ = 48
b1$ = 80
path$ = 624
flags$ = 632
p_open	PROC						; COMDAT

; 2099 : static void *p_open(const char *path, int flags) {

  00000	40 53		 push	 rbx
  00002	48 81 ec 60 02
	00 00		 sub	 rsp, 608		; 00000260H
  00009	8b da		 mov	 ebx, edx

; 2100 : #if MG_ARCH == MG_ARCH_WIN32
; 2101 :   const char *mode = flags == MG_FS_READ ? "rb" : "a+b";
; 2102 :   wchar_t b1[MG_PATH_MAX], b2[10];
; 2103 :   MultiByteToWideChar(CP_UTF8, 0, path, -1, b1, sizeof(b1) / sizeof(b1[0]));

  0000b	c7 44 24 28 04
	01 00 00	 mov	 DWORD PTR [rsp+40], 260	; 00000104H
  00013	48 8d 44 24 50	 lea	 rax, QWORD PTR b1$[rsp]
  00018	4c 8b c1	 mov	 r8, rcx
  0001b	33 d2		 xor	 edx, edx
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	b9 e9 fd 00 00	 mov	 ecx, 65001		; 0000fde9H
  00027	41 83 c9 ff	 or	 r9d, -1
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MultiByteToWideChar
  00031	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02JDPG@rb@

; 2104 :   MultiByteToWideChar(CP_UTF8, 0, mode, -1, b2, sizeof(b2) / sizeof(b2[0]));

  00038	c7 44 24 28 0a
	00 00 00	 mov	 DWORD PTR [rsp+40], 10
  00040	83 fb 01	 cmp	 ebx, 1
  00043	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03DOPCBAKB@a?$CLb@
  0004a	b9 e9 fd 00 00	 mov	 ecx, 65001		; 0000fde9H
  0004f	4c 0f 44 c0	 cmove	 r8, rax
  00053	48 8d 44 24 30	 lea	 rax, QWORD PTR b2$[rsp]
  00058	41 83 c9 ff	 or	 r9d, -1
  0005c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00061	33 d2		 xor	 edx, edx
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MultiByteToWideChar

; 2105 :   return (void *) _wfopen(b1, b2);

  00069	48 8d 54 24 30	 lea	 rdx, QWORD PTR b2$[rsp]
  0006e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR b1$[rsp]
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wfopen

; 2106 : #else
; 2107 :   const char *mode = flags == MG_FS_READ ? "rbe" : "a+be";  // e for CLOEXEC
; 2108 :   return (void *) fopen(path, mode);
; 2109 : #endif
; 2110 : }

  00079	48 81 c4 60 02
	00 00		 add	 rsp, 608		; 00000260H
  00080	5b		 pop	 rbx
  00081	c3		 ret	 0
p_open	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT p_close
_TEXT	SEGMENT
fp$ = 8
p_close	PROC						; COMDAT

; 2113 :   fclose((FILE *) fp);

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_fclose
p_close	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT p_read
_TEXT	SEGMENT
fp$ = 8
buf$ = 16
len$ = 24
p_read	PROC						; COMDAT

; 2116 : static size_t p_read(void *fp, void *buf, size_t len) {

  00000	48 8b c2	 mov	 rax, rdx

; 2117 :   return fread(buf, 1, len, (FILE *) fp);

  00003	4c 8b c9	 mov	 r9, rcx
  00006	48 8b c8	 mov	 rcx, rax
  00009	ba 01 00 00 00	 mov	 edx, 1
  0000e	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_fread
p_read	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT p_write
_TEXT	SEGMENT
fp$ = 8
buf$ = 16
len$ = 24
p_write	PROC						; COMDAT

; 2120 : static size_t p_write(void *fp, const void *buf, size_t len) {

  00000	48 8b c2	 mov	 rax, rdx

; 2121 :   return fwrite(buf, 1, len, (FILE *) fp);

  00003	4c 8b c9	 mov	 r9, rcx
  00006	48 8b c8	 mov	 rcx, rax
  00009	ba 01 00 00 00	 mov	 edx, 1
  0000e	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_fwrite
p_write	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT p_seek
_TEXT	SEGMENT
fp$ = 48
offset$ = 56
p_seek	PROC						; COMDAT

; 2124 : static size_t p_seek(void *fp, size_t offset) {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2125 : #if (defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64) ||  \
; 2126 :     (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200112L) || \
; 2127 :     (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 600)
; 2128 :   if (fseeko((FILE *) fp, (off_t) offset, SEEK_SET) != 0) (void) 0;
; 2129 : #else
; 2130 :   if (fseek((FILE *) fp, (long) offset, SEEK_SET) != 0) (void) 0;

  00006	45 33 c0	 xor	 r8d, r8d
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek

; 2131 : #endif
; 2132 :   return (size_t) ftell((FILE *) fp);

  00012	48 8b cb	 mov	 rcx, rbx
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ftell
  0001b	48 98		 cdqe

; 2133 : }

  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5b		 pop	 rbx
  00022	c3		 ret	 0
p_seek	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT p_rename
_TEXT	SEGMENT
from$ = 48
to$ = 56
p_rename PROC						; COMDAT

; 2135 : static bool p_rename(const char *from, const char *to) {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2136 :   return rename(from, to) == 0;

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rename
  0000a	85 c0		 test	 eax, eax
  0000c	0f 94 c0	 sete	 al

; 2137 : }

  0000f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00013	c3		 ret	 0
p_rename ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT p_remove
_TEXT	SEGMENT
path$ = 48
p_remove PROC						; COMDAT

; 2139 : static bool p_remove(const char *path) {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2140 :   return remove(path) == 0;

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_remove
  0000a	85 c0		 test	 eax, eax
  0000c	0f 94 c0	 sete	 al

; 2141 : }

  0000f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00013	c3		 ret	 0
p_remove ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT p_mkdir
_TEXT	SEGMENT
path$ = 48
p_mkdir	PROC						; COMDAT

; 2143 : static bool p_mkdir(const char *path) {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2144 :   return mkdir(path, 0775) == 0;

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__mkdir
  0000a	85 c0		 test	 eax, eax
  0000c	0f 94 c0	 sete	 al

; 2145 : }

  0000f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00013	c3		 ret	 0
p_mkdir	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_to_size_t
_TEXT	SEGMENT
str$ = 8
val$ = 16
mg_to_size_t PROC					; COMDAT

; 2210 : bool mg_to_size_t(struct mg_str str, size_t *val) {

$LN40:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000f	4c 89 70 20	 mov	 QWORD PTR [rax+32], r14

; 2211 :   size_t i = 0, max = (size_t) -1, max2 = max / 10, result = 0, ndigits = 0;
; 2212 :   while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\t')) i++;

  00013	4c 8b 51 08	 mov	 r10, QWORD PTR [rcx+8]
  00017	45 33 c0	 xor	 r8d, r8d
  0001a	45 33 c9	 xor	 r9d, r9d
  0001d	45 33 db	 xor	 r11d, r11d
  00020	4c 8b f2	 mov	 r14, rdx
  00023	4d 85 d2	 test	 r10, r10
  00026	74 17		 je	 SHORT $LN3@mg_to_size
  00028	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
$LL2@mg_to_size:
  0002b	42 8a 04 02	 mov	 al, BYTE PTR [rdx+r8]
  0002f	3c 20		 cmp	 al, 32			; 00000020H
  00031	74 04		 je	 SHORT $LN8@mg_to_size
  00033	3c 09		 cmp	 al, 9
  00035	75 08		 jne	 SHORT $LN3@mg_to_size
$LN8@mg_to_size:
  00037	49 ff c0	 inc	 r8
  0003a	4d 3b c2	 cmp	 r8, r10
  0003d	72 ec		 jb	 SHORT $LL2@mg_to_size
$LN3@mg_to_size:

; 2213 :   if (i < str.len && str.ptr[i] == '-') return false;

  0003f	4d 3b c2	 cmp	 r8, r10
  00042	73 78		 jae	 SHORT $LN33@mg_to_size
  00044	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00047	41 80 3c 00 2d	 cmp	 BYTE PTR [r8+rax], 45	; 0000002dH
  0004c	74 6e		 je	 SHORT $LN33@mg_to_size

; 2214 :   while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {

  0004e	48 8b f0	 mov	 rsi, rax
$LL4@mg_to_size:
  00051	42 8a 04 06	 mov	 al, BYTE PTR [rsi+r8]
  00055	2c 30		 sub	 al, 48			; 00000030H
  00057	3c 09		 cmp	 al, 9
  00059	77 4b		 ja	 SHORT $LN38@mg_to_size

; 2215 :     size_t digit = (size_t) (str.ptr[i] - '0');

  0005b	42 0f be 04 06	 movsx	 eax, BYTE PTR [rsi+r8]
  00060	83 e8 30	 sub	 eax, 48			; 00000030H
  00063	48 63 d0	 movsxd	 rdx, eax

; 2216 :     if (result > max2) return false;  // Overflow

  00066	48 b8 99 99 99
	99 99 99 99 19	 mov	 rax, 1844674407370955161 ; 1999999999999999H
  00070	4c 3b c8	 cmp	 r9, rax
  00073	77 47		 ja	 SHORT $LN33@mg_to_size

; 2217 :     result *= 10;

  00075	4f 8d 0c 89	 lea	 r9, QWORD PTR [r9+r9*4]

; 2218 :     if (result > max - digit) return false;  // Overflow

  00079	48 8b c2	 mov	 rax, rdx
  0007c	4d 03 c9	 add	 r9, r9
  0007f	48 f7 d0	 not	 rax
  00082	4c 3b c8	 cmp	 r9, rax
  00085	77 35		 ja	 SHORT $LN33@mg_to_size

; 2219 :     result += digit;

  00087	4c 03 ca	 add	 r9, rdx

; 2220 :     i++, ndigits++;

  0008a	49 ff c0	 inc	 r8
  0008d	49 ff c3	 inc	 r11
  00090	4d 3b c2	 cmp	 r8, r10
  00093	72 bc		 jb	 SHORT $LL4@mg_to_size

; 2218 :     if (result > max - digit) return false;  // Overflow

  00095	eb 14		 jmp	 SHORT $LN7@mg_to_size
$LL6@mg_to_size:

; 2221 :   }
; 2222 :   while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\t')) i++;

  00097	42 8a 04 06	 mov	 al, BYTE PTR [rsi+r8]
  0009b	3c 20		 cmp	 al, 32			; 00000020H
  0009d	74 04		 je	 SHORT $LN12@mg_to_size
  0009f	3c 09		 cmp	 al, 9
  000a1	75 08		 jne	 SHORT $LN7@mg_to_size
$LN12@mg_to_size:
  000a3	49 ff c0	 inc	 r8
$LN38@mg_to_size:
  000a6	4d 3b c2	 cmp	 r8, r10
  000a9	72 ec		 jb	 SHORT $LL6@mg_to_size
$LN7@mg_to_size:

; 2223 :   if (ndigits == 0) return false;  // #2322: Content-Length = 1 * DIGIT

  000ab	4d 85 db	 test	 r11, r11
  000ae	74 0c		 je	 SHORT $LN33@mg_to_size

; 2224 :   if (i != str.len) return false;  // Ditto

  000b0	4d 3b c2	 cmp	 r8, r10
  000b3	75 07		 jne	 SHORT $LN33@mg_to_size

; 2225 :   *val = (size_t) result;

  000b5	4d 89 0e	 mov	 QWORD PTR [r14], r9

; 2226 :   return true;

  000b8	b0 01		 mov	 al, 1
  000ba	eb 02		 jmp	 SHORT $LN1@mg_to_size
$LN33@mg_to_size:

; 2224 :   if (i != str.len) return false;  // Ditto

  000bc	32 c0		 xor	 al, al
$LN1@mg_to_size:

; 2227 : }

  000be	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  000c3	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]
  000c8	48 8b 7c 24 18	 mov	 rdi, QWORD PTR [rsp+24]
  000cd	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
  000d2	c3		 ret	 0
mg_to_size_t ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_next_multipart
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
$T4 = 64
$T5 = 80
$T6 = 80
$T7 = 96
$T8 = 112
b$1$ = 192
body$ = 192
tv788 = 200
b1$1$ = 200
ofs$ = 200
h1$1$ = 208
part$ = 208
mg_http_next_multipart PROC				; COMDAT

; 2245 :                               struct mg_http_part *part) {

$LN56:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 8b ec	 mov	 rbp, rsp
  00013	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 2246 :   struct mg_str cd = mg_str_n("Content-Disposition", 19);
; 2247 :   const char *s = body.ptr;

  0001a	4c 8b 39	 mov	 r15, QWORD PTR [rcx]
  0001d	4d 8b e0	 mov	 r12, r8

; 2248 :   size_t b = ofs, h1, h2, b1, b2, max = body.len;

  00020	4c 8b 71 08	 mov	 r14, QWORD PTR [rcx+8]
  00024	4c 8b ea	 mov	 r13, rdx

; 2249 : 
; 2250 :   // Init part params
; 2251 :   if (part != NULL) part->name = part->filename = part->body = mg_str_n(0, 0);

  00027	4d 85 c0	 test	 r8, r8
  0002a	74 1f		 je	 SHORT $LN33@mg_http_ne

; 7845 :   struct mg_str str = {s, n};

  0002c	48 83 65 a0 00	 and	 QWORD PTR $T2[rbp-128], 0
  00031	48 83 65 a8 00	 and	 QWORD PTR $T2[rbp-120], 0

; 2249 : 
; 2250 :   // Init part params
; 2251 :   if (part != NULL) part->name = part->filename = part->body = mg_str_n(0, 0);

  00036	0f 10 45 a0	 movups	 xmm0, XMMWORD PTR $T2[rbp-128]
  0003a	f3 41 0f 7f 40
	20		 movdqu	 XMMWORD PTR [r8+32], xmm0
  00040	f3 41 0f 7f 40
	10		 movdqu	 XMMWORD PTR [r8+16], xmm0
  00046	f3 41 0f 7f 00	 movdqu	 XMMWORD PTR [r8], xmm0
$LN33@mg_http_ne:

; 2252 : 
; 2253 :   // Skip boundary
; 2254 :   while (b + 2 < max && s[b] != '\r' && s[b + 1] != '\n') b++;

  0004b	48 8d 42 02	 lea	 rax, QWORD PTR [rdx+2]
  0004f	49 3b c6	 cmp	 rax, r14
  00052	0f 83 f0 01 00
	00		 jae	 $LN13@mg_http_ne
  00058	41 b9 02 00 00
	00		 mov	 r9d, 2
  0005e	49 8d 0c 17	 lea	 rcx, QWORD PTR [r15+rdx]
  00062	44 8a 01	 mov	 r8b, BYTE PTR [rcx]
  00065	4d 2b cf	 sub	 r9, r15
  00068	4c 89 4d 48	 mov	 QWORD PTR tv788[rbp-128], r9
$LL2@mg_http_ne:
  0006c	41 80 f8 0d	 cmp	 r8b, 13
  00070	74 1b		 je	 SHORT $LN3@mg_http_ne
  00072	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  00076	44 8a 00	 mov	 r8b, BYTE PTR [rax]
  00079	48 8b c8	 mov	 rcx, rax
  0007c	41 80 f8 0a	 cmp	 r8b, 10
  00080	74 0b		 je	 SHORT $LN3@mg_http_ne
  00082	48 ff c2	 inc	 rdx
  00085	49 03 c1	 add	 rax, r9
  00088	49 3b c6	 cmp	 rax, r14
  0008b	72 df		 jb	 SHORT $LL2@mg_http_ne
$LN3@mg_http_ne:
  0008d	48 89 55 40	 mov	 QWORD PTR b$1$[rbp-128], rdx

; 2255 :   if (b <= ofs || b + 2 >= max) return 0;

  00091	49 3b d5	 cmp	 rdx, r13
  00094	0f 86 ae 01 00
	00		 jbe	 $LN13@mg_http_ne
  0009a	48 8d 5a 02	 lea	 rbx, QWORD PTR [rdx+2]
  0009e	49 3b de	 cmp	 rbx, r14
  000a1	0f 83 a1 01 00
	00		 jae	 $LN13@mg_http_ne

; 2256 :   // MG_INFO(("B: %zu %zu [%.*s]", ofs, b - ofs, (int) (b - ofs), s));
; 2257 : 
; 2258 :   // Skip headers
; 2259 :   h1 = h2 = b + 2;

  000a7	48 8b fb	 mov	 rdi, rbx
$LN54@mg_http_ne:

; 2260 :   for (;;) {
; 2261 :     while (h2 + 2 < max && s[h2] != '\r' && s[h2 + 1] != '\n') h2++;

  000aa	48 8d 43 02	 lea	 rax, QWORD PTR [rbx+2]
  000ae	48 89 7d 50	 mov	 QWORD PTR h1$1$[rbp-128], rdi
  000b2	49 3b c6	 cmp	 rax, r14
  000b5	73 24		 jae	 SHORT $LN8@mg_http_ne
  000b7	4a 8d 0c 3b	 lea	 rcx, QWORD PTR [rbx+r15]
  000bb	8a 11		 mov	 dl, BYTE PTR [rcx]
$LL7@mg_http_ne:
  000bd	80 fa 0d	 cmp	 dl, 13
  000c0	74 19		 je	 SHORT $LN8@mg_http_ne
  000c2	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  000c6	8a 10		 mov	 dl, BYTE PTR [rax]
  000c8	48 8b c8	 mov	 rcx, rax
  000cb	80 fa 0a	 cmp	 dl, 10
  000ce	74 0b		 je	 SHORT $LN8@mg_http_ne
  000d0	48 ff c3	 inc	 rbx
  000d3	49 03 c1	 add	 rax, r9
  000d6	49 3b c6	 cmp	 rax, r14
  000d9	72 e2		 jb	 SHORT $LL7@mg_http_ne
$LN8@mg_http_ne:

; 2262 :     if (h2 == h1) break;

  000db	48 8d 73 02	 lea	 rsi, QWORD PTR [rbx+2]
  000df	48 3b df	 cmp	 rbx, rdi
  000e2	0f 84 ce 00 00
	00		 je	 $LN37@mg_http_ne

; 2263 :     if (h2 + 2 >= max) return 0;

  000e8	49 3b f6	 cmp	 rsi, r14
  000eb	0f 83 57 01 00
	00		 jae	 $LN13@mg_http_ne

; 2264 :     // MG_INFO(("Header: [%.*s]", (int) (h2 - h1), &s[h1]));
; 2265 :     if (part != NULL && h1 + cd.len + 2 < h2 && s[h1 + cd.len] == ':' &&

  000f1	4d 85 e4	 test	 r12, r12
  000f4	0f 84 b1 00 00
	00		 je	 $LN16@mg_http_ne
  000fa	48 8d 47 15	 lea	 rax, QWORD PTR [rdi+21]
  000fe	48 3b c3	 cmp	 rax, rbx
  00101	0f 83 a4 00 00
	00		 jae	 $LN16@mg_http_ne
  00107	42 80 7c 3f 13
	3a		 cmp	 BYTE PTR [rdi+r15+19], 58 ; 0000003aH
  0010d	0f 85 98 00 00
	00		 jne	 $LN16@mg_http_ne
  00113	4a 8d 0c 3f	 lea	 rcx, QWORD PTR [rdi+r15]
  00117	41 b8 13 00 00
	00		 mov	 r8d, 19
  0011d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@LMOOGHBG@Content?9Disposition@
  00124	e8 00 00 00 00	 call	 mg_ncasecmp
  00129	85 c0		 test	 eax, eax
  0012b	75 7a		 jne	 SHORT $LN53@mg_http_ne

; 2266 :         mg_ncasecmp(&s[h1], cd.ptr, cd.len) == 0) {
; 2267 :       struct mg_str v = mg_str_n(&s[h1 + cd.len + 2], h2 - (h1 + cd.len + 2));

  0012d	48 2b 5d 50	 sub	 rbx, QWORD PTR h1$1$[rbp-128]

; 2268 :       part->name = mg_http_get_header_var(v, mg_str_n("name", 4));

  00131	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04MEMAJGDJ@name@
  00138	48 83 c7 15	 add	 rdi, 21
  0013c	48 89 45 a0	 mov	 QWORD PTR $T1[rbp-128], rax
  00140	49 03 ff	 add	 rdi, r15
  00143	48 c7 45 a8 04
	00 00 00	 mov	 QWORD PTR $T1[rbp-120], 4
  0014b	48 83 c3 eb	 add	 rbx, -21
  0014f	48 89 7d b0	 mov	 QWORD PTR $T3[rbp-128], rdi
  00153	4c 8d 45 a0	 lea	 r8, QWORD PTR $T1[rbp-128]
  00157	48 89 5d b8	 mov	 QWORD PTR $T3[rbp-120], rbx
  0015b	48 8d 55 b0	 lea	 rdx, QWORD PTR $T3[rbp-128]
  0015f	48 8d 4d e0	 lea	 rcx, QWORD PTR $T7[rbp-128]
  00163	e8 00 00 00 00	 call	 mg_http_get_header_var

; 2269 :       part->filename = mg_http_get_header_var(v, mg_str_n("filename", 8));

  00168	4c 8d 45 c0	 lea	 r8, QWORD PTR $T4[rbp-128]
  0016c	48 c7 45 c8 08
	00 00 00	 mov	 QWORD PTR $T4[rbp-120], 8
  00174	48 8d 55 d0	 lea	 rdx, QWORD PTR $T5[rbp-128]
  00178	48 89 7d d0	 mov	 QWORD PTR $T5[rbp-128], rdi
  0017c	48 8d 4d f0	 lea	 rcx, QWORD PTR $T8[rbp-128]
  00180	48 89 5d d8	 mov	 QWORD PTR $T5[rbp-120], rbx
  00184	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00187	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08BABJIOEM@filename@
  0018e	48 89 45 c0	 mov	 QWORD PTR $T4[rbp-128], rax
  00192	f3 41 0f 7f 04
	24		 movdqu	 XMMWORD PTR [r12], xmm0
  00198	e8 00 00 00 00	 call	 mg_http_get_header_var
  0019d	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  001a0	f3 41 0f 7f 44
	24 10		 movdqu	 XMMWORD PTR [r12+16], xmm0
$LN53@mg_http_ne:

; 2270 :     }
; 2271 :     h1 = h2 = h2 + 2;

  001a7	4c 8b 4d 48	 mov	 r9, QWORD PTR tv788[rbp-128]
$LN16@mg_http_ne:
  001ab	48 8b de	 mov	 rbx, rsi
  001ae	48 8b fe	 mov	 rdi, rsi

; 2272 :   }

  001b1	e9 f4 fe ff ff	 jmp	 $LN54@mg_http_ne
$LN37@mg_http_ne:

; 2274 :   while (b2 + 2 + (b - ofs) + 2 < max && !(s[b2] == '\r' && s[b2 + 1] == '\n' &&

  001b6	48 8b 55 40	 mov	 rdx, QWORD PTR b$1$[rbp-128]
  001ba	48 8b c6	 mov	 rax, rsi
  001bd	49 2b c5	 sub	 rax, r13
  001c0	48 89 75 48	 mov	 QWORD PTR b1$1$[rbp-128], rsi
  001c4	48 83 c0 04	 add	 rax, 4
  001c8	4c 8b c6	 mov	 r8, rsi
  001cb	48 03 c2	 add	 rax, rdx
  001ce	49 3b c6	 cmp	 rax, r14
  001d1	73 4b		 jae	 SHORT $LN10@mg_http_ne

; 2273 :   b1 = b2 = h2 + 2;

  001d3	49 8d 5f 01	 lea	 rbx, QWORD PTR [r15+1]
  001d7	48 8b fa	 mov	 rdi, rdx
  001da	48 03 de	 add	 rbx, rsi
  001dd	49 2b ff	 sub	 rdi, r15
  001e0	49 2b fd	 sub	 rdi, r13
$LL9@mg_http_ne:

; 2274 :   while (b2 + 2 + (b - ofs) + 2 < max && !(s[b2] == '\r' && s[b2 + 1] == '\n' &&

  001e3	80 7b ff 0d	 cmp	 BYTE PTR [rbx-1], 13
  001e7	75 1f		 jne	 SHORT $LN17@mg_http_ne
  001e9	80 3b 0a	 cmp	 BYTE PTR [rbx], 10
  001ec	75 1a		 jne	 SHORT $LN17@mg_http_ne
  001ee	4c 8b c2	 mov	 r8, rdx
  001f1	48 8d 4b 01	 lea	 rcx, QWORD PTR [rbx+1]
  001f5	4d 2b c5	 sub	 r8, r13
  001f8	49 8b d7	 mov	 rdx, r15
  001fb	e8 00 00 00 00	 call	 memcmp
  00200	85 c0		 test	 eax, eax
  00202	74 16		 je	 SHORT $LN52@mg_http_ne
  00204	48 8b 55 40	 mov	 rdx, QWORD PTR b$1$[rbp-128]
$LN17@mg_http_ne:

; 2275 :                                            memcmp(&s[b2 + 2], s, b - ofs) == 0))
; 2276 :     b2++;

  00208	48 ff c3	 inc	 rbx
  0020b	48 8d 47 03	 lea	 rax, QWORD PTR [rdi+3]
  0020f	48 03 c3	 add	 rax, rbx
  00212	48 ff c6	 inc	 rsi
  00215	49 3b c6	 cmp	 rax, r14
  00218	72 c9		 jb	 SHORT $LL9@mg_http_ne
$LN52@mg_http_ne:
  0021a	4c 8b 45 48	 mov	 r8, QWORD PTR b1$1$[rbp-128]
$LN10@mg_http_ne:

; 2277 : 
; 2278 :   if (b2 + 2 >= max) return 0;

  0021e	48 8d 46 02	 lea	 rax, QWORD PTR [rsi+2]
  00222	49 3b c6	 cmp	 rax, r14
  00225	73 21		 jae	 SHORT $LN13@mg_http_ne

; 2279 :   if (part != NULL) part->body = mg_str_n(&s[b1], b2 - b1);

  00227	4d 85 e4	 test	 r12, r12
  0022a	74 1e		 je	 SHORT $LN1@mg_http_ne
  0022c	4b 8d 0c 38	 lea	 rcx, QWORD PTR [r8+r15]
  00230	49 2b f0	 sub	 rsi, r8
  00233	48 89 4d d0	 mov	 QWORD PTR $T6[rbp-128], rcx

; 7845 :   struct mg_str str = {s, n};

  00237	48 89 75 d8	 mov	 QWORD PTR $T6[rbp-120], rsi

; 2279 :   if (part != NULL) part->body = mg_str_n(&s[b1], b2 - b1);

  0023b	0f 10 45 d0	 movups	 xmm0, XMMWORD PTR $T6[rbp-128]
  0023f	f3 41 0f 7f 44
	24 20		 movdqu	 XMMWORD PTR [r12+32], xmm0

; 2280 :   // MG_INFO(("Body: [%.*s]", (int) (b2 - b1), &s[b1]));
; 2281 :   return b2 + 2;

  00246	eb 02		 jmp	 SHORT $LN1@mg_http_ne
$LN13@mg_http_ne:

; 2255 :   if (b <= ofs || b + 2 >= max) return 0;

  00248	33 c0		 xor	 eax, eax
$LN1@mg_http_ne:

; 2282 : }

  0024a	48 8b 9c 24 d8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+216]
  00252	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00259	41 5f		 pop	 r15
  0025b	41 5e		 pop	 r14
  0025d	41 5d		 pop	 r13
  0025f	41 5c		 pop	 r12
  00261	5f		 pop	 rdi
  00262	5e		 pop	 rsi
  00263	5d		 pop	 rbp
  00264	c3		 ret	 0
mg_http_next_multipart ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_bauth
_TEXT	SEGMENT
c$ = 80
user$ = 88
pass$ = 96
mg_http_bauth PROC					; COMDAT

; 2285 :                    const char *pass) {

$LN38:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  0000f	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  00013	57		 push	 rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	41 57		 push	 r15
  0001c	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 7840 :   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};

  00020	48 83 ce ff	 or	 rsi, -1
  00024	33 db		 xor	 ebx, ebx

; 2285 :                    const char *pass) {

  00026	49 8b c0	 mov	 rax, r8
  00029	4c 8b ea	 mov	 r13, rdx
  0002c	48 8b f9	 mov	 rdi, rcx

; 7840 :   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};

  0002f	48 85 d2	 test	 rdx, rdx
  00032	75 04		 jne	 SHORT $LN19@mg_http_ba
  00034	8b eb		 mov	 ebp, ebx
  00036	eb 0c		 jmp	 SHORT $LN20@mg_http_ba
$LN19@mg_http_ba:
  00038	48 8b ee	 mov	 rbp, rsi
$LL36@mg_http_ba:
  0003b	48 ff c5	 inc	 rbp
  0003e	38 5c 15 00	 cmp	 BYTE PTR [rbp+rdx], bl
  00042	75 f7		 jne	 SHORT $LL36@mg_http_ba
$LN20@mg_http_ba:
  00044	48 85 c0	 test	 rax, rax
  00047	75 05		 jne	 SHORT $LL35@mg_http_ba
  00049	48 8b f3	 mov	 rsi, rbx
  0004c	eb 09		 jmp	 SHORT $LN24@mg_http_ba
$LL35@mg_http_ba:
  0004e	48 ff c6	 inc	 rsi
  00051	41 38 1c 30	 cmp	 BYTE PTR [r8+rsi], bl
  00055	75 f7		 jne	 SHORT $LL35@mg_http_ba
$LN24@mg_http_ba:

; 2286 :   struct mg_str u = mg_str(user), p = mg_str(pass);
; 2287 :   size_t need = c->send.len + 36 + (u.len + p.len) * 2;

  00057	48 8b 41 78	 mov	 rax, QWORD PTR [rcx+120]
  0005b	4c 8d 76 12	 lea	 r14, QWORD PTR [rsi+18]
  0005f	4c 03 f5	 add	 r14, rbp

; 2288 :   if (c->send.size < need) mg_iobuf_resize(&c->send, need);

  00062	4c 8d 79 68	 lea	 r15, QWORD PTR [rcx+104]
  00066	4e 8d 34 70	 lea	 r14, QWORD PTR [rax+r14*2]
  0006a	4c 39 71 70	 cmp	 QWORD PTR [rcx+112], r14
  0006e	73 0b		 jae	 SHORT $LN11@mg_http_ba
  00070	49 8b d6	 mov	 rdx, r14
  00073	49 8b cf	 mov	 rcx, r15
  00076	e8 00 00 00 00	 call	 mg_iobuf_resize
$LN11@mg_http_ba:

; 2289 :   if (c->send.size >= need) {

  0007b	4c 39 77 70	 cmp	 QWORD PTR [rdi+112], r14
  0007f	0f 82 a2 00 00
	00		 jb	 $LN10@mg_http_ba

; 2290 :     size_t i, n = 0;
; 2291 :     char *buf = (char *) &c->send.buf[c->send.len];

  00085	48 8b 4f 78	 mov	 rcx, QWORD PTR [rdi+120]
  00089	48 8b d3	 mov	 rdx, rbx
  0008c	49 03 0f	 add	 rcx, QWORD PTR [r15]
  0008f	4c 8b e3	 mov	 r12, rbx

; 2292 :     memcpy(buf, "Authorization: Basic ", 21);  // DON'T use mg_send!

  00092	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BG@EPHDEOFO@Authorization?3?5Basic?5@
  00099	4c 8d 71 15	 lea	 r14, QWORD PTR [rcx+21]
  0009d	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  000a0	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR ??_C@_0BG@EPHDEOFO@Authorization?3?5Basic?5@+16
  000a6	89 41 10	 mov	 DWORD PTR [rcx+16], eax
  000a9	8a 05 14 00 00
	00		 mov	 al, BYTE PTR ??_C@_0BG@EPHDEOFO@Authorization?3?5Basic?5@+20
  000af	88 41 14	 mov	 BYTE PTR [rcx+20], al
  000b2	48 85 ed	 test	 rbp, rbp

; 2293 :     for (i = 0; i < u.len; i++) {

  000b5	74 1a		 je	 SHORT $LN31@mg_http_ba
$LL4@mg_http_ba:

; 2294 :       n = mg_base64_update(((unsigned char *) u.ptr)[i], buf + 21, n);

  000b7	43 8a 0c 2c	 mov	 cl, BYTE PTR [r12+r13]
  000bb	4c 8b c2	 mov	 r8, rdx
  000be	49 8b d6	 mov	 rdx, r14
  000c1	e8 00 00 00 00	 call	 mg_base64_update
  000c6	49 ff c4	 inc	 r12
  000c9	48 8b d0	 mov	 rdx, rax
  000cc	4c 3b e5	 cmp	 r12, rbp
  000cf	72 e6		 jb	 SHORT $LL4@mg_http_ba
$LN31@mg_http_ba:

; 2295 :     }
; 2296 :     if (p.len > 0) {

  000d1	48 85 f6	 test	 rsi, rsi
  000d4	74 2e		 je	 SHORT $LN6@mg_http_ba

; 2297 :       n = mg_base64_update(':', buf + 21, n);

  000d6	4c 8b c2	 mov	 r8, rdx
  000d9	b1 3a		 mov	 cl, 58			; 0000003aH
  000db	49 8b d6	 mov	 rdx, r14
  000de	e8 00 00 00 00	 call	 mg_base64_update
  000e3	48 8b 6c 24 60	 mov	 rbp, QWORD PTR pass$[rsp]
  000e8	48 8b d0	 mov	 rdx, rax
$LL7@mg_http_ba:

; 2298 :       for (i = 0; i < p.len; i++) {
; 2299 :         n = mg_base64_update(((unsigned char *) p.ptr)[i], buf + 21, n);

  000eb	8a 0c 2b	 mov	 cl, BYTE PTR [rbx+rbp]
  000ee	4c 8b c2	 mov	 r8, rdx
  000f1	49 8b d6	 mov	 rdx, r14
  000f4	e8 00 00 00 00	 call	 mg_base64_update
  000f9	48 ff c3	 inc	 rbx
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 3b de	 cmp	 rbx, rsi
  00102	72 e7		 jb	 SHORT $LL7@mg_http_ba
$LN6@mg_http_ba:

; 2300 :       }
; 2301 :     }
; 2302 :     n = mg_base64_final(buf + 21, n);

  00104	49 8b ce	 mov	 rcx, r14
  00107	e8 00 00 00 00	 call	 mg_base64_final

; 2303 :     c->send.len += 21 + (size_t) n + 2;

  0010c	48 83 c0 17	 add	 rax, 23

; 2304 :     memcpy(&c->send.buf[c->send.len - 2], "\r\n", 2);

  00110	ba 0d 0a 00 00	 mov	 edx, 2573		; 00000a0dH
  00115	48 01 47 78	 add	 QWORD PTR [rdi+120], rax
  00119	48 8b 4f 78	 mov	 rcx, QWORD PTR [rdi+120]
  0011d	49 8b 07	 mov	 rax, QWORD PTR [r15]
  00120	66 89 54 01 fe	 mov	 WORD PTR [rcx+rax-2], dx

; 2305 :   } else {

  00125	eb 36		 jmp	 SHORT $LN9@mg_http_ba
$LN10@mg_http_ba:

; 2306 :     MG_ERROR(("%lu oom %d->%d ", c->id, (int) c->send.size, (int) need));

  00127	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR mg_log_level, 1
  0012e	7c 2d		 jl	 SHORT $LN9@mg_http_ba
  00130	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0O@KKGICJJI@mg_http_bauth@
  00137	b9 01 00 00 00	 mov	 ecx, 1
  0013c	41 b8 02 09 00
	00		 mov	 r8d, 2306		; 00000902H
  00142	e8 00 00 00 00	 call	 mg_log_prefix
  00147	44 8b 47 70	 mov	 r8d, DWORD PTR [rdi+112]
  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@LNKDPIGG@?$CFlu?5oom?5?$CFd?9?$DO?$CFd?5@
  00152	8b 57 40	 mov	 edx, DWORD PTR [rdi+64]
  00155	45 8b ce	 mov	 r9d, r14d
  00158	e8 00 00 00 00	 call	 mg_log
$LN9@mg_http_ba:

; 2307 :   }
; 2308 : }

  0015d	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00162	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00167	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  0016c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00170	41 5f		 pop	 r15
  00172	41 5e		 pop	 r14
  00174	41 5d		 pop	 r13
  00176	41 5c		 pop	 r12
  00178	5f		 pop	 rdi
  00179	c3		 ret	 0
mg_http_bauth ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_var
_TEXT	SEGMENT
k$ = 32
$T1 = 32
v$ = 48
__$ReturnAddress$ = 80
buf$ = 88
name$ = 96
mg_http_var PROC					; COMDAT

; 2310 : struct mg_str mg_http_var(struct mg_str buf, struct mg_str name) {

$LN14:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 7845 :   struct mg_str str = {s, n};

  0000f	48 83 64 24 20
	00		 and	 QWORD PTR $T1[rsp], 0

; 2310 : struct mg_str mg_http_var(struct mg_str buf, struct mg_str name) {

  00015	49 8b f8	 mov	 rdi, r8

; 7845 :   struct mg_str str = {s, n};

  00018	48 83 64 24 28
	00		 and	 QWORD PTR $T1[rsp+8], 0

; 2310 : struct mg_str mg_http_var(struct mg_str buf, struct mg_str name) {

  0001e	48 8b f2	 mov	 rsi, rdx

; 2311 :   struct mg_str k, v, result = mg_str_n(NULL, 0);

  00021	0f 10 44 24 20	 movups	 xmm0, XMMWORD PTR $T1[rsp]
  00026	48 8b d9	 mov	 rbx, rcx
  00029	f3 0f 7f 01	 movdqu	 XMMWORD PTR [rcx], xmm0
$LN4@mg_http_va:

; 2312 :   while (mg_split(&buf, &k, &v, '&')) {
; 2313 :     if (name.len == k.len && mg_ncasecmp(name.ptr, k.ptr, k.len) == 0) {

  0002d	41 b1 26	 mov	 r9b, 38			; 00000026H
  00030	4c 8d 44 24 30	 lea	 r8, QWORD PTR v$[rsp]
  00035	48 8d 54 24 20	 lea	 rdx, QWORD PTR k$[rsp]
  0003a	48 8b ce	 mov	 rcx, rsi
  0003d	e8 00 00 00 00	 call	 mg_split
  00042	84 c0		 test	 al, al
  00044	74 25		 je	 SHORT $LN12@mg_http_va
  00046	4c 8b 44 24 28	 mov	 r8, QWORD PTR k$[rsp+8]
  0004b	4c 39 47 08	 cmp	 QWORD PTR [rdi+8], r8
  0004f	75 dc		 jne	 SHORT $LN4@mg_http_va
  00051	48 8b 54 24 20	 mov	 rdx, QWORD PTR k$[rsp]
  00056	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00059	e8 00 00 00 00	 call	 mg_ncasecmp
  0005e	85 c0		 test	 eax, eax
  00060	75 cb		 jne	 SHORT $LN4@mg_http_va

; 2314 :       result = v;

  00062	0f 10 44 24 30	 movups	 xmm0, XMMWORD PTR v$[rsp]
  00067	f3 0f 7f 03	 movdqu	 XMMWORD PTR [rbx], xmm0
$LN12@mg_http_va:

; 2315 :       break;
; 2316 :     }
; 2317 :   }
; 2318 :   return result;
; 2319 : }

  0006b	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00070	48 8b c3	 mov	 rax, rbx
  00073	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00078	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0007c	5f		 pop	 rdi
  0007d	c3		 ret	 0
mg_http_var ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_get_var
_TEXT	SEGMENT
$T1 = 48
$T2 = 64
v$3 = 64
$T4 = 80
buf$ = 112
name$ = 120
dst$ = 128
dst_len$ = 136
mg_http_get_var PROC					; COMDAT

; 2322 :                     size_t dst_len) {

$LN18:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	49 8b f9	 mov	 rdi, r9
  0000d	49 8b d8	 mov	 rbx, r8

; 2323 :   int len;
; 2324 :   if (dst == NULL || dst_len == 0) {

  00010	4d 85 c0	 test	 r8, r8
  00013	0f 84 93 00 00
	00		 je	 $LN4@mg_http_ge
  00019	4d 85 c9	 test	 r9, r9
  0001c	0f 84 8a 00 00
	00		 je	 $LN4@mg_http_ge

; 2326 :   } else if (buf->ptr == NULL || name == NULL || buf->len == 0) {

  00022	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00026	74 7a		 je	 SHORT $LN7@mg_http_ge
  00028	48 85 d2	 test	 rdx, rdx
  0002b	74 75		 je	 SHORT $LN7@mg_http_ge
  0002d	48 83 79 08 00	 cmp	 QWORD PTR [rcx+8], 0
  00032	74 6e		 je	 SHORT $LN7@mg_http_ge

; 7840 :   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};

  00034	48 83 c8 ff	 or	 rax, -1
$LL16@mg_http_ge:
  00038	48 ff c0	 inc	 rax
  0003b	80 3c 02 00	 cmp	 BYTE PTR [rdx+rax], 0
  0003f	75 f7		 jne	 SHORT $LL16@mg_http_ge

; 2330 :     struct mg_str v = mg_http_var(*buf, mg_str(name));

  00041	0f 10 01	 movups	 xmm0, XMMWORD PTR [rcx]
  00044	48 89 54 24 30	 mov	 QWORD PTR $T1[rsp], rdx
  00049	4c 8d 44 24 30	 lea	 r8, QWORD PTR $T1[rsp]
  0004e	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T2[rsp]
  00053	48 89 44 24 38	 mov	 QWORD PTR $T1[rsp+8], rax
  00058	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T4[rsp]
  0005d	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T2[rsp], xmm0
  00063	e8 00 00 00 00	 call	 mg_http_var
  00068	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]

; 2331 :     if (v.ptr == NULL) {

  0006b	66 48 0f 7e c1	 movq	 rcx, xmm0
  00070	0f 11 44 24 40	 movups	 XMMWORD PTR v$3[rsp], xmm0
  00075	48 85 c9	 test	 rcx, rcx
  00078	75 05		 jne	 SHORT $LN8@mg_http_ge

; 2332 :       len = -4;  // Name does not exist

  0007a	8d 41 fc	 lea	 eax, QWORD PTR [rcx-4]

; 2333 :     } else {

  0007d	eb 32		 jmp	 SHORT $LN10@mg_http_ge
$LN8@mg_http_ge:

; 2334 :       len = mg_url_decode(v.ptr, v.len, dst, dst_len, 1);

  0007f	48 8b 54 24 48	 mov	 rdx, QWORD PTR v$3[rsp+8]
  00084	4c 8b cf	 mov	 r9, rdi
  00087	4c 8b c3	 mov	 r8, rbx
  0008a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00092	e8 00 00 00 00	 call	 mg_url_decode

; 2335 :       if (len < 0) len = -3;  // Failed to decode

  00097	85 c0		 test	 eax, eax
  00099	79 16		 jns	 SHORT $LN10@mg_http_ge
  0009b	b8 fd ff ff ff	 mov	 eax, -3
  000a0	eb 0f		 jmp	 SHORT $LN10@mg_http_ge
$LN7@mg_http_ge:

; 2327 :     len = -1;  // Bad source

  000a2	48 83 c8 ff	 or	 rax, -1

; 2328 :     dst[0] = '\0';

  000a6	41 c6 00 00	 mov	 BYTE PTR [r8], 0

; 2329 :   } else {

  000aa	eb 05		 jmp	 SHORT $LN10@mg_http_ge
$LN4@mg_http_ge:

; 2325 :     len = -2;  // Bad destination

  000ac	b8 fe ff ff ff	 mov	 eax, -2
$LN10@mg_http_ge:

; 2336 :     }
; 2337 :   }
; 2338 :   return len;
; 2339 : }

  000b1	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  000b6	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
mg_http_get_var ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT isx
_TEXT	SEGMENT
c$ = 8
isx	PROC						; COMDAT

; 2342 :   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||

  00000	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  00003	83 f8 09	 cmp	 eax, 9
  00006	76 13		 jbe	 SHORT $LN5@isx
  00008	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  0000b	83 f8 05	 cmp	 eax, 5
  0000e	76 0b		 jbe	 SHORT $LN5@isx
  00010	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  00013	83 f8 05	 cmp	 eax, 5
  00016	76 03		 jbe	 SHORT $LN5@isx
  00018	32 c0		 xor	 al, al

; 2343 :          (c >= 'A' && c <= 'F');
; 2344 : }

  0001a	c3		 ret	 0
$LN5@isx:

; 2342 :   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||

  0001b	b0 01		 mov	 al, 1

; 2343 :          (c >= 'A' && c <= 'F');
; 2344 : }

  0001d	c3		 ret	 0
isx	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_url_decode
_TEXT	SEGMENT
src$ = 80
src_len$ = 88
dst$ = 96
dst_len$ = 104
is_form_url_encoded$ = 112
mg_url_decode PROC					; COMDAT

; 2347 :                   int is_form_url_encoded) {

$LN39:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2348 :   size_t i, j;
; 2349 :   for (i = j = 0; i < src_len && j + 1 < dst_len; i++, j++) {

  0001c	33 db		 xor	 ebx, ebx
  0001e	33 ff		 xor	 edi, edi
  00020	4d 8b f1	 mov	 r14, r9
  00023	4d 8b f8	 mov	 r15, r8
  00026	48 8b ea	 mov	 rbp, rdx
  00029	4c 8b e9	 mov	 r13, rcx
  0002c	48 85 d2	 test	 rdx, rdx
  0002f	0f 84 9e 00 00
	00		 je	 $LN35@mg_url_dec
  00035	44 8d 63 01	 lea	 r12d, QWORD PTR [rbx+1]
  00039	49 8b f0	 mov	 rsi, r8
  0003c	4d 2b e0	 sub	 r12, r8
$LL4@mg_url_dec:
  0003f	49 8d 04 34	 lea	 rax, QWORD PTR [r12+rsi]
  00043	49 3b c6	 cmp	 rax, r14
  00046	0f 83 87 00 00
	00		 jae	 $LN35@mg_url_dec

; 2350 :     if (src[i] == '%') {

  0004c	4a 8d 14 2f	 lea	 rdx, QWORD PTR [rdi+r13]
  00050	8a 02		 mov	 al, BYTE PTR [rdx]
  00052	3c 25		 cmp	 al, 37			; 00000025H
  00054	75 59		 jne	 SHORT $LN5@mg_url_dec

; 2351 :       // Use `i + 2 < src_len`, not `i < src_len - 2`, note small src_len
; 2352 :       if (i + 2 < src_len && isx(src[i + 1]) && isx(src[i + 2])) {

  00056	48 83 c7 02	 add	 rdi, 2
  0005a	48 3b fd	 cmp	 rdi, rbp
  0005d	0f 83 a6 00 00
	00		 jae	 $LN7@mg_url_dec
  00063	4c 8d 4a 01	 lea	 r9, QWORD PTR [rdx+1]
  00067	41 8a 09	 mov	 cl, BYTE PTR [r9]

; 2342 :   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||

  0006a	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  0006d	3c 09		 cmp	 al, 9
  0006f	76 13		 jbe	 SHORT $LN34@mg_url_dec
  00071	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  00074	3c 05		 cmp	 al, 5
  00076	76 0c		 jbe	 SHORT $LN34@mg_url_dec
  00078	80 e9 41	 sub	 cl, 65			; 00000041H
  0007b	80 f9 05	 cmp	 cl, 5
  0007e	0f 87 85 00 00
	00		 ja	 $LN7@mg_url_dec
$LN34@mg_url_dec:

; 2351 :       // Use `i + 2 < src_len`, not `i < src_len - 2`, note small src_len
; 2352 :       if (i + 2 < src_len && isx(src[i + 1]) && isx(src[i + 2])) {

  00084	8a 52 02	 mov	 dl, BYTE PTR [rdx+2]

; 2342 :   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||

  00087	8d 42 d0	 lea	 eax, DWORD PTR [rdx-48]
  0008a	3c 09		 cmp	 al, 9
  0008c	76 0f		 jbe	 SHORT $LN33@mg_url_dec
  0008e	8d 42 9f	 lea	 eax, DWORD PTR [rdx-97]
  00091	3c 05		 cmp	 al, 5
  00093	76 08		 jbe	 SHORT $LN33@mg_url_dec
  00095	80 ea 41	 sub	 dl, 65			; 00000041H
  00098	80 fa 05	 cmp	 dl, 5
  0009b	77 6c		 ja	 SHORT $LN7@mg_url_dec
$LN33@mg_url_dec:

; 2353 :         mg_unhex(src + i + 1, 2, (uint8_t *) &dst[j]);

  0009d	4c 8b c6	 mov	 r8, rsi
  000a0	ba 02 00 00 00	 mov	 edx, 2
  000a5	49 8b c9	 mov	 rcx, r9
  000a8	e8 00 00 00 00	 call	 mg_unhex

; 2357 :       }

  000ad	eb 12		 jmp	 SHORT $LN2@mg_url_dec
$LN5@mg_url_dec:

; 2358 :     } else if (is_form_url_encoded && src[i] == '+') {

  000af	83 7c 24 70 00	 cmp	 DWORD PTR is_form_url_encoded$[rsp], 0
  000b4	74 09		 je	 SHORT $LN9@mg_url_dec
  000b6	3c 2b		 cmp	 al, 43			; 0000002bH
  000b8	75 05		 jne	 SHORT $LN9@mg_url_dec

; 2359 :       dst[j] = ' ';

  000ba	c6 06 20	 mov	 BYTE PTR [rsi], 32	; 00000020H

; 2360 :     } else {

  000bd	eb 02		 jmp	 SHORT $LN2@mg_url_dec
$LN9@mg_url_dec:

; 2361 :       dst[j] = src[i];

  000bf	88 06		 mov	 BYTE PTR [rsi], al
$LN2@mg_url_dec:

; 2348 :   size_t i, j;
; 2349 :   for (i = j = 0; i < src_len && j + 1 < dst_len; i++, j++) {

  000c1	48 ff c7	 inc	 rdi
  000c4	48 ff c3	 inc	 rbx
  000c7	48 ff c6	 inc	 rsi
  000ca	48 3b fd	 cmp	 rdi, rbp
  000cd	0f 82 6c ff ff
	ff		 jb	 $LL4@mg_url_dec
$LN35@mg_url_dec:

; 2362 :     }
; 2363 :   }
; 2364 :   if (j < dst_len) dst[j] = '\0';  // Null-terminate the destination

  000d3	49 3b de	 cmp	 rbx, r14
  000d6	73 05		 jae	 SHORT $LN11@mg_url_dec
  000d8	42 c6 04 3b 00	 mov	 BYTE PTR [rbx+r15], 0
$LN11@mg_url_dec:

; 2365 :   return i >= src_len && j < dst_len ? (int) j : -1;

  000dd	48 3b fd	 cmp	 rdi, rbp
  000e0	72 05		 jb	 SHORT $LN13@mg_url_dec
  000e2	49 3b de	 cmp	 rbx, r14
  000e5	72 03		 jb	 SHORT $LN14@mg_url_dec
$LN13@mg_url_dec:
  000e7	83 cb ff	 or	 ebx, -1
$LN14@mg_url_dec:
  000ea	8b c3		 mov	 eax, ebx
$LN1@mg_url_dec:

; 2366 : }

  000ec	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000f1	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000f6	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000fb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ff	41 5f		 pop	 r15
  00101	41 5e		 pop	 r14
  00103	41 5d		 pop	 r13
  00105	41 5c		 pop	 r12
  00107	5f		 pop	 rdi
  00108	c3		 ret	 0
$LN7@mg_url_dec:

; 2354 :         i += 2;
; 2355 :       } else {
; 2356 :         return -1;

  00109	83 c8 ff	 or	 eax, -1
  0010c	eb de		 jmp	 SHORT $LN1@mg_url_dec
mg_url_decode ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT isok
_TEXT	SEGMENT
c$ = 8
isok	PROC						; COMDAT

; 2369 :   return c == '\n' || c == '\r' || c >= ' ';

  00000	80 f9 1f	 cmp	 cl, 31
  00003	77 0d		 ja	 SHORT $LN3@isok
  00005	b8 ff db ff ff	 mov	 eax, -9217		; ffffdbffH
  0000a	0f a3 c8	 bt	 eax, ecx
  0000d	73 03		 jae	 SHORT $LN3@isok
  0000f	32 c0		 xor	 al, al

; 2370 : }

  00011	c3		 ret	 0
$LN3@isok:

; 2369 :   return c == '\n' || c == '\r' || c >= ' ';

  00012	b0 01		 mov	 al, 1

; 2370 : }

  00014	c3		 ret	 0
isok	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_get_request_len
_TEXT	SEGMENT
buf$ = 8
buf_len$ = 16
mg_http_get_request_len PROC				; COMDAT

; 2373 :   size_t i;
; 2374 :   for (i = 0; i < buf_len; i++) {

  00000	45 33 c0	 xor	 r8d, r8d
  00003	48 85 d2	 test	 rdx, rdx
  00006	74 50		 je	 SHORT $LN21@mg_http_ge
  00008	48 ff c9	 dec	 rcx
  0000b	41 b3 0a	 mov	 r11b, 10
$LL4@mg_http_ge:

; 2375 :     if (!isok(buf[i])) return -1;

  0000e	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 2369 :   return c == '\n' || c == '\r' || c >= ' ';

  00012	41 80 39 1f	 cmp	 BYTE PTR [r9], 31
  00016	77 10		 ja	 SHORT $LN19@mg_http_ge
  00018	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  0001c	41 ba ff db ff
	ff		 mov	 r10d, -9217		; ffffdbffH
  00022	41 0f a3 c2	 bt	 r10d, eax
  00026	72 33		 jb	 SHORT $LN20@mg_http_ge
$LN19@mg_http_ge:

; 2376 :     if ((i > 0 && buf[i] == '\n' && buf[i - 1] == '\n') ||

  00028	4d 85 c0	 test	 r8, r8
  0002b	74 0a		 je	 SHORT $LN8@mg_http_ge
  0002d	45 38 19	 cmp	 BYTE PTR [r9], r11b
  00030	75 05		 jne	 SHORT $LN8@mg_http_ge
  00032	44 38 19	 cmp	 BYTE PTR [rcx], r11b
  00035	74 28		 je	 SHORT $LN7@mg_http_ge
$LN8@mg_http_ge:
  00037	49 83 f8 03	 cmp	 r8, 3
  0003b	76 10		 jbe	 SHORT $LN2@mg_http_ge
  0003d	45 38 19	 cmp	 BYTE PTR [r9], r11b
  00040	75 0b		 jne	 SHORT $LN2@mg_http_ge
  00042	80 39 0d	 cmp	 BYTE PTR [rcx], 13
  00045	75 06		 jne	 SHORT $LN2@mg_http_ge
  00047	44 38 59 ff	 cmp	 BYTE PTR [rcx-1], r11b
  0004b	74 12		 je	 SHORT $LN7@mg_http_ge
$LN2@mg_http_ge:

; 2373 :   size_t i;
; 2374 :   for (i = 0; i < buf_len; i++) {

  0004d	49 ff c0	 inc	 r8
  00050	49 8b c9	 mov	 rcx, r9
  00053	4c 3b c2	 cmp	 r8, rdx
  00056	72 b6		 jb	 SHORT $LL4@mg_http_ge
$LN21@mg_http_ge:

; 2379 :   }
; 2380 :   return 0;

  00058	33 c0		 xor	 eax, eax

; 2381 : }

  0005a	c3		 ret	 0
$LN20@mg_http_ge:

; 2375 :     if (!isok(buf[i])) return -1;

  0005b	83 c8 ff	 or	 eax, -1

; 2381 : }

  0005e	c3		 ret	 0
$LN7@mg_http_ge:

; 2377 :         (i > 3 && buf[i] == '\n' && buf[i - 1] == '\r' && buf[i - 2] == '\n'))
; 2378 :       return (int) i + 1;

  0005f	41 8d 40 01	 lea	 eax, DWORD PTR [r8+1]

; 2381 : }

  00063	c3		 ret	 0
mg_http_get_request_len ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_get_header
_TEXT	SEGMENT
h$ = 48
name$ = 56
mg_http_get_header PROC					; COMDAT

; 2382 : struct mg_str *mg_http_get_header(struct mg_http_message *h, const char *name) {

$LN15:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	4c 8b f2	 mov	 r14, rdx

; 2383 :   size_t i, n = strlen(name), max = sizeof(h->headers) / sizeof(h->headers[0]);

  0001c	48 83 cf ff	 or	 rdi, -1
$LL13@mg_http_ge:
  00020	48 ff c7	 inc	 rdi
  00023	80 3c 3a 00	 cmp	 BYTE PTR [rdx+rdi], 0
  00027	75 f7		 jne	 SHORT $LL13@mg_http_ge

; 2384 :   for (i = 0; i < max && h->headers[i].name.len > 0; i++) {

  00029	33 f6		 xor	 esi, esi
  0002b	48 8d 59 48	 lea	 rbx, QWORD PTR [rcx+72]
$LL4@mg_http_ge:
  0002f	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00033	76 25		 jbe	 SHORT $LN12@mg_http_ge

; 2385 :     struct mg_str *k = &h->headers[i].name, *v = &h->headers[i].value;
; 2386 :     if (n == k->len && mg_ncasecmp(k->ptr, name, n) == 0) return v;

  00035	48 3b 3b	 cmp	 rdi, QWORD PTR [rbx]
  00038	75 13		 jne	 SHORT $LN2@mg_http_ge
  0003a	48 8b 4b f8	 mov	 rcx, QWORD PTR [rbx-8]
  0003e	4c 8b c7	 mov	 r8, rdi
  00041	49 8b d6	 mov	 rdx, r14
  00044	e8 00 00 00 00	 call	 mg_ncasecmp
  00049	85 c0		 test	 eax, eax
  0004b	74 2a		 je	 SHORT $LN8@mg_http_ge
$LN2@mg_http_ge:

; 2384 :   for (i = 0; i < max && h->headers[i].name.len > 0; i++) {

  0004d	48 ff c6	 inc	 rsi
  00050	48 83 c3 20	 add	 rbx, 32			; 00000020H
  00054	48 83 fe 1e	 cmp	 rsi, 30
  00058	72 d5		 jb	 SHORT $LL4@mg_http_ge
$LN12@mg_http_ge:

; 2387 :   }
; 2388 :   return NULL;

  0005a	33 c0		 xor	 eax, eax
$LN1@mg_http_ge:

; 2389 : }

  0005c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00061	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00066	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0006b	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	41 5e		 pop	 r14
  00076	c3		 ret	 0
$LN8@mg_http_ge:

; 2385 :     struct mg_str *k = &h->headers[i].name, *v = &h->headers[i].value;
; 2386 :     if (n == k->len && mg_ncasecmp(k->ptr, name, n) == 0) return v;

  00077	48 8d 43 08	 lea	 rax, QWORD PTR [rbx+8]
  0007b	eb df		 jmp	 SHORT $LN1@mg_http_ge
mg_http_get_header ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT vcb
_TEXT	SEGMENT
c$ = 8
vcb	PROC						; COMDAT

; 2393 :   return (c & 0xc0) == 0x80;

  00000	80 e1 c0	 and	 cl, 192			; 000000c0H
  00003	80 f9 80	 cmp	 cl, 128			; 00000080H
  00006	0f 94 c0	 sete	 al

; 2394 : }

  00009	c3		 ret	 0
vcb	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT clen
_TEXT	SEGMENT
s$ = 8
end$ = 16
clen	PROC						; COMDAT

; 2398 :   const unsigned char *u = (unsigned char *) s, c = *u;

  00000	44 8a 01	 mov	 r8b, BYTE PTR [rcx]

; 2399 :   long n = (long) (end - s);

  00003	2b d1		 sub	 edx, ecx

; 2400 :   if (c > ' ' && c < '~') return 1;  // Usual ascii printed char

  00005	41 8d 40 df	 lea	 eax, DWORD PTR [r8-33]
  00009	3c 5c		 cmp	 al, 92			; 0000005cH
  0000b	77 06		 ja	 SHORT $LN2@clen
  0000d	b8 01 00 00 00	 mov	 eax, 1

; 2406 : }

  00012	c3		 ret	 0
$LN2@clen:

; 2401 :   if ((c & 0xe0) == 0xc0 && n > 1 && vcb(u[1])) return 2;  // 2-byte UTF8

  00013	41 8a c0	 mov	 al, r8b
  00016	41 b1 c0	 mov	 r9b, 192		; 000000c0H
  00019	24 e0		 and	 al, 224			; 000000e0H
  0001b	41 b2 80	 mov	 r10b, 128		; 00000080H
  0001e	41 3a c1	 cmp	 al, r9b
  00021	75 16		 jne	 SHORT $LN3@clen
  00023	83 fa 01	 cmp	 edx, 1
  00026	7e 11		 jle	 SHORT $LN3@clen

; 2393 :   return (c & 0xc0) == 0x80;

  00028	8a 41 01	 mov	 al, BYTE PTR [rcx+1]
  0002b	41 22 c1	 and	 al, r9b
  0002e	41 3a c2	 cmp	 al, r10b

; 2401 :   if ((c & 0xe0) == 0xc0 && n > 1 && vcb(u[1])) return 2;  // 2-byte UTF8

  00031	75 06		 jne	 SHORT $LN3@clen
  00033	b8 02 00 00 00	 mov	 eax, 2

; 2406 : }

  00038	c3		 ret	 0
$LN3@clen:

; 2402 :   if ((c & 0xf0) == 0xe0 && n > 2 && vcb(u[1]) && vcb(u[2])) return 3;

  00039	41 8a c0	 mov	 al, r8b
  0003c	24 f0		 and	 al, 240			; 000000f0H
  0003e	3c e0		 cmp	 al, 224			; 000000e0H
  00040	75 21		 jne	 SHORT $LN4@clen
  00042	83 fa 02	 cmp	 edx, 2
  00045	7e 1c		 jle	 SHORT $LN4@clen

; 2393 :   return (c & 0xc0) == 0x80;

  00047	8a 41 01	 mov	 al, BYTE PTR [rcx+1]
  0004a	41 22 c1	 and	 al, r9b
  0004d	41 3a c2	 cmp	 al, r10b

; 2402 :   if ((c & 0xf0) == 0xe0 && n > 2 && vcb(u[1]) && vcb(u[2])) return 3;

  00050	75 11		 jne	 SHORT $LN4@clen

; 2393 :   return (c & 0xc0) == 0x80;

  00052	8a 41 02	 mov	 al, BYTE PTR [rcx+2]
  00055	41 22 c1	 and	 al, r9b
  00058	41 3a c2	 cmp	 al, r10b

; 2402 :   if ((c & 0xf0) == 0xe0 && n > 2 && vcb(u[1]) && vcb(u[2])) return 3;

  0005b	75 06		 jne	 SHORT $LN4@clen
  0005d	b8 03 00 00 00	 mov	 eax, 3

; 2406 : }

  00062	c3		 ret	 0
$LN4@clen:

; 2403 :   if ((c & 0xf8) == 0xf0 && n > 3 && vcb(u[1]) && vcb(u[2]) && vcb(u[3]))

  00063	41 80 e0 f8	 and	 r8b, 248		; 000000f8H
  00067	41 80 f8 f0	 cmp	 r8b, 240		; 000000f0H
  0006b	75 2d		 jne	 SHORT $LN5@clen
  0006d	83 fa 03	 cmp	 edx, 3
  00070	7e 28		 jle	 SHORT $LN5@clen

; 2393 :   return (c & 0xc0) == 0x80;

  00072	8a 41 01	 mov	 al, BYTE PTR [rcx+1]
  00075	41 22 c1	 and	 al, r9b
  00078	41 3a c2	 cmp	 al, r10b

; 2403 :   if ((c & 0xf8) == 0xf0 && n > 3 && vcb(u[1]) && vcb(u[2]) && vcb(u[3]))

  0007b	75 1d		 jne	 SHORT $LN5@clen

; 2393 :   return (c & 0xc0) == 0x80;

  0007d	8a 41 02	 mov	 al, BYTE PTR [rcx+2]
  00080	41 22 c1	 and	 al, r9b
  00083	41 3a c2	 cmp	 al, r10b

; 2403 :   if ((c & 0xf8) == 0xf0 && n > 3 && vcb(u[1]) && vcb(u[2]) && vcb(u[3]))

  00086	75 12		 jne	 SHORT $LN5@clen

; 2393 :   return (c & 0xc0) == 0x80;

  00088	8a 49 03	 mov	 cl, BYTE PTR [rcx+3]
  0008b	33 c0		 xor	 eax, eax
  0008d	41 22 c9	 and	 cl, r9b
  00090	41 3a ca	 cmp	 cl, r10b
  00093	8d 50 04	 lea	 edx, QWORD PTR [rax+4]
  00096	0f 44 c2	 cmove	 eax, edx

; 2406 : }

  00099	c3		 ret	 0
$LN5@clen:

; 2404 :     return 4;
; 2405 :   return 0;

  0009a	33 c0		 xor	 eax, eax

; 2406 : }

  0009c	c3		 ret	 0
clen	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT skiptorn
_TEXT	SEGMENT
s$ = 8
end$ = 16
v$ = 24
skiptorn PROC						; COMDAT

; 2410 :   v->ptr = s;

  00000	49 89 08	 mov	 QWORD PTR [r8], rcx

; 2411 :   while (s < end && s[0] != '\n' && s[0] != '\r') s++, v->len++;  // To newline

  00003	48 3b ca	 cmp	 rcx, rdx
  00006	73 3e		 jae	 SHORT $LN5@skiptorn
  00008	41 b1 0a	 mov	 r9b, 10
$LL2@skiptorn:
  0000b	44 38 09	 cmp	 BYTE PTR [rcx], r9b
  0000e	74 11		 je	 SHORT $LN3@skiptorn
  00010	80 39 0d	 cmp	 BYTE PTR [rcx], 13
  00013	74 0c		 je	 SHORT $LN3@skiptorn
  00015	49 ff 40 08	 inc	 QWORD PTR [r8+8]
  00019	48 ff c1	 inc	 rcx
  0001c	48 3b ca	 cmp	 rcx, rdx
  0001f	72 ea		 jb	 SHORT $LL2@skiptorn
$LN3@skiptorn:

; 2412 :   if (s >= end || (s[0] == '\r' && s[1] != '\n')) return NULL;    // Stray \r

  00021	48 3b ca	 cmp	 rcx, rdx
  00024	73 20		 jae	 SHORT $LN5@skiptorn
  00026	80 39 0d	 cmp	 BYTE PTR [rcx], 13
  00029	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  0002d	75 0d		 jne	 SHORT $LN15@skiptorn
  0002f	44 38 08	 cmp	 BYTE PTR [rax], r9b
  00032	75 12		 jne	 SHORT $LN5@skiptorn

; 2413 :   if (s < end && s[0] == '\r') s++;                               // Skip \r

  00034	48 8b c8	 mov	 rcx, rax

; 2414 :   if (s >= end || *s++ != '\n') return NULL;                      // Skip \n

  00037	48 3b c2	 cmp	 rax, rdx
  0003a	73 0a		 jae	 SHORT $LN5@skiptorn
$LN15@skiptorn:
  0003c	44 38 09	 cmp	 BYTE PTR [rcx], r9b
  0003f	75 05		 jne	 SHORT $LN5@skiptorn
  00041	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]

; 2415 :   return s;
; 2416 : }

  00045	c3		 ret	 0
$LN5@skiptorn:

; 2412 :   if (s >= end || (s[0] == '\r' && s[1] != '\n')) return NULL;    // Stray \r

  00046	33 c0		 xor	 eax, eax

; 2415 :   return s;
; 2416 : }

  00048	c3		 ret	 0
skiptorn ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_parse_headers
_TEXT	SEGMENT
v$1 = 32
k$2 = 48
s$ = 80
end$ = 88
h$ = 96
max_hdrs$dead$ = 104
mg_http_parse_headers PROC				; COMDAT

; 2419 :                                   struct mg_http_header *h, size_t max_hdrs) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	49 8b f0	 mov	 rsi, r8
  00017	48 8b fa	 mov	 rdi, rdx
  0001a	4c 8b d9	 mov	 r11, rcx

; 2420 :   size_t i, n;
; 2421 :   for (i = 0; i < max_hdrs; i++) {

  0001d	33 ed		 xor	 ebp, ebp
$LL4@mg_http_pa:

; 2422 :     struct mg_str k = {NULL, 0}, v = {NULL, 0};

  0001f	33 db		 xor	 ebx, ebx
  00021	48 21 5c 24 20	 and	 QWORD PTR v$1[rsp], rbx
  00026	48 21 5c 24 28	 and	 QWORD PTR v$1[rsp+8], rbx
  0002b	48 89 5c 24 38	 mov	 QWORD PTR k$2[rsp+8], rbx

; 2423 :     if (s >= end) return false;

  00030	4c 3b df	 cmp	 r11, rdi
  00033	73 6a		 jae	 SHORT $LN16@mg_http_pa

; 2424 :     if (s[0] == '\n' || (s[0] == '\r' && s[1] == '\n')) break;

  00035	41 80 3b 0a	 cmp	 BYTE PTR [r11], 10
  00039	0f 84 e2 00 00
	00		 je	 $LN13@mg_http_pa
  0003f	41 80 3b 0d	 cmp	 BYTE PTR [r11], 13
  00043	75 0b		 jne	 SHORT $LN12@mg_http_pa
  00045	41 80 7b 01 0a	 cmp	 BYTE PTR [r11+1], 10
  0004a	0f 84 d1 00 00
	00		 je	 $LN13@mg_http_pa
$LN12@mg_http_pa:

; 2425 :     k.ptr = s;

  00050	4c 89 5c 24 30	 mov	 QWORD PTR k$2[rsp], r11
$LL5@mg_http_pa:

; 2426 :     while (s < end && s[0] != ':' && (n = clen(s, end)) > 0) s += n, k.len += n;

  00055	41 80 3b 3a	 cmp	 BYTE PTR [r11], 58	; 0000003aH
  00059	74 1b		 je	 SHORT $LN6@mg_http_pa
  0005b	48 8b d7	 mov	 rdx, rdi
  0005e	49 8b cb	 mov	 rcx, r11
  00061	e8 00 00 00 00	 call	 clen
  00066	48 85 c0	 test	 rax, rax
  00069	74 0b		 je	 SHORT $LN6@mg_http_pa
  0006b	4c 03 d8	 add	 r11, rax
  0006e	48 03 d8	 add	 rbx, rax
  00071	4c 3b df	 cmp	 r11, rdi
  00074	72 df		 jb	 SHORT $LL5@mg_http_pa
$LN6@mg_http_pa:
  00076	48 89 5c 24 38	 mov	 QWORD PTR k$2[rsp+8], rbx

; 2427 :     if (k.len == 0) return false;                     // Empty name

  0007b	48 85 db	 test	 rbx, rbx
  0007e	74 1f		 je	 SHORT $LN16@mg_http_pa

; 2428 :     if (s >= end || clen(s, end) == 0) return false;  // Invalid UTF-8

  00080	4c 3b df	 cmp	 r11, rdi
  00083	73 1a		 jae	 SHORT $LN16@mg_http_pa
  00085	48 8b d7	 mov	 rdx, rdi
  00088	49 8b cb	 mov	 rcx, r11
  0008b	e8 00 00 00 00	 call	 clen
  00090	48 85 c0	 test	 rax, rax
  00093	74 0a		 je	 SHORT $LN16@mg_http_pa

; 2429 :     if (*s++ != ':') return false;  // Invalid, not followed by :

  00095	41 8a 03	 mov	 al, BYTE PTR [r11]
  00098	49 ff c3	 inc	 r11
  0009b	3c 3a		 cmp	 al, 58			; 0000003aH
  0009d	74 20		 je	 SHORT $LN44@mg_http_pa
$LN16@mg_http_pa:

; 2428 :     if (s >= end || clen(s, end) == 0) return false;  // Invalid UTF-8

  0009f	32 c0		 xor	 al, al
$LN1@mg_http_pa:

; 2438 : }

  000a1	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000a6	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000ab	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000b0	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000b4	5f		 pop	 rdi
  000b5	c3		 ret	 0
$LL7@mg_http_pa:

; 2430 :     // if (clen(s, end) == 0) return false;        // Invalid UTF-8
; 2431 :     while (s < end && s[0] == ' ') s++;  // Skip spaces

  000b6	41 80 3b 20	 cmp	 BYTE PTR [r11], 32	; 00000020H
  000ba	75 08		 jne	 SHORT $LN8@mg_http_pa
  000bc	49 ff c3	 inc	 r11
$LN44@mg_http_pa:
  000bf	4c 3b df	 cmp	 r11, rdi
  000c2	72 f2		 jb	 SHORT $LL7@mg_http_pa
$LN8@mg_http_pa:

; 2432 :     if ((s = skiptorn(s, end, &v)) == NULL) return false;

  000c4	4c 8d 44 24 20	 lea	 r8, QWORD PTR v$1[rsp]
  000c9	48 8b d7	 mov	 rdx, rdi
  000cc	49 8b cb	 mov	 rcx, r11
  000cf	e8 00 00 00 00	 call	 skiptorn
  000d4	4c 8b d8	 mov	 r11, rax
  000d7	48 85 c0	 test	 rax, rax
  000da	74 c3		 je	 SHORT $LN16@mg_http_pa

; 2433 :     while (v.len > 0 && v.ptr[v.len - 1] == ' ') v.len--;  // Trim spaces

  000dc	48 8b 44 24 28	 mov	 rax, QWORD PTR v$1[rsp+8]
  000e1	48 85 c0	 test	 rax, rax
  000e4	74 17		 je	 SHORT $LN10@mg_http_pa
  000e6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$1[rsp]
$LL9@mg_http_pa:
  000eb	80 7c 01 ff 20	 cmp	 BYTE PTR [rcx+rax-1], 32 ; 00000020H
  000f0	75 06		 jne	 SHORT $LN43@mg_http_pa
  000f2	48 83 e8 01	 sub	 rax, 1
  000f6	75 f3		 jne	 SHORT $LL9@mg_http_pa
$LN43@mg_http_pa:
  000f8	48 89 44 24 28	 mov	 QWORD PTR v$1[rsp+8], rax
$LN10@mg_http_pa:

; 2434 :     // MG_INFO(("--HH [%.*s] [%.*s]", (int) k.len, k.ptr, (int) v.len, v.ptr));
; 2435 :     h[i].name = k, h[i].value = v;  // Success. Assign values

  000fd	0f 10 44 24 30	 movups	 xmm0, XMMWORD PTR k$2[rsp]
  00102	48 ff c5	 inc	 rbp
  00105	0f 10 4c 24 20	 movups	 xmm1, XMMWORD PTR v$1[rsp]
  0010a	f3 0f 7f 06	 movdqu	 XMMWORD PTR [rsi], xmm0
  0010e	f3 0f 7f 4e 10	 movdqu	 XMMWORD PTR [rsi+16], xmm1
  00113	48 83 c6 20	 add	 rsi, 32			; 00000020H
  00117	48 83 fd 1e	 cmp	 rbp, 30
  0011b	0f 82 fe fe ff
	ff		 jb	 $LL4@mg_http_pa
$LN13@mg_http_pa:

; 2436 :   }
; 2437 :   return true;

  00121	b0 01		 mov	 al, 1
  00123	e9 79 ff ff ff	 jmp	 $LN1@mg_http_pa
mg_http_parse_headers ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_parse
_TEXT	SEGMENT
$T1 = 32
s$ = 96
len$ = 104
hm$ = 112
mg_http_parse PROC					; COMDAT

; 2440 : int mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {

$LN57:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001c	49 8b f8	 mov	 rdi, r8
  0001f	48 8b d9	 mov	 rbx, rcx

; 2441 :   int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);

  00022	e8 00 00 00 00	 call	 mg_http_get_request_len
  00027	4c 63 e0	 movsxd	 r12, eax

; 2442 :   const char *end = s == NULL ? NULL : s + req_len, *qs;  // Cannot add to NULL

  0002a	48 8b d3	 mov	 rdx, rbx
  0002d	48 f7 da	 neg	 rdx

; 2443 :   struct mg_str *cl;
; 2444 :   size_t n;
; 2445 : 
; 2446 :   memset(hm, 0, sizeof(*hm));

  00030	41 b8 30 04 00
	00		 mov	 r8d, 1072		; 00000430H
  00036	48 8b cf	 mov	 rcx, rdi
  00039	48 1b f6	 sbb	 rsi, rsi
  0003c	33 d2		 xor	 edx, edx
  0003e	4d 8d 0c 1c	 lea	 r9, QWORD PTR [r12+rbx]
  00042	49 23 f1	 and	 rsi, r9
  00045	e8 00 00 00 00	 call	 memset

; 2447 :   if (req_len <= 0) return req_len;

  0004a	45 85 e4	 test	 r12d, r12d
  0004d	7f 08		 jg	 SHORT $LN10@mg_http_pa
$LN55@mg_http_pa:

; 2509 : 
; 2510 :   return req_len;
; 2511 : }

  0004f	41 8b c4	 mov	 eax, r12d
  00052	e9 ca 01 00 00	 jmp	 $LN1@mg_http_pa
$LN10@mg_http_pa:

; 2448 : 
; 2449 :   hm->message.ptr = hm->head.ptr = s;
; 2450 :   hm->body.ptr = end;
; 2451 :   hm->head.len = (size_t) req_len;
; 2452 :   hm->message.len = hm->body.len = (size_t) -1;  // Set body length to infinite

  00057	48 83 c8 ff	 or	 rax, -1
  0005b	48 89 9f 10 04
	00 00		 mov	 QWORD PTR [rdi+1040], rbx
  00062	4c 8d b7 08 04
	00 00		 lea	 r14, QWORD PTR [rdi+1032]
  00069	48 89 87 28 04
	00 00		 mov	 QWORD PTR [rdi+1064], rax
  00070	49 89 06	 mov	 QWORD PTR [r14], rax
  00073	48 89 9f 20 04
	00 00		 mov	 QWORD PTR [rdi+1056], rbx
  0007a	48 89 b7 00 04
	00 00		 mov	 QWORD PTR [rdi+1024], rsi
  00081	4c 89 a7 18 04
	00 00		 mov	 QWORD PTR [rdi+1048], r12

; 2453 : 
; 2454 :   // Parse request line
; 2455 :   hm->method.ptr = s;

  00088	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  0008b	eb 17		 jmp	 SHORT $LN51@mg_http_pa
$LL2@mg_http_pa:

; 2456 :   while (s < end && (n = clen(s, end)) > 0) s += n, hm->method.len += n;

  0008d	48 8b d6	 mov	 rdx, rsi
  00090	48 8b cb	 mov	 rcx, rbx
  00093	e8 00 00 00 00	 call	 clen
  00098	48 85 c0	 test	 rax, rax
  0009b	74 16		 je	 SHORT $LN52@mg_http_pa
  0009d	48 03 d8	 add	 rbx, rax
  000a0	48 01 47 08	 add	 QWORD PTR [rdi+8], rax
$LN51@mg_http_pa:
  000a4	48 3b de	 cmp	 rbx, rsi
  000a7	72 e4		 jb	 SHORT $LL2@mg_http_pa
  000a9	eb 0d		 jmp	 SHORT $LN5@mg_http_pa
$LL4@mg_http_pa:

; 2457 :   while (s < end && s[0] == ' ') s++;  // Skip spaces

  000ab	80 3b 20	 cmp	 BYTE PTR [rbx], 32	; 00000020H
  000ae	75 08		 jne	 SHORT $LN5@mg_http_pa
  000b0	48 ff c3	 inc	 rbx
$LN52@mg_http_pa:
  000b3	48 3b de	 cmp	 rbx, rsi
  000b6	72 f3		 jb	 SHORT $LL4@mg_http_pa
$LN5@mg_http_pa:

; 2458 :   hm->uri.ptr = s;

  000b8	4c 8d 6f 10	 lea	 r13, QWORD PTR [rdi+16]
  000bc	49 89 5d 00	 mov	 QWORD PTR [r13], rbx
  000c0	eb 17		 jmp	 SHORT $LN53@mg_http_pa
$LL6@mg_http_pa:

; 2459 :   while (s < end && (n = clen(s, end)) > 0) s += n, hm->uri.len += n;

  000c2	48 8b d6	 mov	 rdx, rsi
  000c5	48 8b cb	 mov	 rcx, rbx
  000c8	e8 00 00 00 00	 call	 clen
  000cd	48 85 c0	 test	 rax, rax
  000d0	74 16		 je	 SHORT $LN54@mg_http_pa
  000d2	48 03 d8	 add	 rbx, rax
  000d5	48 01 47 18	 add	 QWORD PTR [rdi+24], rax
$LN53@mg_http_pa:
  000d9	48 3b de	 cmp	 rbx, rsi
  000dc	72 e4		 jb	 SHORT $LL6@mg_http_pa
  000de	eb 0d		 jmp	 SHORT $LN9@mg_http_pa
$LL8@mg_http_pa:

; 2460 :   while (s < end && s[0] == ' ') s++;  // Skip spaces

  000e0	80 3b 20	 cmp	 BYTE PTR [rbx], 32	; 00000020H
  000e3	75 08		 jne	 SHORT $LN9@mg_http_pa
  000e5	48 ff c3	 inc	 rbx
$LN54@mg_http_pa:
  000e8	48 3b de	 cmp	 rbx, rsi
  000eb	72 f3		 jb	 SHORT $LL8@mg_http_pa
$LN9@mg_http_pa:

; 2461 :   if ((s = skiptorn(s, end, &hm->proto)) == NULL) return false;

  000ed	4c 8d 47 30	 lea	 r8, QWORD PTR [rdi+48]
  000f1	48 8b d6	 mov	 rdx, rsi
  000f4	48 8b cb	 mov	 rcx, rbx
  000f7	e8 00 00 00 00	 call	 skiptorn
  000fc	48 8b e8	 mov	 rbp, rax
  000ff	48 85 c0	 test	 rax, rax
  00102	0f 84 19 01 00
	00		 je	 $LN1@mg_http_pa
$LN11@mg_http_pa:

; 2462 : 
; 2463 :   // If URI contains '?' character, setup query string
; 2464 :   if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {

  00108	48 8b 5f 18	 mov	 rbx, QWORD PTR [rdi+24]
  0010c	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  00111	49 8b 4d 00	 mov	 rcx, QWORD PTR [r13]
  00115	4c 8b c3	 mov	 r8, rbx
  00118	e8 00 00 00 00	 call	 memchr
  0011d	48 85 c0	 test	 rax, rax
  00120	74 24		 je	 SHORT $LN12@mg_http_pa

; 2465 :     hm->query.ptr = qs + 1;
; 2466 :     hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));

  00122	48 ff cb	 dec	 rbx
  00125	48 8d 48 01	 lea	 rcx, QWORD PTR [rax+1]
  00129	48 89 4f 20	 mov	 QWORD PTR [rdi+32], rcx
  0012d	49 8b 4d 00	 mov	 rcx, QWORD PTR [r13]
  00131	48 2b c8	 sub	 rcx, rax
  00134	48 03 cb	 add	 rcx, rbx

; 2467 :     hm->uri.len = (size_t) (qs - hm->uri.ptr);

  00137	48 8b d8	 mov	 rbx, rax
  0013a	49 2b 5d 00	 sub	 rbx, QWORD PTR [r13]
  0013e	48 89 5f 18	 mov	 QWORD PTR [rdi+24], rbx
  00142	48 89 4f 28	 mov	 QWORD PTR [rdi+40], rcx
$LN12@mg_http_pa:

; 2468 :   }
; 2469 : 
; 2470 :   // Sanity check. Allow protocol/reason to be empty
; 2471 :   // Do this check after hm->method.len and hm->uri.len are finalised
; 2472 :   if (hm->method.len == 0 || hm->uri.len == 0) return -1;

  00146	48 83 7f 08 00	 cmp	 QWORD PTR [rdi+8], 0
  0014b	0f 84 cd 00 00
	00		 je	 $LN14@mg_http_pa
  00151	48 85 db	 test	 rbx, rbx
  00154	0f 84 c4 00 00
	00		 je	 $LN14@mg_http_pa

; 2473 : 
; 2474 :   if (!mg_http_parse_headers(s, end, hm->headers,

  0015a	4c 8d 47 40	 lea	 r8, QWORD PTR [rdi+64]
  0015e	48 8b d6	 mov	 rdx, rsi
  00161	48 8b cd	 mov	 rcx, rbp
  00164	e8 00 00 00 00	 call	 mg_http_parse_headers
  00169	84 c0		 test	 al, al
  0016b	0f 84 ad 00 00
	00		 je	 $LN14@mg_http_pa

; 2475 :                              sizeof(hm->headers) / sizeof(hm->headers[0])))
; 2476 :     return -1;  // error when parsing
; 2477 :   if ((cl = mg_http_get_header(hm, "Content-Length")) != NULL) {

  00171	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@HOJGPHBA@Content?9Length@
  00178	48 8b cf	 mov	 rcx, rdi
  0017b	e8 00 00 00 00	 call	 mg_http_get_header
  00180	48 85 c0	 test	 rax, rax
  00183	74 27		 je	 SHORT $LN41@mg_http_pa

; 2478 :     if (mg_to_size_t(*cl, &hm->body.len) == false) return -1;

  00185	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00188	49 8b d6	 mov	 rdx, r14
  0018b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00190	f3 0f 7f 44 24
	20		 movdqu	 XMMWORD PTR $T1[rsp], xmm0
  00196	e8 00 00 00 00	 call	 mg_to_size_t
  0019b	84 c0		 test	 al, al
  0019d	74 7f		 je	 SHORT $LN14@mg_http_pa

; 2479 :     hm->message.len = (size_t) req_len + hm->body.len;

  0019f	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  001a2	49 03 cc	 add	 rcx, r12
  001a5	48 89 8f 28 04
	00 00		 mov	 QWORD PTR [rdi+1064], rcx
$LN41@mg_http_pa:

; 2480 :   }
; 2481 : 
; 2482 :   // mg_http_parse() is used to parse both HTTP requests and HTTP
; 2483 :   // responses. If HTTP response does not have Content-Length set, then
; 2484 :   // body is read until socket is closed, i.e. body.len is infinite (~0).
; 2485 :   //
; 2486 :   // For HTTP requests though, according to
; 2487 :   // http://tools.ietf.org/html/rfc7231#section-8.1.3,
; 2488 :   // only POST and PUT methods have defined body semantics.
; 2489 :   // Therefore, if Content-Length is not specified and methods are
; 2490 :   // not one of PUT or POST, set body length to 0.
; 2491 :   //
; 2492 :   // So, if it is HTTP request, and Content-Length is not set,
; 2493 :   // and method is not (PUT or POST) then reset body length to zero.
; 2494 :   is_response = mg_ncasecmp(hm->method.ptr, "HTTP/", 5) == 0;

  001ac	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  001af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05FKGKDBHO@HTTP?1@
  001b6	41 b8 05 00 00
	00		 mov	 r8d, 5
  001bc	e8 00 00 00 00	 call	 mg_ncasecmp

; 2495 :   if (hm->body.len == (size_t) ~0 && !is_response &&
; 2496 :       mg_vcasecmp(&hm->method, "PUT") != 0 &&

  001c1	49 83 3e ff	 cmp	 QWORD PTR [r14], -1
  001c5	75 4a		 jne	 SHORT $LN19@mg_http_pa
  001c7	85 c0		 test	 eax, eax
  001c9	74 28		 je	 SHORT $LN43@mg_http_pa
  001cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03KBBGFLEK@PUT@
  001d2	48 8b cf	 mov	 rcx, rdi
  001d5	e8 00 00 00 00	 call	 mg_vcasecmp
  001da	85 c0		 test	 eax, eax
  001dc	74 33		 je	 SHORT $LN19@mg_http_pa
  001de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04HCJEIHPL@POST@
  001e5	48 8b cf	 mov	 rcx, rdi
  001e8	e8 00 00 00 00	 call	 mg_vcasecmp
  001ed	85 c0		 test	 eax, eax
  001ef	75 15		 jne	 SHORT $LN45@mg_http_pa
  001f1	eb 1e		 jmp	 SHORT $LN19@mg_http_pa
$LN43@mg_http_pa:

; 2497 :       mg_vcasecmp(&hm->method, "POST") != 0) {
; 2498 :     hm->body.len = 0;
; 2499 :     hm->message.len = (size_t) req_len;
; 2500 :   }
; 2501 : 
; 2502 :   // The 204 (No content) responses also have 0 body length
; 2503 :   if (hm->body.len == (size_t) ~0 && is_response &&

  001f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03BLNIAGKO@204@
  001fa	49 8b cd	 mov	 rcx, r13
  001fd	e8 00 00 00 00	 call	 mg_vcasecmp
  00202	85 c0		 test	 eax, eax
  00204	75 0b		 jne	 SHORT $LN19@mg_http_pa
$LN45@mg_http_pa:

; 2504 :       mg_vcasecmp(&hm->uri, "204") == 0) {
; 2505 :     hm->body.len = 0;

  00206	49 83 26 00	 and	 QWORD PTR [r14], 0

; 2506 :     hm->message.len = (size_t) req_len;

  0020a	4c 89 a7 28 04
	00 00		 mov	 QWORD PTR [rdi+1064], r12
$LN19@mg_http_pa:

; 2507 :   }
; 2508 :   if (hm->message.len < (size_t) req_len) return -1;  // Overflow protection

  00211	4c 39 a7 28 04
	00 00		 cmp	 QWORD PTR [rdi+1064], r12
  00218	0f 83 31 fe ff
	ff		 jae	 $LN55@mg_http_pa
$LN14@mg_http_pa:

; 2468 :   }
; 2469 : 
; 2470 :   // Sanity check. Allow protocol/reason to be empty
; 2471 :   // Do this check after hm->method.len and hm->uri.len are finalised
; 2472 :   if (hm->method.len == 0 || hm->uri.len == 0) return -1;

  0021e	83 c8 ff	 or	 eax, -1
$LN1@mg_http_pa:

; 2509 : 
; 2510 :   return req_len;
; 2511 : }

  00221	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00226	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  0022b	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  00230	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00234	41 5f		 pop	 r15
  00236	41 5e		 pop	 r14
  00238	41 5d		 pop	 r13
  0023a	41 5c		 pop	 r12
  0023c	5f		 pop	 rdi
  0023d	c3		 ret	 0
mg_http_parse ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_vprintf_chunk
_TEXT	SEGMENT
c$ = 48
fmt$ = 56
ap$ = 64
mg_http_vprintf_chunk PROC				; COMDAT

; 2514 :                                   va_list *ap) {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000f	4c 89 70 20	 mov	 QWORD PTR [rax+32], r14
  00013	41 57		 push	 r15
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2515 :   size_t len = c->send.len;

  00019	4c 8b 71 78	 mov	 r14, QWORD PTR [rcx+120]
  0001d	49 8b d8	 mov	 rbx, r8
  00020	48 8b fa	 mov	 rdi, rdx

; 2516 :   mg_send(c, "        \r\n", 10);

  00023	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@HNOLOFKI@?5?5?5?5?5?5?5?5?$AN?6@
  00030	48 8b f1	 mov	 rsi, rcx
  00033	e8 00 00 00 00	 call	 mg_send

; 2517 :   mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);

  00038	4c 8d 7e 68	 lea	 r15, QWORD PTR [rsi+104]
  0003c	4c 8b cb	 mov	 r9, rbx
  0003f	49 8b d7	 mov	 rdx, r15
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mg_pfn_iobuf
  00049	4c 8b c7	 mov	 r8, rdi
  0004c	e8 00 00 00 00	 call	 mg_vxprintf

; 2518 :   if (c->send.len >= len + 10) {

  00051	4c 8b 4e 78	 mov	 r9, QWORD PTR [rsi+120]
  00055	49 8d 5e 0a	 lea	 rbx, QWORD PTR [r14+10]
  00059	4c 3b cb	 cmp	 r9, rbx
  0005c	72 35		 jb	 SHORT $LN3@mg_http_vp

; 2519 :     mg_snprintf((char *) c->send.buf + len, 9, "%08lx", c->send.len - len - 10);

  0005e	49 8b 0f	 mov	 rcx, QWORD PTR [r15]
  00061	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05CLMJGDKL@?$CF08lx@
  00068	4d 2b ce	 sub	 r9, r14
  0006b	49 03 ce	 add	 rcx, r14
  0006e	49 83 e9 0a	 sub	 r9, 10
  00072	ba 09 00 00 00	 mov	 edx, 9
  00077	e8 00 00 00 00	 call	 mg_snprintf

; 2520 :     c->send.buf[len + 8] = '\r';

  0007c	49 8b 07	 mov	 rax, QWORD PTR [r15]
  0007f	42 c6 44 30 08
	0d		 mov	 BYTE PTR [rax+r14+8], 13

; 2521 :     if (c->send.len == len + 10) c->is_resp = 0;  // Last chunk, reset marker

  00085	48 39 5e 78	 cmp	 QWORD PTR [rsi+120], rbx
  00089	75 08		 jne	 SHORT $LN3@mg_http_vp
  0008b	0f ba b6 10 01
	00 00 0f	 btr	 DWORD PTR [rsi+272], 15
$LN3@mg_http_vp:

; 2522 :   }
; 2523 :   mg_send(c, "\r\n", 2);

  00093	41 b8 02 00 00
	00		 mov	 r8d, 2
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02PCIJFNDE@?$AN?6@
  000a0	48 8b ce	 mov	 rcx, rsi

; 2524 : }

  000a3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a8	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000ad	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000b2	4c 8b 74 24 48	 mov	 r14, QWORD PTR [rsp+72]
  000b7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bb	41 5f		 pop	 r15

; 2522 :   }
; 2523 :   mg_send(c, "\r\n", 2);

  000bd	e9 00 00 00 00	 jmp	 mg_send
mg_http_vprintf_chunk ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_printf_chunk
_TEXT	SEGMENT
c$ = 64
fmt$ = 72
mg_http_printf_chunk PROC				; COMDAT

; 2526 : void mg_http_printf_chunk(struct mg_connection *c, const char *fmt, ...) {

$LN4:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 53 10	 mov	 QWORD PTR [r11+16], rdx
  00007	4d 89 43 18	 mov	 QWORD PTR [r11+24], r8
  0000b	4d 89 4b 20	 mov	 QWORD PTR [r11+32], r9
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2527 :   va_list ap;
; 2528 :   va_start(ap, fmt);

  00013	49 8d 43 18	 lea	 rax, QWORD PTR [r11+24]

; 2529 :   mg_http_vprintf_chunk(c, fmt, &ap);

  00017	4d 8d 43 e8	 lea	 r8, QWORD PTR [r11-24]
  0001b	49 89 43 e8	 mov	 QWORD PTR [r11-24], rax
  0001f	e8 00 00 00 00	 call	 mg_http_vprintf_chunk

; 2530 :   va_end(ap);
; 2531 : }

  00024	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00028	c3		 ret	 0
mg_http_printf_chunk ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_write_chunk
_TEXT	SEGMENT
c$ = 48
buf$ = 56
len$ = 64
mg_http_write_chunk PROC				; COMDAT

; 2533 : void mg_http_write_chunk(struct mg_connection *c, const char *buf, size_t len) {

$LN5:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b da	 mov	 rbx, rdx
  00012	49 8b f8	 mov	 rdi, r8

; 2534 :   mg_printf(c, "%lx\r\n", (unsigned long) len);

  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05BJCCKDDP@?$CFlx?$AN?6@
  0001c	48 8b f1	 mov	 rsi, rcx
  0001f	e8 00 00 00 00	 call	 mg_printf

; 2535 :   mg_send(c, buf, len);

  00024	4c 8b c7	 mov	 r8, rdi
  00027	48 8b d3	 mov	 rdx, rbx
  0002a	48 8b ce	 mov	 rcx, rsi
  0002d	e8 00 00 00 00	 call	 mg_send

; 2536 :   mg_send(c, "\r\n", 2);

  00032	41 b8 02 00 00
	00		 mov	 r8d, 2
  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02PCIJFNDE@?$AN?6@
  0003f	48 8b ce	 mov	 rcx, rsi
  00042	e8 00 00 00 00	 call	 mg_send

; 2537 :   if (len == 0) c->is_resp = 0;

  00047	48 85 ff	 test	 rdi, rdi
  0004a	75 08		 jne	 SHORT $LN2@mg_http_wr
  0004c	0f ba b6 10 01
	00 00 0f	 btr	 DWORD PTR [rsi+272], 15
$LN2@mg_http_wr:

; 2538 : }

  00054	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00059	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5f		 pop	 rdi
  00063	c3		 ret	 0
mg_http_write_chunk ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_status_code_str
_TEXT	SEGMENT
status_code$ = 8
mg_http_status_code_str PROC				; COMDAT

; 2542 :   switch (status_code) {

  00000	b8 9a 01 00 00	 mov	 eax, 410		; 0000019aH
  00005	3b c8		 cmp	 ecx, eax
  00007	0f 8f d4 01 00
	00		 jg	 $LN69@mg_http_st
  0000d	0f 84 c6 01 00
	00		 je	 $LN35@mg_http_st
  00013	b8 2e 01 00 00	 mov	 eax, 302		; 0000012eH
  00018	3b c8		 cmp	 ecx, eax
  0001a	0f 8f e2 00 00
	00		 jg	 $LN70@mg_http_st
  00020	0f 84 d4 00 00
	00		 je	 $LN19@mg_http_st
  00026	b8 cc 00 00 00	 mov	 eax, 204		; 000000ccH
  0002b	3b c8		 cmp	 ecx, eax
  0002d	7f 69		 jg	 SHORT $LN71@mg_http_st
  0002f	74 5f		 je	 SHORT $LN11@mg_http_st
  00031	83 e9 64	 sub	 ecx, 100		; 00000064H
  00034	74 52		 je	 SHORT $LN4@mg_http_st
  00036	83 e9 01	 sub	 ecx, 1
  00039	74 45		 je	 SHORT $LN5@mg_http_st
  0003b	83 e9 01	 sub	 ecx, 1
  0003e	74 38		 je	 SHORT $LN6@mg_http_st
  00040	83 e9 62	 sub	 ecx, 98			; 00000062H
  00043	74 2b		 je	 SHORT $LN7@mg_http_st
  00045	83 e9 01	 sub	 ecx, 1
  00048	74 1e		 je	 SHORT $LN8@mg_http_st
  0004a	83 e9 01	 sub	 ecx, 1
  0004d	74 11		 je	 SHORT $LN9@mg_http_st
  0004f	83 f9 01	 cmp	 ecx, 1
  00052	0f 85 5c 03 00
	00		 jne	 $LN75@mg_http_st

; 2549 :     case 203: return "Non-authoritative Information";

  00058	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@FFMKBPKJ@Non?9authoritative?5Information@

; 2607 :   }
; 2608 : }

  0005f	c3		 ret	 0
$LN9@mg_http_st:

; 2548 :     case 202: return "Accepted";

  00060	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08DOBOODLA@Accepted@

; 2607 :   }
; 2608 : }

  00067	c3		 ret	 0
$LN8@mg_http_st:

; 2547 :     case 201: return "Created";

  00068	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07BBIDHECN@Created@

; 2607 :   }
; 2608 : }

  0006f	c3		 ret	 0
$LN7@mg_http_st:

; 2546 :     case 200: return "OK";

  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02GIPFHKNO@OK@

; 2607 :   }
; 2608 : }

  00077	c3		 ret	 0
$LN6@mg_http_st:

; 2545 :     case 102: return "Processing";

  00078	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0L@HFFAKEO@Processing@

; 2607 :   }
; 2608 : }

  0007f	c3		 ret	 0
$LN5@mg_http_st:

; 2544 :     case 101: return "Switching Protocols";

  00080	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@FGMIEJDD@Switching?5Protocols@

; 2607 :   }
; 2608 : }

  00087	c3		 ret	 0
$LN4@mg_http_st:

; 2543 :     case 100: return "Continue";

  00088	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08LJHDLOLO@Continue@

; 2607 :   }
; 2608 : }

  0008f	c3		 ret	 0
$LN11@mg_http_st:

; 2550 :     case 204: return "No Content";

  00090	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0L@FDPJCNGK@No?5Content@

; 2607 :   }
; 2608 : }

  00097	c3		 ret	 0
$LN71@mg_http_st:

; 2542 :   switch (status_code) {

  00098	81 e9 cd 00 00
	00		 sub	 ecx, 205		; 000000cdH
  0009e	74 52		 je	 SHORT $LN12@mg_http_st
  000a0	83 e9 01	 sub	 ecx, 1
  000a3	74 45		 je	 SHORT $LN13@mg_http_st
  000a5	83 e9 01	 sub	 ecx, 1
  000a8	74 38		 je	 SHORT $LN14@mg_http_st
  000aa	83 e9 01	 sub	 ecx, 1
  000ad	74 2b		 je	 SHORT $LN15@mg_http_st
  000af	83 e9 12	 sub	 ecx, 18
  000b2	74 1e		 je	 SHORT $LN16@mg_http_st
  000b4	83 e9 4a	 sub	 ecx, 74			; 0000004aH
  000b7	74 11		 je	 SHORT $LN17@mg_http_st
  000b9	83 f9 01	 cmp	 ecx, 1
  000bc	0f 85 f2 02 00
	00		 jne	 $LN75@mg_http_st

; 2557 :     case 301: return "Moved Permanently";

  000c2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@BPBCNFPI@Moved?5Permanently@

; 2607 :   }
; 2608 : }

  000c9	c3		 ret	 0
$LN17@mg_http_st:

; 2556 :     case 300: return "Multiple Choices";

  000ca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BB@HLFEHKPE@Multiple?5Choices@

; 2607 :   }
; 2608 : }

  000d1	c3		 ret	 0
$LN16@mg_http_st:

; 2555 :     case 226: return "IM Used";

  000d2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07EIILAAHO@IM?5Used@

; 2607 :   }
; 2608 : }

  000d9	c3		 ret	 0
$LN15@mg_http_st:

; 2554 :     case 208: return "Already Reported";

  000da	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BB@BPJDMGEO@Already?5Reported@

; 2607 :   }
; 2608 : }

  000e1	c3		 ret	 0
$LN14@mg_http_st:

; 2553 :     case 207: return "Multi-Status";

  000e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0N@BFLFIKGM@Multi?9Status@

; 2607 :   }
; 2608 : }

  000e9	c3		 ret	 0
$LN13@mg_http_st:

; 2552 :     case 206: return "Partial Content";

  000ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BA@NNLNHGMN@Partial?5Content@

; 2607 :   }
; 2608 : }

  000f1	c3		 ret	 0
$LN12@mg_http_st:

; 2551 :     case 205: return "Reset Content";

  000f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0O@BFFLKCLE@Reset?5Content@

; 2607 :   }
; 2608 : }

  000f9	c3		 ret	 0
$LN19@mg_http_st:

; 2558 :     case 302: return "Found";

  000fa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05JDGHEPJG@Found@

; 2607 :   }
; 2608 : }

  00101	c3		 ret	 0
$LN70@mg_http_st:

; 2542 :   switch (status_code) {

  00102	b8 92 01 00 00	 mov	 eax, 402		; 00000192H
  00107	3b c8		 cmp	 ecx, eax
  00109	7f 6c		 jg	 SHORT $LN72@mg_http_st
  0010b	74 62		 je	 SHORT $LN27@mg_http_st
  0010d	81 e9 2f 01 00
	00		 sub	 ecx, 303		; 0000012fH
  00113	74 52		 je	 SHORT $LN20@mg_http_st
  00115	83 e9 01	 sub	 ecx, 1
  00118	74 45		 je	 SHORT $LN21@mg_http_st
  0011a	83 e9 01	 sub	 ecx, 1
  0011d	74 38		 je	 SHORT $LN22@mg_http_st
  0011f	83 e9 02	 sub	 ecx, 2
  00122	74 2b		 je	 SHORT $LN23@mg_http_st
  00124	83 e9 01	 sub	 ecx, 1
  00127	74 1e		 je	 SHORT $LN24@mg_http_st
  00129	83 e9 5c	 sub	 ecx, 92			; 0000005cH
  0012c	74 11		 je	 SHORT $LN25@mg_http_st
  0012e	83 f9 01	 cmp	 ecx, 1
  00131	0f 85 7d 02 00
	00		 jne	 $LN75@mg_http_st

; 2565 :     case 401: return "Unauthorized";

  00137	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0N@OOAPMOJA@Unauthorized@

; 2607 :   }
; 2608 : }

  0013e	c3		 ret	 0
$LN25@mg_http_st:

; 2564 :     case 400: return "Bad Request";

  0013f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0M@LNAIDEEG@Bad?5Request@

; 2607 :   }
; 2608 : }

  00146	c3		 ret	 0
$LN24@mg_http_st:

; 2563 :     case 308: return "Permanent Redirect";

  00147	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@INBAOFGJ@Permanent?5Redirect@

; 2607 :   }
; 2608 : }

  0014e	c3		 ret	 0
$LN23@mg_http_st:

; 2562 :     case 307: return "Temporary Redirect";

  0014f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJMNAMDM@Temporary?5Redirect@

; 2607 :   }
; 2608 : }

  00156	c3		 ret	 0
$LN22@mg_http_st:

; 2561 :     case 305: return "Use Proxy";

  00157	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_09JFBGBFIM@Use?5Proxy@

; 2607 :   }
; 2608 : }

  0015e	c3		 ret	 0
$LN21@mg_http_st:

; 2560 :     case 304: return "Not Modified";

  0015f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0N@IFEFAIJB@Not?5Modified@

; 2607 :   }
; 2608 : }

  00166	c3		 ret	 0
$LN20@mg_http_st:

; 2559 :     case 303: return "See Other";

  00167	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_09FAMPMKIP@See?5Other@

; 2607 :   }
; 2608 : }

  0016e	c3		 ret	 0
$LN27@mg_http_st:

; 2566 :     case 402: return "Payment Required";

  0016f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BB@LMPIHCBH@Payment?5Required@

; 2607 :   }
; 2608 : }

  00176	c3		 ret	 0
$LN72@mg_http_st:

; 2542 :   switch (status_code) {

  00177	81 e9 93 01 00
	00		 sub	 ecx, 403		; 00000193H
  0017d	74 52		 je	 SHORT $LN28@mg_http_st
  0017f	83 e9 01	 sub	 ecx, 1
  00182	74 45		 je	 SHORT $LN29@mg_http_st
  00184	83 e9 01	 sub	 ecx, 1
  00187	74 38		 je	 SHORT $LN30@mg_http_st
  00189	83 e9 01	 sub	 ecx, 1
  0018c	74 2b		 je	 SHORT $LN31@mg_http_st
  0018e	83 e9 01	 sub	 ecx, 1
  00191	74 1e		 je	 SHORT $LN32@mg_http_st
  00193	83 e9 01	 sub	 ecx, 1
  00196	74 11		 je	 SHORT $LN33@mg_http_st
  00198	83 f9 01	 cmp	 ecx, 1
  0019b	0f 85 13 02 00
	00		 jne	 $LN75@mg_http_st

; 2573 :     case 409: return "Conflict";

  001a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08OJCIFGDF@Conflict@

; 2607 :   }
; 2608 : }

  001a8	c3		 ret	 0
$LN33@mg_http_st:

; 2572 :     case 408: return "Request Timeout";

  001a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BA@HALFGGF@Request?5Timeout@

; 2607 :   }
; 2608 : }

  001b0	c3		 ret	 0
$LN32@mg_http_st:

; 2571 :     case 407: return "Proxy Authentication Required";

  001b1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ONPAAOGI@Proxy?5Authentication?5Required@

; 2607 :   }
; 2608 : }

  001b8	c3		 ret	 0
$LN31@mg_http_st:

; 2570 :     case 406: return "Not Acceptable";

  001b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0P@HHIDFAOI@Not?5Acceptable@

; 2607 :   }
; 2608 : }

  001c0	c3		 ret	 0
$LN30@mg_http_st:

; 2569 :     case 405: return "Method Not Allowed";

  001c1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@CCIPIALO@Method?5Not?5Allowed@

; 2607 :   }
; 2608 : }

  001c8	c3		 ret	 0
$LN29@mg_http_st:

; 2568 :     case 404: return "Not Found";

  001c9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_09CFCBFJND@Not?5Found@

; 2607 :   }
; 2608 : }

  001d0	c3		 ret	 0
$LN28@mg_http_st:

; 2567 :     case 403: return "Forbidden";

  001d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_09LMDIMFJD@Forbidden@

; 2607 :   }
; 2608 : }

  001d8	c3		 ret	 0
$LN35@mg_http_st:

; 2574 :     case 410: return "Gone";

  001d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04OKIIBCCG@Gone@

; 2607 :   }
; 2608 : }

  001e0	c3		 ret	 0
$LN69@mg_http_st:

; 2542 :   switch (status_code) {

  001e1	b8 c3 01 00 00	 mov	 eax, 451		; 000001c3H
  001e6	3b c8		 cmp	 ecx, eax
  001e8	0f 8f ff 00 00
	00		 jg	 $LN73@mg_http_st
  001ee	0f 84 f1 00 00
	00		 je	 $LN53@mg_http_st
  001f4	b8 a5 01 00 00	 mov	 eax, 421		; 000001a5H
  001f9	3b c8		 cmp	 ecx, eax
  001fb	7f 79		 jg	 SHORT $LN74@mg_http_st
  001fd	74 6f		 je	 SHORT $LN44@mg_http_st
  001ff	81 e9 9b 01 00
	00		 sub	 ecx, 411		; 0000019bH
  00205	74 5f		 je	 SHORT $LN36@mg_http_st
  00207	83 e9 01	 sub	 ecx, 1
  0020a	74 52		 je	 SHORT $LN37@mg_http_st
  0020c	83 e9 01	 sub	 ecx, 1
  0020f	74 45		 je	 SHORT $LN38@mg_http_st
  00211	83 e9 01	 sub	 ecx, 1
  00214	74 38		 je	 SHORT $LN39@mg_http_st
  00216	83 e9 01	 sub	 ecx, 1
  00219	74 2b		 je	 SHORT $LN40@mg_http_st
  0021b	83 e9 01	 sub	 ecx, 1
  0021e	74 1e		 je	 SHORT $LN41@mg_http_st
  00220	83 e9 01	 sub	 ecx, 1
  00223	74 11		 je	 SHORT $LN42@mg_http_st
  00225	83 f9 01	 cmp	 ecx, 1
  00228	0f 85 86 01 00
	00		 jne	 $LN75@mg_http_st

; 2582 :     case 418: return "I'm a teapot";

  0022e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0N@EHOCJLEI@I?8m?5a?5teapot@

; 2607 :   }
; 2608 : }

  00235	c3		 ret	 0
$LN42@mg_http_st:

; 2581 :     case 417: return "Expectation Failed";

  00236	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@NDMHPAED@Expectation?5Failed@

; 2607 :   }
; 2608 : }

  0023d	c3		 ret	 0
$LN41@mg_http_st:

; 2580 :     case 416: return "Requested Range Not Satisfiable";

  0023e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CA@CBAMGINK@Requested?5Range?5Not?5Satisfiable@

; 2607 :   }
; 2608 : }

  00245	c3		 ret	 0
$LN40@mg_http_st:

; 2579 :     case 415: return "Unsupported Media Type";

  00246	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@HLJJIAEN@Unsupported?5Media?5Type@

; 2607 :   }
; 2608 : }

  0024d	c3		 ret	 0
$LN39@mg_http_st:

; 2578 :     case 414: return "Request-URI Too Long";

  0024e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@IHICNLJ@Request?9URI?5Too?5Long@

; 2607 :   }
; 2608 : }

  00255	c3		 ret	 0
$LN38@mg_http_st:

; 2577 :     case 413: return "Payload Too Large";

  00256	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@OEAEGMJF@Payload?5Too?5Large@

; 2607 :   }
; 2608 : }

  0025d	c3		 ret	 0
$LN37@mg_http_st:

; 2576 :     case 412: return "Precondition Failed";

  0025e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@BBDBJOM@Precondition?5Failed@

; 2607 :   }
; 2608 : }

  00265	c3		 ret	 0
$LN36@mg_http_st:

; 2575 :     case 411: return "Length Required";

  00266	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BA@JCKHPIPI@Length?5Required@

; 2607 :   }
; 2608 : }

  0026d	c3		 ret	 0
$LN44@mg_http_st:

; 2583 :     case 421: return "Misdirected Request";

  0026e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@GGAHKOMD@Misdirected?5Request@

; 2607 :   }
; 2608 : }

  00275	c3		 ret	 0
$LN74@mg_http_st:

; 2542 :   switch (status_code) {

  00276	81 e9 a6 01 00
	00		 sub	 ecx, 422		; 000001a6H
  0027c	74 5f		 je	 SHORT $LN45@mg_http_st
  0027e	83 e9 01	 sub	 ecx, 1
  00281	74 52		 je	 SHORT $LN46@mg_http_st
  00283	83 e9 01	 sub	 ecx, 1
  00286	74 45		 je	 SHORT $LN47@mg_http_st
  00288	83 e9 02	 sub	 ecx, 2
  0028b	74 38		 je	 SHORT $LN48@mg_http_st
  0028d	83 e9 02	 sub	 ecx, 2
  00290	74 2b		 je	 SHORT $LN49@mg_http_st
  00292	83 e9 01	 sub	 ecx, 1
  00295	74 1e		 je	 SHORT $LN50@mg_http_st
  00297	83 e9 02	 sub	 ecx, 2
  0029a	74 11		 je	 SHORT $LN51@mg_http_st
  0029c	83 f9 0d	 cmp	 ecx, 13
  0029f	0f 85 0f 01 00
	00		 jne	 $LN75@mg_http_st

; 2591 :     case 444: return "Connection Closed Without Response";

  002a5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CD@CBAJJADO@Connection?5Closed?5Without?5Respo@

; 2607 :   }
; 2608 : }

  002ac	c3		 ret	 0
$LN51@mg_http_st:

; 2590 :     case 431: return "Request Header Fields Too Large";

  002ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CA@IOEEABLM@Request?5Header?5Fields?5Too?5Large@

; 2607 :   }
; 2608 : }

  002b4	c3		 ret	 0
$LN50@mg_http_st:

; 2589 :     case 429: return "Too Many Requests";

  002b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@JPBLCMB@Too?5Many?5Requests@

; 2607 :   }
; 2608 : }

  002bc	c3		 ret	 0
$LN49@mg_http_st:

; 2588 :     case 428: return "Precondition Required";

  002bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMCBMLGE@Precondition?5Required@

; 2607 :   }
; 2608 : }

  002c4	c3		 ret	 0
$LN48@mg_http_st:

; 2587 :     case 426: return "Upgrade Required";

  002c5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BB@NMNIKHMI@Upgrade?5Required@

; 2607 :   }
; 2608 : }

  002cc	c3		 ret	 0
$LN47@mg_http_st:

; 2586 :     case 424: return "Failed Dependency";

  002cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@KKPOPIFM@Failed?5Dependency@

; 2607 :   }
; 2608 : }

  002d4	c3		 ret	 0
$LN46@mg_http_st:

; 2585 :     case 423: return "Locked";

  002d5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06GFKCFIPE@Locked@

; 2607 :   }
; 2608 : }

  002dc	c3		 ret	 0
$LN45@mg_http_st:

; 2584 :     case 422: return "Unprocessable Entity";

  002dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@BHJGKCEF@Unprocessable?5Entity@

; 2607 :   }
; 2608 : }

  002e4	c3		 ret	 0
$LN53@mg_http_st:

; 2592 :     case 451: return "Unavailable For Legal Reasons";

  002e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@BDFIKLNJ@Unavailable?5For?5Legal?5Reasons@

; 2607 :   }
; 2608 : }

  002ec	c3		 ret	 0
$LN73@mg_http_st:

; 2542 :   switch (status_code) {

  002ed	b8 57 02 00 00	 mov	 eax, 599		; 00000257H
  002f2	3b c8		 cmp	 ecx, eax
  002f4	0f 8f ba 00 00
	00		 jg	 $LN75@mg_http_st
  002fa	0f 84 ac 00 00
	00		 je	 $LN66@mg_http_st
  00300	b8 f9 01 00 00	 mov	 eax, 505		; 000001f9H
  00305	3b c8		 cmp	 ecx, eax
  00307	7f 5f		 jg	 SHORT $LN76@mg_http_st
  00309	74 55		 je	 SHORT $LN60@mg_http_st
  0030b	81 e9 f3 01 00
	00		 sub	 ecx, 499		; 000001f3H
  00311	74 45		 je	 SHORT $LN54@mg_http_st
  00313	83 e9 01	 sub	 ecx, 1
  00316	74 38		 je	 SHORT $LN55@mg_http_st
  00318	83 e9 01	 sub	 ecx, 1
  0031b	74 2b		 je	 SHORT $LN56@mg_http_st
  0031d	83 e9 01	 sub	 ecx, 1
  00320	74 1e		 je	 SHORT $LN57@mg_http_st
  00322	83 e9 01	 sub	 ecx, 1
  00325	74 11		 je	 SHORT $LN58@mg_http_st
  00327	83 f9 01	 cmp	 ecx, 1
  0032a	0f 85 84 00 00
	00		 jne	 $LN75@mg_http_st

; 2598 :     case 504: return "Gateway Timeout";

  00330	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BA@MCOKJNOA@Gateway?5Timeout@

; 2607 :   }
; 2608 : }

  00337	c3		 ret	 0
$LN58@mg_http_st:

; 2597 :     case 503: return "Service Unavailable";

  00338	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@NGHLFKBN@Service?5Unavailable@

; 2607 :   }
; 2608 : }

  0033f	c3		 ret	 0
$LN57@mg_http_st:

; 2596 :     case 502: return "Bad Gateway";

  00340	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0M@BNCNLPGM@Bad?5Gateway@

; 2607 :   }
; 2608 : }

  00347	c3		 ret	 0
$LN56@mg_http_st:

; 2595 :     case 501: return "Not Implemented";

  00348	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BA@JGKGKAME@Not?5Implemented@

; 2607 :   }
; 2608 : }

  0034f	c3		 ret	 0
$LN55@mg_http_st:

; 2594 :     case 500: return "Internal Server Error";

  00350	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@NJGANGCC@Internal?5Server?5Error@

; 2607 :   }
; 2608 : }

  00357	c3		 ret	 0
$LN54@mg_http_st:

; 2593 :     case 499: return "Client Closed Request";

  00358	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@NOEDODFP@Client?5Closed?5Request@

; 2607 :   }
; 2608 : }

  0035f	c3		 ret	 0
$LN60@mg_http_st:

; 2599 :     case 505: return "HTTP Version Not Supported";

  00360	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@ODCMNOHA@HTTP?5Version?5Not?5Supported@

; 2607 :   }
; 2608 : }

  00367	c3		 ret	 0
$LN76@mg_http_st:

; 2542 :   switch (status_code) {

  00368	81 e9 fa 01 00
	00		 sub	 ecx, 506		; 000001faH
  0036e	74 34		 je	 SHORT $LN61@mg_http_st
  00370	83 e9 01	 sub	 ecx, 1
  00373	74 27		 je	 SHORT $LN62@mg_http_st
  00375	83 e9 01	 sub	 ecx, 1
  00378	74 1a		 je	 SHORT $LN63@mg_http_st
  0037a	83 e9 02	 sub	 ecx, 2
  0037d	74 0d		 je	 SHORT $LN64@mg_http_st
  0037f	83 f9 01	 cmp	 ecx, 1
  00382	75 30		 jne	 SHORT $LN75@mg_http_st

; 2604 :     case 511: return "Network Authentication Required";

  00384	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CA@JCJMCNEH@Network?5Authentication?5Required@

; 2607 :   }
; 2608 : }

  0038b	c3		 ret	 0
$LN64@mg_http_st:

; 2603 :     case 510: return "Not Extended";

  0038c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0N@JKOFFNBC@Not?5Extended@

; 2607 :   }
; 2608 : }

  00393	c3		 ret	 0
$LN63@mg_http_st:

; 2602 :     case 508: return "Loop Detected";

  00394	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0O@KJBLEGOO@Loop?5Detected@

; 2607 :   }
; 2608 : }

  0039b	c3		 ret	 0
$LN62@mg_http_st:

; 2601 :     case 507: return "Insufficient Storage";

  0039c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@GDOFGFPB@Insufficient?5Storage@

; 2607 :   }
; 2608 : }

  003a3	c3		 ret	 0
$LN61@mg_http_st:

; 2600 :     case 506: return "Variant Also Negotiates";

  003a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BI@PDOLHBJO@Variant?5Also?5Negotiates@

; 2607 :   }
; 2608 : }

  003ab	c3		 ret	 0
$LN66@mg_http_st:

; 2605 :     case 599: return "Network Connect Timeout Error";

  003ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@OINGLCPC@Network?5Connect?5Timeout?5Error@

; 2607 :   }
; 2608 : }

  003b3	c3		 ret	 0
$LN75@mg_http_st:

; 2606 :     default: return "";

  003b4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@@

; 2607 :   }
; 2608 : }

  003bb	c3		 ret	 0
mg_http_status_code_str ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_reply
_TEXT	SEGMENT
ap$ = 48
c$ = 96
code$ = 104
headers$ = 112
fmt$ = 120
mg_http_reply PROC					; COMDAT

; 2612 :                    const char *fmt, ...) {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	53		 push	 rbx
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000c	48 8b d9	 mov	 rbx, rcx

; 2613 :   va_list ap;
; 2614 :   size_t len;
; 2615 :   mg_printf(c, "HTTP/1.1 %d %s\r\n%sContent-Length:            \r\n\r\n", code,

  0000f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
  00016	4d 85 c0	 test	 r8, r8
  00019	8b ca		 mov	 ecx, edx
  0001b	4c 0f 44 c0	 cmove	 r8, rax
  0001f	e8 00 00 00 00	 call	 mg_http_status_code_str
  00024	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  00029	4c 8b c8	 mov	 r9, rax
  0002c	44 8b c2	 mov	 r8d, edx
  0002f	48 8b cb	 mov	 rcx, rbx
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@GEFECBIH@HTTP?11?41?5?$CFd?5?$CFs?$AN?6?$CFsContent?9Lengt@
  00039	e8 00 00 00 00	 call	 mg_printf

; 2616 :             mg_http_status_code_str(code), headers == NULL ? "" : headers);
; 2617 :   len = c->send.len;
; 2618 :   va_start(ap, fmt);
; 2619 :   mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, &ap);

  0003e	4c 8b 44 24 78	 mov	 r8, QWORD PTR fmt$[rsp]
  00043	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0004b	48 8b 7b 78	 mov	 rdi, QWORD PTR [rbx+120]
  0004f	48 8d 73 68	 lea	 rsi, QWORD PTR [rbx+104]
  00053	48 8b d6	 mov	 rdx, rsi
  00056	48 89 44 24 30	 mov	 QWORD PTR ap$[rsp], rax
  0005b	4c 8d 4c 24 30	 lea	 r9, QWORD PTR ap$[rsp]
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mg_pfn_iobuf
  00067	e8 00 00 00 00	 call	 mg_vxprintf

; 2620 :   va_end(ap);

  0006c	48 83 64 24 30
	00		 and	 QWORD PTR ap$[rsp], 0

; 2621 :   if (c->send.len > 16) {

  00072	48 83 7b 78 10	 cmp	 QWORD PTR [rbx+120], 16
  00077	76 2a		 jbe	 SHORT $LN2@mg_http_re

; 2622 :     size_t n = mg_snprintf((char *) &c->send.buf[len - 15], 11, "%-10lu",

  00079	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  0007c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06DLMLPGDC@?$CF?910lu@
  00083	44 8b 4b 78	 mov	 r9d, DWORD PTR [rbx+120]
  00087	48 83 c1 f1	 add	 rcx, -15
  0008b	48 03 cf	 add	 rcx, rdi
  0008e	44 2b cf	 sub	 r9d, edi
  00091	ba 0b 00 00 00	 mov	 edx, 11
  00096	e8 00 00 00 00	 call	 mg_snprintf

; 2623 :                            (unsigned long) (c->send.len - len));
; 2624 :     c->send.buf[len - 15 + n] = ' ';  // Change ending 0 to space

  0009b	48 03 06	 add	 rax, QWORD PTR [rsi]
  0009e	c6 44 38 f1 20	 mov	 BYTE PTR [rax+rdi-15], 32 ; 00000020H
$LN2@mg_http_re:

; 2625 :   }
; 2626 :   c->is_resp = 0;

  000a3	0f ba b3 10 01
	00 00 0f	 btr	 DWORD PTR [rbx+272], 15

; 2627 : }

  000ab	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000af	5f		 pop	 rdi
  000b0	5e		 pop	 rsi
  000b1	5b		 pop	 rbx
  000b2	c3		 ret	 0
mg_http_reply ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT restore_http_cb
_TEXT	SEGMENT
c$ = 48
restore_http_cb PROC					; COMDAT

; 2630 : static void restore_http_cb(struct mg_connection *c) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2631 :   mg_fs_close((struct mg_fd *) c->pfn_data);

  0000a	48 8b b9 e0 00
	00 00		 mov	 rdi, QWORD PTR [rcx+224]
  00011	48 8b d9	 mov	 rbx, rcx

; 1611 :   if (fd != NULL) {

  00014	48 85 ff	 test	 rdi, rdi
  00017	74 13		 je	 SHORT $LN4@restore_ht

; 1612 :     fd->fs->cl(fd->fd);

  00019	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  0001d	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00020	ff 50 18	 call	 QWORD PTR [rax+24]

; 1613 :     free(fd);

  00023	48 8b cf	 mov	 rcx, rdi
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@restore_ht:

; 2632 :   c->pfn_data = NULL;

  0002c	48 83 a3 e0 00
	00 00 00	 and	 QWORD PTR [rbx+224], 0

; 2633 :   c->pfn = http_cb;

  00034	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:http_cb

; 2634 :   c->is_resp = 0;

  0003b	0f ba b3 10 01
	00 00 0f	 btr	 DWORD PTR [rbx+272], 15
  00043	48 89 83 d8 00
	00 00		 mov	 QWORD PTR [rbx+216], rax

; 2635 : }

  0004a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5f		 pop	 rdi
  00054	c3		 ret	 0
restore_http_cb ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_etag
_TEXT	SEGMENT
buf$ = 64
len$dead$ = 72
size$ = 80
mtime$ = 88
mg_http_etag PROC					; COMDAT

; 2638 : char *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2639 :   mg_snprintf(buf, len, "\"%lld.%lld\"", (int64_t) mtime, (int64_t) size);

  00006	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  0000b	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00010	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@KPHLEGAC@?$CC?$CFlld?4?$CFlld?$CC@
  00017	48 8b d9	 mov	 rbx, rcx
  0001a	e8 00 00 00 00	 call	 mg_snprintf

; 2640 :   return buf;

  0001f	48 8b c3	 mov	 rax, rbx

; 2641 : }

  00022	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00026	5b		 pop	 rbx
  00027	c3		 ret	 0
mg_http_etag ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT static_cb
_TEXT	SEGMENT
c$ = 48
ev$ = 56
ev_data$ = 64
static_cb PROC						; COMDAT

; 2643 : static void static_cb(struct mg_connection *c, int ev, void *ev_data) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b d9	 mov	 rbx, rcx

; 2644 :   if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {

  00012	83 fa 08	 cmp	 edx, 8
  00015	74 0c		 je	 SHORT $LN4@static_cb
  00017	83 fa 02	 cmp	 edx, 2
  0001a	74 07		 je	 SHORT $LN4@static_cb

; 2657 :   } else if (ev == MG_EV_CLOSE) {

  0001c	83 fa 09	 cmp	 edx, 9
  0001f	74 5c		 je	 SHORT $LN12@static_cb
  00021	eb 62		 jmp	 SHORT $LN8@static_cb
$LN4@static_cb:

; 2645 :     struct mg_fd *fd = (struct mg_fd *) c->pfn_data;

  00023	48 8b b1 e0 00
	00 00		 mov	 rsi, QWORD PTR [rcx+224]

; 2646 :     // Read to send IO buffer directly, avoid extra on-stack buffer
; 2647 :     size_t n, max = MG_IO_SIZE, space;
; 2648 :     size_t *cl = (size_t *) &c->data[(sizeof(c->data) - sizeof(size_t)) /
; 2649 :                                      sizeof(size_t) * sizeof(size_t)];
; 2650 :     if (c->send.size < max) mg_iobuf_resize(&c->send, max);

  0002a	48 8d 79 68	 lea	 rdi, QWORD PTR [rcx+104]
  0002e	ba 00 08 00 00	 mov	 edx, 2048		; 00000800H
  00033	48 39 51 70	 cmp	 QWORD PTR [rcx+112], rdx
  00037	73 08		 jae	 SHORT $LN5@static_cb
  00039	48 8b cf	 mov	 rcx, rdi
  0003c	e8 00 00 00 00	 call	 mg_iobuf_resize
$LN5@static_cb:

; 2651 :     if (c->send.len >= c->send.size) return;  // Rate limit

  00041	48 8b 53 78	 mov	 rdx, QWORD PTR [rbx+120]
  00045	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
  00049	48 3b d0	 cmp	 rdx, rax
  0004c	73 37		 jae	 SHORT $LN8@static_cb

; 2652 :     if ((space = c->send.size - c->send.len) > *cl) space = *cl;

  0004e	4c 8b 83 00 01
	00 00		 mov	 r8, QWORD PTR [rbx+256]
  00055	48 2b c2	 sub	 rax, rdx

; 2653 :     n = fd->fs->rd(fd->fd, c->send.buf + c->send.len, space);

  00058	4c 8b 4e 08	 mov	 r9, QWORD PTR [rsi+8]
  0005c	49 3b c0	 cmp	 rax, r8
  0005f	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00062	4c 0f 46 c0	 cmovbe	 r8, rax
  00066	48 03 17	 add	 rdx, QWORD PTR [rdi]
  00069	41 ff 51 20	 call	 QWORD PTR [r9+32]

; 2654 :     c->send.len += n;

  0006d	48 01 43 78	 add	 QWORD PTR [rbx+120], rax

; 2655 :     *cl -= n;

  00071	48 29 83 00 01
	00 00		 sub	 QWORD PTR [rbx+256], rax

; 2656 :     if (n == 0) restore_http_cb(c);

  00078	48 85 c0	 test	 rax, rax
  0007b	75 08		 jne	 SHORT $LN8@static_cb
$LN12@static_cb:
  0007d	48 8b cb	 mov	 rcx, rbx
  00080	e8 00 00 00 00	 call	 restore_http_cb
$LN8@static_cb:

; 2658 :     restore_http_cb(c);
; 2659 :   }
; 2660 :   (void) ev_data;
; 2661 : }

  00085	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0008f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00093	5f		 pop	 rdi
  00094	c3		 ret	 0
static_cb ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT guess_content_type
_TEXT	SEGMENT
s$ = 32
k$ = 48
v$ = 64
$T1 = 80
$T2 = 80
$T3 = 96
$T4 = 96
__$ReturnAddress$ = 128
path$ = 136
extra$ = 144
guess_content_type PROC					; COMDAT

; 2701 : static struct mg_str guess_content_type(struct mg_str path, const char *extra) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi
  0000a	55		 push	 rbp
  0000b	48 8b ec	 mov	 rbp, rsp
  0000e	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 7840 :   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};

  00018	4d 85 c0	 test	 r8, r8
  0001b	75 04		 jne	 SHORT $LN20@guess_cont
  0001d	33 c0		 xor	 eax, eax
  0001f	eb 0e		 jmp	 SHORT $LN21@guess_cont
$LN20@guess_cont:
  00021	48 83 c8 ff	 or	 rax, -1
$LL35@guess_cont:
  00025	48 ff c0	 inc	 rax
  00028	41 80 3c 00 00	 cmp	 BYTE PTR [r8+rax], 0
  0002d	75 f6		 jne	 SHORT $LL35@guess_cont
$LN21@guess_cont:

; 2702 :   struct mg_str k, v, s = mg_str(extra);
; 2703 :   size_t i = 0;
; 2704 : 
; 2705 :   // Shrink path to its extension only
; 2706 :   while (i < path.len && path.ptr[path.len - i - 1] != '.') i++;

  0002f	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00033	33 d2		 xor	 edx, edx
  00035	4c 89 45 b0	 mov	 QWORD PTR s$[rbp-112], r8
  00039	48 89 45 b8	 mov	 QWORD PTR s$[rbp-104], rax
  0003d	48 85 c9	 test	 rcx, rcx
  00040	74 1a		 je	 SHORT $LN3@guess_cont
  00042	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
  00045	49 ff c8	 dec	 r8
  00048	4c 03 c1	 add	 r8, rcx
$LL2@guess_cont:
  0004b	41 80 38 2e	 cmp	 BYTE PTR [r8], 46	; 0000002eH
  0004f	74 0b		 je	 SHORT $LN3@guess_cont
  00051	48 ff c2	 inc	 rdx
  00054	49 ff c8	 dec	 r8
  00057	48 3b d1	 cmp	 rdx, rcx
  0005a	72 ef		 jb	 SHORT $LL2@guess_cont
$LN3@guess_cont:

; 2707 :   path.ptr += path.len - i;

  0005c	48 2b ca	 sub	 rcx, rdx

; 2708 :   path.len = i;

  0005f	48 89 57 08	 mov	 QWORD PTR [rdi+8], rdx
  00063	48 01 0f	 add	 QWORD PTR [rdi], rcx

; 7992 :   return mg_split(s, k, v, ',');

  00066	eb 26		 jmp	 SHORT $LN38@guess_cont
$LL4@guess_cont:

; 2712 :     if (mg_strcmp(path, k) == 0) return v;

  00068	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR k$[rbp-112]
  0006c	48 8d 55 e0	 lea	 rdx, QWORD PTR $T2[rbp-112]
  00070	0f 28 0f	 movaps	 xmm1, XMMWORD PTR [rdi]
  00073	48 8d 4d f0	 lea	 rcx, QWORD PTR $T4[rbp-112]
  00077	66 0f 7f 45 e0	 movdqa	 XMMWORD PTR $T2[rbp-112], xmm0
  0007c	66 0f 7f 4d f0	 movdqa	 XMMWORD PTR $T4[rbp-112], xmm1
  00081	e8 00 00 00 00	 call	 mg_strcmp
  00086	85 c0		 test	 eax, eax
  00088	0f 84 8a 00 00
	00		 je	 $LN25@guess_cont
$LN38@guess_cont:

; 2709 : 
; 2710 :   // Process user-provided mime type overrides, if any
; 2711 :   while (mg_commalist(&s, &k, &v)) {

  0008e	41 b1 2c	 mov	 r9b, 44			; 0000002cH
  00091	4c 8d 45 d0	 lea	 r8, QWORD PTR v$[rbp-112]
  00095	48 8d 55 c0	 lea	 rdx, QWORD PTR k$[rbp-112]
  00099	48 8d 4d b0	 lea	 rcx, QWORD PTR s$[rbp-112]
  0009d	e8 00 00 00 00	 call	 mg_split
  000a2	84 c0		 test	 al, al
  000a4	75 c2		 jne	 SHORT $LL4@guess_cont

; 2713 :   }
; 2714 : 
; 2715 :   // Process built-in mime types
; 2716 :   for (i = 0; s_known_types[i].ptr != NULL; i += 2) {

  000a6	45 33 d2	 xor	 r10d, r10d
  000a9	4c 39 15 00 00
	00 00		 cmp	 QWORD PTR s_known_types, r10
  000b0	74 3f		 je	 SHORT $LN7@guess_cont

; 2717 :     if (mg_strcmp(path, s_known_types[i]) == 0) return s_known_types[i + 1];

  000b2	0f 28 07	 movaps	 xmm0, XMMWORD PTR [rdi]
  000b5	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:s_known_types
  000bc	49 8b c3	 mov	 rax, r11
  000bf	66 0f 7f 45 e0	 movdqa	 XMMWORD PTR $T1[rbp-112], xmm0
$LL8@guess_cont:
  000c4	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  000c7	48 8d 55 f0	 lea	 rdx, QWORD PTR $T3[rbp-112]
  000cb	48 8d 4d e0	 lea	 rcx, QWORD PTR $T1[rbp-112]
  000cf	f3 0f 7f 45 f0	 movdqu	 XMMWORD PTR $T3[rbp-112], xmm0
  000d4	e8 00 00 00 00	 call	 mg_strcmp
  000d9	85 c0		 test	 eax, eax
  000db	74 45		 je	 SHORT $LN26@guess_cont

; 2713 :   }
; 2714 : 
; 2715 :   // Process built-in mime types
; 2716 :   for (i = 0; s_known_types[i].ptr != NULL; i += 2) {

  000dd	49 83 c2 02	 add	 r10, 2
  000e1	49 8b c2	 mov	 rax, r10
  000e4	48 c1 e0 04	 shl	 rax, 4
  000e8	49 03 c3	 add	 rax, r11
  000eb	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000ef	75 d3		 jne	 SHORT $LL8@guess_cont
$LN7@guess_cont:

; 2718 :   }
; 2719 : 
; 2720 :   return mg_str("text/plain; charset=utf-8");

  000f1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@LKDCPLNF@text?1plain?$DL?5charset?$DNutf?98@
  000f8	48 89 03	 mov	 QWORD PTR [rbx], rax
  000fb	48 c7 43 08 19
	00 00 00	 mov	 QWORD PTR [rbx+8], 25
$LN39@guess_cont:

; 2721 : }

  00103	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  00108	48 8b c3	 mov	 rax, rbx
  0010b	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  0010f	49 8b 7b 18	 mov	 rdi, QWORD PTR [r11+24]
  00113	49 8b e3	 mov	 rsp, r11
  00116	5d		 pop	 rbp
  00117	c3		 ret	 0
$LN25@guess_cont:

; 2712 :     if (mg_strcmp(path, k) == 0) return v;

  00118	0f 10 45 d0	 movups	 xmm0, XMMWORD PTR v$[rbp-112]
$LN40@guess_cont:

; 2721 : }

  0011c	f3 0f 7f 03	 movdqu	 XMMWORD PTR [rbx], xmm0
  00120	eb e1		 jmp	 SHORT $LN39@guess_cont
$LN26@guess_cont:

; 2717 :     if (mg_strcmp(path, s_known_types[i]) == 0) return s_known_types[i + 1];

  00122	4d 03 d2	 add	 r10, r10
  00125	43 0f 10 44 d3
	10		 movups	 xmm0, XMMWORD PTR [r11+r10*8+16]
  0012b	eb ef		 jmp	 SHORT $LN40@guess_cont
guess_content_type ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT getrange
_TEXT	SEGMENT
v$1 = 32
$T2 = 48
$T3 = 48
$T4 = 48
k$5 = 48
s$ = 80
a$ = 88
b$ = 96
getrange PROC						; COMDAT

; 2723 : static int getrange(struct mg_str *s, size_t *a, size_t *b) {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000f	4c 89 70 20	 mov	 QWORD PTR [rax+32], r14
  00013	55		 push	 rbp
  00014	48 8b ec	 mov	 rbp, rsp
  00017	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 2724 :   size_t i, numparsed = 0;

  0001b	33 db		 xor	 ebx, ebx
  0001d	49 8b f0	 mov	 rsi, r8
  00020	48 8b fa	 mov	 rdi, rdx
  00023	4c 8b d1	 mov	 r10, rcx

; 2725 :   for (i = 0; i + 6 < s->len; i++) {

  00026	44 8d 4b 06	 lea	 r9d, QWORD PTR [rbx+6]
  0002a	4c 39 49 08	 cmp	 QWORD PTR [rcx+8], r9
  0002e	0f 86 b1 00 00
	00		 jbe	 $LN19@getrange

; 2726 :     struct mg_str k, v = mg_str_n(s->ptr + i + 6, s->len - i - 6);

  00034	4c 8b 19	 mov	 r11, QWORD PTR [rcx]
  00037	44 8d 73 01	 lea	 r14d, QWORD PTR [rbx+1]
  0003b	49 8b cb	 mov	 rcx, r11
  0003e	4d 2b cb	 sub	 r9, r11
$LL4@getrange:
  00041	48 8d 41 06	 lea	 rax, QWORD PTR [rcx+6]
  00045	48 89 45 e0	 mov	 QWORD PTR v$1[rbp-64], rax
  00049	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  0004d	48 2b c1	 sub	 rax, rcx
  00050	48 83 c0 fa	 add	 rax, -6
  00054	49 03 c3	 add	 rax, r11

; 2727 :     if (memcmp(&s->ptr[i], "bytes=", 6) != 0) continue;

  00057	81 39 62 79 74
	65		 cmp	 DWORD PTR [rcx], 1702132066 ; 65747962H
  0005d	48 89 45 e8	 mov	 QWORD PTR v$1[rbp-56], rax
  00061	75 08		 jne	 SHORT $LN18@getrange
  00063	66 81 79 04 73
	3d		 cmp	 WORD PTR [rcx+4], 15731	; 00003d73H
  00069	74 0f		 je	 SHORT $LN5@getrange
$LN18@getrange:

; 2725 :   for (i = 0; i + 6 < s->len; i++) {

  0006b	49 03 ce	 add	 rcx, r14
  0006e	49 8d 04 09	 lea	 rax, QWORD PTR [r9+rcx]
  00072	49 3b 42 08	 cmp	 rax, QWORD PTR [r10+8]
  00076	73 6d		 jae	 SHORT $LN19@getrange
  00078	eb c7		 jmp	 SHORT $LL4@getrange
$LN5@getrange:

; 2728 :     if (mg_split(&v, &k, NULL, '-')) {

  0007a	41 b1 2d	 mov	 r9b, 45			; 0000002dH
  0007d	48 8d 55 f0	 lea	 rdx, QWORD PTR k$5[rbp-64]
  00081	45 33 c0	 xor	 r8d, r8d
  00084	48 8d 4d e0	 lea	 rcx, QWORD PTR v$1[rbp-64]
  00088	e8 00 00 00 00	 call	 mg_split
  0008d	48 8d 4d f0	 lea	 rcx, QWORD PTR $T4[rbp-64]
  00091	48 8b d7	 mov	 rdx, rdi
  00094	84 c0		 test	 al, al
  00096	74 39		 je	 SHORT $LN6@getrange

; 2729 :       if (mg_to_size_t(k, a)) numparsed++;

  00098	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR k$5[rbp-64]
  0009c	66 0f 7f 45 f0	 movdqa	 XMMWORD PTR $T4[rbp-64], xmm0
  000a1	e8 00 00 00 00	 call	 mg_to_size_t
  000a6	84 c0		 test	 al, al
  000a8	49 0f 45 de	 cmovne	 rbx, r14

; 2730 :       if (v.len > 0 && mg_to_size_t(v, b)) numparsed++;

  000ac	48 83 7d e8 00	 cmp	 QWORD PTR v$1[rbp-56], 0
  000b1	76 32		 jbe	 SHORT $LN19@getrange
  000b3	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR v$1[rbp-64]
  000b7	48 8d 4d f0	 lea	 rcx, QWORD PTR $T3[rbp-64]
  000bb	48 8b d6	 mov	 rdx, rsi
  000be	66 0f 7f 45 f0	 movdqa	 XMMWORD PTR $T3[rbp-64], xmm0
  000c3	e8 00 00 00 00	 call	 mg_to_size_t
  000c8	84 c0		 test	 al, al
  000ca	74 19		 je	 SHORT $LN19@getrange
  000cc	49 03 de	 add	 rbx, r14

; 2731 :     } else {

  000cf	eb 14		 jmp	 SHORT $LN19@getrange
$LN6@getrange:

; 2732 :       if (mg_to_size_t(v, a)) numparsed++;

  000d1	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR v$1[rbp-64]
  000d5	66 0f 7f 45 f0	 movdqa	 XMMWORD PTR $T2[rbp-64], xmm0
  000da	e8 00 00 00 00	 call	 mg_to_size_t
  000df	84 c0		 test	 al, al
  000e1	49 0f 45 de	 cmovne	 rbx, r14
$LN19@getrange:

; 2733 :     }
; 2734 :     break;
; 2735 :   }
; 2736 :   return (int) numparsed;
; 2737 : }

  000e5	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  000ea	8b c3		 mov	 eax, ebx
  000ec	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000f1	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  000f6	4c 8b 74 24 68	 mov	 r14, QWORD PTR [rsp+104]
  000fb	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ff	5d		 pop	 rbp
  00100	c3		 ret	 0
getrange ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_serve_file
_TEXT	SEGMENT
$T1 = 96
$T2 = 96
mime$ = 96
$T3 = 112
r1$4 = 112
$T5 = 112
$T6 = 112
mtime$ = 128
$T7 = 144
r2$8 = 144
etag$ = 160
range$9 = 224
tmp$ = 336
c$ = 672
hm$ = 680
gzip$1$ = 688
path$ = 688
size$ = 696
opts$ = 696
mg_http_serve_file PROC					; COMDAT

; 2741 :                         const struct mg_http_serve_opts *opts) {

$LN55:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 55		 push	 r13
  00011	41 56		 push	 r14
  00013	41 57		 push	 r15
  00015	48 8d ac 24 a0
	fe ff ff	 lea	 rbp, QWORD PTR [rsp-352]
  0001d	48 81 ec 60 02
	00 00		 sub	 rsp, 608		; 00000260H
  00024	48 8b f1	 mov	 rsi, rcx

; 2742 :   char etag[64], tmp[MG_PATH_MAX];
; 2743 :   struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;

  00027	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:mg_fs_posix
  0002e	33 c9		 xor	 ecx, ecx
  00030	4d 8b f9	 mov	 r15, r9
  00033	49 39 49 28	 cmp	 QWORD PTR [r9+40], rcx
  00037	49 8b f8	 mov	 rdi, r8
  0003a	4c 8b ea	 mov	 r13, rdx

; 2744 :   struct mg_fd *fd = NULL;
; 2745 :   size_t size = 0;

  0003d	48 89 8d b8 01
	00 00		 mov	 QWORD PTR size$[rbp-256], rcx
  00044	4d 0f 45 61 28	 cmovne	 r12, QWORD PTR [r9+40]
  00049	8b d9		 mov	 ebx, ecx

; 7840 :   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};

  0004b	49 83 ce ff	 or	 r14, -1

; 2746 :   time_t mtime = 0;

  0004f	48 89 4d 80	 mov	 QWORD PTR mtime$[rbp-256], rcx

; 7840 :   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};

  00053	4d 85 c0	 test	 r8, r8
  00056	75 04		 jne	 SHORT $LN26@mg_http_se
  00058	8b c1		 mov	 eax, ecx
  0005a	eb 0c		 jmp	 SHORT $LN27@mg_http_se
$LN26@mg_http_se:
  0005c	49 8b c6	 mov	 rax, r14
$LL51@mg_http_se:
  0005f	48 ff c0	 inc	 rax
  00062	41 38 0c 00	 cmp	 BYTE PTR [r8+rax], cl
  00066	75 f7		 jne	 SHORT $LL51@mg_http_se
$LN27@mg_http_se:

; 2747 :   struct mg_str *inm = NULL;
; 2748 :   struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);

  00068	4d 8b 41 18	 mov	 r8, QWORD PTR [r9+24]
  0006c	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T2[rsp]
  00071	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T6[rsp]
  00076	48 89 7c 24 60	 mov	 QWORD PTR $T2[rsp], rdi
  0007b	48 89 44 24 68	 mov	 QWORD PTR $T2[rsp+8], rax
  00080	e8 00 00 00 00	 call	 guess_content_type

; 2749 :   bool gzip = false;

  00085	c6 85 b0 01 00
	00 00		 mov	 BYTE PTR gzip$1$[rbp-256], 0
  0008c	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0008f	f3 0f 7f 44 24
	60		 movdqu	 XMMWORD PTR mime$[rsp], xmm0

; 2750 : 
; 2751 :   if (path != NULL) {

  00095	48 85 ff	 test	 rdi, rdi
  00098	0f 84 a6 00 00
	00		 je	 $LN49@mg_http_se

; 2752 :     // If a browser sends us "Accept-Encoding: gzip", try to open .gz first
; 2753 :     struct mg_str *ae = mg_http_get_header(hm, "Accept-Encoding");

  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@KDJCHKHJ@Accept?9Encoding@
  000a5	49 8b cd	 mov	 rcx, r13
  000a8	e8 00 00 00 00	 call	 mg_http_get_header

; 2754 :     if (ae != NULL && mg_strstr(*ae, mg_str("gzip")) != NULL) {

  000ad	48 85 c0	 test	 rax, rax
  000b0	74 72		 je	 SHORT $LN48@mg_http_se
  000b2	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04HOHEGKBO@gzip@
  000bc	48 c7 44 24 78
	04 00 00 00	 mov	 QWORD PTR $T3[rsp+8], 4
  000c5	48 89 4c 24 70	 mov	 QWORD PTR $T3[rsp], rcx
  000ca	48 8d 54 24 70	 lea	 rdx, QWORD PTR $T3[rsp]
  000cf	48 8d 4d 90	 lea	 rcx, QWORD PTR $T7[rbp-256]
  000d3	f3 0f 7f 45 90	 movdqu	 XMMWORD PTR $T7[rbp-256], xmm0
  000d8	e8 00 00 00 00	 call	 mg_strstr
  000dd	48 85 c0	 test	 rax, rax
  000e0	74 42		 je	 SHORT $LN48@mg_http_se

; 2755 :       mg_snprintf(tmp, sizeof(tmp), "%s.gz", path);

  000e2	4c 8b cf	 mov	 r9, rdi
  000e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05HPILMEBC@?$CFs?4gz@
  000ec	ba 04 01 00 00	 mov	 edx, 260		; 00000104H
  000f1	48 8d 4d 50	 lea	 rcx, QWORD PTR tmp$[rbp-256]
  000f5	e8 00 00 00 00	 call	 mg_snprintf

; 2756 :       fd = mg_fs_open(fs, tmp, MG_FS_READ);

  000fa	41 b8 01 00 00
	00		 mov	 r8d, 1
  00100	48 8d 55 50	 lea	 rdx, QWORD PTR tmp$[rbp-256]
  00104	49 8b cc	 mov	 rcx, r12
  00107	e8 00 00 00 00	 call	 mg_fs_open
  0010c	48 8b d8	 mov	 rbx, rax

; 2757 :       if (fd != NULL) gzip = true, path = tmp;

  0010f	48 85 c0	 test	 rax, rax
  00112	74 10		 je	 SHORT $LN48@mg_http_se
  00114	c6 85 b0 01 00
	00 01		 mov	 BYTE PTR gzip$1$[rbp-256], 1
  0011b	48 8d 7d 50	 lea	 rdi, QWORD PTR tmp$[rbp-256]

; 2758 :     }
; 2759 :     // No luck opening .gz? Open what we've told to open
; 2760 :     if (fd == NULL) fd = mg_fs_open(fs, path, MG_FS_READ);

  0011f	e9 85 00 00 00	 jmp	 $LN47@mg_http_se
$LN48@mg_http_se:
  00124	41 b8 01 00 00
	00		 mov	 r8d, 1
  0012a	48 8b d7	 mov	 rdx, rdi
  0012d	49 8b cc	 mov	 rcx, r12
  00130	e8 00 00 00 00	 call	 mg_fs_open
  00135	c6 85 b0 01 00
	00 00		 mov	 BYTE PTR gzip$1$[rbp-256], 0
  0013c	48 8b d8	 mov	 rbx, rax

; 2761 :   }
; 2762 : 
; 2763 :   // Failed to open, and page404 is configured? Open it, then
; 2764 :   if (fd == NULL && opts->page404 != NULL) {

  0013f	48 85 c0	 test	 rax, rax
  00142	75 65		 jne	 SHORT $LN47@mg_http_se
$LN49@mg_http_se:
  00144	49 8b 57 20	 mov	 rdx, QWORD PTR [r15+32]
  00148	48 85 d2	 test	 rdx, rdx
  0014b	0f 84 86 02 00
	00		 je	 $LN9@mg_http_se

; 2765 :     fd = mg_fs_open(fs, opts->page404, MG_FS_READ);

  00151	41 b8 01 00 00
	00		 mov	 r8d, 1
  00157	49 8b cc	 mov	 rcx, r12
  0015a	e8 00 00 00 00	 call	 mg_fs_open
  0015f	48 8b d8	 mov	 rbx, rax

; 7840 :   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};

  00162	48 85 ff	 test	 rdi, rdi
  00165	75 05		 jne	 SHORT $LL50@mg_http_se
  00167	45 33 f6	 xor	 r14d, r14d
  0016a	eb 0a		 jmp	 SHORT $LN38@mg_http_se
$LL50@mg_http_se:
  0016c	49 ff c6	 inc	 r14
  0016f	42 80 3c 37 00	 cmp	 BYTE PTR [rdi+r14], 0
  00174	75 f6		 jne	 SHORT $LL50@mg_http_se
$LN38@mg_http_se:

; 2766 :     mime = guess_content_type(mg_str(path), opts->mime_types);

  00176	4d 8b 47 18	 mov	 r8, QWORD PTR [r15+24]
  0017a	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T1[rsp]
  0017f	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T5[rsp]
  00184	48 89 7c 24 60	 mov	 QWORD PTR $T1[rsp], rdi
  00189	4c 89 74 24 68	 mov	 QWORD PTR $T1[rsp+8], r14
  0018e	e8 00 00 00 00	 call	 guess_content_type

; 2767 :     path = opts->page404;

  00193	49 8b 7f 20	 mov	 rdi, QWORD PTR [r15+32]
  00197	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0019a	f3 0f 7f 44 24
	60		 movdqu	 XMMWORD PTR mime$[rsp], xmm0

; 2768 :   }
; 2769 : 
; 2770 :   if (fd == NULL || fs->st(path, &size, &mtime) == 0) {

  001a0	48 85 db	 test	 rbx, rbx
  001a3	0f 84 2e 02 00
	00		 je	 $LN9@mg_http_se
$LN47@mg_http_se:
  001a9	4c 8d 45 80	 lea	 r8, QWORD PTR mtime$[rbp-256]
  001ad	48 8b cf	 mov	 rcx, rdi
  001b0	48 8d 95 b8 01
	00 00		 lea	 rdx, QWORD PTR size$[rbp-256]
  001b7	41 ff 14 24	 call	 QWORD PTR [r12]
  001bb	85 c0		 test	 eax, eax
  001bd	0f 84 14 02 00
	00		 je	 $LN9@mg_http_se

; 2639 :   mg_snprintf(buf, len, "\"%lld.%lld\"", (int64_t) mtime, (int64_t) size);

  001c3	48 8b 85 b8 01
	00 00		 mov	 rax, QWORD PTR size$[rbp-256]
  001ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@KPHLEGAC@?$CC?$CFlld?4?$CFlld?$CC@
  001d1	4c 8b 4d 80	 mov	 r9, QWORD PTR mtime$[rbp-256]
  001d5	48 8d 4d a0	 lea	 rcx, QWORD PTR etag$[rbp-256]
  001d9	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001de	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e3	e8 00 00 00 00	 call	 mg_snprintf

; 2772 :     mg_fs_close(fd);
; 2773 :     // NOTE: mg_http_etag() call should go first!
; 2774 :   } else if (mg_http_etag(etag, sizeof(etag), size, mtime) != NULL &&
; 2775 :              (inm = mg_http_get_header(hm, "If-None-Match")) != NULL &&

  001e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@PLENHEOP@If?9None?9Match@
  001ef	49 8b cd	 mov	 rcx, r13
  001f2	e8 00 00 00 00	 call	 mg_http_get_header
  001f7	48 85 c0	 test	 rax, rax
  001fa	74 40		 je	 SHORT $LN10@mg_http_se
  001fc	48 8d 55 a0	 lea	 rdx, QWORD PTR etag$[rbp-256]
  00200	48 8b c8	 mov	 rcx, rax
  00203	e8 00 00 00 00	 call	 mg_vcasecmp
  00208	85 c0		 test	 eax, eax
  0020a	75 30		 jne	 SHORT $LN10@mg_http_se

; 1612 :     fd->fs->cl(fd->fd);

  0020c	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00210	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00213	ff 50 18	 call	 QWORD PTR [rax+24]

; 1613 :     free(fd);

  00216	48 8b cb	 mov	 rcx, rbx
  00219	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2776 :              mg_vcasecmp(inm, etag) == 0) {
; 2777 :     mg_fs_close(fd);
; 2778 :     mg_http_reply(c, 304, opts->extra_headers, "");

  0021f	4d 8b 47 10	 mov	 r8, QWORD PTR [r15+16]
  00223	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_00CNPNBAHC@@
  0022a	ba 30 01 00 00	 mov	 edx, 304		; 00000130H
  0022f	48 8b ce	 mov	 rcx, rsi
  00232	e8 00 00 00 00	 call	 mg_http_reply

; 2779 :   } else {

  00237	e9 cb 01 00 00	 jmp	 $LN29@mg_http_se
$LN10@mg_http_se:

; 2780 :     int n, status = 200;
; 2781 :     char range[100];
; 2782 :     size_t r1 = 0, r2 = 0, cl = size;
; 2783 : 
; 2784 :     // Handle Range header
; 2785 :     struct mg_str *rh = mg_http_get_header(hm, "Range");

  0023c	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR hm$[rbp-256]
  00243	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CFMCGLCK@Range@
  0024a	48 83 64 24 70
	00		 and	 QWORD PTR r1$4[rsp], 0
  00250	41 bd c8 00 00
	00		 mov	 r13d, 200		; 000000c8H
  00256	48 83 65 90 00	 and	 QWORD PTR r2$8[rbp-256], 0
  0025b	48 8b bd b8 01
	00 00		 mov	 rdi, QWORD PTR size$[rbp-256]
  00262	e8 00 00 00 00	 call	 mg_http_get_header

; 2786 :     range[0] = '\0';

  00267	c6 45 e0 00	 mov	 BYTE PTR range$9[rbp-256], 0

; 2787 :     if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0) {

  0026b	48 85 c0	 test	 rax, rax
  0026e	0f 84 a2 00 00
	00		 je	 $LN15@mg_http_se
  00274	4c 8d 45 90	 lea	 r8, QWORD PTR r2$8[rbp-256]
  00278	48 8b c8	 mov	 rcx, rax
  0027b	48 8d 54 24 70	 lea	 rdx, QWORD PTR r1$4[rsp]
  00280	e8 00 00 00 00	 call	 getrange
  00285	85 c0		 test	 eax, eax
  00287	0f 8e 89 00 00
	00		 jle	 $LN15@mg_http_se

; 2788 :       // If range is specified like "400-", set second limit to content len
; 2789 :       if (n == 1) r2 = cl - 1;

  0028d	83 f8 01	 cmp	 eax, 1
  00290	48 8d 47 ff	 lea	 rax, QWORD PTR [rdi-1]
  00294	74 04		 je	 SHORT $LN13@mg_http_se
  00296	48 8b 45 90	 mov	 rax, QWORD PTR r2$8[rbp-256]
$LN13@mg_http_se:

; 2790 :       if (r1 > r2 || r2 >= cl) {

  0029a	4c 8b 74 24 70	 mov	 r14, QWORD PTR r1$4[rsp]
  0029f	4c 3b f0	 cmp	 r14, rax
  002a2	77 50		 ja	 SHORT $LN16@mg_http_se
  002a4	48 3b c7	 cmp	 rax, rdi
  002a7	73 4b		 jae	 SHORT $LN16@mg_http_se

; 2794 :                     (int64_t) size);
; 2795 :       } else {
; 2796 :         status = 206;
; 2797 :         cl = r2 - r1 + 1;

  002a9	48 8b f8	 mov	 rdi, rax

; 2798 :         mg_snprintf(range, sizeof(range),

  002ac	49 8d 4e ff	 lea	 rcx, QWORD PTR [r14-1]
  002b0	48 8b 85 b8 01
	00 00		 mov	 rax, QWORD PTR size$[rbp-256]
  002b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CG@JKKKPNMP@Content?9Range?3?5bytes?5?$CFllu?9?$CFllu?1@
  002be	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002c3	49 2b fe	 sub	 rdi, r14
  002c6	48 ff c7	 inc	 rdi
  002c9	41 bd ce 00 00
	00		 mov	 r13d, 206		; 000000ceH
  002cf	48 03 cf	 add	 rcx, rdi
  002d2	4d 8b ce	 mov	 r9, r14
  002d5	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002da	48 8d 4d e0	 lea	 rcx, QWORD PTR range$9[rbp-256]
  002de	41 8d 55 96	 lea	 edx, QWORD PTR [r13-106]
  002e2	e8 00 00 00 00	 call	 mg_snprintf

; 2799 :                     "Content-Range: bytes %llu-%llu/%llu\r\n", (uint64_t) r1,
; 2800 :                     (uint64_t) (r1 + cl - 1), (uint64_t) size);
; 2801 :         fs->sk(fd->fd, r1);

  002e7	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  002ea	49 8b d6	 mov	 rdx, r14
  002ed	41 ff 54 24 30	 call	 QWORD PTR [r12+48]
  002f2	eb 22		 jmp	 SHORT $LN15@mg_http_se
$LN16@mg_http_se:

; 2791 :         status = 416;
; 2792 :         cl = 0;
; 2793 :         mg_snprintf(range, sizeof(range), "Content-Range: bytes */%lld\r\n",

  002f4	4c 8b 8d b8 01
	00 00		 mov	 r9, QWORD PTR size$[rbp-256]
  002fb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BO@IKDCAKCB@Content?9Range?3?5bytes?5?$CK?1?$CFlld?$AN?6@
  00302	33 ff		 xor	 edi, edi
  00304	48 8d 4d e0	 lea	 rcx, QWORD PTR range$9[rbp-256]
  00308	41 bd a0 01 00
	00		 mov	 r13d, 416		; 000001a0H
  0030e	8d 57 64	 lea	 edx, QWORD PTR [rdi+100]
  00311	e8 00 00 00 00	 call	 mg_snprintf
$LN15@mg_http_se:

; 2802 :       }
; 2803 :     }
; 2804 :     mg_printf(c,

  00316	49 83 7f 10 00	 cmp	 QWORD PTR [r15+16], 0
  0031b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@@
  00322	49 8b d0	 mov	 rdx, r8
  00325	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@MBGLAIMM@Content?9Encoding?3?5gzip?$AN?6@
  0032c	49 0f 45 57 10	 cmovne	 rdx, QWORD PTR [r15+16]
  00331	41 8b cd	 mov	 ecx, r13d
  00334	80 bd b0 01 00
	00 00		 cmp	 BYTE PTR gzip$1$[rbp-256], 0
  0033b	4c 0f 45 c0	 cmovne	 r8, rax
  0033f	e8 00 00 00 00	 call	 mg_http_status_code_str
  00344	48 89 54 24 50	 mov	 QWORD PTR [rsp+80], rdx
  00349	4c 8b c8	 mov	 r9, rax
  0034c	48 8d 45 e0	 lea	 rax, QWORD PTR range$9[rbp-256]
  00350	48 8b ce	 mov	 rcx, rsi
  00353	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00358	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EN@DLMBNGCO@HTTP?11?41?5?$CFd?5?$CFs?$AN?6Content?9Type?3?5?$CF@
  0035f	4c 89 44 24 40	 mov	 QWORD PTR [rsp+64], r8
  00364	48 8d 45 a0	 lea	 rax, QWORD PTR etag$[rbp-256]
  00368	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0036d	45 8b c5	 mov	 r8d, r13d
  00370	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00375	48 8b 44 24 60	 mov	 rax, QWORD PTR mime$[rsp]
  0037a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0037f	8b 44 24 68	 mov	 eax, DWORD PTR mime$[rsp+8]
  00383	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00387	e8 00 00 00 00	 call	 mg_printf

; 2805 :               "HTTP/1.1 %d %s\r\n"
; 2806 :               "Content-Type: %.*s\r\n"
; 2807 :               "Etag: %s\r\n"
; 2808 :               "Content-Length: %llu\r\n"
; 2809 :               "%s%s%s\r\n",
; 2810 :               status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,
; 2811 :               etag, (uint64_t) cl, gzip ? "Content-Encoding: gzip\r\n" : "",
; 2812 :               range, opts->extra_headers ? opts->extra_headers : "");
; 2813 :     if (mg_vcasecmp(&hm->method, "HEAD") == 0) {

  0038c	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR hm$[rbp-256]
  00393	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04BINJNOJD@HEAD@
  0039a	e8 00 00 00 00	 call	 mg_vcasecmp
  0039f	85 c0		 test	 eax, eax
  003a1	75 16		 jne	 SHORT $LN17@mg_http_se

; 2814 :       c->is_draining = 1;

  003a3	8b 86 10 01 00
	00		 mov	 eax, DWORD PTR [rsi+272]
  003a9	0f ba f0 0f	 btr	 eax, 15

; 2815 :       c->is_resp = 0;

  003ad	0f ba e8 0c	 bts	 eax, 12
  003b1	89 86 10 01 00
	00		 mov	 DWORD PTR [rsi+272], eax

; 2816 :       mg_fs_close(fd);
; 2817 :     } else {

  003b7	eb 36		 jmp	 SHORT $LN53@mg_http_se
$LN17@mg_http_se:

; 2818 :       // Track to-be-sent content length at the end of c->data, aligned
; 2819 :       size_t *clp = (size_t *) &c->data[(sizeof(c->data) - sizeof(size_t)) /
; 2820 :                                         sizeof(size_t) * sizeof(size_t)];
; 2821 :       c->pfn = static_cb;

  003b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:static_cb

; 2822 :       c->pfn_data = fd;

  003c0	48 89 9e e0 00
	00 00		 mov	 QWORD PTR [rsi+224], rbx
  003c7	48 89 86 d8 00
	00 00		 mov	 QWORD PTR [rsi+216], rax

; 2823 :       *clp = cl;

  003ce	48 89 be 00 01
	00 00		 mov	 QWORD PTR [rsi+256], rdi
  003d5	eb 30		 jmp	 SHORT $LN29@mg_http_se
$LN9@mg_http_se:

; 2771 :     mg_http_reply(c, 404, opts->extra_headers, "Not found\n");

  003d7	4d 8b 47 10	 mov	 r8, QWORD PTR [r15+16]
  003db	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0L@CKKNHDCB@Not?5found?6@
  003e2	ba 94 01 00 00	 mov	 edx, 404		; 00000194H
  003e7	48 8b ce	 mov	 rcx, rsi
  003ea	e8 00 00 00 00	 call	 mg_http_reply
$LN53@mg_http_se:

; 2824 :     }
; 2825 :   }
; 2826 : }

  003ef	48 85 db	 test	 rbx, rbx
  003f2	74 13		 je	 SHORT $LN29@mg_http_se
  003f4	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  003f8	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  003fb	ff 50 18	 call	 QWORD PTR [rax+24]
  003fe	48 8b cb	 mov	 rcx, rbx
  00401	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN29@mg_http_se:
  00407	48 8b 9c 24 a0
	02 00 00	 mov	 rbx, QWORD PTR [rsp+672]
  0040f	48 81 c4 60 02
	00 00		 add	 rsp, 608		; 00000260H
  00416	41 5f		 pop	 r15
  00418	41 5e		 pop	 r14
  0041a	41 5d		 pop	 r13
  0041c	41 5c		 pop	 r12
  0041e	5f		 pop	 rdi
  0041f	5e		 pop	 rsi
  00420	5d		 pop	 rbp
  00421	c3		 ret	 0
mg_http_serve_file ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT printdirentry
_TEXT	SEGMENT
sz$ = 96
mod$ = 136
path$ = 176
name$ = 496
size$ = 504
userdata$ = 504
t$ = 512
printdirentry PROC					; COMDAT

; 2836 : static void printdirentry(const char *name, void *userdata) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 8d ac 24 40
	ff ff ff	 lea	 rbp, QWORD PTR [rsp-192]
  00014	48 81 ec c0 01
	00 00		 sub	 rsp, 448		; 000001c0H

; 2837 :   struct printdirentrydata *d = (struct printdirentrydata *) userdata;
; 2838 :   struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;

  0001b	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  0001f	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:mg_fs_posix

; 2839 :   size_t size = 0;
; 2840 :   time_t t = 0;
; 2841 :   char path[MG_PATH_MAX], sz[40], mod[40];
; 2842 :   int flags, n = 0;
; 2843 : 
; 2844 :   // MG_DEBUG(("[%s] [%s]", d->dir, name));
; 2845 :   if (mg_snprintf(path, sizeof(path), "%s%c%s", d->dir, '/', name) >

  00026	4c 8b 4a 18	 mov	 r9, QWORD PTR [rdx+24]
  0002a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06GIIGBPHC@?$CFs?$CFc?$CFs@
  00031	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00036	4c 8b fa	 mov	 r15, rdx
  00039	48 8b f1	 mov	 rsi, rcx
  0003c	c7 44 24 20 2f
	00 00 00	 mov	 DWORD PTR [rsp+32], 47	; 0000002fH
  00044	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00049	48 8d 4d b0	 lea	 rcx, QWORD PTR path$[rbp-256]
  0004d	bf 04 01 00 00	 mov	 edi, 260		; 00000104H
  00052	48 0f 45 58 28	 cmovne	 rbx, QWORD PTR [rax+40]
  00057	8b d7		 mov	 edx, edi
  00059	48 83 a5 f8 00
	00 00 00	 and	 QWORD PTR size$[rbp-256], 0
  00061	48 83 a5 00 01
	00 00 00	 and	 QWORD PTR t$[rbp-256], 0
  00069	e8 00 00 00 00	 call	 mg_snprintf
  0006e	48 3b c7	 cmp	 rax, rdi
  00071	76 38		 jbe	 SHORT $LN8@printdiren

; 2846 :       sizeof(path)) {
; 2847 :     MG_ERROR(("%s truncated", name));

  00073	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR mg_log_level, 1
  0007a	0f 8c 5d 01 00
	00		 jl	 $LN12@printdiren
  00080	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0O@NAEKIGEC@printdirentry@
  00087	b9 01 00 00 00	 mov	 ecx, 1
  0008c	41 b8 1f 0b 00
	00		 mov	 r8d, 2847		; 00000b1fH
  00092	e8 00 00 00 00	 call	 mg_log_prefix
  00097	48 8b d6	 mov	 rdx, rsi
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@BELOEIBP@?$CFs?5truncated@
  000a1	e8 00 00 00 00	 call	 mg_log

; 2848 :   } else if ((flags = fs->st(path, &size, &t)) == 0) {

  000a6	e9 32 01 00 00	 jmp	 $LN12@printdiren
$LN8@printdiren:
  000ab	4c 8d 85 00 01
	00 00		 lea	 r8, QWORD PTR t$[rbp-256]
  000b2	48 8d 95 f8 00
	00 00		 lea	 rdx, QWORD PTR size$[rbp-256]
  000b9	48 8d 4d b0	 lea	 rcx, QWORD PTR path$[rbp-256]
  000bd	ff 13		 call	 QWORD PTR [rbx]
  000bf	8b d8		 mov	 ebx, eax
  000c1	85 c0		 test	 eax, eax
  000c3	75 46		 jne	 SHORT $LN11@printdiren

; 2849 :     MG_ERROR(("%lu stat(%s): %d", d->c->id, path, errno));

  000c5	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR mg_log_level, 1
  000cc	0f 8c 0b 01 00
	00		 jl	 $LN12@printdiren
  000d2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0O@NAEKIGEC@printdirentry@
  000d9	41 b8 21 0b 00
	00		 mov	 r8d, 2849		; 00000b21H
  000df	8d 48 01	 lea	 ecx, QWORD PTR [rax+1]
  000e2	e8 00 00 00 00	 call	 mg_log_prefix
  000e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ed	49 8b 0f	 mov	 rcx, QWORD PTR [r15]
  000f0	4c 8d 45 b0	 lea	 r8, QWORD PTR path$[rbp-256]
  000f4	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  000f7	8b 51 40	 mov	 edx, DWORD PTR [rcx+64]
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@MFGDKDCP@?$CFlu?5stat?$CI?$CFs?$CJ?3?5?$CFd@
  00101	e8 00 00 00 00	 call	 mg_log

; 2850 :   } else {

  00106	e9 d2 00 00 00	 jmp	 $LN12@printdiren
$LN11@printdiren:

; 2851 :     const char *slash = flags & MG_FS_DIR ? "/" : "";

  0010b	83 e3 04	 and	 ebx, 4
  0010e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01KMDKNFGN@?1@
  00115	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:??_C@_00CNPNBAHC@@

; 2852 :     if (flags & MG_FS_DIR) {

  0011c	bf 28 00 00 00	 mov	 edi, 40			; 00000028H
  00121	4c 0f 45 f0	 cmovne	 r14, rax
  00125	48 8d 4c 24 60	 lea	 rcx, QWORD PTR sz$[rsp]
  0012a	8b d7		 mov	 edx, edi
  0012c	85 db		 test	 ebx, ebx
  0012e	74 10		 je	 SHORT $LN14@printdiren

; 2853 :       mg_snprintf(sz, sizeof(sz), "%s", "[DIR]");

  00130	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_05DDGJGJB@?$FLDIR?$FN@
  00137	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@

; 2854 :     } else {

  0013e	eb 0e		 jmp	 SHORT $LN20@printdiren
$LN14@printdiren:

; 2855 :       mg_snprintf(sz, sizeof(sz), "%lld", (uint64_t) size);

  00140	4c 8b 8d f8 00
	00 00		 mov	 r9, QWORD PTR size$[rbp-256]
  00147	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04BFAHMMK@?$CFlld@
$LN20@printdiren:

; 2856 :     }
; 2857 : #if defined(MG_HTTP_DIRLIST_TIME_FMT)
; 2858 :     {
; 2859 :       char time_str[40];
; 2860 :       struct tm *time_info = localtime(&t);
; 2861 :       strftime(time_str, sizeof time_str, "%Y/%m/%d %H:%M:%S", time_info);
; 2862 :       mg_snprintf(mod, sizeof(mod), "%s", time_str);
; 2863 :     }
; 2864 : #else
; 2865 :     mg_snprintf(mod, sizeof(mod), "%lu", (unsigned long) t);

  0014e	e8 00 00 00 00	 call	 mg_snprintf
  00153	44 8b 8d 00 01
	00 00		 mov	 r9d, DWORD PTR t$[rbp-256]
  0015a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03FKNCMABI@?$CFlu@
  00161	48 8b d7	 mov	 rdx, rdi
  00164	48 8d 4d 88	 lea	 rcx, QWORD PTR mod$[rbp-256]
  00168	e8 00 00 00 00	 call	 mg_snprintf

; 2866 : #endif
; 2867 :     n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));

  0016d	48 83 cf ff	 or	 rdi, -1
  00171	48 8b d7	 mov	 rdx, rdi
$LL19@printdiren:
  00174	48 ff c2	 inc	 rdx
  00177	80 3c 16 00	 cmp	 BYTE PTR [rsi+rdx], 0
  0017b	75 f7		 jne	 SHORT $LL19@printdiren
  0017d	4c 8d 45 b0	 lea	 r8, QWORD PTR path$[rbp-256]
  00181	48 8b ce	 mov	 rcx, rsi
  00184	e8 00 00 00 00	 call	 mg_url_encode

; 2868 :     mg_printf(d->c,

  00189	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR size$[rbp-256]
  00190	48 8d 54 24 60	 lea	 rdx, QWORD PTR sz$[rsp]
  00195	48 89 54 24 50	 mov	 QWORD PTR [rsp+80], rdx
  0019a	4c 8d 4d b0	 lea	 r9, QWORD PTR path$[rbp-256]
  0019e	85 db		 test	 ebx, ebx
  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FI@IPGJIOJD@?5?5?$DMtr?$DO?$DMtd?$DO?$DMa?5href?$DN?$CC?$CF?4?$CKs?$CFs?$CC?$DO?$CFs?$CFs@
  001a7	44 8b c0	 mov	 r8d, eax
  001aa	48 0f 45 cf	 cmovne	 rcx, rdi
  001ae	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001b3	48 8d 4d 88	 lea	 rcx, QWORD PTR mod$[rbp-256]
  001b7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001bc	8b 8d 00 01 00
	00		 mov	 ecx, DWORD PTR t$[rbp-256]
  001c2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001c6	49 8b 0f	 mov	 rcx, QWORD PTR [r15]
  001c9	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  001ce	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  001d3	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  001d8	e8 00 00 00 00	 call	 mg_printf
$LN12@printdiren:

; 2869 :               "  <tr><td><a href=\"%.*s%s\">%s%s</a></td>"
; 2870 :               "<td name=%lu>%s</td><td name=%lld>%s</td></tr>\n",
; 2871 :               n, path, slash, name, slash, (unsigned long) t, mod,
; 2872 :               flags & MG_FS_DIR ? (int64_t) -1 : (int64_t) size, sz);
; 2873 :   }
; 2874 : }

  001dd	48 8b 9c 24 f0
	01 00 00	 mov	 rbx, QWORD PTR [rsp+496]
  001e5	48 81 c4 c0 01
	00 00		 add	 rsp, 448		; 000001c0H
  001ec	41 5f		 pop	 r15
  001ee	41 5e		 pop	 r14
  001f0	5f		 pop	 rdi
  001f1	5e		 pop	 rsi
  001f2	5d		 pop	 rbp
  001f3	c3		 ret	 0
printdirentry ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT listdir
_TEXT	SEGMENT
tmp$ = 64
$T1 = 80
d$ = 96
buf$ = 128
c$ = 448
hm$ = 456
opts$ = 464
dir$ = 472
listdir	PROC						; COMDAT

; 2877 :                     const struct mg_http_serve_opts *opts, char *dir) {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000f	4c 89 60 20	 mov	 QWORD PTR [rax+32], r12
  00013	55		 push	 rbp
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 8d a8 48 ff
	ff ff		 lea	 rbp, QWORD PTR [rax-184]
  0001f	48 81 ec a0 01
	00 00		 sub	 rsp, 416		; 000001a0H

; 2878 :   const char *sort_js_code =
; 2879 :       "<script>function srt(tb, sc, so, d) {"
; 2880 :       "var tr = Array.prototype.slice.call(tb.rows, 0),"
; 2881 :       "tr = tr.sort(function (a, b) { var c1 = a.cells[sc], c2 = b.cells[sc],"
; 2882 :       "n1 = c1.getAttribute('name'), n2 = c2.getAttribute('name'), "
; 2883 :       "t1 = a.cells[2].getAttribute('name'), "
; 2884 :       "t2 = b.cells[2].getAttribute('name'); "
; 2885 :       "return so * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : "
; 2886 :       "n1 ? parseInt(n2) - parseInt(n1) : "
; 2887 :       "c1.textContent.trim().localeCompare(c2.textContent.trim())); });";
; 2888 :   const char *sort_js_code2 =
; 2889 :       "for (var i = 0; i < tr.length; i++) tb.appendChild(tr[i]); "
; 2890 :       "if (!d) window.location.hash = ('sc=' + sc + '&so=' + so); "
; 2891 :       "};"
; 2892 :       "window.onload = function() {"
; 2893 :       "var tb = document.getElementById('tb');"
; 2894 :       "var m = /sc=([012]).so=(1|-1)/.exec(window.location.hash) || [0, 2, 1];"
; 2895 :       "var sc = m[1], so = m[2]; document.onclick = function(ev) { "
; 2896 :       "var c = ev.target.rel; if (c) {if (c == sc) so *= -1; srt(tb, c, so); "
; 2897 :       "sc = c; ev.preventDefault();}};"
; 2898 :       "srt(tb, sc, so, true);"
; 2899 :       "}"
; 2900 :       "</script>";
; 2901 :   struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
; 2902 :   struct printdirentrydata d = {c, hm, opts, dir};
; 2903 :   char tmp[10], buf[MG_PATH_MAX];
; 2904 :   size_t off, n;
; 2905 :   int len = mg_url_decode(hm->uri.ptr, hm->uri.len, buf, sizeof(buf), 0);

  00026	48 8d 5a 10	 lea	 rbx, QWORD PTR [rdx+16]
  0002a	48 89 4c 24 60	 mov	 QWORD PTR d$[rsp], rcx
  0002f	45 33 e4	 xor	 r12d, r12d
  00032	48 89 54 24 68	 mov	 QWORD PTR d$[rsp+8], rdx
  00037	4d 39 60 28	 cmp	 QWORD PTR [r8+40], r12
  0003b	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:mg_fs_posix
  00042	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00046	4d 8b f9	 mov	 r15, r9
  00049	49 0f 45 70 28	 cmovne	 rsi, QWORD PTR [r8+40]
  0004e	49 8b f8	 mov	 rdi, r8
  00051	4c 8b f1	 mov	 r14, rcx
  00054	4c 89 44 24 70	 mov	 QWORD PTR d$[rsp+16], r8
  00059	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0005c	4c 8d 45 80	 lea	 r8, QWORD PTR buf$[rbp-256]
  00060	4c 89 4c 24 78	 mov	 QWORD PTR d$[rsp+24], r9
  00065	41 b9 04 01 00
	00		 mov	 r9d, 260		; 00000104H
  0006b	0f 29 70 d8	 movaps	 XMMWORD PTR [rax-40], xmm6
  0006f	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  00074	e8 00 00 00 00	 call	 mg_url_decode

; 2906 :   struct mg_str uri = len > 0 ? mg_str_n(buf, (size_t) len) : hm->uri;

  00079	85 c0		 test	 eax, eax
  0007b	7e 15		 jle	 SHORT $LN7@listdir

; 7845 :   struct mg_str str = {s, n};

  0007d	48 8d 4d 80	 lea	 rcx, QWORD PTR buf$[rbp-256]

; 2906 :   struct mg_str uri = len > 0 ? mg_str_n(buf, (size_t) len) : hm->uri;

  00081	48 98		 cdqe

; 7845 :   struct mg_str str = {s, n};

  00083	48 89 4c 24 50	 mov	 QWORD PTR $T1[rsp], rcx

; 2906 :   struct mg_str uri = len > 0 ? mg_str_n(buf, (size_t) len) : hm->uri;

  00088	48 8d 5c 24 50	 lea	 rbx, QWORD PTR $T1[rsp]
  0008d	48 89 44 24 58	 mov	 QWORD PTR $T1[rsp+8], rax
$LN7@listdir:

; 2907 : 
; 2908 :   mg_printf(c,

  00092	4c 39 67 10	 cmp	 QWORD PTR [rdi+16], r12
  00096	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@@
  0009d	0f 10 33	 movups	 xmm6, XMMWORD PTR [rbx]
  000a0	4c 0f 45 47 10	 cmovne	 r8, QWORD PTR [rdi+16]
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FI@EOBPCODB@HTTP?11?41?5200?5OK?$AN?6Content?9Type?3?5@
  000ac	49 8b ce	 mov	 rcx, r14
  000af	e8 00 00 00 00	 call	 mg_printf

; 2909 :             "HTTP/1.1 200 OK\r\n"
; 2910 :             "Content-Type: text/html; charset=utf-8\r\n"
; 2911 :             "%s"
; 2912 :             "Content-Length:         \r\n\r\n",
; 2913 :             opts->extra_headers == NULL ? "" : opts->extra_headers);
; 2914 :   off = c->send.len;  // Start of body

  000b4	49 8b 5e 78	 mov	 rbx, QWORD PTR [r14+120]

; 2915 :   mg_printf(c,

  000b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BME@DCNGJJJ@for?5?$CIvar?5i?5?$DN?50?$DL?5i?5?$DM?5tr?4length?$DL?5@
  000bf	66 49 0f 7e f1	 movq	 r9, xmm6
  000c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BII@BEKFAOHG@?$DM?$CBDOCTYPE?5html?$DO?$DMhtml?$DO?$DMhead?$DO?$DMtit@
  000cb	4c 89 4c 24 38	 mov	 QWORD PTR [rsp+56], r9
  000d0	66 0f 73 de 08	 psrldq	 xmm6, 8
  000d5	66 0f 7e 74 24
	30		 movd	 DWORD PTR [rsp+48], xmm6
  000db	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BMF@KFFEPKPH@?$DMscript?$DOfunction?5srt?$CItb?0?5sc?0?5so@
  000e7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000ec	49 8b ce	 mov	 rcx, r14
  000ef	66 41 0f 7e f0	 movd	 r8d, xmm6
  000f4	e8 00 00 00 00	 call	 mg_printf

; 2916 :             "<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s"
; 2917 :             "<style>th,td {text-align: left; padding-right: 1em; "
; 2918 :             "font-family: monospace; }</style></head>"
; 2919 :             "<body><h1>Index of %.*s</h1><table cellpadding=\"0\"><thead>"
; 2920 :             "<tr><th><a href=\"#\" rel=\"0\">Name</a></th><th>"
; 2921 :             "<a href=\"#\" rel=\"1\">Modified</a></th>"
; 2922 :             "<th><a href=\"#\" rel=\"2\">Size</a></th></tr>"
; 2923 :             "<tr><td colspan=\"3\"><hr></td></tr>"
; 2924 :             "</thead>"
; 2925 :             "<tbody id=\"tb\">\n",
; 2926 :             (int) uri.len, uri.ptr, sort_js_code, sort_js_code2, (int) uri.len,
; 2927 :             uri.ptr);
; 2928 :   mg_printf(c, "%s",

  000f9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0FA@IECPBOOL@?5?5?$DMtr?$DO?$DMtd?$DO?$DMa?5href?$DN?$CC?4?4?$CC?$DO?4?4?$DM?1a?$DO?$DM?1@
  00100	49 8b ce	 mov	 rcx, r14
  00103	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  0010a	e8 00 00 00 00	 call	 mg_printf

; 2929 :             "  <tr><td><a href=\"..\">..</a></td>"
; 2930 :             "<td name=-1></td><td name=-1>[DIR]</td></tr>\n");
; 2931 : 
; 2932 :   fs->ls(dir, printdirentry, &d);

  0010f	4c 8d 44 24 60	 lea	 r8, QWORD PTR d$[rsp]
  00114	49 8b cf	 mov	 rcx, r15
  00117	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:printdirentry
  0011e	ff 56 08	 call	 QWORD PTR [rsi+8]

; 2933 :   mg_printf(c,

  00121	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04KCOIGPKP@7?412@
  00128	49 8b ce	 mov	 rcx, r14
  0012b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0HB@HMGLNPND@?$DM?1tbody?$DO?$DMtfoot?$DO?$DMtr?$DO?$DMtd?5colspan?$DN@
  00132	e8 00 00 00 00	 call	 mg_printf

; 2934 :             "</tbody><tfoot><tr><td colspan=\"3\"><hr></td></tr></tfoot>"
; 2935 :             "</table><address>Mongoose v.%s</address></body></html>\n",
; 2936 :             MG_VERSION);
; 2937 :   n = mg_snprintf(tmp, sizeof(tmp), "%lu", (unsigned long) (c->send.len - off));

  00137	45 8b 4e 78	 mov	 r9d, DWORD PTR [r14+120]
  0013b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03FKNCMABI@?$CFlu@
  00142	44 2b cb	 sub	 r9d, ebx
  00145	48 8d 4c 24 40	 lea	 rcx, QWORD PTR tmp$[rsp]
  0014a	ba 0a 00 00 00	 mov	 edx, 10
  0014f	e8 00 00 00 00	 call	 mg_snprintf

; 2938 :   if (n > sizeof(tmp)) n = 0;

  00154	48 83 f8 0a	 cmp	 rax, 10

; 2939 :   memcpy(c->send.buf + off - 12, tmp, n);  // Set content length

  00158	48 8d 4b f4	 lea	 rcx, QWORD PTR [rbx-12]
  0015c	4c 8b c0	 mov	 r8, rax
  0015f	48 8d 54 24 40	 lea	 rdx, QWORD PTR tmp$[rsp]
  00164	4d 0f 47 c4	 cmova	 r8, r12
  00168	49 03 4e 68	 add	 rcx, QWORD PTR [r14+104]
  0016c	e8 00 00 00 00	 call	 memcpy

; 2940 :   c->is_resp = 0;                          // Mark response end

  00171	41 0f ba b6 10
	01 00 00 0f	 btr	 DWORD PTR [r14+272], 15

; 2941 : }

  0017a	4c 8d 9c 24 a0
	01 00 00	 lea	 r11, QWORD PTR [rsp+416]
  00182	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  00186	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  0018a	49 8b 7b 30	 mov	 rdi, QWORD PTR [r11+48]
  0018e	4d 8b 63 38	 mov	 r12, QWORD PTR [r11+56]
  00192	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  00197	49 8b e3	 mov	 rsp, r11
  0019a	41 5f		 pop	 r15
  0019c	41 5e		 pop	 r14
  0019e	5d		 pop	 rbp
  0019f	c3		 ret	 0
listdir	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT uri_to_path2
_TEXT	SEGMENT
c$ = 96
hm$ = 104
fs$ = 112
url$ = 120
dir$ = 128
path$ = 136
path_size$dead$ = 144
uri_to_path2 PROC					; COMDAT

; 2947 :                         char *path, size_t path_size) {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  00007	49 89 6b 10	 mov	 QWORD PTR [r11+16], rbp
  0000b	49 89 73 18	 mov	 QWORD PTR [r11+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2948 :   int flags, tmp;
; 2949 :   // Append URI to the root_dir, and sanitize it
; 2950 :   size_t n = mg_snprintf(path, path_size, "%.*s", (int) dir.len, dir.ptr);

  0001c	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR path$[rsp]
  00024	49 8b f9	 mov	 rdi, r9
  00027	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR dir$[rsp]
  0002f	4d 8b e8	 mov	 r13, r8
  00032	4c 8b fa	 mov	 r15, rdx
  00035	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04EBNJJJJI@?$CF?4?$CKs@
  0003c	48 8b e9	 mov	 rbp, rcx
  0003f	41 be 04 01 00
	00		 mov	 r14d, 260		; 00000104H
  00045	41 8b d6	 mov	 edx, r14d
  00048	48 8b cb	 mov	 rcx, rbx
  0004b	49 8b 01	 mov	 rax, QWORD PTR [r9]
  0004e	45 8b 49 08	 mov	 r9d, DWORD PTR [r9+8]
  00052	49 89 43 c8	 mov	 QWORD PTR [r11-56], rax
  00056	e8 00 00 00 00	 call	 mg_snprintf

; 2951 :   if (n + 2 >= path_size) {

  0005b	48 8d 50 02	 lea	 rdx, QWORD PTR [rax+2]
  0005f	49 3b d6	 cmp	 rdx, r14
  00062	72 23		 jb	 SHORT $LN7@uri_to_pat

; 2952 :     mg_http_reply(c, 400, "", "Exceeded path size");

  00064	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BD@CCPJKDLJ@Exceeded?5path?5size@
$LN34@uri_to_pat:

; 3002 : }

  0006b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@@
  00072	ba 90 01 00 00	 mov	 edx, 400		; 00000190H
  00077	48 8b cd	 mov	 rcx, rbp
  0007a	e8 00 00 00 00	 call	 mg_http_reply
  0007f	83 c8 ff	 or	 eax, -1
  00082	e9 c6 01 00 00	 jmp	 $LN1@uri_to_pat
$LN7@uri_to_pat:

; 2953 :     return -1;
; 2954 :   }
; 2955 :   path[path_size - 1] = '\0';

  00087	45 33 d2	 xor	 r10d, r10d
  0008a	44 88 93 03 01
	00 00		 mov	 BYTE PTR [rbx+259], r10b

; 2956 :   // Terminate root dir with slash
; 2957 :   if (n > 0 && path[n - 1] != '/') path[n++] = '/', path[n] = '\0';

  00091	48 85 c0	 test	 rax, rax
  00094	74 12		 je	 SHORT $LN8@uri_to_pat
  00096	80 7c 18 ff 2f	 cmp	 BYTE PTR [rax+rbx-1], 47 ; 0000002fH
  0009b	74 0b		 je	 SHORT $LN8@uri_to_pat
  0009d	c6 04 18 2f	 mov	 BYTE PTR [rax+rbx], 47	; 0000002fH
  000a1	48 ff c0	 inc	 rax
  000a4	44 88 14 18	 mov	 BYTE PTR [rax+rbx], r10b
$LN8@uri_to_pat:

; 2958 :   if (url.len < hm->uri.len) {

  000a8	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  000ac	4d 8d 67 10	 lea	 r12, QWORD PTR [r15+16]
  000b0	49 8b 57 18	 mov	 rdx, QWORD PTR [r15+24]
  000b4	48 3b ca	 cmp	 rcx, rdx
  000b7	73 1e		 jae	 SHORT $LN29@uri_to_pat

; 2959 :     mg_url_decode(hm->uri.ptr + url.len, hm->uri.len - url.len, path + n,

  000b9	48 2b d1	 sub	 rdx, rcx
  000bc	44 89 54 24 20	 mov	 DWORD PTR [rsp+32], r10d
  000c1	49 03 0c 24	 add	 rcx, QWORD PTR [r12]
  000c5	4c 8d 04 18	 lea	 r8, QWORD PTR [rax+rbx]
  000c9	4d 8b ce	 mov	 r9, r14
  000cc	4c 2b c8	 sub	 r9, rax
  000cf	e8 00 00 00 00	 call	 mg_url_decode
  000d4	45 33 d2	 xor	 r10d, r10d
$LN29@uri_to_pat:

; 2960 :                   path_size - n, 0);
; 2961 :   }
; 2962 :   path[path_size - 1] = '\0';  // Double-check
; 2963 :   if (!mg_path_is_sane(path)) {

  000d7	48 8b cb	 mov	 rcx, rbx
  000da	44 88 93 03 01
	00 00		 mov	 BYTE PTR [rbx+259], r10b
  000e1	e8 00 00 00 00	 call	 mg_path_is_sane
  000e6	84 c0		 test	 al, al
  000e8	75 0c		 jne	 SHORT $LN10@uri_to_pat

; 2964 :     mg_http_reply(c, 400, "", "Invalid path");

  000ea	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0N@KKHAJPLM@Invalid?5path@

; 2965 :     return -1;

  000f1	e9 75 ff ff ff	 jmp	 $LN34@uri_to_pat
$LN10@uri_to_pat:

; 2966 :   }
; 2967 :   n = strlen(path);

  000f6	48 83 ce ff	 or	 rsi, -1
$LL31@uri_to_pat:
  000fa	48 ff c6	 inc	 rsi
  000fd	44 38 14 33	 cmp	 BYTE PTR [rbx+rsi], r10b
  00101	75 f7		 jne	 SHORT $LL31@uri_to_pat
  00103	eb 0e		 jmp	 SHORT $LN33@uri_to_pat
$LL2@uri_to_pat:

; 2968 :   while (n > 1 && path[n - 1] == '/') path[--n] = 0;  // Trim trailing slashes

  00105	80 7c 1e ff 2f	 cmp	 BYTE PTR [rsi+rbx-1], 47 ; 0000002fH
  0010a	75 0d		 jne	 SHORT $LN3@uri_to_pat
  0010c	48 ff ce	 dec	 rsi
  0010f	44 88 14 1e	 mov	 BYTE PTR [rsi+rbx], r10b
$LN33@uri_to_pat:
  00113	48 83 fe 01	 cmp	 rsi, 1
  00117	77 ec		 ja	 SHORT $LL2@uri_to_pat
$LN3@uri_to_pat:

; 2969 :   flags = mg_vcmp(&hm->uri, "/") == 0 ? MG_FS_DIR : fs->st(path, NULL, NULL);

  00119	49 8b cc	 mov	 rcx, r12
  0011c	e8 00 00 00 00	 call	 mg_vcmp
  00121	85 c0		 test	 eax, eax
  00123	75 05		 jne	 SHORT $LN24@uri_to_pat
  00125	8d 78 04	 lea	 edi, QWORD PTR [rax+4]
  00128	eb 0e		 jmp	 SHORT $LN25@uri_to_pat
$LN24@uri_to_pat:
  0012a	45 33 c0	 xor	 r8d, r8d
  0012d	33 d2		 xor	 edx, edx
  0012f	48 8b cb	 mov	 rcx, rbx
  00132	41 ff 55 00	 call	 QWORD PTR [r13]
  00136	8b f8		 mov	 edi, eax
$LN25@uri_to_pat:

; 2970 :   MG_VERBOSE(("%lu %.*s -> %s %d", c->id, (int) hm->uri.len, hm->uri.ptr, path,

  00138	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR mg_log_level, 4
  0013f	7c 37		 jl	 SHORT $LN4@uri_to_pat
  00141	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0N@GNCHAPHH@uri_to_path2@
  00148	b9 04 00 00 00	 mov	 ecx, 4
  0014d	41 b8 9b 0b 00
	00		 mov	 r8d, 2971		; 00000b9bH
  00153	e8 00 00 00 00	 call	 mg_log_prefix
  00158	4d 8b 0c 24	 mov	 r9, QWORD PTR [r12]
  0015c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@GKOJEFML@?$CFlu?5?$CF?4?$CKs?5?9?$DO?5?$CFs?5?$CFd@
  00163	45 8b 47 18	 mov	 r8d, DWORD PTR [r15+24]
  00167	8b 55 40	 mov	 edx, DWORD PTR [rbp+64]
  0016a	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  0016e	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00173	e8 00 00 00 00	 call	 mg_log
$LN4@uri_to_pat:

; 2971 :               flags));
; 2972 :   if (flags == 0) {

  00178	85 ff		 test	 edi, edi
  0017a	0f 84 cb 00 00
	00		 je	 $LN22@uri_to_pat

; 2973 :     // Do nothing - let's caller decide
; 2974 :   } else if ((flags & MG_FS_DIR) && hm->uri.len > 0 &&

  00180	40 f6 c7 04	 test	 dil, 4
  00184	0f 84 c1 00 00
	00		 je	 $LN22@uri_to_pat
  0018a	49 8b 47 18	 mov	 rax, QWORD PTR [r15+24]
  0018e	48 85 c0	 test	 rax, rax
  00191	74 2e		 je	 SHORT $LN14@uri_to_pat
  00193	4d 8b 0c 24	 mov	 r9, QWORD PTR [r12]
  00197	41 80 7c 01 ff
	2f		 cmp	 BYTE PTR [r9+rax-1], 47	; 0000002fH
  0019d	74 22		 je	 SHORT $LN14@uri_to_pat

; 2975 :              hm->uri.ptr[hm->uri.len - 1] != '/') {
; 2976 :     mg_printf(c,

  0019f	44 8b c0	 mov	 r8d, eax
  001a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@NDIFMFHG@HTTP?11?41?5301?5Moved?$AN?6Location?3?5?$CF@
  001a9	48 8b cd	 mov	 rcx, rbp
  001ac	e8 00 00 00 00	 call	 mg_printf

; 2977 :               "HTTP/1.1 301 Moved\r\n"
; 2978 :               "Location: %.*s/\r\n"
; 2979 :               "Content-Length: 0\r\n"
; 2980 :               "\r\n",
; 2981 :               (int) hm->uri.len, hm->uri.ptr);
; 2982 :     c->is_resp = 0;

  001b1	0f ba b5 10 01
	00 00 0f	 btr	 DWORD PTR [rbp+272], 15

; 2983 :     flags = -1;

  001b9	83 cf ff	 or	 edi, -1
  001bc	e9 8a 00 00 00	 jmp	 $LN22@uri_to_pat
$LN14@uri_to_pat:

; 2984 :   } else if (flags & MG_FS_DIR) {
; 2985 :     if (((mg_snprintf(path + n, path_size - n, "/" MG_HTTP_INDEX) > 0 &&
; 2986 :           (tmp = fs->st(path, NULL, NULL)) != 0) ||

  001c1	4c 2b f6	 sub	 r14, rsi
  001c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@LFMFBCIF@?1index?4html@
  001cb	48 03 f3	 add	 rsi, rbx
  001ce	49 8b d6	 mov	 rdx, r14
  001d1	48 8b ce	 mov	 rcx, rsi
  001d4	e8 00 00 00 00	 call	 mg_snprintf
  001d9	48 85 c0	 test	 rax, rax
  001dc	74 10		 je	 SHORT $LN20@uri_to_pat
  001de	45 33 c0	 xor	 r8d, r8d
  001e1	33 d2		 xor	 edx, edx
  001e3	48 8b cb	 mov	 rcx, rbx
  001e6	41 ff 55 00	 call	 QWORD PTR [r13]
  001ea	85 c0		 test	 eax, eax
  001ec	75 27		 jne	 SHORT $LN19@uri_to_pat
$LN20@uri_to_pat:
  001ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@LEPNGMOP@?1index?4shtml@
  001f5	49 8b d6	 mov	 rdx, r14
  001f8	48 8b ce	 mov	 rcx, rsi
  001fb	e8 00 00 00 00	 call	 mg_snprintf
  00200	48 85 c0	 test	 rax, rax
  00203	74 14		 je	 SHORT $LN17@uri_to_pat
  00205	45 33 c0	 xor	 r8d, r8d
  00208	33 d2		 xor	 edx, edx
  0020a	48 8b cb	 mov	 rcx, rbx
  0020d	41 ff 55 00	 call	 QWORD PTR [r13]
  00211	85 c0		 test	 eax, eax
  00213	74 04		 je	 SHORT $LN17@uri_to_pat
$LN19@uri_to_pat:

; 2987 :          (mg_snprintf(path + n, path_size - n, "/index.shtml") > 0 &&
; 2988 :           (tmp = fs->st(path, NULL, NULL)) != 0))) {
; 2989 :       flags = tmp;

  00215	8b f8		 mov	 edi, eax

; 2990 :     } else if ((mg_snprintf(path + n, path_size - n, "/" MG_HTTP_INDEX ".gz") >

  00217	eb 32		 jmp	 SHORT $LN22@uri_to_pat
$LN17@uri_to_pat:

; 2991 :                     0 &&

  00219	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0P@KMKBALOG@?1index?4html?4gz@
  00220	49 8b d6	 mov	 rdx, r14
  00223	48 8b ce	 mov	 rcx, rsi
  00226	e8 00 00 00 00	 call	 mg_snprintf
  0022b	48 85 c0	 test	 rax, rax
  0022e	74 18		 je	 SHORT $LN21@uri_to_pat
  00230	45 33 c0	 xor	 r8d, r8d
  00233	33 d2		 xor	 edx, edx
  00235	48 8b cb	 mov	 rcx, rbx
  00238	41 ff 55 00	 call	 QWORD PTR [r13]
  0023c	85 c0		 test	 eax, eax
  0023e	74 08		 je	 SHORT $LN21@uri_to_pat

; 2992 :                 (tmp = fs->st(path, NULL, NULL)) !=
; 2993 :                     0)) {  // check for gzipped index
; 2994 :       flags = tmp;

  00240	8b f8		 mov	 edi, eax

; 2995 :       path[n + 1 + strlen(MG_HTTP_INDEX)] =

  00242	c6 46 0b 00	 mov	 BYTE PTR [rsi+11], 0

; 2996 :           '\0';  // Remove appended .gz in index file name
; 2997 :     } else {

  00246	eb 03		 jmp	 SHORT $LN22@uri_to_pat
$LN21@uri_to_pat:

; 2998 :       path[n] = '\0';  // Remove appended index file name

  00248	c6 06 00	 mov	 BYTE PTR [rsi], 0
$LN22@uri_to_pat:

; 2999 :     }
; 3000 :   }
; 3001 :   return flags;

  0024b	8b c7		 mov	 eax, edi
$LN1@uri_to_pat:

; 3002 : }

  0024d	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00252	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  00257	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  0025c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00260	41 5f		 pop	 r15
  00262	41 5e		 pop	 r14
  00264	41 5d		 pop	 r13
  00266	41 5c		 pop	 r12
  00268	5f		 pop	 rdi
  00269	c3		 ret	 0
uri_to_path2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT uri_to_path
_TEXT	SEGMENT
k$ = 64
u$ = 80
v$ = 96
s$ = 112
$T1 = 128
$T2 = 128
p$ = 128
$T3 = 144
$T4 = 144
c$ = 240
hm$ = 248
opts$ = 256
path$ = 264
path_size$dead$ = 272
uri_to_path PROC					; COMDAT

; 3006 :                        size_t path_size) {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000f	55		 push	 rbp
  00010	41 54		 push	 r12
  00012	41 56		 push	 r14
  00014	48 8d 68 a9	 lea	 rbp, QWORD PTR [rax-87]
  00018	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H

; 3007 :   struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;

  0001f	49 83 78 28 00	 cmp	 QWORD PTR [r8+40], 0
  00024	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:mg_fs_posix

; 3008 :   struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};

  0002b	4d 8b 10	 mov	 r10, QWORD PTR [r8]
  0002e	49 8b f1	 mov	 rsi, r9
  00031	49 0f 45 78 28	 cmovne	 rdi, QWORD PTR [r8+40]
  00036	48 8b da	 mov	 rbx, rdx
  00039	0f 29 70 d8	 movaps	 XMMWORD PTR [rax-40], xmm6
  0003d	4c 8b f1	 mov	 r14, rcx
  00040	0f 29 78 c8	 movaps	 XMMWORD PTR [rax-56], xmm7
  00044	44 0f 29 40 b8	 movaps	 XMMWORD PTR [rax-72], xmm8

; 7840 :   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};

  00049	4d 85 d2	 test	 r10, r10
  0004c	75 04		 jne	 SHORT $LN20@uri_to_pat
  0004e	33 c0		 xor	 eax, eax
  00050	eb 0e		 jmp	 SHORT $LN21@uri_to_pat
$LN20@uri_to_pat:
  00052	48 83 c8 ff	 or	 rax, -1
$LL28@uri_to_pat:
  00056	48 ff c0	 inc	 rax
  00059	41 80 3c 02 00	 cmp	 BYTE PTR [r10+rax], 0
  0005e	75 f6		 jne	 SHORT $LL28@uri_to_pat
$LN21@uri_to_pat:

; 3008 :   struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};

  00060	48 83 65 bf 00	 and	 QWORD PTR u$[rbp-145], 0

; 7992 :   return mg_split(s, k, v, ',');

  00065	4c 8d 45 cf	 lea	 r8, QWORD PTR v$[rbp-145]

; 3008 :   struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};

  00069	48 83 65 c7 00	 and	 QWORD PTR u$[rbp-137], 0

; 7992 :   return mg_split(s, k, v, ',');

  0006e	48 8d 55 af	 lea	 rdx, QWORD PTR k$[rbp-145]

; 3008 :   struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};

  00072	48 83 65 ef 00	 and	 QWORD PTR p$[rbp-145], 0

; 7992 :   return mg_split(s, k, v, ',');

  00077	48 8d 4d df	 lea	 rcx, QWORD PTR s$[rbp-145]

; 3008 :   struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};

  0007b	48 83 65 f7 00	 and	 QWORD PTR p$[rbp-137], 0

; 7992 :   return mg_split(s, k, v, ',');

  00080	41 b1 2c	 mov	 r9b, 44			; 0000002cH

; 3008 :   struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};

  00083	4c 89 55 df	 mov	 QWORD PTR s$[rbp-145], r10
  00087	48 89 45 e7	 mov	 QWORD PTR s$[rbp-137], rax

; 7992 :   return mg_split(s, k, v, ',');

  0008b	e8 00 00 00 00	 call	 mg_split

; 3009 :   while (mg_commalist(&s, &k, &v)) {

  00090	0f 28 75 ef	 movaps	 xmm6, XMMWORD PTR p$[rbp-145]
  00094	84 c0		 test	 al, al
  00096	0f 84 87 00 00
	00		 je	 $LN3@uri_to_pat

; 3012 :     if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;

  0009c	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:??_C@_01KMDKNFGN@?1@
$LL2@uri_to_pat:

; 3010 :     if (v.len == 0) v = k, k = mg_str("/"), u = k, p = v;

  000a3	48 83 7d d7 00	 cmp	 QWORD PTR v$[rbp-137], 0
  000a8	75 22		 jne	 SHORT $LN29@uri_to_pat
  000aa	0f 28 7d af	 movaps	 xmm7, XMMWORD PTR k$[rbp-145]
  000ae	b9 01 00 00 00	 mov	 ecx, 1
  000b3	0f 29 7d cf	 movaps	 XMMWORD PTR v$[rbp-145], xmm7
  000b7	0f 28 f7	 movaps	 xmm6, xmm7
  000ba	48 89 4d b7	 mov	 QWORD PTR k$[rbp-137], rcx
  000be	48 89 4d c7	 mov	 QWORD PTR u$[rbp-137], rcx
  000c2	4c 89 65 af	 mov	 QWORD PTR k$[rbp-145], r12
  000c6	4c 89 65 bf	 mov	 QWORD PTR u$[rbp-145], r12
  000ca	eb 08		 jmp	 SHORT $LN4@uri_to_pat
$LN29@uri_to_pat:
  000cc	0f 28 7d cf	 movaps	 xmm7, XMMWORD PTR v$[rbp-145]
  000d0	48 8b 4d b7	 mov	 rcx, QWORD PTR k$[rbp-137]
$LN4@uri_to_pat:

; 3011 :     if (hm->uri.len < k.len) continue;

  000d4	48 39 4b 18	 cmp	 QWORD PTR [rbx+24], rcx
  000d8	72 31		 jb	 SHORT $LN25@uri_to_pat

; 3012 :     if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;

  000da	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000de	48 8d 55 ef	 lea	 rdx, QWORD PTR $T2[rbp-145]
  000e2	44 0f 28 45 af	 movaps	 xmm8, XMMWORD PTR k$[rbp-145]
  000e7	48 89 4d f7	 mov	 QWORD PTR $T2[rbp-137], rcx
  000eb	48 8d 4d ff	 lea	 rcx, QWORD PTR $T4[rbp-145]
  000ef	48 89 45 ef	 mov	 QWORD PTR $T2[rbp-145], rax
  000f3	66 44 0f 7f 45
	ff		 movdqa	 XMMWORD PTR $T4[rbp-145], xmm8
  000f9	e8 00 00 00 00	 call	 mg_strcmp
  000fe	85 c0		 test	 eax, eax
  00100	75 09		 jne	 SHORT $LN25@uri_to_pat

; 3013 :     u = k, p = v;

  00102	66 44 0f 7f 45
	bf		 movdqa	 XMMWORD PTR u$[rbp-145], xmm8
  00108	0f 28 f7	 movaps	 xmm6, xmm7
$LN25@uri_to_pat:

; 7992 :   return mg_split(s, k, v, ',');

  0010b	41 b1 2c	 mov	 r9b, 44			; 0000002cH
  0010e	4c 8d 45 cf	 lea	 r8, QWORD PTR v$[rbp-145]
  00112	48 8d 55 af	 lea	 rdx, QWORD PTR k$[rbp-145]
  00116	48 8d 4d df	 lea	 rcx, QWORD PTR s$[rbp-145]
  0011a	e8 00 00 00 00	 call	 mg_split

; 3009 :   while (mg_commalist(&s, &k, &v)) {

  0011f	84 c0		 test	 al, al
  00121	75 80		 jne	 SHORT $LL2@uri_to_pat
$LN3@uri_to_pat:

; 3014 :   }
; 3015 :   return uri_to_path2(c, hm, fs, u, p, path, path_size);

  00123	0f 28 45 bf	 movaps	 xmm0, XMMWORD PTR u$[rbp-145]
  00127	48 8d 45 ff	 lea	 rax, QWORD PTR $T3[rbp-145]
  0012b	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  00130	4c 8d 4d ef	 lea	 r9, QWORD PTR $T1[rbp-145]
  00134	4c 8b c7	 mov	 r8, rdi
  00137	66 0f 7f 45 ef	 movdqa	 XMMWORD PTR $T1[rbp-145], xmm0
  0013c	48 8b d3	 mov	 rdx, rbx
  0013f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00144	49 8b ce	 mov	 rcx, r14
  00147	66 0f 7f 75 ff	 movdqa	 XMMWORD PTR $T3[rbp-145], xmm6
  0014c	e8 00 00 00 00	 call	 uri_to_path2

; 3016 : }

  00151	4c 8d 9c 24 d0
	00 00 00	 lea	 r11, QWORD PTR [rsp+208]
  00159	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  0015d	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  00161	49 8b 7b 30	 mov	 rdi, QWORD PTR [r11+48]
  00165	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  0016a	41 0f 28 7b e0	 movaps	 xmm7, XMMWORD PTR [r11-32]
  0016f	45 0f 28 43 d0	 movaps	 xmm8, XMMWORD PTR [r11-48]
  00174	49 8b e3	 mov	 rsp, r11
  00177	41 5e		 pop	 r14
  00179	41 5c		 pop	 r12
  0017b	5d		 pop	 rbp
  0017c	c3		 ret	 0
uri_to_path ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_serve_dir
_TEXT	SEGMENT
$T1 = 48
$T2 = 64
path$ = 80
c$ = 368
hm$ = 376
opts$ = 384
mg_http_serve_dir PROC					; COMDAT

; 3019 :                        const struct mg_http_serve_opts *opts) {

$LN20:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 60 01
	00 00		 sub	 rsp, 352		; 00000160H

; 3020 :   char path[MG_PATH_MAX];
; 3021 :   const char *sp = opts->ssi_pattern;

  00017	49 8b 58 08	 mov	 rbx, QWORD PTR [r8+8]

; 3022 :   int flags = uri_to_path(c, hm, opts, path, sizeof(path));

  0001b	4c 8d 4c 24 50	 lea	 r9, QWORD PTR path$[rsp]
  00020	49 8b f0	 mov	 rsi, r8
  00023	48 8b ea	 mov	 rbp, rdx
  00026	48 8b f9	 mov	 rdi, rcx
  00029	e8 00 00 00 00	 call	 uri_to_path

; 3023 :   if (flags < 0) {

  0002e	85 c0		 test	 eax, eax
  00030	0f 88 98 00 00
	00		 js	 $LN7@mg_http_se

; 3024 :     // Do nothing: the response has already been sent by uri_to_path()
; 3025 :   } else if (flags & MG_FS_DIR) {

  00036	a8 04		 test	 al, 4
  00038	74 15		 je	 SHORT $LN4@mg_http_se

; 3026 : #if MG_ENABLE_DIRLIST
; 3027 :     listdir(c, hm, opts, path);

  0003a	4c 8d 4c 24 50	 lea	 r9, QWORD PTR path$[rsp]
  0003f	4c 8b c6	 mov	 r8, rsi
  00042	48 8b d5	 mov	 rdx, rbp
  00045	48 8b cf	 mov	 rcx, rdi
  00048	e8 00 00 00 00	 call	 listdir
  0004d	eb 7f		 jmp	 SHORT $LN7@mg_http_se
$LN4@mg_http_se:

; 3028 : #else
; 3029 :     mg_http_reply(c, 403, "", "Forbidden\n");
; 3030 : #endif
; 3031 :   } else if (flags && sp != NULL &&

  0004f	85 c0		 test	 eax, eax
  00051	74 68		 je	 SHORT $LN6@mg_http_se
  00053	48 85 db	 test	 rbx, rbx
  00056	74 63		 je	 SHORT $LN6@mg_http_se
  00058	48 83 c8 ff	 or	 rax, -1

; 7965 :   return mg_match(mg_str_n(s2, n2), mg_str_n(s1, n1), NULL);

  0005c	48 89 5c 24 30	 mov	 QWORD PTR $T1[rsp], rbx

; 3028 : #else
; 3029 :     mg_http_reply(c, 403, "", "Forbidden\n");
; 3030 : #endif
; 3031 :   } else if (flags && sp != NULL &&

  00061	48 8b c8	 mov	 rcx, rax
$LL18@mg_http_se:
  00064	48 ff c1	 inc	 rcx
  00067	80 3c 0b 00	 cmp	 BYTE PTR [rbx+rcx], 0
  0006b	75 f7		 jne	 SHORT $LL18@mg_http_se
  0006d	48 89 4c 24 38	 mov	 QWORD PTR $T1[rsp+8], rcx

; 7965 :   return mg_match(mg_str_n(s2, n2), mg_str_n(s1, n1), NULL);

  00072	48 8d 4c 24 50	 lea	 rcx, QWORD PTR path$[rsp]
  00077	48 89 4c 24 40	 mov	 QWORD PTR $T2[rsp], rcx

; 3028 : #else
; 3029 :     mg_http_reply(c, 403, "", "Forbidden\n");
; 3030 : #endif
; 3031 :   } else if (flags && sp != NULL &&

  0007c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR path$[rsp]
$LL17@mg_http_se:
  00081	48 ff c0	 inc	 rax
  00084	80 3c 01 00	 cmp	 BYTE PTR [rcx+rax], 0
  00088	75 f7		 jne	 SHORT $LL17@mg_http_se

; 7965 :   return mg_match(mg_str_n(s2, n2), mg_str_n(s1, n1), NULL);

  0008a	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]

; 3028 : #else
; 3029 :     mg_http_reply(c, 403, "", "Forbidden\n");
; 3030 : #endif
; 3031 :   } else if (flags && sp != NULL &&

  0008f	48 89 44 24 48	 mov	 QWORD PTR $T2[rsp+8], rax

; 7965 :   return mg_match(mg_str_n(s2, n2), mg_str_n(s1, n1), NULL);

  00094	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  00099	e8 00 00 00 00	 call	 mg_match

; 3028 : #else
; 3029 :     mg_http_reply(c, 403, "", "Forbidden\n");
; 3030 : #endif
; 3031 :   } else if (flags && sp != NULL &&

  0009e	84 c0		 test	 al, al
  000a0	74 19		 je	 SHORT $LN6@mg_http_se

; 7829 :   mg_http_reply(c, 501, NULL, "SSI not enabled");

  000a2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BA@BDBJPBPM@SSI?5not?5enabled@
  000a9	45 33 c0	 xor	 r8d, r8d
  000ac	ba f5 01 00 00	 mov	 edx, 501		; 000001f5H
  000b1	48 8b cf	 mov	 rcx, rdi
  000b4	e8 00 00 00 00	 call	 mg_http_reply

; 3032 :              mg_globmatch(sp, strlen(sp), path, strlen(path))) {
; 3033 :     mg_http_serve_ssi(c, opts->root_dir, path);
; 3034 :   } else {

  000b9	eb 13		 jmp	 SHORT $LN7@mg_http_se
$LN6@mg_http_se:

; 3035 :     mg_http_serve_file(c, hm, path, opts);

  000bb	4c 8b ce	 mov	 r9, rsi
  000be	4c 8d 44 24 50	 lea	 r8, QWORD PTR path$[rsp]
  000c3	48 8b d5	 mov	 rdx, rbp
  000c6	48 8b cf	 mov	 rcx, rdi
  000c9	e8 00 00 00 00	 call	 mg_http_serve_file
$LN7@mg_http_se:

; 3036 :   }
; 3037 : }

  000ce	4c 8d 9c 24 60
	01 00 00	 lea	 r11, QWORD PTR [rsp+352]
  000d6	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000da	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  000de	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  000e2	49 8b e3	 mov	 rsp, r11
  000e5	5f		 pop	 rdi
  000e6	c3		 ret	 0
mg_http_serve_dir ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_is_url_safe
_TEXT	SEGMENT
c$ = 8
mg_is_url_safe PROC					; COMDAT

; 3040 :   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') ||

  00000	8d 41 d3	 lea	 eax, DWORD PTR [rcx-45]
  00003	83 f8 32	 cmp	 eax, 50			; 00000032H
  00006	77 10		 ja	 SHORT $LN8@mg_is_url_
  00008	48 ba fb 1f f0
	ff ff 3f 04 00	 mov	 rdx, 1196268649979899	; 00043ffffff01ffbH
  00012	48 0f a3 c2	 bt	 rdx, rax
  00016	72 10		 jb	 SHORT $LN5@mg_is_url_
$LN8@mg_is_url_:
  00018	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  0001b	83 f8 19	 cmp	 eax, 25
  0001e	76 08		 jbe	 SHORT $LN5@mg_is_url_
  00020	83 f9 7e	 cmp	 ecx, 126		; 0000007eH
  00023	74 03		 je	 SHORT $LN5@mg_is_url_
  00025	32 c0		 xor	 al, al

; 3041 :          (c >= 'A' && c <= 'Z') || c == '.' || c == '_' || c == '-' || c == '~';
; 3042 : }

  00027	c3		 ret	 0
$LN5@mg_is_url_:

; 3040 :   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') ||

  00028	b0 01		 mov	 al, 1

; 3041 :          (c >= 'A' && c <= 'Z') || c == '.' || c == '_' || c == '-' || c == '~';
; 3042 : }

  0002a	c3		 ret	 0
mg_is_url_safe ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_url_encode
_TEXT	SEGMENT
s$ = 48
sl$ = 56
buf$ = 64
len$dead$ = 72
mg_url_encode PROC					; COMDAT

; 3044 : size_t mg_url_encode(const char *s, size_t sl, char *buf, size_t len) {

$LN20:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3045 :   size_t i, n = 0;

  00014	45 33 db	 xor	 r11d, r11d
  00017	49 8b d8	 mov	 rbx, r8
  0001a	48 8b ea	 mov	 rbp, rdx
  0001d	48 8b f1	 mov	 rsi, rcx

; 3046 :   for (i = 0; i < sl; i++) {

  00020	48 85 d2	 test	 rdx, rdx
  00023	74 57		 je	 SHORT $LN18@mg_url_enc
  00025	48 8b f9	 mov	 rdi, rcx
$LL4@mg_url_enc:

; 3047 :     int c = *(unsigned char *) &s[i];
; 3048 :     if (n + 4 >= len) return 0;

  00028	49 8d 43 04	 lea	 rax, QWORD PTR [r11+4]
  0002c	48 3d 04 01 00
	00		 cmp	 rax, 260		; 00000104H
  00032	73 6c		 jae	 SHORT $LN12@mg_url_enc

; 3049 :     if (mg_is_url_safe(c)) {

  00034	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  00037	4d 8d 04 1b	 lea	 r8, QWORD PTR [r11+rbx]
  0003b	49 ff c3	 inc	 r11
  0003e	e8 00 00 00 00	 call	 mg_is_url_safe
  00043	84 c0		 test	 al, al
  00045	74 05		 je	 SHORT $LN6@mg_url_enc

; 3050 :       buf[n++] = s[i];

  00047	41 88 08	 mov	 BYTE PTR [r8], cl

; 3051 :     } else {

  0004a	eb 19		 jmp	 SHORT $LN2@mg_url_enc
$LN6@mg_url_enc:

; 3052 :       buf[n++] = '%';

  0004c	41 c6 00 25	 mov	 BYTE PTR [r8], 37	; 00000025H

; 3053 :       mg_hex(&s[i], 1, &buf[n]);

  00050	ba 01 00 00 00	 mov	 edx, 1
  00055	4d 8d 04 1b	 lea	 r8, QWORD PTR [r11+rbx]
  00059	48 8b cf	 mov	 rcx, rdi
  0005c	e8 00 00 00 00	 call	 mg_hex

; 3054 :       n += 2;

  00061	49 83 c3 02	 add	 r11, 2
$LN2@mg_url_enc:

; 3046 :   for (i = 0; i < sl; i++) {

  00065	48 ff c7	 inc	 rdi
  00068	48 8b c7	 mov	 rax, rdi
  0006b	48 2b c6	 sub	 rax, rsi
  0006e	48 3b c5	 cmp	 rax, rbp
  00071	72 b5		 jb	 SHORT $LL4@mg_url_enc

; 3055 :     }
; 3056 :   }
; 3057 :   if (len > 0 && n < len - 1) buf[n] = '\0';  // Null-terminate the destination

  00073	49 81 fb 03 01
	00 00		 cmp	 r11, 259		; 00000103H
  0007a	73 05		 jae	 SHORT $LN8@mg_url_enc
$LN18@mg_url_enc:
  0007c	41 c6 04 1b 00	 mov	 BYTE PTR [r11+rbx], 0
$LN8@mg_url_enc:

; 3058 :   if (len > 0) buf[len - 1] = '\0';           // Always.

  00081	c6 83 03 01 00
	00 00		 mov	 BYTE PTR [rbx+259], 0

; 3059 :   return n;

  00088	49 8b c3	 mov	 rax, r11
$LN1@mg_url_enc:

; 3060 : }

  0008b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00090	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00095	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5f		 pop	 rdi
  0009f	c3		 ret	 0
$LN12@mg_url_enc:

; 3047 :     int c = *(unsigned char *) &s[i];
; 3048 :     if (n + 4 >= len) return 0;

  000a0	33 c0		 xor	 eax, eax
  000a2	eb e7		 jmp	 SHORT $LN1@mg_url_enc
mg_url_encode ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_creds
_TEXT	SEGMENT
$T1 = 48
t$2 = 48
$T3 = 64
$T4 = 80
buf$5 = 96
hm$ = 384
user$ = 392
userlen$ = 400
pass$ = 408
passlen$ = 416
mg_http_creds PROC					; COMDAT

; 3063 :                    char *pass, size_t passlen) {

$LN17:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000f	55		 push	 rbp
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 8d 68 88	 lea	 rbp, QWORD PTR [rax-120]
  00018	48 81 ec 60 01
	00 00		 sub	 rsp, 352		; 00000160H
  0001f	4c 8b f2	 mov	 r14, rdx
  00022	49 8b d9	 mov	 rbx, r9

; 3064 :   struct mg_str *v = mg_http_get_header(hm, "Authorization");

  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@NAFGPKMI@Authorization@
  0002c	4d 8b f8	 mov	 r15, r8
  0002f	48 8b f9	 mov	 rdi, rcx
  00032	e8 00 00 00 00	 call	 mg_http_get_header

; 3065 :   user[0] = pass[0] = '\0';

  00037	c6 03 00	 mov	 BYTE PTR [rbx], 0
  0003a	4c 8b d0	 mov	 r10, rax
  0003d	41 c6 06 00	 mov	 BYTE PTR [r14], 0

; 3066 :   if (v != NULL && v->len > 6 && memcmp(v->ptr, "Basic ", 6) == 0) {

  00041	48 85 c0	 test	 rax, rax
  00044	0f 84 e9 00 00
	00		 je	 $LN5@mg_http_cr
  0004a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004e	48 83 f8 06	 cmp	 rax, 6
  00052	0f 86 db 00 00
	00		 jbe	 $LN5@mg_http_cr
  00058	49 8b 0a	 mov	 rcx, QWORD PTR [r10]
  0005b	81 39 42 61 73
	69		 cmp	 DWORD PTR [rcx], 1769169218 ; 69736142H
  00061	0f 85 9f 00 00
	00		 jne	 $LN2@mg_http_cr
  00067	66 81 79 04 63
	20		 cmp	 WORD PTR [rcx+4], 8291	; 00002063H
  0006d	0f 85 93 00 00
	00		 jne	 $LN2@mg_http_cr

; 3067 :     char buf[256];
; 3068 :     size_t n = mg_base64_decode(v->ptr + 6, v->len - 6, buf, sizeof(buf));

  00073	48 8d 50 fa	 lea	 rdx, QWORD PTR [rax-6]
  00077	48 83 c1 06	 add	 rcx, 6
  0007b	41 b9 00 01 00
	00		 mov	 r9d, 256		; 00000100H
  00081	4c 8d 44 24 60	 lea	 r8, QWORD PTR buf$5[rsp]
  00086	e8 00 00 00 00	 call	 mg_base64_decode

; 3069 :     const char *p = (const char *) memchr(buf, ':', n > 0 ? n : 0);

  0008b	45 33 c0	 xor	 r8d, r8d
  0008e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buf$5[rsp]
  00093	48 85 c0	 test	 rax, rax
  00096	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  0009b	48 8b f8	 mov	 rdi, rax
  0009e	4c 0f 45 c0	 cmovne	 r8, rax
  000a2	e8 00 00 00 00	 call	 memchr
  000a7	48 8b f0	 mov	 rsi, rax

; 3070 :     if (p != NULL) {

  000aa	48 85 c0	 test	 rax, rax
  000ad	0f 84 15 01 00
	00		 je	 $LN8@mg_http_cr

; 3071 :       mg_snprintf(user, userlen, "%.*s", p - buf, buf);

  000b3	48 8d 44 24 60	 lea	 rax, QWORD PTR buf$5[rsp]
  000b8	4c 8b ce	 mov	 r9, rsi
  000bb	4c 2b c8	 sub	 r9, rax
  000be	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04EBNJJJJI@?$CF?4?$CKs@
  000c5	48 8d 44 24 60	 lea	 rax, QWORD PTR buf$5[rsp]
  000ca	49 8b d7	 mov	 rdx, r15
  000cd	49 8b ce	 mov	 rcx, r14
  000d0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d5	e8 00 00 00 00	 call	 mg_snprintf

; 3072 :       mg_snprintf(pass, passlen, "%.*s", n - (size_t) (p - buf) - 1, p + 1);

  000da	48 8b 95 a0 00
	00 00		 mov	 rdx, QWORD PTR passlen$[rbp-256]
  000e1	48 8d 46 01	 lea	 rax, QWORD PTR [rsi+1]
  000e5	48 2b fe	 sub	 rdi, rsi
  000e8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ed	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04EBNJJJJI@?$CF?4?$CKs@
  000f4	48 8b cb	 mov	 rcx, rbx
  000f7	4c 8d 4c 3c 5f	 lea	 r9, QWORD PTR buf$5[rsp+rdi-1]
  000fc	e8 00 00 00 00	 call	 mg_snprintf

; 3073 :     }

  00101	e9 c2 00 00 00	 jmp	 $LN8@mg_http_cr
$LN2@mg_http_cr:

; 3074 :   } else if (v != NULL && v->len > 7 && memcmp(v->ptr, "Bearer ", 7) == 0) {

  00106	48 83 f8 07	 cmp	 rax, 7
  0010a	76 27		 jbe	 SHORT $LN5@mg_http_cr
  0010c	81 39 42 65 61
	72		 cmp	 DWORD PTR [rcx], 1918985538 ; 72616542H
  00112	48 8b c1	 mov	 rax, rcx
  00115	75 1c		 jne	 SHORT $LN5@mg_http_cr
  00117	66 81 79 04 65
	72		 cmp	 WORD PTR [rcx+4], 29285	; 00007265H
  0011d	75 14		 jne	 SHORT $LN5@mg_http_cr
  0011f	80 79 06 20	 cmp	 BYTE PTR [rcx+6], 32	; 00000020H
  00123	75 0e		 jne	 SHORT $LN5@mg_http_cr

; 3075 :     mg_snprintf(pass, passlen, "%.*s", (int) v->len - 7, v->ptr + 7);

  00125	45 8b 4a 08	 mov	 r9d, DWORD PTR [r10+8]
  00129	48 83 c0 07	 add	 rax, 7
  0012d	41 83 e9 07	 sub	 r9d, 7
  00131	eb 65		 jmp	 SHORT $LN15@mg_http_cr
$LN5@mg_http_cr:

; 3076 :   } else if ((v = mg_http_get_header(hm, "Cookie")) != NULL) {

  00133	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06EGBLANDJ@Cookie@
  0013a	48 8b cf	 mov	 rcx, rdi
  0013d	e8 00 00 00 00	 call	 mg_http_get_header
  00142	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@GOCCFLMF@access_token@
  00149	48 85 c0	 test	 rax, rax
  0014c	74 67		 je	 SHORT $LN7@mg_http_cr

; 3077 :     struct mg_str t = mg_http_get_header_var(*v, mg_str_n("access_token", 12));

  0014e	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00151	48 89 54 24 40	 mov	 QWORD PTR $T3[rsp], rdx
  00156	4c 8d 44 24 40	 lea	 r8, QWORD PTR $T3[rsp]
  0015b	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  00160	48 c7 44 24 48
	0c 00 00 00	 mov	 QWORD PTR $T3[rsp+8], 12
  00169	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T4[rsp]
  0016e	f3 0f 7f 44 24
	30		 movdqu	 XMMWORD PTR $T1[rsp], xmm0
  00174	e8 00 00 00 00	 call	 mg_http_get_header_var
  00179	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0017c	0f 11 44 24 30	 movups	 XMMWORD PTR t$2[rsp], xmm0

; 3078 :     if (t.len > 0) mg_snprintf(pass, passlen, "%.*s", (int) t.len, t.ptr);

  00181	66 0f 73 d8 08	 psrldq	 xmm0, 8
  00186	66 48 0f 7e c1	 movq	 rcx, xmm0
  0018b	48 85 c9	 test	 rcx, rcx
  0018e	74 38		 je	 SHORT $LN8@mg_http_cr
  00190	48 8b 44 24 30	 mov	 rax, QWORD PTR t$2[rsp]
  00195	44 8b c9	 mov	 r9d, ecx
$LN15@mg_http_cr:

; 3081 :   }
; 3082 : }

  00198	48 8b 95 a0 00
	00 00		 mov	 rdx, QWORD PTR passlen$[rbp-256]
  0019f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04EBNJJJJI@?$CF?4?$CKs@
  001a6	48 8b cb	 mov	 rcx, rbx
  001a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ae	e8 00 00 00 00	 call	 mg_snprintf
  001b3	eb 13		 jmp	 SHORT $LN8@mg_http_cr
$LN7@mg_http_cr:

; 3079 :   } else {
; 3080 :     mg_http_get_var(&hm->query, "access_token", pass, passlen);

  001b5	4c 8b 8d a0 00
	00 00		 mov	 r9, QWORD PTR passlen$[rbp-256]
  001bc	48 8d 4f 20	 lea	 rcx, QWORD PTR [rdi+32]
  001c0	4c 8b c3	 mov	 r8, rbx
  001c3	e8 00 00 00 00	 call	 mg_http_get_var
$LN8@mg_http_cr:

; 3081 :   }
; 3082 : }

  001c8	4c 8d 9c 24 60
	01 00 00	 lea	 r11, QWORD PTR [rsp+352]
  001d0	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  001d4	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  001d8	49 8b 7b 30	 mov	 rdi, QWORD PTR [r11+48]
  001dc	49 8b e3	 mov	 rsp, r11
  001df	41 5f		 pop	 r15
  001e1	41 5e		 pop	 r14
  001e3	5d		 pop	 rbp
  001e4	c3		 ret	 0
mg_http_creds ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT stripquotes
_TEXT	SEGMENT
$T1 = 0
__$ReturnAddress$ = 32
s$ = 40
stripquotes PROC					; COMDAT

; 3084 : static struct mg_str stripquotes(struct mg_str s) {

  00000	48 83 ec 18	 sub	 rsp, 24

; 3085 :   return s.len > 1 && s.ptr[0] == '"' && s.ptr[s.len - 1] == '"'

  00004	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00008	49 83 f8 01	 cmp	 r8, 1
  0000c	76 24		 jbe	 SHORT $LN4@stripquote
  0000e	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00011	80 38 22	 cmp	 BYTE PTR [rax], 34	; 00000022H
  00014	75 1c		 jne	 SHORT $LN4@stripquote
  00016	42 80 7c 00 ff
	22		 cmp	 BYTE PTR [rax+r8-1], 34	; 00000022H
  0001c	75 14		 jne	 SHORT $LN4@stripquote
  0001e	48 ff c0	 inc	 rax
  00021	48 8d 14 24	 lea	 rdx, QWORD PTR $T1[rsp]
  00025	48 89 04 24	 mov	 QWORD PTR $T1[rsp], rax
  00029	49 8d 40 fe	 lea	 rax, QWORD PTR [r8-2]
  0002d	48 89 44 24 08	 mov	 QWORD PTR $T1[rsp+8], rax
$LN4@stripquote:
  00032	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  00035	48 8b c1	 mov	 rax, rcx
  00038	f3 0f 7f 01	 movdqu	 XMMWORD PTR [rcx], xmm0

; 3086 :              ? mg_str_n(s.ptr + 1, s.len - 2)
; 3087 :              : s;
; 3088 : }

  0003c	48 83 c4 18	 add	 rsp, 24
  00040	c3		 ret	 0
stripquotes ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_get_header_var
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
__$ReturnAddress$ = 112
s$ = 120
v$ = 128
mg_http_get_header_var PROC				; COMDAT

; 3090 : struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {

$LN44:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 3091 :   size_t i;
; 3092 :   for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {

  0001c	4d 8b 70 08	 mov	 r14, QWORD PTR [r8+8]
  00020	33 ed		 xor	 ebp, ebp
  00022	4d 8b e8	 mov	 r13, r8
  00025	4c 8b fa	 mov	 r15, rdx
  00028	48 8b d9	 mov	 rbx, rcx
  0002b	4d 85 f6	 test	 r14, r14
  0002e	0f 84 cd 00 00
	00		 je	 $LN3@mg_http_ge
  00034	4c 8b 62 08	 mov	 r12, QWORD PTR [rdx+8]
  00038	49 8b fe	 mov	 rdi, r14
$LL4@mg_http_ge:
  0003b	48 8d 47 02	 lea	 rax, QWORD PTR [rdi+2]
  0003f	49 3b c4	 cmp	 rax, r12
  00042	0f 83 b9 00 00
	00		 jae	 $LN3@mg_http_ge

; 3093 :     if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {

  00048	49 8b 37	 mov	 rsi, QWORD PTR [r15]
  0004b	80 3c 37 3d	 cmp	 BYTE PTR [rdi+rsi], 61	; 0000003dH
  0004f	75 14		 jne	 SHORT $LN2@mg_http_ge
  00051	49 8b 55 00	 mov	 rdx, QWORD PTR [r13]
  00055	48 8d 0c 2e	 lea	 rcx, QWORD PTR [rsi+rbp]
  00059	4d 8b c6	 mov	 r8, r14
  0005c	e8 00 00 00 00	 call	 memcmp
  00061	85 c0		 test	 eax, eax
  00063	74 08		 je	 SHORT $LN23@mg_http_ge
$LN2@mg_http_ge:

; 3091 :   size_t i;
; 3092 :   for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {

  00065	48 ff c5	 inc	 rbp
  00068	48 ff c7	 inc	 rdi
  0006b	eb ce		 jmp	 SHORT $LL4@mg_http_ge
$LN23@mg_http_ge:

; 3094 :       const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];

  0006d	49 8d 4e 01	 lea	 rcx, QWORD PTR [r14+1]
  00071	48 03 ce	 add	 rcx, rsi
  00074	4e 8d 04 26	 lea	 r8, QWORD PTR [rsi+r12]
  00078	48 03 cd	 add	 rcx, rbp
  0007b	4c 8b d1	 mov	 r10, rcx
  0007e	4c 8b d9	 mov	 r11, rcx

; 3095 :       int q = p < x && *p == '"' ? 1 : 0;

  00081	49 3b c8	 cmp	 rcx, r8
  00084	73 20		 jae	 SHORT $LN9@mg_http_ge
  00086	80 39 22	 cmp	 BYTE PTR [rcx], 34	; 00000022H
  00089	75 1b		 jne	 SHORT $LN9@mg_http_ge
  0008b	ba 01 00 00 00	 mov	 edx, 1
  00090	44 8b ca	 mov	 r9d, edx
$LL5@mg_http_ge:

; 3096 :       while (p < x &&

  00093	45 85 c9	 test	 r9d, r9d
  00096	74 20		 je	 SHORT $LN15@mg_http_ge
  00098	49 3b ca	 cmp	 rcx, r10
  0009b	74 10		 je	 SHORT $LN31@mg_http_ge
  0009d	80 39 22	 cmp	 BYTE PTR [rcx], 34	; 00000022H
  000a0	75 0b		 jne	 SHORT $LN31@mg_http_ge
  000a2	33 c0		 xor	 eax, eax
  000a4	eb 0c		 jmp	 SHORT $LN14@mg_http_ge
$LN9@mg_http_ge:

; 3095 :       int q = p < x && *p == '"' ? 1 : 0;

  000a6	45 33 c9	 xor	 r9d, r9d
  000a9	33 d2		 xor	 edx, edx
  000ab	eb 27		 jmp	 SHORT $LN41@mg_http_ge
$LN31@mg_http_ge:

; 3096 :       while (p < x &&

  000ad	b8 01 00 00 00	 mov	 eax, 1
$LN14@mg_http_ge:
  000b2	85 c0		 test	 eax, eax
  000b4	74 23		 je	 SHORT $LN6@mg_http_ge
  000b6	eb 19		 jmp	 SHORT $LN32@mg_http_ge
$LN15@mg_http_ge:
  000b8	80 39 3b	 cmp	 BYTE PTR [rcx], 59	; 0000003bH
  000bb	77 14		 ja	 SHORT $LN32@mg_http_ge
  000bd	48 0f be 01	 movsx	 rax, BYTE PTR [rcx]
  000c1	48 bf 00 00 00
	00 01 10 00 08	 mov	 rdi, 576478348784435200	; 0800100100000000H
  000cb	48 0f a3 c7	 bt	 rdi, rax
  000cf	72 08		 jb	 SHORT $LN6@mg_http_ge
$LN32@mg_http_ge:

; 3097 :              (q ? p == b || *p != '"' : *p != ';' && *p != ' ' && *p != ','))
; 3098 :         p++;

  000d1	48 ff c1	 inc	 rcx
$LN41@mg_http_ge:

; 3096 :       while (p < x &&

  000d4	49 3b c8	 cmp	 rcx, r8
  000d7	72 ba		 jb	 SHORT $LL5@mg_http_ge
$LN6@mg_http_ge:

; 3099 :       // MG_INFO(("[%.*s] [%.*s] [%.*s]", (int) s.len, s.ptr, (int) v.len,
; 3100 :       // v.ptr, (int) (p - b), b));
; 3101 :       return stripquotes(mg_str_n(b, (size_t) (p - b + q)));

  000d9	49 2b d2	 sub	 rdx, r10
  000dc	4c 89 5c 24 20	 mov	 QWORD PTR $T1[rsp], r11
  000e1	48 03 d1	 add	 rdx, rcx
  000e4	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  000e9	48 89 54 24 28	 mov	 QWORD PTR $T1[rsp+8], rdx
  000ee	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  000f3	e8 00 00 00 00	 call	 stripquotes
  000f8	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  000fb	f3 0f 7f 03	 movdqu	 XMMWORD PTR [rbx], xmm0
  000ff	eb 09		 jmp	 SHORT $LN42@mg_http_ge
$LN3@mg_http_ge:

; 3102 :     }
; 3103 :   }
; 3104 :   return mg_str_n(NULL, 0);

  00101	48 83 23 00	 and	 QWORD PTR [rbx], 0
  00105	48 83 63 08 00	 and	 QWORD PTR [rbx+8], 0
$LN42@mg_http_ge:

; 3105 : }

  0010a	4c 8d 5c 24 40	 lea	 r11, QWORD PTR [rsp+64]
  0010f	48 8b c3	 mov	 rax, rbx
  00112	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  00116	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  0011a	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  0011e	49 8b e3	 mov	 rsp, r11
  00121	41 5f		 pop	 r15
  00123	41 5e		 pop	 r14
  00125	41 5d		 pop	 r13
  00127	41 5c		 pop	 r12
  00129	5f		 pop	 rdi
  0012a	c3		 ret	 0
mg_http_get_header_var ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_match_uri
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
hm$ = 80
glob$ = 88
mg_http_match_uri PROC					; COMDAT

; 3107 : bool mg_http_match_uri(const struct mg_http_message *hm, const char *glob) {

$LN9:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 7840 :   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};

  00004	33 c0		 xor	 eax, eax

; 3107 : bool mg_http_match_uri(const struct mg_http_message *hm, const char *glob) {

  00006	4c 8b c1	 mov	 r8, rcx

; 7840 :   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};

  00009	48 85 d2	 test	 rdx, rdx
  0000c	74 0f		 je	 SHORT $LN6@mg_http_ma
  0000e	48 83 c9 ff	 or	 rcx, -1
$LL7@mg_http_ma:
  00012	48 ff c1	 inc	 rcx
  00015	38 04 0a	 cmp	 BYTE PTR [rdx+rcx], al
  00018	75 f8		 jne	 SHORT $LL7@mg_http_ma
  0001a	48 8b c1	 mov	 rax, rcx
$LN6@mg_http_ma:

; 3108 :   return mg_match(hm->uri, mg_str(glob), NULL);

  0001d	41 0f 10 40 10	 movups	 xmm0, XMMWORD PTR [r8+16]
  00022	48 89 54 24 20	 mov	 QWORD PTR $T1[rsp], rdx
  00027	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  0002c	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00031	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp+8], rax
  00036	f3 0f 7f 44 24
	30		 movdqu	 XMMWORD PTR $T2[rsp], xmm0
  0003c	e8 00 00 00 00	 call	 mg_match

; 3109 : }

  00041	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00045	c3		 ret	 0
mg_http_match_uri ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_upload
_TEXT	SEGMENT
buf$ = 48
c$ = 128
current_size$1 = 136
hm$ = 136
fs$ = 144
path$ = 152
max_size$ = 160
mg_http_upload PROC					; COMDAT

; 3112 :                     struct mg_fs *fs, const char *path, size_t max_size) {

$LN24:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 55		 push	 r13
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 3113 :   char buf[20] = "0";

  00016	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  0001b	48 8b e9	 mov	 rbp, rcx
  0001e	66 89 44 24 30	 mov	 WORD PTR buf$[rsp], ax

; 3114 :   long res = 0, offset;
; 3115 :   mg_http_get_var(&hm->query, "offset", buf, sizeof(buf));

  00023	48 8d 4a 20	 lea	 rcx, QWORD PTR [rdx+32]
  00027	33 c0		 xor	 eax, eax
  00029	49 8b f9	 mov	 rdi, r9
  0002c	4d 8b f8	 mov	 r15, r8
  0002f	66 89 44 24 42	 mov	 WORD PTR buf$[rsp+18], ax
  00034	4c 8b ea	 mov	 r13, rdx
  00037	4c 8d 44 24 30	 lea	 r8, QWORD PTR buf$[rsp]
  0003c	0f 57 c0	 xorps	 xmm0, xmm0
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06KLHHMIGM@offset@
  00046	44 8d 48 14	 lea	 r9d, QWORD PTR [rax+20]
  0004a	33 db		 xor	 ebx, ebx
  0004c	0f 11 44 24 32	 movups	 XMMWORD PTR buf$[rsp+2], xmm0
  00051	e8 00 00 00 00	 call	 mg_http_get_var

; 3116 :   offset = strtol(buf, NULL, 0);

  00056	45 33 c0	 xor	 r8d, r8d
  00059	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  0005e	33 d2		 xor	 edx, edx
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtol
  00066	48 63 f0	 movsxd	 rsi, eax

; 3117 :   if (hm->body.len == 0) {

  00069	49 39 9d 08 04
	00 00		 cmp	 QWORD PTR [r13+1032], rbx
  00070	0f 84 74 01 00
	00		 je	 $LN22@mg_http_up

; 3118 :     mg_http_reply(c, 200, "", "%ld", res);  // Nothing to write
; 3119 :   } else {
; 3120 :     struct mg_fd *fd;
; 3121 :     size_t current_size = 0;
; 3122 :     MG_DEBUG(("%s -> %d bytes @ %ld", path, (int) hm->body.len, offset));

  00076	8d 4b 03	 lea	 ecx, QWORD PTR [rbx+3]
  00079	48 89 9c 24 88
	00 00 00	 mov	 QWORD PTR current_size$1[rsp], rbx
  00081	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  00087	7c 2b		 jl	 SHORT $LN2@mg_http_up
  00089	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0P@HACFLAGA@mg_http_upload@
  00090	41 b8 32 0c 00
	00		 mov	 r8d, 3122		; 00000c32H
  00096	e8 00 00 00 00	 call	 mg_log_prefix
  0009b	45 8b 85 08 04
	00 00		 mov	 r8d, DWORD PTR [r13+1032]
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@OCKNFKIO@?$CFs?5?9?$DO?5?$CFd?5bytes?5?$EA?5?$CFld@
  000a9	44 8b ce	 mov	 r9d, esi
  000ac	48 8b d7	 mov	 rdx, rdi
  000af	e8 00 00 00 00	 call	 mg_log
$LN2@mg_http_up:

; 3123 :     if (offset == 0) fs->rm(path);  // If offset if 0, truncate file

  000b4	85 f6		 test	 esi, esi
  000b6	75 07		 jne	 SHORT $LN8@mg_http_up
  000b8	48 8b cf	 mov	 rcx, rdi
  000bb	41 ff 57 40	 call	 QWORD PTR [r15+64]
$LN8@mg_http_up:

; 3124 :     fs->st(path, &current_size, NULL);

  000bf	45 33 c0	 xor	 r8d, r8d
  000c2	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR current_size$1[rsp]
  000ca	48 8b cf	 mov	 rcx, rdi
  000cd	41 ff 17	 call	 QWORD PTR [r15]

; 3125 :     if (offset < 0) {

  000d0	85 f6		 test	 esi, esi
  000d2	79 23		 jns	 SHORT $LN9@mg_http_up

; 3126 :       mg_http_reply(c, 400, "", "offset required");

  000d4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BA@ELGKPKEI@offset?5required@
  000db	ba 90 01 00 00	 mov	 edx, 400		; 00000190H
  000e0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@@
  000e7	48 8b cd	 mov	 rcx, rbp
  000ea	e8 00 00 00 00	 call	 mg_http_reply

; 3127 :       res = -1;

  000ef	83 cb ff	 or	 ebx, -1
  000f2	e9 12 01 00 00	 jmp	 $LN16@mg_http_up
$LN9@mg_http_up:

; 3128 :     } else if (offset > 0 && current_size != (size_t) offset) {

  000f7	48 8b ce	 mov	 rcx, rsi
  000fa	85 f6		 test	 esi, esi
  000fc	7e 34		 jle	 SHORT $LN21@mg_http_up
  000fe	48 39 8c 24 88
	00 00 00	 cmp	 QWORD PTR current_size$1[rsp], rcx
  00106	74 2a		 je	 SHORT $LN21@mg_http_up

; 3129 :       mg_http_reply(c, 400, "", "%s: offset mismatch", path);

  00108	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BE@OMMGLANF@?$CFs?3?5offset?5mismatch@
  0010f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00114	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@@
  0011b	ba 90 01 00 00	 mov	 edx, 400		; 00000190H
  00120	48 8b cd	 mov	 rcx, rbp
  00123	e8 00 00 00 00	 call	 mg_http_reply

; 3130 :       res = -2;

  00128	bb fe ff ff ff	 mov	 ebx, -2
  0012d	e9 d7 00 00 00	 jmp	 $LN16@mg_http_up
$LN21@mg_http_up:

; 3131 :     } else if ((size_t) offset + hm->body.len > max_size) {

  00132	49 03 8d 08 04
	00 00		 add	 rcx, QWORD PTR [r13+1032]
  00139	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR max_size$[rsp]
  00141	48 3b c8	 cmp	 rcx, rax
  00144	76 2e		 jbe	 SHORT $LN13@mg_http_up

; 3132 :       mg_http_reply(c, 400, "", "%s: over max size of %lu", path,

  00146	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0014a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BJ@IDGNCELE@?$CFs?3?5over?5max?5size?5of?5?$CFlu@
  00151	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@@
  00158	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0015d	ba 90 01 00 00	 mov	 edx, 400		; 00000190H
  00162	48 8b cd	 mov	 rcx, rbp
  00165	e8 00 00 00 00	 call	 mg_http_reply

; 3133 :                     (unsigned long) max_size);
; 3134 :       res = -3;

  0016a	bb fd ff ff ff	 mov	 ebx, -3
  0016f	e9 95 00 00 00	 jmp	 $LN16@mg_http_up
$LN13@mg_http_up:

; 3135 :     } else if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {

  00174	41 b8 02 00 00
	00		 mov	 r8d, 2
  0017a	48 8b d7	 mov	 rdx, rdi
  0017d	49 8b cf	 mov	 rcx, r15
  00180	e8 00 00 00 00	 call	 mg_fs_open
  00185	4c 8b f0	 mov	 r14, rax
  00188	48 85 c0	 test	 rax, rax
  0018b	75 32		 jne	 SHORT $LN15@mg_http_up

; 3136 :       mg_http_reply(c, 400, "", "open(%s): %d", path, errno);

  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00193	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0N@BCMHMOCL@open?$CI?$CFs?$CJ?3?5?$CFd@
  0019a	ba 90 01 00 00	 mov	 edx, 400		; 00000190H
  0019f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@@
  001a6	8b 08		 mov	 ecx, DWORD PTR [rax]
  001a8	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  001ac	48 8b cd	 mov	 rcx, rbp
  001af	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  001b4	e8 00 00 00 00	 call	 mg_http_reply

; 3137 :       res = -4;

  001b9	41 8d 5e fc	 lea	 ebx, QWORD PTR [r14-4]

; 3138 :     } else {

  001bd	eb 4a		 jmp	 SHORT $LN16@mg_http_up
$LN15@mg_http_up:

; 3139 :       res = offset + (long) fs->wr(fd->fd, hm->body.ptr, hm->body.len);

  001bf	4d 8b 85 08 04
	00 00		 mov	 r8, QWORD PTR [r13+1032]
  001c6	49 8b 95 00 04
	00 00		 mov	 rdx, QWORD PTR [r13+1024]
  001cd	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001d0	41 ff 57 28	 call	 QWORD PTR [r15+40]

; 1612 :     fd->fs->cl(fd->fd);

  001d4	49 8b 56 08	 mov	 rdx, QWORD PTR [r14+8]
  001d8	49 8b 0e	 mov	 rcx, QWORD PTR [r14]

; 3139 :       res = offset + (long) fs->wr(fd->fd, hm->body.ptr, hm->body.len);

  001db	8d 1c 06	 lea	 ebx, DWORD PTR [rsi+rax]

; 1612 :     fd->fs->cl(fd->fd);

  001de	ff 52 18	 call	 QWORD PTR [rdx+24]

; 1613 :     free(fd);

  001e1	49 8b ce	 mov	 rcx, r14
  001e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN22@mg_http_up:

; 3140 :       mg_fs_close(fd);
; 3141 :       mg_http_reply(c, 200, "", "%ld", res);
; 3142 :     }
; 3143 :   }
; 3144 :   return res;

  001ea	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_03JALODAI@?$CFld@
  001f1	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  001f5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@@
  001fc	ba c8 00 00 00	 mov	 edx, 200		; 000000c8H
  00201	48 8b cd	 mov	 rcx, rbp
  00204	e8 00 00 00 00	 call	 mg_http_reply
$LN16@mg_http_up:

; 3145 : }

  00209	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  0020e	8b c3		 mov	 eax, ebx
  00210	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  00214	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  00218	49 8b e3	 mov	 rsp, r11
  0021b	41 5f		 pop	 r15
  0021d	41 5e		 pop	 r14
  0021f	41 5d		 pop	 r13
  00221	5f		 pop	 rdi
  00222	5e		 pop	 rsi
  00223	c3		 ret	 0
mg_http_upload ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_status
_TEXT	SEGMENT
hm$ = 8
mg_http_status PROC					; COMDAT

; 3148 :   return atoi(hm->uri.ptr);

  00000	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00004	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_atoi
mg_http_status ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT is_hex_digit
_TEXT	SEGMENT
c$ = 8
is_hex_digit PROC					; COMDAT

; 3152 :   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||

  00000	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  00003	83 f8 09	 cmp	 eax, 9
  00006	76 13		 jbe	 SHORT $LN5@is_hex_dig
  00008	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  0000b	83 f8 05	 cmp	 eax, 5
  0000e	76 0b		 jbe	 SHORT $LN5@is_hex_dig
  00010	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  00013	83 f8 05	 cmp	 eax, 5
  00016	76 03		 jbe	 SHORT $LN5@is_hex_dig
  00018	32 c0		 xor	 al, al

; 3153 :          (c >= 'A' && c <= 'F');
; 3154 : }

  0001a	c3		 ret	 0
$LN5@is_hex_dig:

; 3152 :   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||

  0001b	b0 01		 mov	 al, 1

; 3153 :          (c >= 'A' && c <= 'F');
; 3154 : }

  0001d	c3		 ret	 0
is_hex_digit ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT skip_chunk
_TEXT	SEGMENT
buf$ = 48
len$ = 56
pl$ = 64
dl$ = 72
skip_chunk PROC						; COMDAT

; 3156 : static int skip_chunk(const char *buf, int len, int *pl, int *dl) {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000f	4c 89 70 20	 mov	 QWORD PTR [rax+32], r14
  00013	41 57		 push	 r15
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	48 63 fa	 movsxd	 rdi, edx

; 3157 :   int i = 0, n = 0;

  0001c	33 db		 xor	 ebx, ebx
  0001e	4d 8b f1	 mov	 r14, r9
  00021	4d 8b f8	 mov	 r15, r8
  00024	48 8b f1	 mov	 rsi, rcx

; 3158 :   if (len < 3) return 0;

  00027	83 ff 03	 cmp	 edi, 3
  0002a	0f 8c 87 00 00
	00		 jl	 $LN29@skip_chunk

; 3159 :   while (i < len && is_hex_digit(buf[i])) i++;

  00030	85 d2		 test	 edx, edx
  00032	74 7e		 je	 SHORT $LN8@skip_chunk
  00034	33 d2		 xor	 edx, edx
$LL2@skip_chunk:
  00036	8a 0c 32	 mov	 cl, BYTE PTR [rdx+rsi]

; 3152 :   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||

  00039	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  0003c	3c 09		 cmp	 al, 9
  0003e	76 0f		 jbe	 SHORT $LN26@skip_chunk
  00040	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  00043	3c 05		 cmp	 al, 5
  00045	76 08		 jbe	 SHORT $LN26@skip_chunk
  00047	80 e9 41	 sub	 cl, 65			; 00000041H
  0004a	80 f9 05	 cmp	 cl, 5
  0004d	77 0a		 ja	 SHORT $LN3@skip_chunk
$LN26@skip_chunk:

; 3159 :   while (i < len && is_hex_digit(buf[i])) i++;

  0004f	ff c3		 inc	 ebx
  00051	48 ff c2	 inc	 rdx
  00054	48 3b d7	 cmp	 rdx, rdi
  00057	7c dd		 jl	 SHORT $LL2@skip_chunk
$LN3@skip_chunk:

; 3160 :   if (i == 0) return -1;                     // Error, no length specified

  00059	85 db		 test	 ebx, ebx
  0005b	74 55		 je	 SHORT $LN8@skip_chunk

; 3161 :   if (i > (int) sizeof(int) * 2) return -1;  // Chunk length is too big

  0005d	83 fb 08	 cmp	 ebx, 8
  00060	7f 50		 jg	 SHORT $LN8@skip_chunk

; 3162 :   if (len < i + 1 || buf[i] != '\r' || buf[i + 1] != '\n') return -1;  // Error

  00062	8d 43 01	 lea	 eax, DWORD PTR [rbx+1]
  00065	3b f8		 cmp	 edi, eax
  00067	7c 49		 jl	 SHORT $LN8@skip_chunk
  00069	48 63 d3	 movsxd	 rdx, ebx
  0006c	80 3c 32 0d	 cmp	 BYTE PTR [rdx+rsi], 13
  00070	75 40		 jne	 SHORT $LN8@skip_chunk
  00072	80 7c 32 01 0a	 cmp	 BYTE PTR [rdx+rsi+1], 10
  00077	75 39		 jne	 SHORT $LN8@skip_chunk

; 3163 :   n = (int) mg_unhexn(buf, (size_t) i);  // Decode chunk length

  00079	48 8b ce	 mov	 rcx, rsi
  0007c	e8 00 00 00 00	 call	 mg_unhexn
  00081	8b d0		 mov	 edx, eax

; 3164 :   if (n < 0) return -1;                  // Error

  00083	85 c0		 test	 eax, eax
  00085	78 2b		 js	 SHORT $LN8@skip_chunk

; 3165 :   if (n > len - i - 4) return 0;         // Chunk not yet fully buffered

  00087	2b fb		 sub	 edi, ebx
  00089	83 ef 04	 sub	 edi, 4
  0008c	3b c7		 cmp	 eax, edi
  0008e	7f 27		 jg	 SHORT $LN29@skip_chunk

; 3166 :   if (buf[i + n + 2] != '\r' || buf[i + n + 3] != '\n') return -1;  // Error

  00090	8d 0c 18	 lea	 ecx, DWORD PTR [rax+rbx]
  00093	48 63 c1	 movsxd	 rax, ecx
  00096	80 7c 30 02 0d	 cmp	 BYTE PTR [rax+rsi+2], 13
  0009b	75 15		 jne	 SHORT $LN8@skip_chunk
  0009d	80 7c 30 03 0a	 cmp	 BYTE PTR [rax+rsi+3], 10
  000a2	75 0e		 jne	 SHORT $LN8@skip_chunk

; 3167 :   *pl = i + 2, *dl = n;

  000a4	8d 43 02	 lea	 eax, DWORD PTR [rbx+2]
  000a7	41 89 16	 mov	 DWORD PTR [r14], edx
  000aa	41 89 07	 mov	 DWORD PTR [r15], eax

; 3168 :   return i + 2 + n + 2;

  000ad	8d 41 04	 lea	 eax, DWORD PTR [rcx+4]
  000b0	eb 07		 jmp	 SHORT $LN1@skip_chunk
$LN8@skip_chunk:

; 3162 :   if (len < i + 1 || buf[i] != '\r' || buf[i + 1] != '\n') return -1;  // Error

  000b2	83 c8 ff	 or	 eax, -1
  000b5	eb 02		 jmp	 SHORT $LN1@skip_chunk
$LN29@skip_chunk:

; 3165 :   if (n > len - i - 4) return 0;         // Chunk not yet fully buffered

  000b7	33 c0		 xor	 eax, eax
$LN1@skip_chunk:

; 3169 : }

  000b9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000be	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000c3	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000c8	4c 8b 74 24 48	 mov	 r14, QWORD PTR [rsp+72]
  000cd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d1	41 5f		 pop	 r15
  000d3	c3		 ret	 0
skip_chunk ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT http_cb
_TEXT	SEGMENT
pl$1 = 32
tv517 = 36
n$1$ = 40
ofs$1$ = 48
s$1$ = 56
hm$2 = 64
c$ = 1200
ev$ = 1208
ev_data$ = 1216
dl$3 = 1224
http_cb	PROC						; COMDAT

; 3171 : static void http_cb(struct mg_connection *c, int ev, void *ev_data) {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 18	 mov	 QWORD PTR [rax+24], rbx
  00007	89 50 10	 mov	 DWORD PTR [rax+16], edx
  0000a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0000e	55		 push	 rbp
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	41 54		 push	 r12
  00013	41 55		 push	 r13
  00015	41 56		 push	 r14
  00017	41 57		 push	 r15
  00019	48 8d a8 58 fc
	ff ff		 lea	 rbp, QWORD PTR [rax-936]
  00020	48 81 ec 70 04
	00 00		 sub	 rsp, 1136		; 00000470H

; 3172 :   if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {

  00027	8d 42 f9	 lea	 eax, DWORD PTR [rdx-7]
  0002a	8b da		 mov	 ebx, edx
  0002c	48 8b f1	 mov	 rsi, rcx
  0002f	a9 fd ff ff ff	 test	 eax, -3			; fffffffdH
  00034	0f 85 45 02 00
	00		 jne	 $LN23@http_cb

; 3173 :     struct mg_http_message hm;
; 3174 :     size_t ofs = 0;  // Parsing offset

  0003a	45 33 f6	 xor	 r14d, r14d

; 3175 : 
; 3176 :     while (c->is_resp == 0 && ofs < c->recv.len) {

  0003d	bf 00 80 00 00	 mov	 edi, 32768		; 00008000H
  00042	4c 89 74 24 30	 mov	 QWORD PTR ofs$1$[rsp], r14
  00047	85 b9 10 01 00
	00		 test	 DWORD PTR [rcx+272], edi
  0004d	0f 85 2c 02 00
	00		 jne	 $LN23@http_cb
$LL2@http_cb:
  00053	48 8b 56 58	 mov	 rdx, QWORD PTR [rsi+88]
  00057	4c 3b f2	 cmp	 r14, rdx
  0005a	0f 83 0c 02 00
	00		 jae	 $LN35@http_cb

; 3177 :       const char *buf = (char *) c->recv.buf + ofs;

  00060	48 8b 4e 48	 mov	 rcx, QWORD PTR [rsi+72]

; 3178 :       int n = mg_http_parse(buf, c->recv.len - ofs, &hm);

  00064	4c 8d 44 24 40	 lea	 r8, QWORD PTR hm$2[rsp]
  00069	49 03 ce	 add	 rcx, r14
  0006c	49 2b d6	 sub	 rdx, r14
  0006f	e8 00 00 00 00	 call	 mg_http_parse
  00074	4c 63 e0	 movsxd	 r12, eax
  00077	44 89 64 24 28	 mov	 DWORD PTR n$1$[rsp], r12d

; 3179 :       struct mg_str *te;  // Transfer - encoding header
; 3180 :       bool is_chunked = false;
; 3181 :       if (n < 0) {

  0007c	85 c0		 test	 eax, eax
  0007e	0f 88 27 02 00
	00		 js	 $LN31@http_cb

; 3185 :       }
; 3186 :       if (n == 0) break;        // Request is not buffered yet

  00084	0f 84 e2 01 00
	00		 je	 $LN35@http_cb

; 3187 :       if (ev == MG_EV_CLOSE) {  // If client did not set Content-Length

  0008a	83 fb 09	 cmp	 ebx, 9
  0008d	75 25		 jne	 SHORT $LN51@http_cb

; 3188 :         hm.message.len = c->recv.len - ofs;  // and closes now, deliver MSG

  0008f	48 8b 5e 58	 mov	 rbx, QWORD PTR [rsi+88]
  00093	49 2b de	 sub	 rbx, r14
  00096	48 89 9d 68 03
	00 00		 mov	 QWORD PTR hm$2[rbp+808], rbx

; 3189 :         hm.body.len = hm.message.len - (size_t) (hm.body.ptr - hm.message.ptr);

  0009d	48 2b 9d 40 03
	00 00		 sub	 rbx, QWORD PTR hm$2[rbp+768]
  000a4	48 03 9d 60 03
	00 00		 add	 rbx, QWORD PTR hm$2[rbp+800]
  000ab	48 89 9d 48 03
	00 00		 mov	 QWORD PTR hm$2[rbp+776], rbx
  000b2	eb 07		 jmp	 SHORT $LN45@http_cb
$LN51@http_cb:

; 3187 :       if (ev == MG_EV_CLOSE) {  // If client did not set Content-Length

  000b4	48 8b 9d 48 03
	00 00		 mov	 rbx, QWORD PTR hm$2[rbp+776]
$LN45@http_cb:

; 3190 :       }
; 3191 :       if ((te = mg_http_get_header(&hm, "Transfer-Encoding")) != NULL) {

  000bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@ELHLFCNH@Transfer?9Encoding@
  000c2	48 8d 4c 24 40	 lea	 rcx, QWORD PTR hm$2[rsp]
  000c7	e8 00 00 00 00	 call	 mg_http_get_header
  000cc	48 85 c0	 test	 rax, rax
  000cf	0f 84 36 01 00
	00		 je	 $LN15@http_cb

; 3192 :         if (mg_vcasecmp(te, "chunked") == 0) {

  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07KCKHAHHI@chunked@
  000dc	48 8b c8	 mov	 rcx, rax
  000df	e8 00 00 00 00	 call	 mg_vcasecmp
  000e4	85 c0		 test	 eax, eax
  000e6	0f 85 ae 01 00
	00		 jne	 $LN14@http_cb

; 3197 :         }
; 3198 :       }
; 3199 : 
; 3200 :       if (is_chunked) {
; 3201 :         // For chunked data, strip off prefixes and suffixes from chunks
; 3202 :         // and relocate them right after the headers, then report a message
; 3203 :         char *s = (char *) c->recv.buf + ofs + n;
; 3204 :         int o = 0, pl, dl, cl, len = (int) (c->recv.len - ofs - (size_t) n);

  000ec	8b 7e 58	 mov	 edi, DWORD PTR [rsi+88]
  000ef	4f 8d 2c 34	 lea	 r13, QWORD PTR [r12+r14]
  000f3	4c 03 6e 48	 add	 r13, QWORD PTR [rsi+72]
  000f7	41 2b fe	 sub	 edi, r14d
  000fa	45 33 ff	 xor	 r15d, r15d
  000fd	4c 89 6c 24 38	 mov	 QWORD PTR s$1$[rsp], r13
  00102	41 2b fc	 sub	 edi, r12d

; 3205 : 
; 3206 :         // Find zero-length chunk (the end of the body)
; 3207 :         while ((cl = skip_chunk(s + o, len - o, &pl, &dl)) > 0 && dl) o += cl;

  00105	49 8b cd	 mov	 rcx, r13
  00108	8b d7		 mov	 edx, edi
  0010a	eb 17		 jmp	 SHORT $LN54@http_cb
$LL4@http_cb:
  0010c	83 bd c8 03 00
	00 00		 cmp	 DWORD PTR dl$3[rbp-256], 0
  00113	74 2f		 je	 SHORT $LN48@http_cb
  00115	44 03 f8	 add	 r15d, eax
  00118	8b d7		 mov	 edx, edi
  0011a	41 2b d7	 sub	 edx, r15d
  0011d	49 63 cf	 movsxd	 rcx, r15d
  00120	49 03 cd	 add	 rcx, r13
$LN54@http_cb:
  00123	4c 8d 8d c8 03
	00 00		 lea	 r9, QWORD PTR dl$3[rbp-256]
  0012a	4c 8d 44 24 20	 lea	 r8, QWORD PTR pl$1[rsp]
  0012f	e8 00 00 00 00	 call	 skip_chunk
  00134	85 c0		 test	 eax, eax
  00136	7f d4		 jg	 SHORT $LL4@http_cb

; 3208 :         if (cl == 0) break;  // No zero-len chunk, buffer more data

  00138	0f 84 2e 01 00
	00		 je	 $LN35@http_cb

; 3209 :         if (cl < 0) {

  0013e	0f 88 19 01 00
	00		 js	 $LN34@http_cb
$LN48@http_cb:

; 3211 :           break;
; 3212 :         }
; 3213 : 
; 3214 :         // Zero chunk found. Second pass: strip + relocate
; 3215 :         o = 0, hm.body.len = 0, hm.message.len = (size_t) n;

  00144	45 33 ff	 xor	 r15d, r15d
  00147	4c 89 a5 68 03
	00 00		 mov	 QWORD PTR hm$2[rbp+808], r12
  0014e	4c 21 bd 48 03
	00 00		 and	 QWORD PTR hm$2[rbp+776], r15

; 3216 :         while ((cl = skip_chunk(s + o, len - o, &pl, &dl)) > 0) {

  00155	4c 8d 8d c8 03
	00 00		 lea	 r9, QWORD PTR dl$3[rbp-256]
  0015c	4c 8d 44 24 20	 lea	 r8, QWORD PTR pl$1[rsp]
  00161	8b d7		 mov	 edx, edi
  00163	49 8b cd	 mov	 rcx, r13
  00166	e8 00 00 00 00	 call	 skip_chunk
  0016b	44 8b e8	 mov	 r13d, eax
  0016e	85 c0		 test	 eax, eax
  00170	0f 8e 84 00 00
	00		 jle	 $LN30@http_cb
  00176	48 8b b5 48 03
	00 00		 mov	 rsi, QWORD PTR hm$2[rbp+776]
  0017d	44 8b e7	 mov	 r12d, edi
  00180	4c 8b 74 24 38	 mov	 r14, QWORD PTR s$1$[rsp]
$LL6@http_cb:

; 3217 :           memmove(s + hm.body.len, s + o + pl, (size_t) dl);

  00185	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR pl$1[rsp]
  0018a	48 63 bd c8 03
	00 00		 movsxd	 rdi, DWORD PTR dl$3[rbp-256]
  00191	49 03 ce	 add	 rcx, r14
  00194	49 63 d7	 movsxd	 rdx, r15d
  00197	4c 8b c7	 mov	 r8, rdi
  0019a	48 03 d1	 add	 rdx, rcx
  0019d	49 8d 0c 36	 lea	 rcx, QWORD PTR [r14+rsi]
  001a1	e8 00 00 00 00	 call	 memmove

; 3218 :           o += cl, hm.body.len += (size_t) dl, hm.message.len += (size_t) dl;

  001a6	48 8b b5 48 03
	00 00		 mov	 rsi, QWORD PTR hm$2[rbp+776]
  001ad	45 03 fd	 add	 r15d, r13d
  001b0	48 01 bd 68 03
	00 00		 add	 QWORD PTR hm$2[rbp+808], rdi
  001b7	48 03 f7	 add	 rsi, rdi
  001ba	48 89 b5 48 03
	00 00		 mov	 QWORD PTR hm$2[rbp+776], rsi

; 3219 :           if (dl == 0) break;

  001c1	85 ff		 test	 edi, edi
  001c3	74 24		 je	 SHORT $LN52@http_cb

; 3216 :         while ((cl = skip_chunk(s + o, len - o, &pl, &dl)) > 0) {

  001c5	41 8b d4	 mov	 edx, r12d
  001c8	49 63 cf	 movsxd	 rcx, r15d
  001cb	41 2b d7	 sub	 edx, r15d
  001ce	4c 8d 8d c8 03
	00 00		 lea	 r9, QWORD PTR dl$3[rbp-256]
  001d5	49 03 ce	 add	 rcx, r14
  001d8	4c 8d 44 24 20	 lea	 r8, QWORD PTR pl$1[rsp]
  001dd	e8 00 00 00 00	 call	 skip_chunk
  001e2	44 8b e8	 mov	 r13d, eax
  001e5	85 c0		 test	 eax, eax
  001e7	7f 9c		 jg	 SHORT $LL6@http_cb
$LN52@http_cb:
  001e9	48 8b b5 b0 03
	00 00		 mov	 rsi, QWORD PTR c$[rbp-256]
  001f0	4c 8b 74 24 30	 mov	 r14, QWORD PTR ofs$1$[rsp]
  001f5	44 8b 64 24 28	 mov	 r12d, DWORD PTR n$1$[rsp]
$LN30@http_cb:

; 3220 :         }
; 3221 :         ofs += (size_t) (n + o);

  001fa	43 8d 04 27	 lea	 eax, DWORD PTR [r15+r12]

; 3222 :       } else {  // Normal, non-chunked data

  001fe	bf 00 80 00 00	 mov	 edi, 32768		; 00008000H
  00203	48 63 c8	 movsxd	 rcx, eax
  00206	4c 03 f1	 add	 r14, rcx
  00209	eb 16		 jmp	 SHORT $LN55@http_cb
$LN15@http_cb:

; 3223 :         size_t len = c->recv.len - ofs - (size_t) n;
; 3224 :         if (hm.body.len > len) break;  // Buffer more data

  0020b	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  0020f	49 2b c4	 sub	 rax, r12
  00212	49 2b c6	 sub	 rax, r14
  00215	48 3b d8	 cmp	 rbx, rax
  00218	77 52		 ja	 SHORT $LN35@http_cb

; 3225 :         ofs += (size_t) n + hm.body.len;

  0021a	49 8d 04 1c	 lea	 rax, QWORD PTR [r12+rbx]
  0021e	4c 03 f0	 add	 r14, rax
$LN55@http_cb:

; 3226 :       }
; 3227 : 
; 3228 :       if (c->is_accepted) c->is_resp = 1;  // Start generating response

  00221	8b 86 10 01 00
	00		 mov	 eax, DWORD PTR [rsi+272]
  00227	4c 89 74 24 30	 mov	 QWORD PTR ofs$1$[rsp], r14
  0022c	a8 04		 test	 al, 4
  0022e	74 08		 je	 SHORT $LN22@http_cb
  00230	0b c7		 or	 eax, edi
  00232	89 86 10 01 00
	00		 mov	 DWORD PTR [rsi+272], eax
$LN22@http_cb:

; 3229 :       mg_call(c, MG_EV_HTTP_MSG, &hm);     // User handler can clear is_resp

  00238	4c 8d 44 24 40	 lea	 r8, QWORD PTR hm$2[rsp]
  0023d	ba 0a 00 00 00	 mov	 edx, 10
  00242	48 8b ce	 mov	 rcx, rsi
  00245	e8 00 00 00 00	 call	 mg_call
  0024a	85 be 10 01 00
	00		 test	 DWORD PTR [rsi+272], edi
  00250	75 1a		 jne	 SHORT $LN35@http_cb

; 3175 : 
; 3176 :     while (c->is_resp == 0 && ofs < c->recv.len) {

  00252	8b 9d b8 03 00
	00		 mov	 ebx, DWORD PTR ev$[rbp-256]
  00258	e9 f6 fd ff ff	 jmp	 $LL2@http_cb
$LN34@http_cb:

; 3210 :           mg_error(c, "Invalid chunk");

  0025d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@HABHDEMH@Invalid?5chunk@
  00264	48 8b ce	 mov	 rcx, rsi
  00267	e8 00 00 00 00	 call	 mg_error
$LN35@http_cb:

; 3230 :     }
; 3231 :     if (ofs > 0) mg_iobuf_del(&c->recv, 0, ofs);  // Delete processed data

  0026c	4d 85 f6	 test	 r14, r14
  0026f	74 0e		 je	 SHORT $LN23@http_cb
  00271	48 8d 4e 48	 lea	 rcx, QWORD PTR [rsi+72]
  00275	4d 8b c6	 mov	 r8, r14
  00278	33 d2		 xor	 edx, edx
  0027a	e8 00 00 00 00	 call	 mg_iobuf_del
$LN23@http_cb:

; 3232 :   }
; 3233 :   (void) ev_data;
; 3234 : }

  0027f	48 8b 9c 24 c0
	04 00 00	 mov	 rbx, QWORD PTR [rsp+1216]
  00287	48 81 c4 70 04
	00 00		 add	 rsp, 1136		; 00000470H
  0028e	41 5f		 pop	 r15
  00290	41 5e		 pop	 r14
  00292	41 5d		 pop	 r13
  00294	41 5c		 pop	 r12
  00296	5f		 pop	 rdi
  00297	5e		 pop	 rsi
  00298	5d		 pop	 rbp
  00299	c3		 ret	 0
$LN14@http_cb:

; 3193 :           is_chunked = true;
; 3194 :         } else {
; 3195 :           mg_error(c, "Invalid Transfer-Encoding");  // See #2460

  0029a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@LOOLINP@Invalid?5Transfer?9Encoding@
  002a1	48 8b ce	 mov	 rcx, rsi
  002a4	e8 00 00 00 00	 call	 mg_error

; 3196 :           return;

  002a9	eb d4		 jmp	 SHORT $LN23@http_cb
$LN31@http_cb:

; 3182 :         mg_error(c, "HTTP parse, %lu bytes", c->recv.len);

  002ab	4c 8b 46 58	 mov	 r8, QWORD PTR [rsi+88]
  002af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@HFEJOELF@HTTP?5parse?0?5?$CFlu?5bytes@
  002b6	48 8b ce	 mov	 rcx, rsi
  002b9	e8 00 00 00 00	 call	 mg_error

; 3183 :         mg_hexdump(c->recv.buf, c->recv.len > 16 ? 16 : c->recv.len);

  002be	48 8b 56 58	 mov	 rdx, QWORD PTR [rsi+88]
  002c2	b8 10 00 00 00	 mov	 eax, 16
  002c7	48 8b 4e 48	 mov	 rcx, QWORD PTR [rsi+72]
  002cb	48 3b d0	 cmp	 rdx, rax
  002ce	48 0f 47 d0	 cmova	 rdx, rax
  002d2	e8 00 00 00 00	 call	 mg_hexdump

; 3184 :         return;

  002d7	eb a6		 jmp	 SHORT $LN23@http_cb
http_cb	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_hfn
_TEXT	SEGMENT
$T1 = 48
c$ = 80
ev$ = 88
ev_data$ = 96
mg_hfn	PROC						; COMDAT

; 3236 : static void mg_hfn(struct mg_connection *c, int ev, void *ev_data) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	49 8b f8	 mov	 rdi, r8
  0000d	48 8b d9	 mov	 rbx, rcx

; 3237 :   if (ev == MG_EV_HTTP_MSG) {

  00010	83 fa 0a	 cmp	 edx, 10
  00013	0f 85 b0 00 00
	00		 jne	 $LN2@mg_hfn

; 3238 :     struct mg_http_message *hm = (struct mg_http_message *) ev_data;
; 3239 :     if (mg_http_match_uri(hm, "/quit")) {

  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CMMBDMDD@?1quit@
  00020	49 8b c8	 mov	 rcx, r8
  00023	e8 00 00 00 00	 call	 mg_http_match_uri
  00028	84 c0		 test	 al, al
  0002a	74 2f		 je	 SHORT $LN4@mg_hfn

; 3240 :       mg_http_reply(c, 200, "", "ok\n");

  0002c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_03DJDALPN@ok?6@
  00033	ba c8 00 00 00	 mov	 edx, 200		; 000000c8H
  00038	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@@
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	e8 00 00 00 00	 call	 mg_http_reply

; 3241 :       c->is_draining = 1;

  00047	0f ba ab 10 01
	00 00 0c	 bts	 DWORD PTR [rbx+272], 12

; 3242 :       c->data[0] = 'X';

  0004f	c6 83 e8 00 00
	00 58		 mov	 BYTE PTR [rbx+232], 88	; 00000058H
  00056	e9 86 00 00 00	 jmp	 $LN9@mg_hfn
$LN4@mg_hfn:

; 3243 :     } else if (mg_http_match_uri(hm, "/debug")) {

  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06HAHILENG@?1debug@
  00062	48 8b cf	 mov	 rcx, rdi
  00065	e8 00 00 00 00	 call	 mg_http_match_uri
  0006a	84 c0		 test	 al, al
  0006c	74 3e		 je	 SHORT $LN6@mg_hfn

; 3244 :       int level = (int) mg_json_get_long(hm->body, "$.level", MG_LL_DEBUG);

  0006e	0f 10 87 00 04
	00 00		 movups	 xmm0, XMMWORD PTR [rdi+1024]
  00075	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  0007a	f3 0f 7f 44 24
	30		 movdqu	 XMMWORD PTR $T1[rsp], xmm0
  00080	e8 00 00 00 00	 call	 mg_json_get_long

; 3245 :       mg_log_set(level);
; 3246 :       mg_http_reply(c, 200, "", "Debug level set to %d\n", level);

  00085	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BH@JNCLOPOB@Debug?5level?5set?5to?5?$CFd?6@
  0008c	89 05 00 00 00
	00		 mov	 DWORD PTR mg_log_level, eax
  00092	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@@
  00099	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0009d	ba c8 00 00 00	 mov	 edx, 200		; 000000c8H
  000a2	48 8b cb	 mov	 rcx, rbx
  000a5	e8 00 00 00 00	 call	 mg_http_reply

; 3247 :     } else {

  000aa	eb 35		 jmp	 SHORT $LN9@mg_hfn
$LN6@mg_hfn:

; 3248 :       mg_http_reply(c, 200, "", "hi\n");

  000ac	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_03JNMAOHCK@hi?6@
  000b3	ba c8 00 00 00	 mov	 edx, 200		; 000000c8H
  000b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@@
  000bf	48 8b cb	 mov	 rcx, rbx
  000c2	e8 00 00 00 00	 call	 mg_http_reply

; 3249 :     }

  000c7	eb 18		 jmp	 SHORT $LN9@mg_hfn
$LN2@mg_hfn:

; 3250 :   } else if (ev == MG_EV_CLOSE) {

  000c9	83 fa 09	 cmp	 edx, 9
  000cc	75 13		 jne	 SHORT $LN9@mg_hfn

; 3251 :     if (c->data[0] == 'X') *(bool *) c->fn_data = true;

  000ce	80 b9 e8 00 00
	00 58		 cmp	 BYTE PTR [rcx+232], 88	; 00000058H
  000d5	75 0a		 jne	 SHORT $LN9@mg_hfn
  000d7	48 8b 81 d0 00
	00 00		 mov	 rax, QWORD PTR [rcx+208]
  000de	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN9@mg_hfn:

; 3252 :   }
; 3253 : }

  000e1	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000e6	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ea	5f		 pop	 rdi
  000eb	c3		 ret	 0
mg_hfn	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_hello
_TEXT	SEGMENT
mgr$ = 32
url$ = 176
done$ = 184
mg_hello PROC						; COMDAT

; 3255 : void mg_hello(const char *url) {

$LN15:
  00000	48 8b c4	 mov	 rax, rsp
  00003	53		 push	 rbx
  00004	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  0000b	48 8b d9	 mov	 rbx, rcx

; 3256 :   struct mg_mgr mgr;
; 3257 :   bool done = false;

  0000e	c6 40 10 00	 mov	 BYTE PTR [rax+16], 0

; 3258 :   mg_mgr_init(&mgr);

  00012	48 8d 4c 24 20	 lea	 rcx, QWORD PTR mgr$[rsp]
  00017	e8 00 00 00 00	 call	 mg_mgr_init

; 3273 :   struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);

  0001c	4c 8d 8c 24 b8
	00 00 00	 lea	 r9, QWORD PTR done$[rsp]
  00024	48 8b d3	 mov	 rdx, rbx
  00027	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:mg_hfn
  0002e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR mgr$[rsp]
  00033	e8 00 00 00 00	 call	 mg_listen

; 3274 :   if (c != NULL) c->pfn = http_cb;

  00038	48 85 c0	 test	 rax, rax
  0003b	74 17		 je	 SHORT $LN13@mg_hello
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:http_cb
  00044	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx

; 3259 :   if (mg_http_listen(&mgr, url, mg_hfn, &done) == NULL) done = true;

  0004b	8a 84 24 b8 00
	00 00		 mov	 al, BYTE PTR done$[rsp]
  00052	eb 09		 jmp	 SHORT $LN9@mg_hello
$LN13@mg_hello:
  00054	b0 01		 mov	 al, 1
  00056	88 84 24 b8 00
	00 00		 mov	 BYTE PTR done$[rsp], al
$LN9@mg_hello:

; 3260 :   while (done == false) mg_mgr_poll(&mgr, 100);

  0005d	84 c0		 test	 al, al
  0005f	75 19		 jne	 SHORT $LN3@mg_hello
$LL2@mg_hello:
  00061	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00066	48 8d 4c 24 20	 lea	 rcx, QWORD PTR mgr$[rsp]
  0006b	e8 00 00 00 00	 call	 mg_mgr_poll
  00070	80 bc 24 b8 00
	00 00 00	 cmp	 BYTE PTR done$[rsp], 0
  00078	74 e7		 je	 SHORT $LL2@mg_hello
$LN3@mg_hello:

; 3261 :   mg_mgr_free(&mgr);

  0007a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR mgr$[rsp]
  0007f	e8 00 00 00 00	 call	 mg_mgr_free

; 3262 : }

  00084	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  0008b	5b		 pop	 rbx
  0008c	c3		 ret	 0
mg_hello ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_connect
_TEXT	SEGMENT
mgr$ = 48
url$ = 56
fn$ = 64
fn_data$ = 72
mg_http_connect PROC					; COMDAT

; 3265 :                                       mg_event_handler_t fn, void *fn_data) {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3266 :   struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);

  00004	e8 00 00 00 00	 call	 mg_connect

; 3267 :   if (c != NULL) c->pfn = http_cb;

  00009	48 85 c0	 test	 rax, rax
  0000c	74 0e		 je	 SHORT $LN2@mg_http_co
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:http_cb
  00015	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx
$LN2@mg_http_co:

; 3268 :   return c;
; 3269 : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
mg_http_connect ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_listen
_TEXT	SEGMENT
mgr$ = 48
url$ = 56
fn$ = 64
fn_data$ = 72
mg_http_listen PROC					; COMDAT

; 3272 :                                      mg_event_handler_t fn, void *fn_data) {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3273 :   struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);

  00004	e8 00 00 00 00	 call	 mg_listen

; 3274 :   if (c != NULL) c->pfn = http_cb;

  00009	48 85 c0	 test	 rax, rax
  0000c	74 0e		 je	 SHORT $LN2@mg_http_li
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:http_cb
  00015	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx
$LN2@mg_http_li:

; 3275 :   return c;
; 3276 : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
mg_http_listen ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT roundup
_TEXT	SEGMENT
size$ = 8
align$ = 16
roundup	PROC						; COMDAT

; 3286 : static size_t roundup(size_t size, size_t align) {

  00000	4c 8b c2	 mov	 r8, rdx

; 3287 :   return align == 0 ? size : (size + align - 1) / align * align;

  00003	48 85 d2	 test	 rdx, rdx
  00006	74 11		 je	 SHORT $LN4@roundup
  00008	48 ff c9	 dec	 rcx
  0000b	48 03 ca	 add	 rcx, rdx
  0000e	33 d2		 xor	 edx, edx
  00010	48 8b c1	 mov	 rax, rcx
  00013	49 f7 f0	 div	 r8
  00016	48 2b ca	 sub	 rcx, rdx
$LN4@roundup:
  00019	48 8b c1	 mov	 rax, rcx

; 3288 : }

  0001c	c3		 ret	 0
roundup	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_iobuf_resize
_TEXT	SEGMENT
io$ = 48
new_size$ = 56
mg_iobuf_resize PROC					; COMDAT

; 3290 : int mg_iobuf_resize(struct mg_iobuf *io, size_t new_size) {

$LN55:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b d9	 mov	 rbx, rcx
  00017	48 8b fa	 mov	 rdi, rdx

; 3291 :   int ok = 1;
; 3292 :   new_size = roundup(new_size, io->align);

  0001a	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0001e	bd 01 00 00 00	 mov	 ebp, 1

; 3287 :   return align == 0 ? size : (size + align - 1) / align * align;

  00023	48 85 c9	 test	 rcx, rcx
  00026	74 11		 je	 SHORT $LN18@mg_iobuf_r
  00028	48 ff cf	 dec	 rdi
  0002b	33 d2		 xor	 edx, edx
  0002d	48 03 f9	 add	 rdi, rcx
  00030	48 8b c7	 mov	 rax, rdi
  00033	48 f7 f1	 div	 rcx
  00036	48 2b fa	 sub	 rdi, rdx
$LN18@mg_iobuf_r:

; 3293 :   if (new_size == 0) {

  00039	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0003d	48 85 ff	 test	 rdi, rdi
  00040	75 34		 jne	 SHORT $LN5@mg_iobuf_r

; 3294 :     mg_bzero(io->buf, io->size);

  00042	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]

; 13758:   if (buf != NULL) {

  00045	48 85 c9	 test	 rcx, rcx
  00048	74 10		 je	 SHORT $LN46@mg_iobuf_r

; 13759:     while (len--) *buf++ = 0;

  0004a	48 85 c0	 test	 rax, rax
  0004d	74 0b		 je	 SHORT $LN46@mg_iobuf_r
$LL35@mg_iobuf_r:
  0004f	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00052	48 ff c1	 inc	 rcx
  00055	48 2b c5	 sub	 rax, rbp
  00058	75 f5		 jne	 SHORT $LL35@mg_iobuf_r
$LN46@mg_iobuf_r:

; 3295 :     free(io->buf);

  0005a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3296 :     io->buf = NULL;

  00063	48 83 23 00	 and	 QWORD PTR [rbx], 0

; 3297 :     io->len = io->size = 0;

  00067	48 83 63 08 00	 and	 QWORD PTR [rbx+8], 0
  0006c	48 83 63 10 00	 and	 QWORD PTR [rbx+16], 0
  00071	e9 a6 00 00 00	 jmp	 $LN3@mg_iobuf_r
$LN5@mg_iobuf_r:

; 3298 :   } else if (new_size != io->size) {

  00076	48 3b f8	 cmp	 rdi, rax
  00079	0f 84 9d 00 00
	00		 je	 $LN3@mg_iobuf_r

; 3299 :     // NOTE(lsm): do not use realloc here. Use calloc/free only, to ease the
; 3300 :     // porting to some obscure platforms like FreeRTOS
; 3301 :     void *p = calloc(1, new_size);

  0007f	48 8b d7	 mov	 rdx, rdi
  00082	48 8b cd	 mov	 rcx, rbp
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0008b	48 8b f0	 mov	 rsi, rax

; 3302 :     if (p != NULL) {

  0008e	48 85 c0	 test	 rax, rax
  00091	74 4f		 je	 SHORT $LN8@mg_iobuf_r

; 3303 :       size_t len = new_size < io->len ? new_size : io->len;
; 3304 :       if (len > 0 && io->buf != NULL) memmove(p, io->buf, len);

  00093	48 3b 7b 10	 cmp	 rdi, QWORD PTR [rbx+16]
  00097	4c 8b c7	 mov	 r8, rdi
  0009a	4c 0f 43 43 10	 cmovae	 r8, QWORD PTR [rbx+16]
  0009f	4d 85 c0	 test	 r8, r8
  000a2	74 10		 je	 SHORT $LN10@mg_iobuf_r
  000a4	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  000a7	48 85 d2	 test	 rdx, rdx
  000aa	74 08		 je	 SHORT $LN10@mg_iobuf_r
  000ac	48 8b c8	 mov	 rcx, rax
  000af	e8 00 00 00 00	 call	 memmove
$LN10@mg_iobuf_r:

; 3305 :       mg_bzero(io->buf, io->size);

  000b4	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000b7	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]

; 13758:   if (buf != NULL) {

  000bb	48 85 c9	 test	 rcx, rcx
  000be	74 10		 je	 SHORT $LN48@mg_iobuf_r

; 13759:     while (len--) *buf++ = 0;

  000c0	48 85 c0	 test	 rax, rax
  000c3	74 0b		 je	 SHORT $LN48@mg_iobuf_r
$LL40@mg_iobuf_r:
  000c5	c6 01 00	 mov	 BYTE PTR [rcx], 0
  000c8	48 ff c1	 inc	 rcx
  000cb	48 2b c5	 sub	 rax, rbp
  000ce	75 f5		 jne	 SHORT $LL40@mg_iobuf_r
$LN48@mg_iobuf_r:

; 3306 :       free(io->buf);

  000d0	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3307 :       io->buf = (unsigned char *) p;

  000d9	48 89 33	 mov	 QWORD PTR [rbx], rsi

; 3308 :       io->size = new_size;

  000dc	48 89 7b 08	 mov	 QWORD PTR [rbx+8], rdi

; 3309 :     } else {

  000e0	eb 3a		 jmp	 SHORT $LN3@mg_iobuf_r
$LN8@mg_iobuf_r:

; 3310 :       ok = 0;

  000e2	33 ed		 xor	 ebp, ebp

; 3311 :       MG_ERROR(("%lld->%lld", (uint64_t) io->size, (uint64_t) new_size));

  000e4	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR mg_log_level, 1
  000eb	7c 2f		 jl	 SHORT $LN3@mg_iobuf_r
  000ed	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BA@HJJGBKFB@mg_iobuf_resize@
  000f4	41 b8 ef 0c 00
	00		 mov	 r8d, 3311		; 00000cefH
  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@NDGBJGCA@C?3?2Users?2dev?2source?2repos?2alpin@
  00101	8d 4d 01	 lea	 ecx, QWORD PTR [rbp+1]
  00104	e8 00 00 00 00	 call	 mg_log_prefix
  00109	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  0010d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@OOAJBPCA@?$CFlld?9?$DO?$CFlld@
  00114	4c 8b c7	 mov	 r8, rdi
  00117	e8 00 00 00 00	 call	 mg_log
$LN3@mg_iobuf_r:

; 3312 :     }
; 3313 :   }
; 3314 :   return ok;
; 3315 : }

  0011c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00121	8b c5		 mov	 eax, ebp
  00123	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00128	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0012d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00131	5f		 pop	 rdi
  00132	c3		 ret	 0
mg_iobuf_resize ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_iobuf_init
_TEXT	SEGMENT
io$ = 8
size$ = 16
align$ = 24
mg_iobuf_init PROC					; COMDAT

; 3318 :   io->buf = NULL;

  00000	33 c0		 xor	 eax, eax

; 3319 :   io->align = align;

  00002	4c 89 41 18	 mov	 QWORD PTR [rcx+24], r8
  00006	48 89 01	 mov	 QWORD PTR [rcx], rax

; 3320 :   io->size = io->len = 0;

  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  0000d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 3321 :   return mg_iobuf_resize(io, size);

  00011	e9 00 00 00 00	 jmp	 mg_iobuf_resize
mg_iobuf_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_iobuf_add
_TEXT	SEGMENT
io$ = 64
ofs$ = 72
buf$ = 80
len$ = 88
mg_iobuf_add PROC					; COMDAT

; 3325 :                     size_t len) {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00018	48 8b d9	 mov	 rbx, rcx
  0001b	4d 8b f9	 mov	 r15, r9

; 3326 :   size_t new_size = roundup(io->len + len, io->align);

  0001e	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00022	4d 8b f0	 mov	 r14, r8
  00025	48 8b f2	 mov	 rsi, rdx
  00028	48 8b 6b 10	 mov	 rbp, QWORD PTR [rbx+16]
  0002c	49 03 e9	 add	 rbp, r9

; 3287 :   return align == 0 ? size : (size + align - 1) / align * align;

  0002f	48 85 c9	 test	 rcx, rcx
  00032	74 11		 je	 SHORT $LN10@mg_iobuf_a
  00034	48 ff cd	 dec	 rbp
  00037	33 d2		 xor	 edx, edx
  00039	48 03 e9	 add	 rbp, rcx
  0003c	48 8b c5	 mov	 rax, rbp
  0003f	48 f7 f1	 div	 rcx
  00042	48 2b ea	 sub	 rbp, rdx
$LN10@mg_iobuf_a:

; 3327 :   mg_iobuf_resize(io, new_size);      // Attempt to resize

  00045	48 8b d5	 mov	 rdx, rbp
  00048	48 8b cb	 mov	 rcx, rbx
  0004b	e8 00 00 00 00	 call	 mg_iobuf_resize

; 3328 :   if (new_size != io->size) len = 0;  // Resize failure, append nothing
; 3329 :   if (ofs < io->len) memmove(io->buf + ofs + len, io->buf + ofs, io->len - ofs);

  00050	4c 8b 43 10	 mov	 r8, QWORD PTR [rbx+16]
  00054	33 ff		 xor	 edi, edi
  00056	48 3b 6b 08	 cmp	 rbp, QWORD PTR [rbx+8]
  0005a	49 0f 44 ff	 cmove	 rdi, r15
  0005e	49 3b f0	 cmp	 rsi, r8
  00061	73 12		 jae	 SHORT $LN3@mg_iobuf_a
  00063	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00066	4c 2b c6	 sub	 r8, rsi
  00069	48 03 d6	 add	 rdx, rsi
  0006c	48 8d 0c 17	 lea	 rcx, QWORD PTR [rdi+rdx]
  00070	e8 00 00 00 00	 call	 memmove
$LN3@mg_iobuf_a:

; 3330 :   if (buf != NULL) memmove(io->buf + ofs, buf, len);

  00075	4d 85 f6	 test	 r14, r14
  00078	74 11		 je	 SHORT $LN4@mg_iobuf_a
  0007a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0007d	4c 8b c7	 mov	 r8, rdi
  00080	48 03 ce	 add	 rcx, rsi
  00083	49 8b d6	 mov	 rdx, r14
  00086	e8 00 00 00 00	 call	 memmove
$LN4@mg_iobuf_a:

; 3331 :   if (ofs > io->len) io->len += ofs - io->len;

  0008b	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]

; 3332 :   io->len += len;
; 3333 :   return len;

  0008f	48 8b c7	 mov	 rax, rdi

; 3334 : }

  00092	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00097	48 3b f1	 cmp	 rsi, rcx
  0009a	48 0f 47 ce	 cmova	 rcx, rsi
  0009e	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000a3	48 03 cf	 add	 rcx, rdi
  000a6	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx
  000aa	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000af	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b3	41 5f		 pop	 r15
  000b5	41 5e		 pop	 r14
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
mg_iobuf_add ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_iobuf_del
_TEXT	SEGMENT
io$ = 48
ofs$ = 56
len$ = 64
mg_iobuf_del PROC					; COMDAT

; 3336 : size_t mg_iobuf_del(struct mg_iobuf *io, size_t ofs, size_t len) {

$LN19:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3337 :   if (ofs > io->len) ofs = io->len;

  0000a	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  0000e	49 8b d8	 mov	 rbx, r8
  00011	49 3b d1	 cmp	 rdx, r9

; 3338 :   if (ofs + len > io->len) len = io->len - ofs;

  00014	4d 8b c1	 mov	 r8, r9
  00017	48 8b f9	 mov	 rdi, rcx
  0001a	49 0f 47 d1	 cmova	 rdx, r9
  0001e	4c 2b c2	 sub	 r8, rdx
  00021	48 8d 04 1a	 lea	 rax, QWORD PTR [rdx+rbx]
  00025	49 3b c1	 cmp	 rax, r9

; 3339 :   if (io->buf) memmove(io->buf + ofs, io->buf + ofs + len, io->len - ofs - len);

  00028	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0002b	49 0f 47 d8	 cmova	 rbx, r8
  0002f	48 85 c0	 test	 rax, rax
  00032	74 14		 je	 SHORT $LN4@mg_iobuf_d
  00034	48 8d 0c 10	 lea	 rcx, QWORD PTR [rax+rdx]
  00038	4c 2b c3	 sub	 r8, rbx
  0003b	48 8d 14 19	 lea	 rdx, QWORD PTR [rcx+rbx]
  0003f	e8 00 00 00 00	 call	 memmove
  00044	4c 8b 4f 10	 mov	 r9, QWORD PTR [rdi+16]
$LN4@mg_iobuf_d:

; 3340 :   if (io->buf) mg_bzero(io->buf + io->len - len, len);

  00048	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0004b	48 85 c9	 test	 rcx, rcx
  0004e	74 1c		 je	 SHORT $LN13@mg_iobuf_d
  00050	48 2b cb	 sub	 rcx, rbx
  00053	48 8b c3	 mov	 rax, rbx
  00056	49 03 c9	 add	 rcx, r9

; 13758:   if (buf != NULL) {

  00059	74 11		 je	 SHORT $LN13@mg_iobuf_d

; 13759:     while (len--) *buf++ = 0;

  0005b	48 85 db	 test	 rbx, rbx
  0005e	74 0c		 je	 SHORT $LN13@mg_iobuf_d
$LL8@mg_iobuf_d:
  00060	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00063	48 ff c1	 inc	 rcx
  00066	48 83 e8 01	 sub	 rax, 1
  0006a	75 f4		 jne	 SHORT $LL8@mg_iobuf_d
$LN13@mg_iobuf_d:

; 3341 :   io->len -= len;

  0006c	48 29 5f 10	 sub	 QWORD PTR [rdi+16], rbx

; 3342 :   return len;

  00070	48 8b c3	 mov	 rax, rbx

; 3343 : }

  00073	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00078	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007c	5f		 pop	 rdi
  0007d	c3		 ret	 0
mg_iobuf_del ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_iobuf_free
_TEXT	SEGMENT
io$ = 8
mg_iobuf_free PROC					; COMDAT

; 3346 :   mg_iobuf_resize(io, 0);

  00000	33 d2		 xor	 edx, edx
  00002	e9 00 00 00 00	 jmp	 mg_iobuf_resize
mg_iobuf_free ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT escapeseq
_TEXT	SEGMENT
esc$ = 8
escapeseq PROC						; COMDAT

; 3357 :   return esc ? "\b\f\n\r\t\\\"" : "bfnrt\\\"";

  00000	85 c9		 test	 ecx, ecx
  00002	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07GIIPGIPO@?$AI?$AM?6?$AN?7?2?$CC@
  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07HHNAIFDF@bfnrt?2?$CC@
  00010	48 0f 45 c2	 cmovne	 rax, rdx

; 3358 : }

  00014	c3		 ret	 0
escapeseq ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT json_esc
_TEXT	SEGMENT
c$ = 8
esc$ = 16
json_esc PROC						; COMDAT

; 3357 :   return esc ? "\b\f\n\r\t\\\"" : "bfnrt\\\"";

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07GIIPGIPO@?$AI?$AM?6?$AN?7?2?$CC@
  00007	85 d2		 test	 edx, edx
  00009	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_07HHNAIFDF@bfnrt?2?$CC@

; 3360 : static char json_esc(int c, int esc) {

  00010	44 8b d1	 mov	 r10d, ecx

; 3357 :   return esc ? "\b\f\n\r\t\\\"" : "bfnrt\\\"";

  00013	4d 8b c1	 mov	 r8, r9
  00016	4c 0f 44 c8	 cmove	 r9, rax
  0001a	4c 0f 45 c0	 cmovne	 r8, rax

; 3361 :   const char *p, *esc1 = escapeseq(esc), *esc2 = escapeseq(!esc);
; 3362 :   for (p = esc1; *p != '\0'; p++) {

  0001e	49 8b c8	 mov	 rcx, r8
  00021	41 8a 00	 mov	 al, BYTE PTR [r8]
  00024	eb 0d		 jmp	 SHORT $LN16@json_esc
$LL4@json_esc:

; 3363 :     if (*p == c) return esc2[p - esc1];

  00026	0f be c0	 movsx	 eax, al
  00029	41 3b c2	 cmp	 eax, r10d
  0002c	74 0a		 je	 SHORT $LN12@json_esc

; 3361 :   const char *p, *esc1 = escapeseq(esc), *esc2 = escapeseq(!esc);
; 3362 :   for (p = esc1; *p != '\0'; p++) {

  0002e	48 ff c1	 inc	 rcx
  00031	8a 01		 mov	 al, BYTE PTR [rcx]
$LN16@json_esc:
  00033	84 c0		 test	 al, al
  00035	75 ef		 jne	 SHORT $LL4@json_esc

; 3364 :   }
; 3365 :   return 0;
; 3366 : }

  00037	c3		 ret	 0
$LN12@json_esc:

; 3363 :     if (*p == c) return esc2[p - esc1];

  00038	49 2b c8	 sub	 rcx, r8
  0003b	42 8a 04 09	 mov	 al, BYTE PTR [rcx+r9]

; 3364 :   }
; 3365 :   return 0;
; 3366 : }

  0003f	c3		 ret	 0
json_esc ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_pass_string
_TEXT	SEGMENT
s$ = 64
len$ = 72
mg_pass_string PROC					; COMDAT

; 3368 : static int mg_pass_string(const char *s, int len) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3369 :   int i;
; 3370 :   for (i = 0; i < len; i++) {

  00018	33 db		 xor	 ebx, ebx
  0001a	48 63 ea	 movsxd	 rbp, edx
  0001d	4c 8b f1	 mov	 r14, rcx
  00020	85 d2		 test	 edx, edx
  00022	7e 3f		 jle	 SHORT $LN3@mg_pass_st
  00024	45 33 db	 xor	 r11d, r11d
$LL4@mg_pass_st:

; 3371 :     if (s[i] == '\\' && i + 1 < len && json_esc(s[i + 1], 1)) {

  00027	43 8a 04 33	 mov	 al, BYTE PTR [r11+r14]
  0002b	3c 5c		 cmp	 al, 92			; 0000005cH
  0002d	75 22		 jne	 SHORT $LN5@mg_pass_st
  0002f	8d 7b 01	 lea	 edi, DWORD PTR [rbx+1]
  00032	3b fd		 cmp	 edi, ebp
  00034	7d 23		 jge	 SHORT $LN2@mg_pass_st
  00036	43 0f be 4c 33
	01		 movsx	 ecx, BYTE PTR [r11+r14+1]
  0003c	ba 01 00 00 00	 mov	 edx, 1
  00041	e8 00 00 00 00	 call	 json_esc
  00046	84 c0		 test	 al, al
  00048	74 0f		 je	 SHORT $LN2@mg_pass_st

; 3372 :       i++;

  0004a	8b df		 mov	 ebx, edi
  0004c	49 ff c3	 inc	 r11
  0004f	eb 08		 jmp	 SHORT $LN2@mg_pass_st
$LN5@mg_pass_st:

; 3373 :     } else if (s[i] == '\0') {

  00051	84 c0		 test	 al, al
  00053	74 0e		 je	 SHORT $LN3@mg_pass_st

; 3374 :       return MG_JSON_INVALID;
; 3375 :     } else if (s[i] == '"') {

  00055	3c 22		 cmp	 al, 34			; 00000022H
  00057	74 28		 je	 SHORT $LN13@mg_pass_st
$LN2@mg_pass_st:

; 3369 :   int i;
; 3370 :   for (i = 0; i < len; i++) {

  00059	ff c3		 inc	 ebx
  0005b	49 ff c3	 inc	 r11
  0005e	4c 3b dd	 cmp	 r11, rbp
  00061	7c c4		 jl	 SHORT $LL4@mg_pass_st
$LN3@mg_pass_st:

; 3377 :     }
; 3378 :   }
; 3379 :   return MG_JSON_INVALID;

  00063	b8 fe ff ff ff	 mov	 eax, -2
$LN1@mg_pass_st:

; 3380 : }

  00068	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0006d	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00072	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00077	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007b	41 5f		 pop	 r15
  0007d	41 5e		 pop	 r14
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
$LN13@mg_pass_st:

; 3376 :       return i;

  00081	8b c3		 mov	 eax, ebx
  00083	eb e3		 jmp	 SHORT $LN1@mg_pass_st
mg_pass_string ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_atod
_TEXT	SEGMENT
p$ = 16
len$ = 24
numlen$ = 32
mg_atod	PROC						; COMDAT

; 3382 : static double mg_atod(const char *p, int len, int *numlen) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi

; 3383 :   double d = 0.0;
; 3384 :   int i = 0, sign = 1;

  0000b	45 33 c9	 xor	 r9d, r9d
  0000e	49 8b f8	 mov	 rdi, r8
  00011	4c 8b d1	 mov	 r10, rcx
  00014	0f 57 e4	 xorps	 xmm4, xmm4
  00017	0f 57 c9	 xorps	 xmm1, xmm1
  0001a	41 8d 71 01	 lea	 esi, QWORD PTR [r9+1]
  0001e	44 8b de	 mov	 r11d, esi

; 3385 : 
; 3386 :   // Sign
; 3387 :   if (i < len && *p == '-') {

  00021	85 d2		 test	 edx, edx
  00023	7e 15		 jle	 SHORT $LN18@mg_atod
  00025	80 39 2d	 cmp	 BYTE PTR [rcx], 45	; 0000002dH
  00028	75 09		 jne	 SHORT $LN46@mg_atod

; 3388 :     sign = -1, i++;

  0002a	41 83 cb ff	 or	 r11d, -1
  0002e	44 8b ce	 mov	 r9d, esi
  00031	eb 07		 jmp	 SHORT $LN18@mg_atod
$LN46@mg_atod:

; 3389 :   } else if (i < len && *p == '+') {

  00033	80 39 2b	 cmp	 BYTE PTR [rcx], 43	; 0000002bH
  00036	44 0f 44 ce	 cmove	 r9d, esi
$LN18@mg_atod:

; 3390 :     i++;
; 3391 :   }
; 3392 : 
; 3393 :   // Decimal
; 3394 :   for (; i < len && p[i] >= '0' && p[i] <= '9'; i++) {

  0003a	f2 0f 10 2d 00
	00 00 00	 movsd	 xmm5, QWORD PTR __real@4024000000000000
  00042	41 8b c9	 mov	 ecx, r9d
  00045	48 63 da	 movsxd	 rbx, edx
  00048	eb 28		 jmp	 SHORT $LN58@mg_atod
$LL4@mg_atod:
  0004a	42 8a 04 11	 mov	 al, BYTE PTR [rcx+r10]
  0004e	2c 30		 sub	 al, 48			; 00000030H
  00050	3c 09		 cmp	 al, 9
  00052	77 23		 ja	 SHORT $LN3@mg_atod

; 3395 :     d *= 10.0;
; 3396 :     d += p[i] - '0';

  00054	42 0f be 04 11	 movsx	 eax, BYTE PTR [rcx+r10]
  00059	44 03 ce	 add	 r9d, esi
  0005c	83 e8 30	 sub	 eax, 48			; 00000030H
  0005f	f2 0f 59 cd	 mulsd	 xmm1, xmm5
  00063	48 03 ce	 add	 rcx, rsi
  00066	66 0f 6e c0	 movd	 xmm0, eax
  0006a	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0006e	f2 0f 58 c8	 addsd	 xmm1, xmm0
$LN58@mg_atod:

; 3390 :     i++;
; 3391 :   }
; 3392 : 
; 3393 :   // Decimal
; 3394 :   for (; i < len && p[i] >= '0' && p[i] <= '9'; i++) {

  00072	48 3b cb	 cmp	 rcx, rbx
  00075	7c d3		 jl	 SHORT $LL4@mg_atod
$LN3@mg_atod:
  00077	66 41 0f 6e d3	 movd	 xmm2, r11d

; 3397 :   }
; 3398 :   d *= sign;

  0007c	f3 0f e6 d2	 cvtdq2pd xmm2, xmm2
  00080	f2 0f 59 ca	 mulsd	 xmm1, xmm2

; 3399 : 
; 3400 :   // Fractional
; 3401 :   if (i < len && p[i] == '.') {

  00084	44 3b ca	 cmp	 r9d, edx
  00087	0f 8d f8 00 00
	00		 jge	 $LN14@mg_atod
  0008d	49 63 c1	 movsxd	 rax, r9d
  00090	42 80 3c 10 2e	 cmp	 BYTE PTR [rax+r10], 46	; 0000002eH
  00095	75 52		 jne	 SHORT $LN53@mg_atod

; 3402 :     double frac = 0.0, base = 0.1;

  00097	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3fb999999999999a

; 3403 :     i++;

  0009f	44 03 ce	 add	 r9d, esi
  000a2	49 63 c9	 movsxd	 rcx, r9d
  000a5	eb 2c		 jmp	 SHORT $LN59@mg_atod
$LL7@mg_atod:

; 3404 :     for (; i < len && p[i] >= '0' && p[i] <= '9'; i++) {

  000a7	42 8a 04 11	 mov	 al, BYTE PTR [rcx+r10]
  000ab	2c 30		 sub	 al, 48			; 00000030H
  000ad	3c 09		 cmp	 al, 9
  000af	77 27		 ja	 SHORT $LN6@mg_atod

; 3405 :       frac += base * (p[i] - '0');

  000b1	42 0f be 04 11	 movsx	 eax, BYTE PTR [rcx+r10]
  000b6	44 03 ce	 add	 r9d, esi
  000b9	83 e8 30	 sub	 eax, 48			; 00000030H
  000bc	48 03 ce	 add	 rcx, rsi
  000bf	66 0f 6e c0	 movd	 xmm0, eax
  000c3	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000c7	f2 0f 59 c3	 mulsd	 xmm0, xmm3

; 3406 :       base /= 10.0;

  000cb	f2 0f 5e dd	 divsd	 xmm3, xmm5
  000cf	f2 0f 58 e0	 addsd	 xmm4, xmm0
$LN59@mg_atod:

; 3404 :     for (; i < len && p[i] >= '0' && p[i] <= '9'; i++) {

  000d3	48 3b cb	 cmp	 rcx, rbx
  000d6	7c cf		 jl	 SHORT $LL7@mg_atod
$LN6@mg_atod:

; 3407 :     }
; 3408 :     d += frac * sign;

  000d8	f2 0f 59 d4	 mulsd	 xmm2, xmm4
  000dc	f2 0f 58 ca	 addsd	 xmm1, xmm2

; 3409 :   }
; 3410 : 
; 3411 :   // Exponential
; 3412 :   if (i < len && (p[i] == 'e' || p[i] == 'E')) {

  000e0	44 3b ca	 cmp	 r9d, edx
  000e3	0f 8d 9c 00 00
	00		 jge	 $LN14@mg_atod
$LN53@mg_atod:
  000e9	49 63 c1	 movsxd	 rax, r9d
  000ec	42 8a 0c 10	 mov	 cl, BYTE PTR [rax+r10]
  000f0	80 e9 45	 sub	 cl, 69			; 00000045H
  000f3	f6 c1 df	 test	 cl, 223			; 000000dfH
  000f6	0f 85 89 00 00
	00		 jne	 $LN14@mg_atod

; 3413 :     int j, exp = 0, minus = 0;

  000fc	33 c9		 xor	 ecx, ecx
  000fe	45 33 c0	 xor	 r8d, r8d

; 3414 :     i++;

  00101	44 03 ce	 add	 r9d, esi

; 3415 :     if (i < len && p[i] == '-') minus = 1, i++;

  00104	44 3b ca	 cmp	 r9d, edx
  00107	7d 22		 jge	 SHORT $LN29@mg_atod
  00109	49 63 c1	 movsxd	 rax, r9d
  0010c	42 80 3c 10 2d	 cmp	 BYTE PTR [rax+r10], 45	; 0000002dH
  00111	75 0b		 jne	 SHORT $LN52@mg_atod
  00113	44 03 ce	 add	 r9d, esi
  00116	44 8b c6	 mov	 r8d, esi

; 3416 :     if (i < len && p[i] == '+') i++;

  00119	44 3b ca	 cmp	 r9d, edx
  0011c	7d 0d		 jge	 SHORT $LN29@mg_atod
$LN52@mg_atod:
  0011e	49 63 c1	 movsxd	 rax, r9d
  00121	42 80 3c 10 2b	 cmp	 BYTE PTR [rax+r10], 43	; 0000002bH
  00126	75 03		 jne	 SHORT $LN29@mg_atod
  00128	44 03 ce	 add	 r9d, esi
$LN29@mg_atod:

; 3417 :     while (i < len && p[i] >= '0' && p[i] <= '9' && exp < 308)

  0012b	49 63 d1	 movsxd	 rdx, r9d
  0012e	eb 26		 jmp	 SHORT $LN61@mg_atod
$LL8@mg_atod:
  00130	42 8a 04 12	 mov	 al, BYTE PTR [rdx+r10]
  00134	2c 30		 sub	 al, 48			; 00000030H
  00136	3c 09		 cmp	 al, 9
  00138	77 21		 ja	 SHORT $LN9@mg_atod
  0013a	81 f9 34 01 00
	00		 cmp	 ecx, 308		; 00000134H
  00140	7d 19		 jge	 SHORT $LN9@mg_atod

; 3418 :       exp = exp * 10 + (p[i++] - '0');

  00142	42 0f be 04 12	 movsx	 eax, BYTE PTR [rdx+r10]
  00147	8d 0c 89	 lea	 ecx, DWORD PTR [rcx+rcx*4]
  0014a	8d 49 e8	 lea	 ecx, DWORD PTR [rcx-24]
  0014d	44 03 ce	 add	 r9d, esi
  00150	48 03 d6	 add	 rdx, rsi
  00153	8d 0c 48	 lea	 ecx, DWORD PTR [rax+rcx*2]
$LN61@mg_atod:

; 3417 :     while (i < len && p[i] >= '0' && p[i] <= '9' && exp < 308)

  00156	48 3b d3	 cmp	 rdx, rbx
  00159	7c d5		 jl	 SHORT $LL8@mg_atod
$LN9@mg_atod:

; 3420 :     for (j = 0; j < exp; j++) d *= 10.0;

  0015b	8b c1		 mov	 eax, ecx
  0015d	f7 d8		 neg	 eax
  0015f	45 85 c0	 test	 r8d, r8d
  00162	0f 44 c1	 cmove	 eax, ecx
  00165	85 c0		 test	 eax, eax
  00167	7e 0b		 jle	 SHORT $LN11@mg_atod

; 3419 :     if (minus) exp = -exp;

  00169	8b c8		 mov	 ecx, eax
$LL37@mg_atod:

; 3420 :     for (j = 0; j < exp; j++) d *= 10.0;

  0016b	f2 0f 59 cd	 mulsd	 xmm1, xmm5
  0016f	48 2b ce	 sub	 rcx, rsi
  00172	75 f7		 jne	 SHORT $LL37@mg_atod
$LN11@mg_atod:

; 3421 :     for (j = 0; j < -exp; j++) d /= 10.0;

  00174	f7 d8		 neg	 eax
  00176	85 c0		 test	 eax, eax
  00178	7e 0b		 jle	 SHORT $LN14@mg_atod
  0017a	8b c8		 mov	 ecx, eax
$LL39@mg_atod:
  0017c	f2 0f 5e cd	 divsd	 xmm1, xmm5
  00180	48 2b ce	 sub	 rcx, rsi
  00183	75 f7		 jne	 SHORT $LL39@mg_atod
$LN14@mg_atod:

; 3422 :   }
; 3423 : 
; 3424 :   if (numlen != NULL) *numlen = i;

  00185	48 85 ff	 test	 rdi, rdi
  00188	74 03		 je	 SHORT $LN25@mg_atod
  0018a	44 89 0f	 mov	 DWORD PTR [rdi], r9d
$LN25@mg_atod:

; 3425 :   return d;
; 3426 : }

  0018d	48 8b 5c 24 10	 mov	 rbx, QWORD PTR [rsp+16]
  00192	0f 28 c1	 movaps	 xmm0, xmm1
  00195	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  0019a	5f		 pop	 rdi
  0019b	c3		 ret	 0
mg_atod	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_json_next
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
sub$3 = 32
obj$ = 112
n$4 = 120
n$5 = 120
ofs$ = 120
key$ = 128
val$ = 136
mg_json_next PROC					; COMDAT

; 3430 :                     struct mg_str *val) {

$LN61:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 55		 push	 r13
  00011	41 56		 push	 r14
  00013	41 57		 push	 r15
  00015	48 8b ec	 mov	 rbp, rsp
  00018	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3431 :   if (ofs >= obj.len) {

  0001c	4c 8b 79 08	 mov	 r15, QWORD PTR [rcx+8]
  00020	4d 8b e1	 mov	 r12, r9
  00023	4d 8b f0	 mov	 r14, r8
  00026	49 3b d7	 cmp	 rdx, r15
  00029	0f 83 b5 01 00
	00		 jae	 $LN10@mg_json_ne

; 3432 :     ofs = 0;  // Out of boundaries, stop scanning
; 3433 :   } else if (obj.len < 2 || (*obj.ptr != '{' && *obj.ptr != '[')) {

  0002f	49 83 ff 02	 cmp	 r15, 2
  00033	0f 82 ab 01 00
	00		 jb	 $LN10@mg_json_ne
  00039	4c 8b 29	 mov	 r13, QWORD PTR [rcx]
  0003c	41 8a 45 00	 mov	 al, BYTE PTR [r13]
  00040	2c 5b		 sub	 al, 91			; 0000005bH
  00042	a8 df		 test	 al, 223			; 000000dfH
  00044	0f 85 9a 01 00
	00		 jne	 $LN10@mg_json_ne

; 3434 :     ofs = 0;  // Not an array or object, stop
; 3435 :   } else {
; 3436 :     struct mg_str sub = mg_str_n(obj.ptr + ofs, obj.len - ofs);

  0004a	49 8b cf	 mov	 rcx, r15
  0004d	4a 8d 1c 2a	 lea	 rbx, QWORD PTR [rdx+r13]
  00051	48 2b ca	 sub	 rcx, rdx
  00054	48 8b c3	 mov	 rax, rbx
  00057	48 8b f9	 mov	 rdi, rcx
  0005a	48 8d 71 ff	 lea	 rsi, QWORD PTR [rcx-1]

; 3437 :     if (ofs == 0) ofs++, sub.ptr++, sub.len--;

  0005e	48 85 d2	 test	 rdx, rdx
  00061	75 0a		 jne	 SHORT $LN55@mg_json_ne
  00063	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
  00067	48 8b fe	 mov	 rdi, rsi
  0006a	48 8b d8	 mov	 rbx, rax
$LN55@mg_json_ne:

; 3438 :     if (*obj.ptr == '[') {  // Iterate over an array

  0006d	48 0f 45 f1	 cmovne	 rsi, rcx
  00071	48 89 45 f0	 mov	 QWORD PTR $T2[rbp-48], rax
  00075	83 65 48 00	 and	 DWORD PTR n$5[rbp-48], 0
  00079	4c 8d 45 48	 lea	 r8, QWORD PTR n$5[rbp-48]
  0007d	41 80 7d 00 5b	 cmp	 BYTE PTR [r13], 91	; 0000005bH
  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$@
  00089	48 89 75 f8	 mov	 QWORD PTR $T2[rbp-40], rsi
  0008d	48 8d 4d f0	 lea	 rcx, QWORD PTR $T2[rbp-48]
  00091	75 3e		 jne	 SHORT $LN12@mg_json_ne

; 3439 :       int n = 0, o = mg_json_get(sub, "$", &n);

  00093	e8 00 00 00 00	 call	 mg_json_get

; 3440 :       if (n < 0 || o < 0 || (size_t) (o + n) > sub.len) {

  00098	48 63 4d 48	 movsxd	 rcx, DWORD PTR n$5[rbp-48]
  0009c	4c 63 c0	 movsxd	 r8, eax
  0009f	85 c9		 test	 ecx, ecx
  000a1	78 27		 js	 SHORT $LN16@mg_json_ne
  000a3	85 c0		 test	 eax, eax
  000a5	78 23		 js	 SHORT $LN16@mg_json_ne
  000a7	41 8d 04 08	 lea	 eax, DWORD PTR [r8+rcx]
  000ab	48 63 d0	 movsxd	 rdx, eax
  000ae	48 3b d6	 cmp	 rdx, rsi
  000b1	77 17		 ja	 SHORT $LN16@mg_json_ne

; 3442 :       } else {
; 3443 :         if (key) *key = mg_str_n(NULL, 0);

  000b3	4d 85 f6	 test	 r14, r14
  000b6	0f 84 c5 00 00
	00		 je	 $LN17@mg_json_ne
  000bc	49 83 26 00	 and	 QWORD PTR [r14], 0
  000c0	49 83 66 08 00	 and	 QWORD PTR [r14+8], 0

; 3444 :         if (val) *val = mg_str_n(sub.ptr + o, (size_t) n);
; 3445 :         ofs = (size_t) (&sub.ptr[o + n] - obj.ptr);

  000c5	e9 b7 00 00 00	 jmp	 $LN17@mg_json_ne
$LN16@mg_json_ne:

; 3441 :         ofs = 0;  // Error parsing key, stop scanning

  000ca	33 d2		 xor	 edx, edx

; 3446 :       }
; 3447 :     } else {  // Iterate over an object

  000cc	e9 c8 00 00 00	 jmp	 $LN43@mg_json_ne
$LN12@mg_json_ne:

; 3448 :       int n = 0, o = mg_json_get(sub, "$", &n);

  000d1	e8 00 00 00 00	 call	 mg_json_get

; 3449 :       if (n < 0 || o < 0 || (size_t) (o + n) > sub.len) {

  000d6	48 63 4d 48	 movsxd	 rcx, DWORD PTR n$4[rbp-48]
  000da	4c 63 c0	 movsxd	 r8, eax
  000dd	85 c9		 test	 ecx, ecx
  000df	0f 88 ff 00 00
	00		 js	 $LN10@mg_json_ne
  000e5	85 c0		 test	 eax, eax
  000e7	0f 88 f7 00 00
	00		 js	 $LN10@mg_json_ne
  000ed	41 8d 04 08	 lea	 eax, DWORD PTR [r8+rcx]
  000f1	48 63 d0	 movsxd	 rdx, eax
  000f4	48 3b d6	 cmp	 rdx, rsi
  000f7	0f 87 e7 00 00
	00		 ja	 $LN10@mg_json_ne

; 3450 :         ofs = 0;  // Error parsing key, stop scanning
; 3451 :       } else {
; 3452 :         if (key) *key = mg_str_n(sub.ptr + o, (size_t) n);

  000fd	4d 85 f6	 test	 r14, r14
  00100	74 0b		 je	 SHORT $LN22@mg_json_ne
  00102	4a 8d 04 03	 lea	 rax, QWORD PTR [rbx+r8]
  00106	49 89 06	 mov	 QWORD PTR [r14], rax
  00109	49 89 4e 08	 mov	 QWORD PTR [r14+8], rcx
$LN22@mg_json_ne:

; 3453 :         sub.ptr += o + n, sub.len -= (size_t) (o + n);

  0010d	48 03 da	 add	 rbx, rdx
  00110	48 2b fa	 sub	 rdi, rdx
  00113	eb 0e		 jmp	 SHORT $LN57@mg_json_ne
$LL2@mg_json_ne:

; 3454 :         while (sub.len > 0 && *sub.ptr != ':') sub.len--, sub.ptr++;

  00115	80 3b 3a	 cmp	 BYTE PTR [rbx], 58	; 0000003aH
  00118	74 13		 je	 SHORT $LN3@mg_json_ne
  0011a	48 ff cf	 dec	 rdi
  0011d	48 ff c3	 inc	 rbx
  00120	48 85 ff	 test	 rdi, rdi
$LN57@mg_json_ne:
  00123	48 89 7d f8	 mov	 QWORD PTR sub$3[rbp-40], rdi
  00127	48 89 5d f0	 mov	 QWORD PTR sub$3[rbp-48], rbx
  0012b	75 e8		 jne	 SHORT $LL2@mg_json_ne
$LN3@mg_json_ne:

; 3455 :         if (sub.len > 0 && *sub.ptr == ':') sub.len--, sub.ptr++;

  0012d	48 85 ff	 test	 rdi, rdi
  00130	74 13		 je	 SHORT $LN23@mg_json_ne
  00132	80 3b 3a	 cmp	 BYTE PTR [rbx], 58	; 0000003aH
  00135	75 0e		 jne	 SHORT $LN23@mg_json_ne
  00137	48 ff cf	 dec	 rdi
  0013a	48 ff c3	 inc	 rbx
  0013d	48 89 7d f8	 mov	 QWORD PTR sub$3[rbp-40], rdi
  00141	48 89 5d f0	 mov	 QWORD PTR sub$3[rbp-48], rbx
$LN23@mg_json_ne:

; 3456 :         n = 0, o = mg_json_get(sub, "$", &n);

  00145	0f 28 45 f0	 movaps	 xmm0, XMMWORD PTR sub$3[rbp-48]
  00149	4c 8d 45 48	 lea	 r8, QWORD PTR n$4[rbp-48]
  0014d	83 65 48 00	 and	 DWORD PTR n$4[rbp-48], 0
  00151	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$@
  00158	48 8d 4d f0	 lea	 rcx, QWORD PTR $T1[rbp-48]
  0015c	66 0f 7f 45 f0	 movdqa	 XMMWORD PTR $T1[rbp-48], xmm0
  00161	e8 00 00 00 00	 call	 mg_json_get

; 3457 :         if (n < 0 || o < 0 || (size_t) (o + n) > sub.len) {

  00166	48 63 4d 48	 movsxd	 rcx, DWORD PTR n$4[rbp-48]
  0016a	4c 63 c0	 movsxd	 r8, eax
  0016d	85 c9		 test	 ecx, ecx
  0016f	78 73		 js	 SHORT $LN10@mg_json_ne
  00171	85 c0		 test	 eax, eax
  00173	78 6f		 js	 SHORT $LN10@mg_json_ne
  00175	41 8d 04 08	 lea	 eax, DWORD PTR [r8+rcx]
  00179	48 63 d0	 movsxd	 rdx, eax
  0017c	48 3b d7	 cmp	 rdx, rdi
  0017f	77 63		 ja	 SHORT $LN10@mg_json_ne
$LN17@mg_json_ne:

; 3458 :           ofs = 0;  // Error parsing value, stop scanning
; 3459 :         } else {
; 3460 :           if (val) *val = mg_str_n(sub.ptr + o, (size_t) n);
; 3461 :           ofs = (size_t) (&sub.ptr[o + n] - obj.ptr);
; 3462 :         }
; 3463 :       }
; 3464 :     }
; 3465 :     //MG_INFO(("SUB ofs %u %.*s", ofs, sub.len, sub.ptr));
; 3466 :     while (ofs && ofs < obj.len &&

  00181	4d 85 e4	 test	 r12, r12
  00184	74 0d		 je	 SHORT $LN27@mg_json_ne
  00186	4a 8d 04 03	 lea	 rax, QWORD PTR [rbx+r8]
  0018a	49 89 04 24	 mov	 QWORD PTR [r12], rax
  0018e	49 89 4c 24 08	 mov	 QWORD PTR [r12+8], rcx
$LN27@mg_json_ne:
  00193	49 2b d5	 sub	 rdx, r13
  00196	48 03 d3	 add	 rdx, rbx
$LN43@mg_json_ne:
  00199	48 85 d2	 test	 rdx, rdx
  0019c	74 41		 je	 SHORT $LN29@mg_json_ne
  0019e	48 8b 4d 40	 mov	 rcx, QWORD PTR obj$[rbp-48]
$LL4@mg_json_ne:
  001a2	49 3b d7	 cmp	 rdx, r15
  001a5	73 3b		 jae	 SHORT $LN59@mg_json_ne
  001a7	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  001aa	80 3c 02 20	 cmp	 BYTE PTR [rdx+rax], 32	; 00000020H
  001ae	77 1b		 ja	 SHORT $LN5@mg_json_ne
  001b0	48 0f be 04 02	 movsx	 rax, BYTE PTR [rdx+rax]
  001b5	49 b8 00 26 00
	00 01 00 00 00	 mov	 r8, 4294977024		; 0000000100002600H
  001bf	49 0f a3 c0	 bt	 r8, rax
  001c3	73 06		 jae	 SHORT $LN5@mg_json_ne

; 3467 :            (obj.ptr[ofs] == ' ' || obj.ptr[ofs] == '\t' ||
; 3468 :             obj.ptr[ofs] == '\n' || obj.ptr[ofs] == '\r')) {
; 3469 :       ofs++;

  001c5	48 83 c2 01	 add	 rdx, 1
  001c9	75 d7		 jne	 SHORT $LL4@mg_json_ne
$LN5@mg_json_ne:

; 3470 :     }
; 3471 :     if (ofs && ofs < obj.len && obj.ptr[ofs] == ',') ofs++;

  001cb	48 85 d2	 test	 rdx, rdx
  001ce	74 0f		 je	 SHORT $LN29@mg_json_ne
  001d0	49 3b d7	 cmp	 rdx, r15
  001d3	73 0d		 jae	 SHORT $LN59@mg_json_ne
  001d5	42 80 3c 2a 2c	 cmp	 BYTE PTR [rdx+r13], 44	; 0000002cH
  001da	75 0a		 jne	 SHORT $LN30@mg_json_ne
  001dc	48 ff c2	 inc	 rdx
$LN29@mg_json_ne:

; 3472 :     if (ofs > obj.len) ofs = 0;

  001df	49 3b d7	 cmp	 rdx, r15
$LN59@mg_json_ne:
  001e2	76 02		 jbe	 SHORT $LN30@mg_json_ne
$LN10@mg_json_ne:

; 3473 :   }
; 3474 :   return ofs;

  001e4	33 d2		 xor	 edx, edx
$LN30@mg_json_ne:

; 3475 : }

  001e6	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  001ee	48 8b c2	 mov	 rax, rdx
  001f1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001f5	41 5f		 pop	 r15
  001f7	41 5e		 pop	 r14
  001f9	41 5d		 pop	 r13
  001fb	41 5c		 pop	 r12
  001fd	5f		 pop	 rdi
  001fe	5e		 pop	 rsi
  001ff	5d		 pop	 rbp
  00200	c3		 ret	 0
mg_json_next ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_json_get
_TEXT	SEGMENT
ed$1$ = 32
numlen$1 = 36
s$1$ = 40
nesting$ = 48
len$1$ = 160
json$ = 160
path$ = 168
ci$1$ = 176
toklen$ = 176
ei$1$ = 184
mg_json_get PROC					; COMDAT

; 3477 : int mg_json_get(struct mg_str json, const char *path, int *toklen) {

$LN150:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3478 :   const char *s = json.ptr;

  00015	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00018	4d 8b f0	 mov	 r14, r8

; 3479 :   int len = (int) json.len;

  0001b	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]

; 3480 :   enum { S_VALUE, S_KEY, S_COLON, S_COMMA_OR_EOO } expecting = S_VALUE;

  0001e	45 33 c0	 xor	 r8d, r8d

; 3481 :   unsigned char nesting[MG_JSON_MAX_DEPTH];
; 3482 :   int i = 0;             // Current offset in `s`
; 3483 :   int j = 0;             // Offset in `s` we're looking for (return value)
; 3484 :   int depth = 0;         // Current depth (nesting level)
; 3485 :   int ed = 0;            // Expected depth
; 3486 :   int pos = 1;           // Current position in `path`
; 3487 :   int ci = -1, ei = -1;  // Current and expected index in array

  00021	83 c9 ff	 or	 ecx, -1
  00024	4c 89 4c 24 28	 mov	 QWORD PTR s$1$[rsp], r9
  00029	33 ff		 xor	 edi, edi
  0002b	89 84 24 a0 00
	00 00		 mov	 DWORD PTR len$1$[rsp], eax
  00032	45 33 ff	 xor	 r15d, r15d
  00035	89 7c 24 20	 mov	 DWORD PTR ed$1$[rsp], edi
  00039	33 ed		 xor	 ebp, ebp
  0003b	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR ci$1$[rsp], ecx
  00042	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR ei$1$[rsp], ecx
  00049	45 8d 68 01	 lea	 r13d, QWORD PTR [r8+1]
  0004d	48 8b f2	 mov	 rsi, rdx
  00050	44 8b d1	 mov	 r10d, ecx
  00053	44 8b d9	 mov	 r11d, ecx

; 3488 : 
; 3489 :   if (toklen) *toklen = 0;

  00056	4d 85 f6	 test	 r14, r14
  00059	74 03		 je	 SHORT $LN31@mg_json_ge
  0005b	41 21 3e	 and	 DWORD PTR [r14], edi
$LN31@mg_json_ge:

; 3490 :   if (path[0] != '$') return MG_JSON_INVALID;

  0005e	80 3a 24	 cmp	 BYTE PTR [rdx], 36	; 00000024H
  00061	0f 85 bb 03 00
	00		 jne	 $LN61@mg_json_ge

; 3491 : 
; 3492 : #define MG_CHECKRET(x)                                  \
; 3493 :   do {                                                  \
; 3494 :     if (depth == ed && path[pos] == '\0' && ci == ei) { \
; 3495 :       if (toklen) *toklen = i - j + 1;                  \
; 3496 :       return j;                                         \
; 3497 :     }                                                   \
; 3498 :   } while (0)
; 3499 : 
; 3500 : // In the ascii table, the distance between `[` and `]` is 2.
; 3501 : // Ditto for `{` and `}`. Hence +2 in the code below.
; 3502 : #define MG_EOO(x)                                            \
; 3503 :   do {                                                       \
; 3504 :     if (depth == ed && ci != ei) return MG_JSON_NOT_FOUND;   \
; 3505 :     if (c != nesting[depth - 1] + 2) return MG_JSON_INVALID; \
; 3506 :     depth--;                                                 \
; 3507 :     MG_CHECKRET(x);                                          \
; 3508 :   } while (0)
; 3509 : 
; 3510 :   for (i = 0; i < len; i++) {

  00067	33 db		 xor	 ebx, ebx
  00069	85 c0		 test	 eax, eax
  0006b	0f 8e 92 04 00
	00		 jle	 $LN138@mg_json_ge
  00071	45 33 e4	 xor	 r12d, r12d
$LL4@mg_json_ge:

; 3511 :     unsigned char c = ((unsigned char *) s)[i];

  00074	48 63 c3	 movsxd	 rax, ebx
  00077	41 8b d7	 mov	 edx, r15d
  0007a	4c 03 c8	 add	 r9, rax

; 3512 :     if (c == ' ' || c == '\t' || c == '\n' || c == '\r') continue;

  0007d	41 80 39 20	 cmp	 BYTE PTR [r9], 32	; 00000020H
  00081	77 18		 ja	 SHORT $LN139@mg_json_ge
  00083	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00087	48 b9 00 26 00
	00 01 00 00 00	 mov	 rcx, 4294977024		; 0000000100002600H
  00091	48 0f a3 c1	 bt	 rcx, rax
  00095	0f 82 34 04 00
	00		 jb	 $LN2@mg_json_ge
$LN139@mg_json_ge:

; 3513 :     switch (expecting) {

  0009b	41 8b c8	 mov	 ecx, r8d
  0009e	45 85 c0	 test	 r8d, r8d
  000a1	0f 84 d5 01 00
	00		 je	 $LN35@mg_json_ge
  000a7	83 e9 01	 sub	 ecx, 1
  000aa	0f 84 ca 00 00
	00		 je	 $LN67@mg_json_ge
  000b0	83 e9 01	 sub	 ecx, 1
  000b3	0f 84 af 00 00
	00		 je	 $LN83@mg_json_ge
  000b9	83 f9 01	 cmp	 ecx, 1
  000bc	0f 85 0d 04 00
	00		 jne	 $LN2@mg_json_ge

; 3598 : 
; 3599 :       case S_COMMA_OR_EOO:
; 3600 :         if (depth <= 0) {

  000c2	4d 85 e4	 test	 r12, r12
  000c5	0f 8e 57 03 00
	00		 jle	 $LN61@mg_json_ge

; 3601 :           return MG_JSON_INVALID;
; 3602 :         } else if (c == ',') {

  000cb	41 80 39 2c	 cmp	 BYTE PTR [r9], 44	; 0000002cH
  000cf	75 12		 jne	 SHORT $LN89@mg_json_ge

; 3603 :           expecting = (nesting[depth - 1] == '{') ? S_KEY : S_VALUE;

  000d1	45 33 c0	 xor	 r8d, r8d
  000d4	42 80 7c 24 2f
	7b		 cmp	 BYTE PTR nesting$[rsp+r12-1], 123 ; 0000007bH
  000da	41 0f 94 c0	 sete	 r8b
  000de	e9 ec 03 00 00	 jmp	 $LN2@mg_json_ge
$LN89@mg_json_ge:

; 3604 :         } else if (c == ']' || c == '}') {

  000e3	41 8a 01	 mov	 al, BYTE PTR [r9]
  000e6	2c 5d		 sub	 al, 93			; 0000005dH
  000e8	a8 df		 test	 al, 223			; 000000dfH
  000ea	0f 85 32 03 00
	00		 jne	 $LN61@mg_json_ge

; 3605 :           if (depth == ed && c == '}' && path[pos - 1] == '.')

  000f0	49 63 d5	 movsxd	 rdx, r13d
  000f3	3b ef		 cmp	 ebp, edi
  000f5	75 27		 jne	 SHORT $LN96@mg_json_ge
  000f7	41 80 39 7d	 cmp	 BYTE PTR [r9], 125	; 0000007dH
  000fb	75 07		 jne	 SHORT $LN133@mg_json_ge
  000fd	80 7c 32 ff 2e	 cmp	 BYTE PTR [rdx+rsi-1], 46 ; 0000002eH
  00102	eb 0b		 jmp	 SHORT $LN146@mg_json_ge
$LN133@mg_json_ge:

; 3606 :             return MG_JSON_NOT_FOUND;
; 3607 :           if (depth == ed && c == ']' && path[pos - 1] == ',')

  00104	41 80 39 5d	 cmp	 BYTE PTR [r9], 93	; 0000005dH
  00108	75 0b		 jne	 SHORT $LN27@mg_json_ge
  0010a	80 7c 16 ff 2c	 cmp	 BYTE PTR [rsi+rdx-1], 44 ; 0000002cH
$LN146@mg_json_ge:

; 3608 :             return MG_JSON_NOT_FOUND;
; 3609 :           MG_EOO('O');

  0010f	0f 84 ee 03 00
	00		 je	 $LN138@mg_json_ge
$LN27@mg_json_ge:
  00115	45 3b d3	 cmp	 r10d, r11d
  00118	0f 85 e5 03 00
	00		 jne	 $LN138@mg_json_ge
$LN96@mg_json_ge:
  0011e	42 0f b6 4c 24
	2f		 movzx	 ecx, BYTE PTR nesting$[rsp+r12-1]
  00124	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00128	83 c1 02	 add	 ecx, 2
  0012b	3b c1		 cmp	 eax, ecx
  0012d	0f 85 ef 02 00
	00		 jne	 $LN61@mg_json_ge
  00133	ff cd		 dec	 ebp
  00135	49 ff cc	 dec	 r12
  00138	3b ef		 cmp	 ebp, edi
  0013a	0f 85 8f 03 00
	00		 jne	 $LN2@mg_json_ge
  00140	80 3c 32 00	 cmp	 BYTE PTR [rdx+rsi], 0
  00144	75 09		 jne	 SHORT $LN28@mg_json_ge
  00146	45 3b d3	 cmp	 r10d, r11d
  00149	0f 84 65 02 00
	00		 je	 $LN123@mg_json_ge
$LN28@mg_json_ge:

; 3491 : 
; 3492 : #define MG_CHECKRET(x)                                  \
; 3493 :   do {                                                  \
; 3494 :     if (depth == ed && path[pos] == '\0' && ci == ei) { \
; 3495 :       if (toklen) *toklen = i - j + 1;                  \
; 3496 :       return j;                                         \
; 3497 :     }                                                   \
; 3498 :   } while (0)
; 3499 : 
; 3500 : // In the ascii table, the distance between `[` and `]` is 2.
; 3501 : // Ditto for `{` and `}`. Hence +2 in the code below.
; 3502 : #define MG_EOO(x)                                            \
; 3503 :   do {                                                       \
; 3504 :     if (depth == ed && ci != ei) return MG_JSON_NOT_FOUND;   \
; 3505 :     if (c != nesting[depth - 1] + 2) return MG_JSON_INVALID; \
; 3506 :     depth--;                                                 \
; 3507 :     MG_CHECKRET(x);                                          \
; 3508 :   } while (0)
; 3509 : 
; 3510 :   for (i = 0; i < len; i++) {

  0014f	45 85 db	 test	 r11d, r11d
  00152	0f 88 77 03 00
	00		 js	 $LN2@mg_json_ge
  00158	41 ff c2	 inc	 r10d
  0015b	44 89 94 24 b0
	00 00 00	 mov	 DWORD PTR ci$1$[rsp], r10d
  00163	e9 67 03 00 00	 jmp	 $LN2@mg_json_ge
$LN83@mg_json_ge:

; 3590 : 
; 3591 :       case S_COLON:
; 3592 :         if (c == ':') {

  00168	41 80 39 3a	 cmp	 BYTE PTR [r9], 58	; 0000003aH
  0016c	0f 85 b0 02 00
	00		 jne	 $LN61@mg_json_ge

; 3593 :           expecting = S_VALUE;

  00172	45 33 c0	 xor	 r8d, r8d

; 3594 :         } else {
; 3595 :           return MG_JSON_INVALID;
; 3596 :         }
; 3597 :         break;

  00175	e9 55 03 00 00	 jmp	 $LN2@mg_json_ge
$LN67@mg_json_ge:

; 3560 :         break;
; 3561 : 
; 3562 :       case S_KEY:
; 3563 :         if (c == '"') {

  0017a	41 80 39 22	 cmp	 BYTE PTR [r9], 34	; 00000022H
  0017e	0f 85 a7 00 00
	00		 jne	 $LN68@mg_json_ge

; 3564 :           int n = mg_pass_string(&s[i + 1], len - i - 1);

  00184	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR len$1$[rsp]
  0018b	8d 43 01	 lea	 eax, DWORD PTR [rbx+1]
  0018e	48 63 f0	 movsxd	 rsi, eax
  00191	2b d3		 sub	 edx, ebx
  00193	48 03 74 24 28	 add	 rsi, QWORD PTR s$1$[rsp]
  00198	ff ca		 dec	 edx
  0019a	48 8b ce	 mov	 rcx, rsi
  0019d	e8 00 00 00 00	 call	 mg_pass_string
  001a2	48 63 f8	 movsxd	 rdi, eax

; 3565 :           if (n < 0) return n;

  001a5	85 c0		 test	 eax, eax
  001a7	0f 88 47 03 00
	00		 js	 $LN110@mg_json_ge

; 3566 :           if (i + 1 + n >= len) return MG_JSON_NOT_FOUND;

  001ad	ff c3		 inc	 ebx
  001af	03 df		 add	 ebx, edi
  001b1	3b 9c 24 a0 00
	00 00		 cmp	 ebx, DWORD PTR len$1$[rsp]
  001b8	0f 8d 45 03 00
	00		 jge	 $LN138@mg_json_ge

; 3567 :           if (depth < ed) return MG_JSON_NOT_FOUND;

  001be	3b 6c 24 20	 cmp	 ebp, DWORD PTR ed$1$[rsp]
  001c2	0f 8c 3b 03 00
	00		 jl	 $LN138@mg_json_ge

; 3568 :           if (depth == ed && path[pos - 1] != '.') return MG_JSON_NOT_FOUND;

  001c8	75 4a		 jne	 SHORT $LN144@mg_json_ge
  001ca	49 63 d5	 movsxd	 rdx, r13d
  001cd	48 03 94 24 a8
	00 00 00	 add	 rdx, QWORD PTR path$[rsp]
  001d5	80 7a ff 2e	 cmp	 BYTE PTR [rdx-1], 46	; 0000002eH
  001d9	0f 85 24 03 00
	00		 jne	 $LN138@mg_json_ge

; 3569 :           // printf("K %s [%.*s] [%.*s] %d %d %d %d %d\n", path, pos, path, n,
; 3570 :           //        &s[i + 1], n, depth, ed, ci, ei);
; 3571 :           //  NOTE(cpq): in the check sequence below is important.
; 3572 :           //  strncmp() must go first: it fails fast if the remaining length
; 3573 :           //  of the path is smaller than `n`.
; 3574 :           if (depth == ed && path[pos - 1] == '.' &&
; 3575 :               strncmp(&s[i + 1], &path[pos], (size_t) n) == 0 &&

  001df	4c 8b c7	 mov	 r8, rdi
  001e2	48 8b ce	 mov	 rcx, rsi
  001e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  001eb	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR path$[rsp]
  001f3	85 c0		 test	 eax, eax
  001f5	75 25		 jne	 SHORT $LN74@mg_json_ge
  001f7	42 8d 14 2f	 lea	 edx, DWORD PTR [rdi+r13]
  001fb	48 63 c2	 movsxd	 rax, edx
  001fe	8a 0c 30	 mov	 cl, BYTE PTR [rax+rsi]
  00201	84 c9		 test	 cl, cl
  00203	74 0a		 je	 SHORT $LN75@mg_json_ge
  00205	80 f9 2e	 cmp	 cl, 46			; 0000002eH
  00208	74 05		 je	 SHORT $LN75@mg_json_ge
  0020a	80 f9 5b	 cmp	 cl, 91			; 0000005bH
  0020d	75 0d		 jne	 SHORT $LN74@mg_json_ge
$LN75@mg_json_ge:

; 3576 :               (path[pos + n] == '\0' || path[pos + n] == '.' ||
; 3577 :                path[pos + n] == '[')) {
; 3578 :             pos += n;

  0020f	44 8b ea	 mov	 r13d, edx
  00212	eb 08		 jmp	 SHORT $LN74@mg_json_ge
$LN144@mg_json_ge:

; 3568 :           if (depth == ed && path[pos - 1] != '.') return MG_JSON_NOT_FOUND;

  00214	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR path$[rsp]
$LN74@mg_json_ge:

; 3579 :           }
; 3580 :           i += n + 1;
; 3581 :           expecting = S_COLON;

  0021c	8b 7c 24 20	 mov	 edi, DWORD PTR ed$1$[rsp]
  00220	41 b8 02 00 00
	00		 mov	 r8d, 2
  00226	e9 a4 02 00 00	 jmp	 $LN2@mg_json_ge
$LN68@mg_json_ge:

; 3582 :         } else if (c == '}') {  // Empty object

  0022b	41 80 39 7d	 cmp	 BYTE PTR [r9], 125	; 0000007dH
  0022f	0f 85 ed 01 00
	00		 jne	 $LN61@mg_json_ge

; 3583 :           MG_EOO('}');

  00235	3b ef		 cmp	 ebp, edi
  00237	75 09		 jne	 SHORT $LN78@mg_json_ge
  00239	45 3b d3	 cmp	 r10d, r11d
  0023c	0f 85 c1 02 00
	00		 jne	 $LN138@mg_json_ge
$LN78@mg_json_ge:
  00242	42 80 7c 24 2f
	7b		 cmp	 BYTE PTR nesting$[rsp+r12-1], 123 ; 0000007bH
  00248	0f 85 d4 01 00
	00		 jne	 $LN61@mg_json_ge
  0024e	ff cd		 dec	 ebp
  00250	49 ff cc	 dec	 r12
  00253	3b ef		 cmp	 ebp, edi
  00255	75 12		 jne	 SHORT $LN22@mg_json_ge
  00257	49 63 c5	 movsxd	 rax, r13d
  0025a	80 3c 30 00	 cmp	 BYTE PTR [rax+rsi], 0
  0025e	75 09		 jne	 SHORT $LN22@mg_json_ge
  00260	45 3b d3	 cmp	 r10d, r11d
  00263	0f 84 4b 01 00
	00		 je	 $LN123@mg_json_ge
$LN22@mg_json_ge:

; 3584 :           expecting = S_COMMA_OR_EOO;

  00269	41 b8 03 00 00
	00		 mov	 r8d, 3

; 3585 :           if (depth == ed && ei >= 0) ci++;

  0026f	3b ef		 cmp	 ebp, edi
  00271	0f 85 58 02 00
	00		 jne	 $LN2@mg_json_ge

; 3586 :         } else {
; 3587 :           return MG_JSON_INVALID;
; 3588 :         }
; 3589 :         break;

  00277	e9 d3 fe ff ff	 jmp	 $LN28@mg_json_ge
$LN35@mg_json_ge:

; 3514 :       case S_VALUE:
; 3515 :         // p("V %s [%.*s] %d %d %d %d\n", path, pos, path, depth, ed, ci, ei);
; 3516 :         if (depth == ed) j = i;
; 3517 :         if (c == '{') {

  0027c	3b ef		 cmp	 ebp, edi
  0027e	44 8b fb	 mov	 r15d, ebx
  00281	44 0f 45 fa	 cmovne	 r15d, edx
  00285	41 80 39 7b	 cmp	 BYTE PTR [r9], 123	; 0000007bH
  00289	75 4c		 jne	 SHORT $LN37@mg_json_ge

; 3518 :           if (depth >= (int) sizeof(nesting)) return MG_JSON_TOO_DEEP;

  0028b	49 83 fc 1e	 cmp	 r12, 30
  0028f	0f 8d 66 02 00
	00		 jge	 $LN118@mg_json_ge

; 3519 :           if (depth == ed && path[pos] == '.' && ci == ei) {

  00295	3b ef		 cmp	 ebp, edi
  00297	75 28		 jne	 SHORT $LN40@mg_json_ge
  00299	49 63 c5	 movsxd	 rax, r13d
  0029c	80 3c 30 2e	 cmp	 BYTE PTR [rax+rsi], 46	; 0000002eH
  002a0	75 1f		 jne	 SHORT $LN40@mg_json_ge
  002a2	45 3b d3	 cmp	 r10d, r11d
  002a5	75 1a		 jne	 SHORT $LN40@mg_json_ge

; 3520 :             // If we start the object, reset array indices
; 3521 :             ed++, pos++, ci = ei = -1;

  002a7	ff c7		 inc	 edi
  002a9	41 ff c5	 inc	 r13d
  002ac	83 c8 ff	 or	 eax, -1
  002af	89 7c 24 20	 mov	 DWORD PTR ed$1$[rsp], edi
  002b3	89 84 24 b8 00
	00 00		 mov	 DWORD PTR ei$1$[rsp], eax
  002ba	89 84 24 b0 00
	00 00		 mov	 DWORD PTR ci$1$[rsp], eax
$LN40@mg_json_ge:

; 3522 :           }
; 3523 :           nesting[depth++] = c;

  002c1	ff c5		 inc	 ebp
  002c3	42 c6 44 24 30
	7b		 mov	 BYTE PTR nesting$[rsp+r12], 123 ; 0000007bH
  002c9	49 ff c4	 inc	 r12

; 3524 :           expecting = S_KEY;

  002cc	41 b8 01 00 00
	00		 mov	 r8d, 1

; 3525 :           break;

  002d2	e9 f8 01 00 00	 jmp	 $LN2@mg_json_ge
$LN37@mg_json_ge:

; 3526 :         } else if (c == '[') {

  002d7	41 80 39 5b	 cmp	 BYTE PTR [r9], 91	; 0000005bH
  002db	0f 85 88 00 00
	00		 jne	 $LN41@mg_json_ge

; 3527 :           if (depth >= (int) sizeof(nesting)) return MG_JSON_TOO_DEEP;

  002e1	49 83 fc 1e	 cmp	 r12, 30
  002e5	0f 8d 10 02 00
	00		 jge	 $LN118@mg_json_ge

; 3528 :           if (depth == ed && path[pos] == '[' && ei == ci) {

  002eb	3b ef		 cmp	 ebp, edi
  002ed	75 6a		 jne	 SHORT $LN45@mg_json_ge
  002ef	49 63 c5	 movsxd	 rax, r13d
  002f2	80 3c 30 5b	 cmp	 BYTE PTR [rax+rsi], 91	; 0000005bH
  002f6	75 61		 jne	 SHORT $LN45@mg_json_ge
  002f8	45 3b da	 cmp	 r11d, r10d
  002fb	75 5c		 jne	 SHORT $LN45@mg_json_ge

; 3529 :             ed++, pos++, ci = 0;

  002fd	33 c0		 xor	 eax, eax
  002ff	41 ff c5	 inc	 r13d
  00302	ff c7		 inc	 edi

; 3530 :             for (ei = 0; path[pos] != ']' && path[pos] != '\0'; pos++) {

  00304	49 63 d5	 movsxd	 rdx, r13d
  00307	48 03 d6	 add	 rdx, rsi
  0030a	89 84 24 b0 00
	00 00		 mov	 DWORD PTR ci$1$[rsp], eax
  00311	45 33 db	 xor	 r11d, r11d
  00314	89 7c 24 20	 mov	 DWORD PTR ed$1$[rsp], edi
  00318	44 89 9c 24 b8
	00 00 00	 mov	 DWORD PTR ei$1$[rsp], r11d
  00320	8a 02		 mov	 al, BYTE PTR [rdx]
  00322	3c 5d		 cmp	 al, 93			; 0000005dH
  00324	74 27		 je	 SHORT $LN8@mg_json_ge
$LL9@mg_json_ge:
  00326	84 c0		 test	 al, al
  00328	74 1b		 je	 SHORT $LN143@mg_json_ge

; 3531 :               ei *= 10;
; 3532 :               ei += path[pos] - '0';

  0032a	0f be c0	 movsx	 eax, al
  0032d	47 8d 1c 9b	 lea	 r11d, DWORD PTR [r11+r11*4]
  00331	48 ff c2	 inc	 rdx
  00334	45 8d 5b e8	 lea	 r11d, DWORD PTR [r11-24]
  00338	41 ff c5	 inc	 r13d
  0033b	46 8d 1c 58	 lea	 r11d, DWORD PTR [rax+r11*2]
  0033f	8a 02		 mov	 al, BYTE PTR [rdx]
  00341	3c 5d		 cmp	 al, 93			; 0000005dH
  00343	75 e1		 jne	 SHORT $LL9@mg_json_ge
$LN143@mg_json_ge:
  00345	44 89 9c 24 b8
	00 00 00	 mov	 DWORD PTR ei$1$[rsp], r11d
$LN8@mg_json_ge:

; 3533 :             }
; 3534 :             if (path[pos] != 0) pos++;

  0034d	49 63 c5	 movsxd	 rax, r13d
  00350	80 3c 30 00	 cmp	 BYTE PTR [rax+rsi], 0
  00354	74 03		 je	 SHORT $LN45@mg_json_ge
  00356	41 ff c5	 inc	 r13d
$LN45@mg_json_ge:

; 3535 :           }
; 3536 :           nesting[depth++] = c;

  00359	ff c5		 inc	 ebp
  0035b	42 c6 44 24 30
	5b		 mov	 BYTE PTR nesting$[rsp+r12], 91 ; 0000005bH
  00361	49 ff c4	 inc	 r12

; 3537 :           break;

  00364	e9 66 01 00 00	 jmp	 $LN2@mg_json_ge
$LN41@mg_json_ge:

; 3538 :         } else if (c == ']' && depth > 0) {  // Empty array

  00369	41 80 39 5d	 cmp	 BYTE PTR [r9], 93	; 0000005dH
  0036d	75 57		 jne	 SHORT $LN46@mg_json_ge
  0036f	4d 85 e4	 test	 r12, r12
  00372	0f 8e aa 00 00
	00		 jle	 $LN61@mg_json_ge

; 3539 :           MG_EOO(']');

  00378	3b ef		 cmp	 ebp, edi
  0037a	75 09		 jne	 SHORT $LN48@mg_json_ge
  0037c	45 3b d3	 cmp	 r10d, r11d
  0037f	0f 85 7e 01 00
	00		 jne	 $LN138@mg_json_ge
$LN48@mg_json_ge:
  00385	42 80 7c 24 2f
	5b		 cmp	 BYTE PTR nesting$[rsp+r12-1], 91 ; 0000005bH
  0038b	0f 85 91 00 00
	00		 jne	 $LN61@mg_json_ge
  00391	ff cd		 dec	 ebp
  00393	49 ff cc	 dec	 r12
  00396	3b ef		 cmp	 ebp, edi
  00398	0f 85 2b 01 00
	00		 jne	 $LN66@mg_json_ge
  0039e	49 63 c5	 movsxd	 rax, r13d
  003a1	80 3c 30 00	 cmp	 BYTE PTR [rax+rsi], 0
  003a5	0f 85 fc 00 00
	00		 jne	 $LN136@mg_json_ge
  003ab	45 3b d3	 cmp	 r10d, r11d
  003ae	0f 85 f3 00 00
	00		 jne	 $LN136@mg_json_ge
$LN123@mg_json_ge:

; 3618 : }

  003b4	4d 85 f6	 test	 r14, r14
  003b7	74 08		 je	 SHORT $LN65@mg_json_ge
  003b9	41 2b df	 sub	 ebx, r15d
  003bc	ff c3		 inc	 ebx
  003be	41 89 1e	 mov	 DWORD PTR [r14], ebx
$LN65@mg_json_ge:
  003c1	41 8b c7	 mov	 eax, r15d
  003c4	eb 61		 jmp	 SHORT $LN1@mg_json_ge
$LN46@mg_json_ge:

; 3540 :         } else if (c == 't' && i + 3 < len && memcmp(&s[i], "true", 4) == 0) {

  003c6	41 80 39 74	 cmp	 BYTE PTR [r9], 116	; 00000074H
  003ca	75 15		 jne	 SHORT $LN52@mg_json_ge
  003cc	83 c3 03	 add	 ebx, 3
  003cf	3b 9c 24 a0 00
	00 00		 cmp	 ebx, DWORD PTR len$1$[rsp]
  003d6	7d 4a		 jge	 SHORT $LN61@mg_json_ge
  003d8	41 81 39 74 72
	75 65		 cmp	 DWORD PTR [r9], 1702195828 ; 65757274H

; 3541 :           i += 3;

  003df	eb 3b		 jmp	 SHORT $LN148@mg_json_ge
$LN52@mg_json_ge:

; 3542 :         } else if (c == 'n' && i + 3 < len && memcmp(&s[i], "null", 4) == 0) {

  003e1	41 80 39 6e	 cmp	 BYTE PTR [r9], 110	; 0000006eH
  003e5	75 15		 jne	 SHORT $LN54@mg_json_ge
  003e7	83 c3 03	 add	 ebx, 3
  003ea	3b 9c 24 a0 00
	00 00		 cmp	 ebx, DWORD PTR len$1$[rsp]
  003f1	7d 2f		 jge	 SHORT $LN61@mg_json_ge
  003f3	41 81 39 6e 75
	6c 6c		 cmp	 DWORD PTR [r9], 1819047278 ; 6c6c756eH

; 3543 :           i += 3;

  003fa	eb 20		 jmp	 SHORT $LN148@mg_json_ge
$LN54@mg_json_ge:

; 3544 :         } else if (c == 'f' && i + 4 < len && memcmp(&s[i], "false", 5) == 0) {

  003fc	41 80 39 66	 cmp	 BYTE PTR [r9], 102	; 00000066H
  00400	75 36		 jne	 SHORT $LN56@mg_json_ge
  00402	83 c3 04	 add	 ebx, 4
  00405	3b 9c 24 a0 00
	00 00		 cmp	 ebx, DWORD PTR len$1$[rsp]
  0040c	7d 14		 jge	 SHORT $LN61@mg_json_ge
  0040e	41 81 39 66 61
	6c 73		 cmp	 DWORD PTR [r9], 1936482662 ; 736c6166H
  00415	75 0b		 jne	 SHORT $LN61@mg_json_ge
  00417	41 80 79 04 65	 cmp	 BYTE PTR [r9+4], 101	; 00000065H
$LN148@mg_json_ge:

; 3556 :         }
; 3557 :         MG_CHECKRET('V');

  0041c	0f 84 81 00 00
	00		 je	 $LN18@mg_json_ge
$LN61@mg_json_ge:

; 3555 :           return MG_JSON_INVALID;

  00422	b8 fe ff ff ff	 mov	 eax, -2
$LN1@mg_json_ge:

; 3618 : }

  00427	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0042b	41 5f		 pop	 r15
  0042d	41 5e		 pop	 r14
  0042f	41 5d		 pop	 r13
  00431	41 5c		 pop	 r12
  00433	5f		 pop	 rdi
  00434	5e		 pop	 rsi
  00435	5d		 pop	 rbp
  00436	5b		 pop	 rbx
  00437	c3		 ret	 0
$LN56@mg_json_ge:

; 3545 :           i += 4;
; 3546 :         } else if (c == '-' || ((c >= '0' && c <= '9'))) {

  00438	41 80 39 2d	 cmp	 BYTE PTR [r9], 45	; 0000002dH
  0043c	74 32		 je	 SHORT $LN60@mg_json_ge
  0043e	41 8a 01	 mov	 al, BYTE PTR [r9]
  00441	2c 30		 sub	 al, 48			; 00000030H
  00443	3c 09		 cmp	 al, 9
  00445	76 29		 jbe	 SHORT $LN60@mg_json_ge

; 3550 :         } else if (c == '"') {

  00447	41 80 39 22	 cmp	 BYTE PTR [r9], 34	; 00000022H
  0044b	75 d5		 jne	 SHORT $LN61@mg_json_ge

; 3551 :           int n = mg_pass_string(&s[i + 1], len - i - 1);

  0044d	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR len$1$[rsp]
  00454	8d 43 01	 lea	 eax, DWORD PTR [rbx+1]
  00457	2b d3		 sub	 edx, ebx
  00459	48 63 c8	 movsxd	 rcx, eax
  0045c	48 03 4c 24 28	 add	 rcx, QWORD PTR s$1$[rsp]
  00461	ff ca		 dec	 edx
  00463	e8 00 00 00 00	 call	 mg_pass_string

; 3552 :           if (n < 0) return n;

  00468	85 c0		 test	 eax, eax
  0046a	78 bb		 js	 SHORT $LN1@mg_json_ge

; 3553 :           i += n + 1;

  0046c	ff c3		 inc	 ebx

; 3554 :         } else {

  0046e	eb 21		 jmp	 SHORT $LN147@mg_json_ge
$LN60@mg_json_ge:

; 3547 :           int numlen = 0;
; 3548 :           mg_atod(&s[i], len - i, &numlen);

  00470	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR len$1$[rsp]
  00477	4c 8d 44 24 24	 lea	 r8, QWORD PTR numlen$1[rsp]
  0047c	83 64 24 24 00	 and	 DWORD PTR numlen$1[rsp], 0
  00481	2b d3		 sub	 edx, ebx
  00483	49 8b c9	 mov	 rcx, r9
  00486	e8 00 00 00 00	 call	 mg_atod

; 3549 :           i += numlen - 1;

  0048b	8b 44 24 24	 mov	 eax, DWORD PTR numlen$1[rsp]
  0048f	ff c8		 dec	 eax
$LN147@mg_json_ge:

; 3556 :         }
; 3557 :         MG_CHECKRET('V');

  00491	44 8b 9c 24 b8
	00 00 00	 mov	 r11d, DWORD PTR ei$1$[rsp]
  00499	03 d8		 add	 ebx, eax
  0049b	44 8b 94 24 b0
	00 00 00	 mov	 r10d, DWORD PTR ci$1$[rsp]
$LN18@mg_json_ge:
  004a3	3b ef		 cmp	 ebp, edi
  004a5	75 22		 jne	 SHORT $LN66@mg_json_ge
$LN136@mg_json_ge:
  004a7	49 63 c5	 movsxd	 rax, r13d
  004aa	80 3c 30 00	 cmp	 BYTE PTR [rax+rsi], 0
  004ae	75 09		 jne	 SHORT $LN16@mg_json_ge
  004b0	45 3b d3	 cmp	 r10d, r11d
  004b3	0f 84 fb fe ff
	ff		 je	 $LN123@mg_json_ge
$LN16@mg_json_ge:

; 3558 :         if (depth == ed && ei >= 0) ci++;

  004b9	45 85 db	 test	 r11d, r11d
  004bc	78 0b		 js	 SHORT $LN66@mg_json_ge
  004be	41 ff c2	 inc	 r10d
  004c1	44 89 94 24 b0
	00 00 00	 mov	 DWORD PTR ci$1$[rsp], r10d
$LN66@mg_json_ge:

; 3559 :         expecting = S_COMMA_OR_EOO;

  004c9	41 b8 03 00 00
	00		 mov	 r8d, 3
$LN2@mg_json_ge:

; 3491 : 
; 3492 : #define MG_CHECKRET(x)                                  \
; 3493 :   do {                                                  \
; 3494 :     if (depth == ed && path[pos] == '\0' && ci == ei) { \
; 3495 :       if (toklen) *toklen = i - j + 1;                  \
; 3496 :       return j;                                         \
; 3497 :     }                                                   \
; 3498 :   } while (0)
; 3499 : 
; 3500 : // In the ascii table, the distance between `[` and `]` is 2.
; 3501 : // Ditto for `{` and `}`. Hence +2 in the code below.
; 3502 : #define MG_EOO(x)                                            \
; 3503 :   do {                                                       \
; 3504 :     if (depth == ed && ci != ei) return MG_JSON_NOT_FOUND;   \
; 3505 :     if (c != nesting[depth - 1] + 2) return MG_JSON_INVALID; \
; 3506 :     depth--;                                                 \
; 3507 :     MG_CHECKRET(x);                                          \
; 3508 :   } while (0)
; 3509 : 
; 3510 :   for (i = 0; i < len; i++) {

  004cf	ff c3		 inc	 ebx
  004d1	3b 9c 24 a0 00
	00 00		 cmp	 ebx, DWORD PTR len$1$[rsp]
  004d8	7d 29		 jge	 SHORT $LN138@mg_json_ge
  004da	44 8b 94 24 b0
	00 00 00	 mov	 r10d, DWORD PTR ci$1$[rsp]
  004e2	44 8b 9c 24 b8
	00 00 00	 mov	 r11d, DWORD PTR ei$1$[rsp]
  004ea	4c 8b 4c 24 28	 mov	 r9, QWORD PTR s$1$[rsp]
  004ef	e9 80 fb ff ff	 jmp	 $LL4@mg_json_ge
$LN110@mg_json_ge:

; 3565 :           if (n < 0) return n;

  004f4	8b c7		 mov	 eax, edi
  004f6	e9 2c ff ff ff	 jmp	 $LN1@mg_json_ge
$LN118@mg_json_ge:

; 3527 :           if (depth >= (int) sizeof(nesting)) return MG_JSON_TOO_DEEP;

  004fb	83 c8 ff	 or	 eax, -1

; 3556 :         }
; 3557 :         MG_CHECKRET('V');

  004fe	e9 24 ff ff ff	 jmp	 $LN1@mg_json_ge
$LN138@mg_json_ge:

; 3610 :           if (depth == ed && ei >= 0) ci++;
; 3611 :         } else {
; 3612 :           return MG_JSON_INVALID;
; 3613 :         }
; 3614 :         break;
; 3615 :     }
; 3616 :   }
; 3617 :   return MG_JSON_NOT_FOUND;

  00503	b8 fd ff ff ff	 mov	 eax, -3
  00508	e9 1a ff ff ff	 jmp	 $LN1@mg_json_ge
mg_json_get ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_json_get_num
_TEXT	SEGMENT
json$ = 64
path$dead$ = 72
toklen$ = 72
v$ = 80
mg_json_get_num PROC					; COMDAT

; 3620 : bool mg_json_get_num(struct mg_str json, const char *path, double *v) {

$LN7:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000b	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3621 :   int n, toklen, found = 0;
; 3622 :   if ((n = mg_json_get(json, path, &toklen)) >= 0 &&

  00014	0f 28 01	 movaps	 xmm0, XMMWORD PTR [rcx]
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07JPIHOLMH@$?4level@
  0001e	49 8b f8	 mov	 rdi, r8
  00021	66 0f 7f 40 e8	 movdqa	 XMMWORD PTR [rax-24], xmm0
  00026	48 8b f1	 mov	 rsi, rcx
  00029	4c 8d 40 10	 lea	 r8, QWORD PTR [rax+16]
  0002d	48 8d 48 e8	 lea	 rcx, QWORD PTR [rax-24]
  00031	33 db		 xor	 ebx, ebx
  00033	e8 00 00 00 00	 call	 mg_json_get
  00038	85 c0		 test	 eax, eax
  0003a	78 2c		 js	 SHORT $LN2@mg_json_ge
  0003c	48 63 c8	 movsxd	 rcx, eax
  0003f	48 03 0e	 add	 rcx, QWORD PTR [rsi]
  00042	8a 01		 mov	 al, BYTE PTR [rcx]
  00044	3c 2d		 cmp	 al, 45			; 0000002dH
  00046	74 06		 je	 SHORT $LN3@mg_json_ge
  00048	2c 30		 sub	 al, 48			; 00000030H
  0004a	3c 09		 cmp	 al, 9
  0004c	77 1a		 ja	 SHORT $LN2@mg_json_ge
$LN3@mg_json_ge:

; 3623 :       (json.ptr[n] == '-' || (json.ptr[n] >= '0' && json.ptr[n] <= '9'))) {
; 3624 :     if (v != NULL) *v = mg_atod(json.ptr + n, toklen, NULL);

  0004e	48 85 ff	 test	 rdi, rdi
  00051	74 10		 je	 SHORT $LN4@mg_json_ge
  00053	8b 54 24 48	 mov	 edx, DWORD PTR toklen$[rsp]
  00057	45 33 c0	 xor	 r8d, r8d
  0005a	e8 00 00 00 00	 call	 mg_atod
  0005f	f2 0f 11 07	 movsd	 QWORD PTR [rdi], xmm0
$LN4@mg_json_ge:

; 3625 :     found = 1;

  00063	bb 01 00 00 00	 mov	 ebx, 1
$LN2@mg_json_ge:

; 3626 :   }
; 3627 :   return found;
; 3628 : }

  00068	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0006d	8a c3		 mov	 al, bl
  0006f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00074	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
mg_json_get_num ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_json_get_bool
_TEXT	SEGMENT
json$ = 64
path$ = 72
v$ = 80
mg_json_get_bool PROC					; COMDAT

; 3630 : bool mg_json_get_bool(struct mg_str json, const char *path, bool *v) {

$LN7:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3631 :   int found = 0, off = mg_json_get(json, path, NULL);

  00010	0f 10 01	 movups	 xmm0, XMMWORD PTR [rcx]
  00013	49 8b f8	 mov	 rdi, r8
  00016	48 8b f1	 mov	 rsi, rcx
  00019	45 33 c0	 xor	 r8d, r8d
  0001c	48 8d 48 e8	 lea	 rcx, QWORD PTR [rax-24]
  00020	f3 0f 7f 40 e8	 movdqu	 XMMWORD PTR [rax-24], xmm0
  00025	33 db		 xor	 ebx, ebx
  00027	e8 00 00 00 00	 call	 mg_json_get

; 3632 :   if (off >= 0 && (json.ptr[off] == 't' || json.ptr[off] == 'f')) {

  0002c	85 c0		 test	 eax, eax
  0002e	78 25		 js	 SHORT $LN2@mg_json_ge
  00030	48 63 d0	 movsxd	 rdx, eax
  00033	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00036	80 3c 02 74	 cmp	 BYTE PTR [rdx+rax], 116	; 00000074H
  0003a	74 06		 je	 SHORT $LN3@mg_json_ge
  0003c	80 3c 02 66	 cmp	 BYTE PTR [rdx+rax], 102	; 00000066H
  00040	75 13		 jne	 SHORT $LN2@mg_json_ge
$LN3@mg_json_ge:

; 3633 :     if (v != NULL) *v = json.ptr[off] == 't';

  00042	48 85 ff	 test	 rdi, rdi
  00045	74 09		 je	 SHORT $LN4@mg_json_ge
  00047	80 3c 02 74	 cmp	 BYTE PTR [rdx+rax], 116	; 00000074H
  0004b	0f 94 c0	 sete	 al
  0004e	88 07		 mov	 BYTE PTR [rdi], al
$LN4@mg_json_ge:

; 3634 :     found = 1;

  00050	bb 01 00 00 00	 mov	 ebx, 1
$LN2@mg_json_ge:

; 3635 :   }
; 3636 :   return found;
; 3637 : }

  00055	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0005a	8a c3		 mov	 al, bl
  0005c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5f		 pop	 rdi
  00066	c3		 ret	 0
mg_json_get_bool ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_json_unescape
_TEXT	SEGMENT
s$ = 48
to$ = 56
n$ = 64
mg_json_unescape PROC					; COMDAT

; 3639 : bool mg_json_unescape(struct mg_str s, char *to, size_t n) {

$LN24:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000f	4c 89 70 20	 mov	 QWORD PTR [rax+32], r14
  00013	41 57		 push	 r15
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3640 :   size_t i, j;
; 3641 :   for (i = 0, j = 0; i < s.len && j < n; i++, j++) {

  00019	33 c0		 xor	 eax, eax
  0001b	33 db		 xor	 ebx, ebx
  0001d	49 8b f8	 mov	 rdi, r8
  00020	48 8b f2	 mov	 rsi, rdx
  00023	4c 8b f9	 mov	 r15, rcx
  00026	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  0002a	76 7e		 jbe	 SHORT $LN3@mg_json_un
$LL4@mg_json_un:
  0002c	48 3b df	 cmp	 rbx, rdi
  0002f	73 7e		 jae	 SHORT $LN21@mg_json_un

; 3642 :     if (s.ptr[i] == '\\' && i + 5 < s.len && s.ptr[i + 1] == 'u') {

  00031	49 8b 0f	 mov	 rcx, QWORD PTR [r15]
  00034	44 8a 04 01	 mov	 r8b, BYTE PTR [rcx+rax]
  00038	41 80 f8 5c	 cmp	 r8b, 92			; 0000005cH
  0003c	75 5c		 jne	 SHORT $LN9@mg_json_un
  0003e	4c 8d 70 05	 lea	 r14, QWORD PTR [rax+5]
  00042	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  00046	4d 3b 77 08	 cmp	 r14, QWORD PTR [r15+8]
  0004a	73 2d		 jae	 SHORT $LN22@mg_json_un
  0004c	80 7a 01 75	 cmp	 BYTE PTR [rdx+1], 117	; 00000075H
  00050	75 27		 jne	 SHORT $LN22@mg_json_un

; 3643 :       //  \uXXXX escape. We could process a simple one-byte chars
; 3644 :       // \u00xx from the ASCII range. More complex chars would require
; 3645 :       // dragging in a UTF8 library, which is too much for us
; 3646 :       if (s.ptr[i + 2] != '0' || s.ptr[i + 3] != '0') return false;  // Give up

  00052	80 7c 01 02 30	 cmp	 BYTE PTR [rcx+rax+2], 48 ; 00000030H
  00057	75 56		 jne	 SHORT $LN21@mg_json_un
  00059	80 7c 01 03 30	 cmp	 BYTE PTR [rcx+rax+3], 48 ; 00000030H
  0005e	75 4f		 jne	 SHORT $LN21@mg_json_un

; 3647 :       ((unsigned char *) to)[j] = (unsigned char) mg_unhexn(s.ptr + i + 4, 2);

  00060	48 83 c1 04	 add	 rcx, 4
  00064	ba 02 00 00 00	 mov	 edx, 2
  00069	48 03 c8	 add	 rcx, rax
  0006c	e8 00 00 00 00	 call	 mg_unhexn
  00071	88 04 33	 mov	 BYTE PTR [rbx+rsi], al

; 3648 : 
; 3649 :       i += 5;

  00074	49 8b c6	 mov	 rax, r14
  00077	eb 25		 jmp	 SHORT $LN2@mg_json_un
$LN22@mg_json_un:

; 3650 :     } else if (s.ptr[i] == '\\' && i + 1 < s.len) {

  00079	4c 8d 58 01	 lea	 r11, QWORD PTR [rax+1]
  0007d	4d 3b 5f 08	 cmp	 r11, QWORD PTR [r15+8]
  00081	73 17		 jae	 SHORT $LN9@mg_json_un

; 3651 :       char c = json_esc(s.ptr[i + 1], 0);

  00083	0f be 4a 01	 movsx	 ecx, BYTE PTR [rdx+1]
  00087	33 d2		 xor	 edx, edx
  00089	e8 00 00 00 00	 call	 json_esc

; 3652 :       if (c == 0) return false;

  0008e	84 c0		 test	 al, al
  00090	74 1d		 je	 SHORT $LN21@mg_json_un

; 3653 :       to[j] = c;

  00092	88 04 33	 mov	 BYTE PTR [rbx+rsi], al

; 3654 :       i++;

  00095	49 8b c3	 mov	 rax, r11

; 3655 :     } else {

  00098	eb 04		 jmp	 SHORT $LN2@mg_json_un
$LN9@mg_json_un:

; 3656 :       to[j] = s.ptr[i];

  0009a	44 88 04 33	 mov	 BYTE PTR [rbx+rsi], r8b
$LN2@mg_json_un:

; 3640 :   size_t i, j;
; 3641 :   for (i = 0, j = 0; i < s.len && j < n; i++, j++) {

  0009e	48 ff c0	 inc	 rax
  000a1	48 ff c3	 inc	 rbx
  000a4	49 3b 47 08	 cmp	 rax, QWORD PTR [r15+8]
  000a8	72 82		 jb	 SHORT $LL4@mg_json_un
$LN3@mg_json_un:

; 3657 :     }
; 3658 :   }
; 3659 :   if (j >= n) return false;

  000aa	48 3b df	 cmp	 rbx, rdi
  000ad	72 04		 jb	 SHORT $LN12@mg_json_un
$LN21@mg_json_un:
  000af	32 c0		 xor	 al, al
  000b1	eb 0b		 jmp	 SHORT $LN1@mg_json_un
$LN12@mg_json_un:

; 3660 :   if (n > 0) to[j] = '\0';

  000b3	48 85 ff	 test	 rdi, rdi
  000b6	74 04		 je	 SHORT $LN13@mg_json_un
  000b8	c6 04 33 00	 mov	 BYTE PTR [rbx+rsi], 0
$LN13@mg_json_un:

; 3661 :   return true;

  000bc	b0 01		 mov	 al, 1
$LN1@mg_json_un:

; 3662 : }

  000be	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c3	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000c8	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000cd	4c 8b 74 24 48	 mov	 r14, QWORD PTR [rsp+72]
  000d2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d6	41 5f		 pop	 r15
  000d8	c3		 ret	 0
mg_json_unescape ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_json_get_str
_TEXT	SEGMENT
$T1 = 32
len$ = 80
json$ = 80
path$ = 88
mg_json_get_str PROC					; COMDAT

; 3664 : char *mg_json_get_str(struct mg_str json, const char *path) {

$LN8:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00007	48 89 68 18	 mov	 QWORD PTR [rax+24], rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 56		 push	 r14
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3665 :   char *result = NULL;
; 3666 :   int len = 0, off = mg_json_get(json, path, &len);

  00013	0f 10 01	 movups	 xmm0, XMMWORD PTR [rcx]
  00016	4c 8b f1	 mov	 r14, rcx
  00019	4c 8d 40 08	 lea	 r8, QWORD PTR [rax+8]
  0001d	33 db		 xor	 ebx, ebx
  0001f	48 8d 48 d8	 lea	 rcx, QWORD PTR [rax-40]
  00023	21 58 08	 and	 DWORD PTR [rax+8], ebx
  00026	f3 0f 7f 40 d8	 movdqu	 XMMWORD PTR [rax-40], xmm0
  0002b	e8 00 00 00 00	 call	 mg_json_get

; 3667 :   if (off >= 0 && len > 1 && json.ptr[off] == '"') {

  00030	85 c0		 test	 eax, eax
  00032	78 60		 js	 SHORT $LN3@mg_json_ge
  00034	48 63 7c 24 50	 movsxd	 rdi, DWORD PTR len$[rsp]
  00039	8d 4b 01	 lea	 ecx, QWORD PTR [rbx+1]
  0003c	3b f9		 cmp	 edi, ecx
  0003e	7e 54		 jle	 SHORT $LN3@mg_json_ge
  00040	4d 8b 36	 mov	 r14, QWORD PTR [r14]
  00043	48 63 e8	 movsxd	 rbp, eax
  00046	41 80 3c 2e 22	 cmp	 BYTE PTR [r14+rbp], 34	; 00000022H
  0004b	75 47		 jne	 SHORT $LN3@mg_json_ge

; 3668 :     if ((result = (char *) calloc(1, (size_t) len)) != NULL &&

  0004d	48 8b d7	 mov	 rdx, rdi
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00056	48 8b d8	 mov	 rbx, rax
  00059	48 85 c0	 test	 rax, rax
  0005c	74 36		 je	 SHORT $LN3@mg_json_ge
  0005e	49 8d 4e 01	 lea	 rcx, QWORD PTR [r14+1]
  00062	4c 8b c7	 mov	 r8, rdi
  00065	48 03 cd	 add	 rcx, rbp
  00068	48 89 4c 24 20	 mov	 QWORD PTR $T1[rsp], rcx
  0006d	8d 4f fe	 lea	 ecx, DWORD PTR [rdi-2]
  00070	48 63 d1	 movsxd	 rdx, ecx
  00073	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00078	48 89 54 24 28	 mov	 QWORD PTR $T1[rsp+8], rdx
  0007d	48 8b d0	 mov	 rdx, rax
  00080	e8 00 00 00 00	 call	 mg_json_unescape
  00085	84 c0		 test	 al, al
  00087	75 0b		 jne	 SHORT $LN3@mg_json_ge

; 3669 :         !mg_json_unescape(mg_str_n(json.ptr + off + 1, (size_t) (len - 2)),
; 3670 :                           result, (size_t) len)) {
; 3671 :       free(result);

  00089	48 8b cb	 mov	 rcx, rbx
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3672 :       result = NULL;

  00092	33 db		 xor	 ebx, ebx
$LN3@mg_json_ge:

; 3673 :     }
; 3674 :   }
; 3675 :   return result;
; 3676 : }

  00094	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00099	48 8b c3	 mov	 rax, rbx
  0009c	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000a1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a5	41 5e		 pop	 r14
  000a7	5f		 pop	 rdi
  000a8	5e		 pop	 rsi
  000a9	c3		 ret	 0
mg_json_get_str ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_json_get_b64
_TEXT	SEGMENT
len$ = 80
json$ = 80
path$ = 88
slen$ = 96
mg_json_get_b64 PROC					; COMDAT

; 3678 : char *mg_json_get_b64(struct mg_str json, const char *path, int *slen) {

$LN6:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00007	48 89 68 18	 mov	 QWORD PTR [rax+24], rbp
  0000b	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3679 :   char *result = NULL;
; 3680 :   int len = 0, off = mg_json_get(json, path, &len);

  00018	0f 10 01	 movups	 xmm0, XMMWORD PTR [rcx]
  0001b	4d 8b f0	 mov	 r14, r8
  0001e	48 8b e9	 mov	 rbp, rcx
  00021	33 db		 xor	 ebx, ebx
  00023	4c 8d 40 08	 lea	 r8, QWORD PTR [rax+8]
  00027	21 58 08	 and	 DWORD PTR [rax+8], ebx
  0002a	48 8d 48 d8	 lea	 rcx, QWORD PTR [rax-40]
  0002e	f3 0f 7f 40 d8	 movdqu	 XMMWORD PTR [rax-40], xmm0
  00033	e8 00 00 00 00	 call	 mg_json_get

; 3681 :   if (off >= 0 && json.ptr[off] == '"' && len > 1 &&

  00038	85 c0		 test	 eax, eax
  0003a	78 4a		 js	 SHORT $LN3@mg_json_ge
  0003c	48 8b 6d 00	 mov	 rbp, QWORD PTR [rbp]
  00040	48 63 f0	 movsxd	 rsi, eax
  00043	80 3c 2e 22	 cmp	 BYTE PTR [rsi+rbp], 34	; 00000022H
  00047	75 3d		 jne	 SHORT $LN3@mg_json_ge
  00049	48 63 7c 24 50	 movsxd	 rdi, DWORD PTR len$[rsp]
  0004e	8d 4b 01	 lea	 ecx, QWORD PTR [rbx+1]
  00051	3b f9		 cmp	 edi, ecx
  00053	7e 31		 jle	 SHORT $LN3@mg_json_ge
  00055	48 8b d7	 mov	 rdx, rdi
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0005e	48 8b d8	 mov	 rbx, rax
  00061	48 85 c0	 test	 rax, rax
  00064	74 20		 je	 SHORT $LN3@mg_json_ge

; 3682 :       (result = (char *) calloc(1, (size_t) len)) != NULL) {
; 3683 :     size_t k = mg_base64_decode(json.ptr + off + 1, (size_t) (len - 2), result,

  00066	8d 4f fe	 lea	 ecx, DWORD PTR [rdi-2]
  00069	4c 8b cf	 mov	 r9, rdi
  0006c	48 63 d1	 movsxd	 rdx, ecx
  0006f	4c 8b c0	 mov	 r8, rax
  00072	48 8d 4d 01	 lea	 rcx, QWORD PTR [rbp+1]
  00076	48 03 ce	 add	 rcx, rsi
  00079	e8 00 00 00 00	 call	 mg_base64_decode

; 3684 :                                 (size_t) len);
; 3685 :     if (slen != NULL) *slen = (int) k;

  0007e	4d 85 f6	 test	 r14, r14
  00081	74 03		 je	 SHORT $LN3@mg_json_ge
  00083	41 89 06	 mov	 DWORD PTR [r14], eax
$LN3@mg_json_ge:

; 3686 :   }
; 3687 :   return result;
; 3688 : }

  00086	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  0008b	48 8b c3	 mov	 rax, rbx
  0008e	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00093	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00098	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009c	41 5f		 pop	 r15
  0009e	41 5e		 pop	 r14
  000a0	5f		 pop	 rdi
  000a1	c3		 ret	 0
mg_json_get_b64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_json_get_hex
_TEXT	SEGMENT
len$ = 80
json$ = 80
path$ = 88
slen$ = 96
mg_json_get_hex PROC					; COMDAT

; 3690 : char *mg_json_get_hex(struct mg_str json, const char *path, int *slen) {

$LN6:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00007	48 89 68 18	 mov	 QWORD PTR [rax+24], rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 56		 push	 r14
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3691 :   char *result = NULL;
; 3692 :   int len = 0, off = mg_json_get(json, path, &len);

  00013	0f 10 01	 movups	 xmm0, XMMWORD PTR [rcx]
  00016	4d 8b f0	 mov	 r14, r8
  00019	48 8b e9	 mov	 rbp, rcx
  0001c	33 db		 xor	 ebx, ebx
  0001e	4c 8d 40 08	 lea	 r8, QWORD PTR [rax+8]
  00022	21 58 08	 and	 DWORD PTR [rax+8], ebx
  00025	48 8d 48 d8	 lea	 rcx, QWORD PTR [rax-40]
  00029	f3 0f 7f 40 d8	 movdqu	 XMMWORD PTR [rax-40], xmm0
  0002e	e8 00 00 00 00	 call	 mg_json_get

; 3693 :   if (off >= 0 && json.ptr[off] == '"' && len > 1 &&

  00033	85 c0		 test	 eax, eax
  00035	78 5b		 js	 SHORT $LN3@mg_json_ge
  00037	48 8b 6d 00	 mov	 rbp, QWORD PTR [rbp]
  0003b	48 63 f0	 movsxd	 rsi, eax
  0003e	80 3c 2e 22	 cmp	 BYTE PTR [rsi+rbp], 34	; 00000022H
  00042	75 4e		 jne	 SHORT $LN3@mg_json_ge
  00044	48 63 7c 24 50	 movsxd	 rdi, DWORD PTR len$[rsp]
  00049	8d 4b 01	 lea	 ecx, QWORD PTR [rbx+1]
  0004c	3b f9		 cmp	 edi, ecx
  0004e	7e 42		 jle	 SHORT $LN3@mg_json_ge
  00050	48 8b d7	 mov	 rdx, rdi
  00053	48 d1 ea	 shr	 rdx, 1
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0005c	48 8b d8	 mov	 rbx, rax
  0005f	48 85 c0	 test	 rax, rax
  00062	74 2e		 je	 SHORT $LN3@mg_json_ge

; 3694 :       (result = (char *) calloc(1, (size_t) len / 2)) != NULL) {
; 3695 :     mg_unhex(json.ptr + off + 1, (size_t) (len - 2), (uint8_t *) result);

  00064	8d 4f fe	 lea	 ecx, DWORD PTR [rdi-2]
  00067	4c 8b c0	 mov	 r8, rax
  0006a	48 63 d1	 movsxd	 rdx, ecx
  0006d	48 8d 4d 01	 lea	 rcx, QWORD PTR [rbp+1]
  00071	48 03 ce	 add	 rcx, rsi
  00074	e8 00 00 00 00	 call	 mg_unhex

; 3696 :     result[len / 2 - 1] = '\0';

  00079	8b c7		 mov	 eax, edi
  0007b	99		 cdq
  0007c	2b c2		 sub	 eax, edx
  0007e	d1 f8		 sar	 eax, 1
  00080	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00083	48 98		 cdqe
  00085	c6 44 18 ff 00	 mov	 BYTE PTR [rax+rbx-1], 0

; 3697 :     if (slen != NULL) *slen = len / 2 - 1;

  0008a	4d 85 f6	 test	 r14, r14
  0008d	74 03		 je	 SHORT $LN3@mg_json_ge
  0008f	41 89 0e	 mov	 DWORD PTR [r14], ecx
$LN3@mg_json_ge:

; 3698 :   }
; 3699 :   return result;
; 3700 : }

  00092	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00097	48 8b c3	 mov	 rax, rbx
  0009a	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0009f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a3	41 5e		 pop	 r14
  000a5	5f		 pop	 rdi
  000a6	5e		 pop	 rsi
  000a7	c3		 ret	 0
mg_json_get_hex ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_json_get_long
_TEXT	SEGMENT
json$ = 64
path$dead$ = 72
dv$ = 72
dflt$dead$ = 80
mg_json_get_long PROC					; COMDAT

; 3702 : long mg_json_get_long(struct mg_str json, const char *path, long dflt) {

$LN5:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  00007	53		 push	 rbx
  00008	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3703 :   double dv;
; 3704 :   long result = dflt;
; 3705 :   if (mg_json_get_num(json, path, &dv)) result = (long) dv;

  0000c	0f 28 01	 movaps	 xmm0, XMMWORD PTR [rcx]
  0000f	4c 8d 40 10	 lea	 r8, QWORD PTR [rax+16]
  00013	48 8d 48 e8	 lea	 rcx, QWORD PTR [rax-24]
  00017	66 0f 7f 40 e8	 movdqa	 XMMWORD PTR [rax-24], xmm0
  0001c	bb 03 00 00 00	 mov	 ebx, 3
  00021	e8 00 00 00 00	 call	 mg_json_get_num
  00026	84 c0		 test	 al, al
  00028	74 06		 je	 SHORT $LN2@mg_json_ge
  0002a	f2 0f 2c 5c 24
	48		 cvttsd2si ebx, QWORD PTR dv$[rsp]
$LN2@mg_json_ge:

; 3706 :   return result;

  00030	8b c3		 mov	 eax, ebx

; 3707 : }

  00032	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00036	5b		 pop	 rbx
  00037	c3		 ret	 0
mg_json_get_long ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_log_set_fn
_TEXT	SEGMENT
fn$ = 8
param$ = 16
mg_log_set_fn PROC					; COMDAT

; 3722 :   s_log_func = fn;

  00000	48 89 0d 00 00
	00 00		 mov	 QWORD PTR s_log_func, rcx

; 3723 :   s_log_func_param = param;

  00007	48 89 15 00 00
	00 00		 mov	 QWORD PTR s_log_func_param, rdx

; 3724 : }

  0000e	c3		 ret	 0
mg_log_set_fn ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT logc
_TEXT	SEGMENT
c$ = 8
logc	PROC						; COMDAT

; 3727 :   s_log_func((char) c, s_log_func_param);

  00000	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR s_log_func_param
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR s_log_func
logc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT logs
_TEXT	SEGMENT
buf$ = 48
len$ = 56
logs	PROC						; COMDAT

; 3731 :   size_t i;
; 3732 :   for (i = 0; i < len; i++) logc(((unsigned char *) buf)[i]);

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 3e		 je	 SHORT $LN12@logs
  00005	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  0000a	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3730 : static void logs(const char *buf, size_t len) {

  00014	48 8b fa	 mov	 rdi, rdx
  00017	48 8b f1	 mov	 rsi, rcx

; 3731 :   size_t i;
; 3732 :   for (i = 0; i < len; i++) logc(((unsigned char *) buf)[i]);

  0001a	33 db		 xor	 ebx, ebx
$LL4@logs:

; 3727 :   s_log_func((char) c, s_log_func_param);

  0001c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR s_log_func_param
  00023	8a 0c 33	 mov	 cl, BYTE PTR [rbx+rsi]
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR s_log_func

; 3731 :   size_t i;
; 3732 :   for (i = 0; i < len; i++) logc(((unsigned char *) buf)[i]);

  0002c	48 ff c3	 inc	 rbx
  0002f	48 3b df	 cmp	 rbx, rdi
  00032	72 e8		 jb	 SHORT $LL4@logs

; 3733 : }

  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5f		 pop	 rdi
$LN12@logs:
  00043	c3		 ret	 0
logs	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_log_prefix
_TEXT	SEGMENT
buf$ = 64
level$ = 128
file$dead$ = 136
line$ = 144
fname$ = 152
mg_log_prefix PROC					; COMDAT

; 3738 : void mg_log_prefix(int level, const char *file, int line, const char *fname) {

$LN15:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00019	8b e9		 mov	 ebp, ecx

; 3739 :   const char *p = strrchr(file, '/');

  0001b	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:??_C@_0DD@NDGBJGCA@C?3?2Users?2dev?2source?2repos?2alpin@
  00022	49 8b ce	 mov	 rcx, r14
  00025	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  0002a	49 8b f9	 mov	 rdi, r9
  0002d	41 8b f0	 mov	 esi, r8d
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strrchr
  00036	48 8b d8	 mov	 rbx, rax

; 3740 :   char buf[41];
; 3741 :   size_t n;
; 3742 :   if (p == NULL) p = strrchr(file, '\\');

  00039	48 85 c0	 test	 rax, rax
  0003c	75 0f		 jne	 SHORT $LN4@mg_log_pre
  0003e	8d 50 5c	 lea	 edx, QWORD PTR [rax+92]
  00041	49 8b ce	 mov	 rcx, r14
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strrchr
  0004a	48 8b d8	 mov	 rbx, rax
$LN4@mg_log_pre:

; 13865:   return GetTickCount();

  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount

; 3743 :   n = mg_snprintf(buf, sizeof(buf), "%-6llx %d %s:%d:%s", mg_millis(), level,

  00053	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00058	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BD@KJILOAFG@?$CF?96llx?5?$CFd?5?$CFs?3?$CFd?3?$CFs@

; 13865:   return GetTickCount();

  0005f	44 8b c8	 mov	 r9d, eax

; 3743 :   n = mg_snprintf(buf, sizeof(buf), "%-6llx %d %s:%d:%s", mg_millis(), level,

  00062	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$[rsp]
  00067	48 85 db	 test	 rbx, rbx
  0006a	89 74 24 30	 mov	 DWORD PTR [rsp+48], esi
  0006e	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
  00072	bb 29 00 00 00	 mov	 ebx, 41			; 00000029H
  00077	49 0f 44 c6	 cmove	 rax, r14
  0007b	8b d3		 mov	 edx, ebx
  0007d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00082	89 6c 24 20	 mov	 DWORD PTR [rsp+32], ebp
  00086	e8 00 00 00 00	 call	 mg_snprintf

; 3744 :                   p == NULL ? file : p + 1, line, fname);
; 3745 :   if (n > sizeof(buf) - 2) n = sizeof(buf) - 2;

  0008b	8d 4b fe	 lea	 ecx, QWORD PTR [rbx-2]

; 3746 :   while (n < sizeof(buf)) buf[n++] = ' ';

  0008e	b2 20		 mov	 dl, 32			; 00000020H
  00090	48 3b c1	 cmp	 rax, rcx
  00093	48 0f 47 c1	 cmova	 rax, rcx
  00097	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$[rsp]
  0009c	48 2b d8	 sub	 rbx, rax
  0009f	48 03 c8	 add	 rcx, rax
  000a2	4c 8b c3	 mov	 r8, rbx
  000a5	e8 00 00 00 00	 call	 memset

; 3747 :   logs(buf, n - 1);

  000aa	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  000af	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$[rsp]
  000b4	e8 00 00 00 00	 call	 logs

; 3748 : }

  000b9	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  000be	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000c2	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  000c6	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  000ca	49 8b 7b 28	 mov	 rdi, QWORD PTR [r11+40]
  000ce	49 8b e3	 mov	 rsp, r11
  000d1	41 5e		 pop	 r14
  000d3	c3		 ret	 0
mg_log_prefix ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_log
_TEXT	SEGMENT
ap$ = 32
fmt$ = 64
mg_log	PROC						; COMDAT

; 3750 : void mg_log(const char *fmt, ...) {

$LN4:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 4b 08	 mov	 QWORD PTR [r11+8], rcx
  00007	49 89 53 10	 mov	 QWORD PTR [r11+16], rdx
  0000b	4d 89 43 18	 mov	 QWORD PTR [r11+24], r8
  0000f	4d 89 4b 20	 mov	 QWORD PTR [r11+32], r9
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3751 :   va_list ap;
; 3752 :   va_start(ap, fmt);
; 3753 :   mg_vxprintf(s_log_func, s_log_func_param, fmt, &ap);

  00017	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR s_log_func_param
  0001e	49 8d 43 10	 lea	 rax, QWORD PTR [r11+16]
  00022	4c 8b c1	 mov	 r8, rcx
  00025	49 89 43 e8	 mov	 QWORD PTR [r11-24], rax
  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR s_log_func
  00030	4d 8d 4b e8	 lea	 r9, QWORD PTR [r11-24]
  00034	e8 00 00 00 00	 call	 mg_vxprintf

; 3754 :   va_end(ap);

  00039	48 83 64 24 20
	00		 and	 QWORD PTR ap$[rsp], 0

; 3755 :   logs("\r\n", 2);

  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02PCIJFNDE@?$AN?6@
  00046	ba 02 00 00 00	 mov	 edx, 2
  0004b	e8 00 00 00 00	 call	 logs

; 3756 : }

  00050	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00054	c3		 ret	 0
mg_log	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT nibble
_TEXT	SEGMENT
c$ = 8
nibble	PROC						; COMDAT

; 3760 :   return (unsigned char) (c < 10 ? c + '0' : c + 'W');

  00000	83 f9 0a	 cmp	 ecx, 10
  00003	1a c0		 sbb	 al, al
  00005	24 d9		 and	 al, 217			; 000000d9H
  00007	04 57		 add	 al, 87			; 00000057H
  00009	02 c1		 add	 al, cl

; 3761 : }

  0000b	c3		 ret	 0
nibble	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_hexdump
_TEXT	SEGMENT
ascii$ = 32
buf$ = 64
len$ = 72
mg_hexdump PROC						; COMDAT

; 3764 : void mg_hexdump(const void *buf, size_t len) {

$LN56:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3765 :   const unsigned char *p = (const unsigned char *) buf;
; 3766 :   unsigned char ascii[16], alen = 0;

  00014	32 db		 xor	 bl, bl
  00016	33 ff		 xor	 edi, edi
  00018	48 8b f2	 mov	 rsi, rdx
  0001b	48 8b e9	 mov	 rbp, rcx

; 3767 :   size_t i;
; 3768 :   for (i = 0; i < len; i++) {

  0001e	48 85 d2	 test	 rdx, rdx
  00021	0f 84 40 01 00
	00		 je	 $LL5@mg_hexdump
$LL4@mg_hexdump:

; 3769 :     if ((i % 16) == 0) {

  00027	40 f6 c7 0f	 test	 dil, 15
  0002b	0f 85 bf 00 00
	00		 jne	 $LN7@mg_hexdump

; 3770 :       // Print buffered ascii chars
; 3771 :       if (i > 0) logs("  ", 2), logs((char *) ascii, 16), logc('\n'), alen = 0;

  00031	48 85 ff	 test	 rdi, rdi
  00034	74 31		 je	 SHORT $LN8@mg_hexdump
  00036	ba 02 00 00 00	 mov	 edx, 2
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02KNHHEEKP@?5?5@
  00042	e8 00 00 00 00	 call	 logs
  00047	ba 10 00 00 00	 mov	 edx, 16
  0004c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ascii$[rsp]
  00051	e8 00 00 00 00	 call	 logs

; 3727 :   s_log_func((char) c, s_log_func_param);

  00056	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR s_log_func_param
  0005d	b1 0a		 mov	 cl, 10
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR s_log_func

; 3770 :       // Print buffered ascii chars
; 3771 :       if (i > 0) logs("  ", 2), logs((char *) ascii, 16), logc('\n'), alen = 0;

  00065	32 db		 xor	 bl, bl
$LN8@mg_hexdump:

; 3727 :   s_log_func((char) c, s_log_func_param);

  00067	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR s_log_func_param

; 3772 :       // Print hex address, then \t
; 3773 :       logc(nibble((i >> 12) & 15)), logc(nibble((i >> 8) & 15)),
; 3774 :           logc(nibble((i >> 4) & 15)), logc('0'), logs("   ", 3);

  0006e	48 8b c7	 mov	 rax, rdi
  00071	48 c1 e8 0c	 shr	 rax, 12
  00075	83 e0 0f	 and	 eax, 15

; 3760 :   return (unsigned char) (c < 10 ? c + '0' : c + 'W');

  00078	83 f8 0a	 cmp	 eax, 10
  0007b	1a c9		 sbb	 cl, cl
  0007d	04 57		 add	 al, 87			; 00000057H
  0007f	80 e1 d9	 and	 cl, -39			; ffffffffffffffd9H
  00082	02 c8		 add	 cl, al

; 3727 :   s_log_func((char) c, s_log_func_param);

  00084	ff 15 00 00 00
	00		 call	 QWORD PTR s_log_func
  0008a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR s_log_func_param

; 3772 :       // Print hex address, then \t
; 3773 :       logc(nibble((i >> 12) & 15)), logc(nibble((i >> 8) & 15)),
; 3774 :           logc(nibble((i >> 4) & 15)), logc('0'), logs("   ", 3);

  00091	48 8b c7	 mov	 rax, rdi
  00094	48 c1 e8 08	 shr	 rax, 8
  00098	83 e0 0f	 and	 eax, 15

; 3760 :   return (unsigned char) (c < 10 ? c + '0' : c + 'W');

  0009b	83 f8 0a	 cmp	 eax, 10
  0009e	1a c9		 sbb	 cl, cl
  000a0	04 57		 add	 al, 87			; 00000057H
  000a2	80 e1 d9	 and	 cl, -39			; ffffffffffffffd9H
  000a5	02 c8		 add	 cl, al

; 3727 :   s_log_func((char) c, s_log_func_param);

  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR s_log_func
  000ad	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR s_log_func_param

; 3772 :       // Print hex address, then \t
; 3773 :       logc(nibble((i >> 12) & 15)), logc(nibble((i >> 8) & 15)),
; 3774 :           logc(nibble((i >> 4) & 15)), logc('0'), logs("   ", 3);

  000b4	48 8b c7	 mov	 rax, rdi
  000b7	48 c1 e8 04	 shr	 rax, 4
  000bb	83 e0 0f	 and	 eax, 15

; 3760 :   return (unsigned char) (c < 10 ? c + '0' : c + 'W');

  000be	83 f8 0a	 cmp	 eax, 10
  000c1	1a c9		 sbb	 cl, cl
  000c3	04 57		 add	 al, 87			; 00000057H
  000c5	80 e1 d9	 and	 cl, -39			; ffffffffffffffd9H
  000c8	02 c8		 add	 cl, al

; 3727 :   s_log_func((char) c, s_log_func_param);

  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR s_log_func
  000d0	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR s_log_func_param
  000d7	b1 30		 mov	 cl, 48			; 00000030H
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR s_log_func

; 3772 :       // Print hex address, then \t
; 3773 :       logc(nibble((i >> 12) & 15)), logc(nibble((i >> 8) & 15)),
; 3774 :           logc(nibble((i >> 4) & 15)), logc('0'), logs("   ", 3);

  000df	ba 03 00 00 00	 mov	 edx, 3
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03NDEAONJP@?5?5?5@
  000eb	e8 00 00 00 00	 call	 logs
$LN7@mg_hexdump:

; 3775 :     }
; 3776 :     logc(nibble(p[i] >> 4)), logc(nibble(p[i] & 15));  // Two nibbles, e.g. c5

  000f0	0f b6 04 2f	 movzx	 eax, BYTE PTR [rdi+rbp]

; 3727 :   s_log_func((char) c, s_log_func_param);

  000f4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR s_log_func_param

; 3775 :     }
; 3776 :     logc(nibble(p[i] >> 4)), logc(nibble(p[i] & 15));  // Two nibbles, e.g. c5

  000fb	c1 e8 04	 shr	 eax, 4

; 3760 :   return (unsigned char) (c < 10 ? c + '0' : c + 'W');

  000fe	83 f8 0a	 cmp	 eax, 10
  00101	1a c9		 sbb	 cl, cl
  00103	04 57		 add	 al, 87			; 00000057H
  00105	80 e1 d9	 and	 cl, -39			; ffffffffffffffd9H
  00108	02 c8		 add	 cl, al

; 3727 :   s_log_func((char) c, s_log_func_param);

  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR s_log_func

; 3775 :     }
; 3776 :     logc(nibble(p[i] >> 4)), logc(nibble(p[i] & 15));  // Two nibbles, e.g. c5

  00110	0f b6 04 2f	 movzx	 eax, BYTE PTR [rdi+rbp]

; 3727 :   s_log_func((char) c, s_log_func_param);

  00114	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR s_log_func_param

; 3775 :     }
; 3776 :     logc(nibble(p[i] >> 4)), logc(nibble(p[i] & 15));  // Two nibbles, e.g. c5

  0011b	83 e0 0f	 and	 eax, 15

; 3760 :   return (unsigned char) (c < 10 ? c + '0' : c + 'W');

  0011e	83 f8 0a	 cmp	 eax, 10
  00121	1a c9		 sbb	 cl, cl
  00123	04 57		 add	 al, 87			; 00000057H
  00125	80 e1 d9	 and	 cl, -39			; ffffffffffffffd9H
  00128	02 c8		 add	 cl, al

; 3727 :   s_log_func((char) c, s_log_func_param);

  0012a	ff 15 00 00 00
	00		 call	 QWORD PTR s_log_func
  00130	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR s_log_func_param
  00137	b1 20		 mov	 cl, 32			; 00000020H
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR s_log_func

; 3777 :     logc(' ');                                         // Space after hex number
; 3778 :     ascii[alen++] = ISPRINT(p[i]) ? p[i] : '.';        // Add to the ascii buf

  0013f	0f b6 14 2f	 movzx	 edx, BYTE PTR [rdi+rbp]
  00143	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  00148	8d 42 e0	 lea	 eax, DWORD PTR [rdx-32]
  0014b	3c 5e		 cmp	 al, 94			; 0000005eH
  0014d	0f b6 c3	 movzx	 eax, bl
  00150	0f 46 ca	 cmovbe	 ecx, edx
  00153	fe c3		 inc	 bl
  00155	48 ff c7	 inc	 rdi
  00158	88 4c 04 20	 mov	 BYTE PTR ascii$[rsp+rax], cl
  0015c	48 3b fe	 cmp	 rdi, rsi
  0015f	0f 82 c2 fe ff
	ff		 jb	 $LL4@mg_hexdump

; 3767 :   size_t i;
; 3768 :   for (i = 0; i < len; i++) {

  00165	eb 1b		 jmp	 SHORT $LN54@mg_hexdump
$LL5@mg_hexdump:

; 3779 :   }
; 3780 :   while (alen < 16) logs("   ", 3), ascii[alen++] = ' ';

  00167	ba 03 00 00 00	 mov	 edx, 3
  0016c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03NDEAONJP@?5?5?5@
  00173	e8 00 00 00 00	 call	 logs
  00178	0f b6 c3	 movzx	 eax, bl
  0017b	fe c3		 inc	 bl
  0017d	c6 44 04 20 20	 mov	 BYTE PTR ascii$[rsp+rax], 32 ; 00000020H
$LN54@mg_hexdump:
  00182	80 fb 10	 cmp	 bl, 16
  00185	72 e0		 jb	 SHORT $LL5@mg_hexdump

; 3781 :   logs("  ", 2), logs((char *) ascii, 16), logc('\n');

  00187	ba 02 00 00 00	 mov	 edx, 2
  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02KNHHEEKP@?5?5@
  00193	e8 00 00 00 00	 call	 logs
  00198	ba 10 00 00 00	 mov	 edx, 16
  0019d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ascii$[rsp]
  001a2	e8 00 00 00 00	 call	 logs

; 3727 :   s_log_func((char) c, s_log_func_param);

  001a7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR s_log_func_param
  001ae	b1 0a		 mov	 cl, 10

; 3782 : }

  001b0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001b5	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001ba	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001bf	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001c3	5f		 pop	 rdi

; 3727 :   s_log_func((char) c, s_log_func_param);

  001c4	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR s_log_func
mg_hexdump ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_byte_reverse
_TEXT	SEGMENT
buf$dead$ = 8
longs$dead$ = 16
mg_byte_reverse PROC					; COMDAT

; 3808 :   if (MG_BIG_ENDIAN) {
; 3809 :     do {
; 3810 :       uint32_t t = (uint32_t) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
; 3811 :                    ((unsigned) buf[1] << 8 | buf[0]);
; 3812 :       *(uint32_t *) buf = t;
; 3813 :       buf += 4;
; 3814 :     } while (--longs);
; 3815 :   } else {
; 3816 :     (void) buf, (void) longs;  // Little endian. Do nothing
; 3817 :   }
; 3818 : }

  00000	c2 00 00	 ret	 0
mg_byte_reverse ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_md5_init
_TEXT	SEGMENT
ctx$ = 8
mg_md5_init PROC					; COMDAT

; 3833 :   ctx->buf[0] = 0x67452301;
; 3834 :   ctx->buf[1] = 0xefcdab89;
; 3835 :   ctx->buf[2] = 0x98badcfe;
; 3836 :   ctx->buf[3] = 0x10325476;
; 3837 : 
; 3838 :   ctx->bits[0] = 0;

  00000	83 61 10 00	 and	 DWORD PTR [rcx+16], 0

; 3839 :   ctx->bits[1] = 0;

  00004	83 61 14 00	 and	 DWORD PTR [rcx+20], 0
  00008	c7 01 01 23 45
	67		 mov	 DWORD PTR [rcx], 1732584193 ; 67452301H
  0000e	c7 41 04 89 ab
	cd ef		 mov	 DWORD PTR [rcx+4], -271733879 ; efcdab89H
  00015	c7 41 08 fe dc
	ba 98		 mov	 DWORD PTR [rcx+8], -1732584194 ; 98badcfeH
  0001c	c7 41 0c 76 54
	32 10		 mov	 DWORD PTR [rcx+12], 271733878 ; 10325476H

; 3840 : }

  00023	c3		 ret	 0
mg_md5_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_md5_transform
_TEXT	SEGMENT
tv1980 = 0
tv1982 = 4
tv1975 = 8
tv1984 = 12
tv1977 = 16
buf$ = 112
tv1986 = 120
in$ = 120
tv1983 = 128
tv1985 = 136
mg_md5_transform PROC					; COMDAT

; 3842 : static void mg_md5_transform(uint32_t buf[4], uint32_t const in[16]) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3843 :   uint32_t a, b, c, d;
; 3844 : 
; 3845 :   a = buf[0];
; 3846 :   b = buf[1];

  00015	44 8b 51 04	 mov	 r10d, DWORD PTR [rcx+4]
  00019	48 8b da	 mov	 rbx, rdx

; 3847 :   c = buf[2];

  0001c	44 8b 49 08	 mov	 r9d, DWORD PTR [rcx+8]

; 3848 :   d = buf[3];

  00020	44 8b 41 0c	 mov	 r8d, DWORD PTR [rcx+12]

; 3849 : 
; 3850 :   MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);

  00024	41 8b c0	 mov	 eax, r8d
  00027	8b 11		 mov	 edx, DWORD PTR [rcx]
  00029	41 33 c1	 xor	 eax, r9d
  0002c	41 23 c2	 and	 eax, r10d
  0002f	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00031	41 33 c0	 xor	 eax, r8d

; 3851 :   MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
; 3852 :   MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
; 3853 :   MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
; 3854 :   MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
; 3855 :   MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);

  00034	44 8b 63 14	 mov	 r12d, DWORD PTR [rbx+20]
  00038	03 c1		 add	 eax, ecx
  0003a	89 4c 24 78	 mov	 DWORD PTR tv1986[rsp], ecx
  0003e	8d 8a 78 a4 6a
	d7		 lea	 ecx, DWORD PTR [rdx-680876936]
  00044	8b 53 04	 mov	 edx, DWORD PTR [rbx+4]
  00047	03 c8		 add	 ecx, eax
  00049	89 94 24 88 00
	00 00		 mov	 DWORD PTR tv1985[rsp], edx
  00050	c1 c1 07	 rol	 ecx, 7
  00053	41 8b c1	 mov	 eax, r9d
  00056	41 33 c2	 xor	 eax, r10d
  00059	41 03 ca	 add	 ecx, r10d
  0005c	23 c1		 and	 eax, ecx
  0005e	41 33 c1	 xor	 eax, r9d
  00061	03 c2		 add	 eax, edx
  00063	41 8d 90 56 b7
	c7 e8		 lea	 edx, DWORD PTR [r8-389564586]
  0006a	44 8b 43 08	 mov	 r8d, DWORD PTR [rbx+8]
  0006e	03 d0		 add	 edx, eax
  00070	c1 c2 0c	 rol	 edx, 12
  00073	41 8b c2	 mov	 eax, r10d
  00076	33 c1		 xor	 eax, ecx
  00078	44 89 44 24 0c	 mov	 DWORD PTR tv1984[rsp], r8d
  0007d	03 d1		 add	 edx, ecx
  0007f	23 c2		 and	 eax, edx
  00081	41 33 c2	 xor	 eax, r10d
  00084	41 03 c0	 add	 eax, r8d
  00087	45 8d 81 db 70
	20 24		 lea	 r8d, DWORD PTR [r9+606105819]
  0008e	44 8b 4b 0c	 mov	 r9d, DWORD PTR [rbx+12]
  00092	44 03 c0	 add	 r8d, eax
  00095	8b c2		 mov	 eax, edx
  00097	44 89 8c 24 80
	00 00 00	 mov	 DWORD PTR tv1983[rsp], r9d
  0009f	33 c1		 xor	 eax, ecx
  000a1	41 c1 c8 0f	 ror	 r8d, 15
  000a5	44 03 c2	 add	 r8d, edx
  000a8	41 23 c0	 and	 eax, r8d
  000ab	33 c1		 xor	 eax, ecx
  000ad	41 03 c1	 add	 eax, r9d
  000b0	45 8d 8a ee ce
	bd c1		 lea	 r9d, DWORD PTR [r10-1044525330]
  000b7	44 8b 53 10	 mov	 r10d, DWORD PTR [rbx+16]
  000bb	44 03 c8	 add	 r9d, eax
  000be	8b c2		 mov	 eax, edx
  000c0	44 89 54 24 04	 mov	 DWORD PTR tv1982[rsp], r10d
  000c5	41 33 c0	 xor	 eax, r8d
  000c8	41 c1 c9 0a	 ror	 r9d, 10
  000cc	45 03 c8	 add	 r9d, r8d
  000cf	41 23 c1	 and	 eax, r9d
  000d2	33 c2		 xor	 eax, edx
  000d4	41 03 c2	 add	 eax, r10d
  000d7	44 8d 91 af 0f
	7c f5		 lea	 r10d, DWORD PTR [rcx-176418897]
  000de	44 03 d0	 add	 r10d, eax
  000e1	8d 8a 2a c6 87
	47		 lea	 ecx, DWORD PTR [rdx+1200080426]

; 3856 :   MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);

  000e7	8b 53 18	 mov	 edx, DWORD PTR [rbx+24]
  000ea	41 8b c0	 mov	 eax, r8d
  000ed	41 33 c1	 xor	 eax, r9d
  000f0	89 14 24	 mov	 DWORD PTR tv1980[rsp], edx
  000f3	41 c1 c2 07	 rol	 r10d, 7
  000f7	45 03 d1	 add	 r10d, r9d
  000fa	41 23 c2	 and	 eax, r10d
  000fd	41 33 c0	 xor	 eax, r8d
  00100	41 03 c4	 add	 eax, r12d
  00103	03 c8		 add	 ecx, eax
  00105	41 8b c1	 mov	 eax, r9d
  00108	41 33 c2	 xor	 eax, r10d
  0010b	c1 c1 0c	 rol	 ecx, 12
  0010e	41 03 ca	 add	 ecx, r10d
  00111	23 c1		 and	 eax, ecx
  00113	41 33 c1	 xor	 eax, r9d
  00116	03 c2		 add	 eax, edx
  00118	41 8d 90 13 46
	30 a8		 lea	 edx, DWORD PTR [r8-1473231341]
  0011f	03 d0		 add	 edx, eax
  00121	c1 ca 0f	 ror	 edx, 15
  00124	03 d1		 add	 edx, ecx

; 3857 :   MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);

  00126	8b 6b 1c	 mov	 ebp, DWORD PTR [rbx+28]
  00129	45 8d 81 01 95
	46 fd		 lea	 r8d, DWORD PTR [r9-45705983]

; 3858 :   MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);

  00130	44 8b 6b 20	 mov	 r13d, DWORD PTR [rbx+32]
  00134	45 8d 8a d8 98
	80 69		 lea	 r9d, DWORD PTR [r10+1770035416]

; 3859 :   MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
; 3860 :   MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);

  0013b	44 8b 73 28	 mov	 r14d, DWORD PTR [rbx+40]
  0013f	8b c1		 mov	 eax, ecx
  00141	41 33 c2	 xor	 eax, r10d

; 3861 :   MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
; 3862 :   MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);

  00144	8b 73 30	 mov	 esi, DWORD PTR [rbx+48]
  00147	23 c2		 and	 eax, edx

; 3863 :   MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);

  00149	44 8b 7b 34	 mov	 r15d, DWORD PTR [rbx+52]
  0014d	41 33 c2	 xor	 eax, r10d

; 3864 :   MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);

  00150	8b 7b 38	 mov	 edi, DWORD PTR [rbx+56]
  00153	44 8b 53 24	 mov	 r10d, DWORD PTR [rbx+36]
  00157	03 c5		 add	 eax, ebp
  00159	44 03 c0	 add	 r8d, eax
  0015c	44 89 54 24 10	 mov	 DWORD PTR tv1977[rsp], r10d
  00161	41 c1 c8 0a	 ror	 r8d, 10
  00165	8b c1		 mov	 eax, ecx
  00167	33 c2		 xor	 eax, edx
  00169	44 03 c2	 add	 r8d, edx
  0016c	41 23 c0	 and	 eax, r8d
  0016f	33 c1		 xor	 eax, ecx
  00171	41 03 c5	 add	 eax, r13d
  00174	44 03 c8	 add	 r9d, eax
  00177	45 8d 98 be d7
	5c 89		 lea	 r11d, DWORD PTR [r8-1990404162]
  0017e	8b c2		 mov	 eax, edx
  00180	41 c1 c1 07	 rol	 r9d, 7
  00184	41 33 c0	 xor	 eax, r8d
  00187	45 03 c8	 add	 r9d, r8d
  0018a	41 23 c1	 and	 eax, r9d
  0018d	33 c2		 xor	 eax, edx
  0018f	41 03 c2	 add	 eax, r10d
  00192	44 8d 91 af f7
	44 8b		 lea	 r10d, DWORD PTR [rcx-1958414417]
  00199	44 03 d0	 add	 r10d, eax
  0019c	8d 8a b1 5b ff
	ff		 lea	 ecx, DWORD PTR [rdx-42063]
  001a2	8b 53 2c	 mov	 edx, DWORD PTR [rbx+44]
  001a5	41 8b c0	 mov	 eax, r8d
  001a8	41 33 c1	 xor	 eax, r9d
  001ab	89 54 24 08	 mov	 DWORD PTR tv1975[rsp], edx
  001af	41 c1 c2 0c	 rol	 r10d, 12
  001b3	45 03 d1	 add	 r10d, r9d
  001b6	41 23 c2	 and	 eax, r10d
  001b9	41 33 c0	 xor	 eax, r8d
  001bc	41 03 c6	 add	 eax, r14d
  001bf	03 c8		 add	 ecx, eax
  001c1	41 8b c2	 mov	 eax, r10d
  001c4	41 33 c1	 xor	 eax, r9d
  001c7	c1 c9 0f	 ror	 ecx, 15
  001ca	41 03 ca	 add	 ecx, r10d
  001cd	23 c1		 and	 eax, ecx
  001cf	44 8b c1	 mov	 r8d, ecx
  001d2	41 33 c1	 xor	 eax, r9d
  001d5	03 c2		 add	 eax, edx
  001d7	41 8d 91 22 11
	90 6b		 lea	 edx, DWORD PTR [r9+1804603682]
  001de	44 03 d8	 add	 r11d, eax
  001e1	44 8d 89 8e 43
	79 a6		 lea	 r9d, DWORD PTR [rcx-1502002290]
  001e8	41 c1 cb 0a	 ror	 r11d, 10
  001ec	41 8b c2	 mov	 eax, r10d
  001ef	33 c1		 xor	 eax, ecx
  001f1	44 03 d9	 add	 r11d, ecx
  001f4	41 23 c3	 and	 eax, r11d
  001f7	45 33 c3	 xor	 r8d, r11d
  001fa	41 33 c2	 xor	 eax, r10d
  001fd	03 c6		 add	 eax, esi
  001ff	03 d0		 add	 edx, eax
  00201	41 8b c3	 mov	 eax, r11d
  00204	c1 c2 07	 rol	 edx, 7
  00207	41 03 d3	 add	 edx, r11d
  0020a	44 23 c2	 and	 r8d, edx
  0020d	33 c2		 xor	 eax, edx
  0020f	44 33 c1	 xor	 r8d, ecx
  00212	41 81 c0 93 71
	98 fd		 add	 r8d, -40341101		; fd987193H
  00219	45 03 c7	 add	 r8d, r15d
  0021c	45 03 c2	 add	 r8d, r10d
  0021f	41 c1 c0 0c	 rol	 r8d, 12
  00223	44 03 c2	 add	 r8d, edx
  00226	41 23 c0	 and	 eax, r8d
  00229	41 33 c3	 xor	 eax, r11d
  0022c	03 c7		 add	 eax, edi
  0022e	44 03 c8	 add	 r9d, eax
  00231	41 c1 c9 0f	 ror	 r9d, 15

; 3865 :   MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);

  00235	8b 5b 3c	 mov	 ebx, DWORD PTR [rbx+60]
  00238	45 03 c8	 add	 r9d, r8d
  0023b	41 8b c8	 mov	 ecx, r8d

; 3866 : 
; 3867 :   MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);

  0023e	41 8b c1	 mov	 eax, r9d
  00241	33 ca		 xor	 ecx, edx
  00243	41 23 c9	 and	 ecx, r9d
  00246	33 ca		 xor	 ecx, edx
  00248	81 c1 21 08 b4
	49		 add	 ecx, 1236535329		; 49b40821H
  0024e	03 cb		 add	 ecx, ebx
  00250	41 03 cb	 add	 ecx, r11d
  00253	c1 c9 0a	 ror	 ecx, 10
  00256	41 03 c9	 add	 ecx, r9d
  00259	33 c1		 xor	 eax, ecx
  0025b	41 23 c0	 and	 eax, r8d
  0025e	41 33 c1	 xor	 eax, r9d
  00261	05 62 25 1e f6	 add	 eax, -165796510		; f61e2562H

; 3868 :   MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
; 3869 :   MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
; 3870 :   MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);

  00266	44 8d 91 aa c7
	b6 e9		 lea	 r10d, DWORD PTR [rcx-373897302]
  0026d	03 84 24 88 00
	00 00		 add	 eax, DWORD PTR tv1985[rsp]
  00274	03 d0		 add	 edx, eax
  00276	8b c1		 mov	 eax, ecx
  00278	c1 c2 05	 rol	 edx, 5
  0027b	03 d1		 add	 edx, ecx
  0027d	33 c2		 xor	 eax, edx
  0027f	41 23 c1	 and	 eax, r9d
  00282	33 c1		 xor	 eax, ecx
  00284	05 40 b3 40 c0	 add	 eax, -1069501632	; c040b340H
  00289	03 04 24	 add	 eax, DWORD PTR tv1980[rsp]
  0028c	44 03 c0	 add	 r8d, eax
  0028f	41 c1 c0 09	 rol	 r8d, 9
  00293	44 03 c2	 add	 r8d, edx
  00296	41 8b c0	 mov	 eax, r8d
  00299	33 c2		 xor	 eax, edx
  0029b	23 c1		 and	 eax, ecx

; 3871 :   MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);

  0029d	8d 8a 5d 10 2f
	d6		 lea	 ecx, DWORD PTR [rdx-701558691]
  002a3	33 c2		 xor	 eax, edx
  002a5	05 51 5a 5e 26	 add	 eax, 643717713		; 265e5a51H
  002aa	03 44 24 08	 add	 eax, DWORD PTR tv1975[rsp]
  002ae	44 03 c8	 add	 r9d, eax
  002b1	41 8b c0	 mov	 eax, r8d
  002b4	41 c1 c1 0e	 rol	 r9d, 14
  002b8	45 03 c8	 add	 r9d, r8d
  002bb	41 33 c1	 xor	 eax, r9d
  002be	23 c2		 and	 eax, edx

; 3872 :   MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);

  002c0	41 8d 90 53 14
	44 02		 lea	 edx, DWORD PTR [r8+38016083]
  002c7	41 33 c0	 xor	 eax, r8d
  002ca	03 44 24 78	 add	 eax, DWORD PTR tv1986[rsp]
  002ce	44 03 d0	 add	 r10d, eax
  002d1	41 8b c1	 mov	 eax, r9d
  002d4	41 c1 ca 0c	 ror	 r10d, 12
  002d8	45 03 d1	 add	 r10d, r9d
  002db	41 33 c2	 xor	 eax, r10d
  002de	41 23 c0	 and	 eax, r8d

; 3873 :   MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);

  002e1	45 8d 81 81 e6
	a1 d8		 lea	 r8d, DWORD PTR [r9-660478335]
  002e8	41 33 c1	 xor	 eax, r9d
  002eb	41 03 c4	 add	 eax, r12d
  002ee	03 c8		 add	 ecx, eax
  002f0	41 8b c2	 mov	 eax, r10d
  002f3	c1 c1 05	 rol	 ecx, 5
  002f6	41 03 ca	 add	 ecx, r10d
  002f9	33 c1		 xor	 eax, ecx
  002fb	41 23 c1	 and	 eax, r9d

; 3874 :   MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);

  002fe	45 8d 8a c8 fb
	d3 e7		 lea	 r9d, DWORD PTR [r10-405537848]
  00305	41 33 c2	 xor	 eax, r10d
  00308	41 03 c6	 add	 eax, r14d
  0030b	03 d0		 add	 edx, eax
  0030d	c1 c2 09	 rol	 edx, 9
  00310	03 d1		 add	 edx, ecx
  00312	8b c2		 mov	 eax, edx
  00314	33 c1		 xor	 eax, ecx
  00316	41 23 c2	 and	 eax, r10d
  00319	33 c1		 xor	 eax, ecx
  0031b	03 c3		 add	 eax, ebx
  0031d	44 03 c0	 add	 r8d, eax
  00320	8b c2		 mov	 eax, edx
  00322	41 c1 c0 0e	 rol	 r8d, 14
  00326	44 03 c2	 add	 r8d, edx
  00329	41 33 c0	 xor	 eax, r8d
  0032c	23 c1		 and	 eax, ecx
  0032e	33 c2		 xor	 eax, edx
  00330	03 44 24 04	 add	 eax, DWORD PTR tv1982[rsp]
  00334	44 03 c8	 add	 r9d, eax

; 3875 :   MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);

  00337	44 8d 91 e6 cd
	e1 21		 lea	 r10d, DWORD PTR [rcx+568446438]
  0033e	41 c1 c9 0c	 ror	 r9d, 12
  00342	45 03 c8	 add	 r9d, r8d

; 3876 :   MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);

  00345	8d 8a d6 07 37
	c3		 lea	 ecx, DWORD PTR [rdx-1019803690]
  0034b	41 8b c0	 mov	 eax, r8d
  0034e	41 33 c1	 xor	 eax, r9d
  00351	23 c2		 and	 eax, edx

; 3877 :   MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);

  00353	41 8d 90 87 0d
	d5 f4		 lea	 edx, DWORD PTR [r8-187363961]
  0035a	41 33 c0	 xor	 eax, r8d

; 3878 :   MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);

  0035d	45 8d 99 ed 14
	5a 45		 lea	 r11d, DWORD PTR [r9+1163531501]
  00364	03 44 24 10	 add	 eax, DWORD PTR tv1977[rsp]
  00368	44 03 d0	 add	 r10d, eax
  0036b	41 8b c1	 mov	 eax, r9d
  0036e	41 c1 c2 05	 rol	 r10d, 5
  00372	45 03 d1	 add	 r10d, r9d
  00375	41 33 c2	 xor	 eax, r10d
  00378	41 23 c0	 and	 eax, r8d
  0037b	41 33 c1	 xor	 eax, r9d
  0037e	03 c7		 add	 eax, edi

; 3879 :   MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);

  00380	45 8d 82 05 e9
	e3 a9		 lea	 r8d, DWORD PTR [r10-1444681467]
  00387	03 c8		 add	 ecx, eax
  00389	c1 c1 09	 rol	 ecx, 9
  0038c	41 03 ca	 add	 ecx, r10d
  0038f	8b c1		 mov	 eax, ecx
  00391	41 33 c2	 xor	 eax, r10d
  00394	41 23 c1	 and	 eax, r9d
  00397	41 33 c2	 xor	 eax, r10d

; 3880 :   MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);

  0039a	44 8d 89 f8 a3
	ef fc		 lea	 r9d, DWORD PTR [rcx-51403784]
  003a1	03 84 24 80 00
	00 00		 add	 eax, DWORD PTR tv1983[rsp]
  003a8	03 d0		 add	 edx, eax
  003aa	8b c1		 mov	 eax, ecx
  003ac	c1 c2 0e	 rol	 edx, 14
  003af	03 d1		 add	 edx, ecx
  003b1	33 c2		 xor	 eax, edx
  003b3	41 23 c2	 and	 eax, r10d
  003b6	33 c1		 xor	 eax, ecx
  003b8	41 03 c5	 add	 eax, r13d

; 3881 :   MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);

  003bb	44 8d 92 d9 02
	6f 67		 lea	 r10d, DWORD PTR [rdx+1735328473]
  003c2	44 03 d8	 add	 r11d, eax
  003c5	8b c2		 mov	 eax, edx
  003c7	41 c1 cb 0c	 ror	 r11d, 12
  003cb	44 03 da	 add	 r11d, edx
  003ce	41 33 c3	 xor	 eax, r11d
  003d1	23 c1		 and	 eax, ecx
  003d3	33 c2		 xor	 eax, edx
  003d5	41 03 c7	 add	 eax, r15d
  003d8	44 03 c0	 add	 r8d, eax
  003db	41 8b c3	 mov	 eax, r11d
  003de	41 c1 c0 05	 rol	 r8d, 5
  003e2	45 03 c3	 add	 r8d, r11d
  003e5	41 33 c0	 xor	 eax, r8d
  003e8	23 c2		 and	 eax, edx

; 3882 :   MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);

  003ea	41 8d 93 8a 4c
	2a 8d		 lea	 edx, DWORD PTR [r11-1926607734]
  003f1	41 33 c3	 xor	 eax, r11d
  003f4	03 44 24 0c	 add	 eax, DWORD PTR tv1984[rsp]
  003f8	44 03 c8	 add	 r9d, eax
  003fb	41 c1 c1 09	 rol	 r9d, 9
  003ff	45 03 c8	 add	 r9d, r8d
  00402	41 8b c1	 mov	 eax, r9d
  00405	41 8b c9	 mov	 ecx, r9d
  00408	41 33 c0	 xor	 eax, r8d
  0040b	41 23 c3	 and	 eax, r11d
  0040e	41 33 c0	 xor	 eax, r8d
  00411	03 c5		 add	 eax, ebp
  00413	44 03 d0	 add	 r10d, eax
  00416	41 c1 c2 0e	 rol	 r10d, 14
  0041a	45 03 d1	 add	 r10d, r9d
  0041d	41 33 ca	 xor	 ecx, r10d
  00420	8b c1		 mov	 eax, ecx
  00422	41 23 c0	 and	 eax, r8d
  00425	41 33 c1	 xor	 eax, r9d
  00428	03 c6		 add	 eax, esi
  0042a	03 d0		 add	 edx, eax
  0042c	c1 ca 0c	 ror	 edx, 12
  0042f	41 03 d2	 add	 edx, r10d

; 3883 : 
; 3884 :   MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);

  00432	33 ca		 xor	 ecx, edx
  00434	81 c1 42 39 fa
	ff		 add	 ecx, -378558		; fffa3942H
  0043a	41 03 cc	 add	 ecx, r12d
  0043d	44 03 c1	 add	 r8d, ecx
  00440	41 c1 c0 04	 rol	 r8d, 4
  00444	44 03 c2	 add	 r8d, edx

; 3885 :   MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);

  00447	41 8b c2	 mov	 eax, r10d

; 3886 :   MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
; 3887 :   MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);

  0044a	44 8d 9a 0c 38
	e5 fd		 lea	 r11d, DWORD PTR [rdx-35309556]
  00451	33 c2		 xor	 eax, edx
  00453	41 33 c0	 xor	 eax, r8d
  00456	05 81 f6 71 87	 add	 eax, -2022574463	; 8771f681H
  0045b	41 03 c5	 add	 eax, r13d
  0045e	44 03 c8	 add	 r9d, eax
  00461	41 c1 c1 0b	 rol	 r9d, 11
  00465	45 03 c8	 add	 r9d, r8d
  00468	41 8b c1	 mov	 eax, r9d
  0046b	41 8b c9	 mov	 ecx, r9d
  0046e	33 c2		 xor	 eax, edx

; 3888 :   MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);

  00470	41 8d 90 44 ea
	be a4		 lea	 edx, DWORD PTR [r8-1530992060]
  00477	41 33 c0	 xor	 eax, r8d
  0047a	05 22 61 9d 6d	 add	 eax, 1839030562		; 6d9d6122H
  0047f	03 44 24 08	 add	 eax, DWORD PTR tv1975[rsp]
  00483	44 03 d0	 add	 r10d, eax
  00486	41 c1 c2 10	 rol	 r10d, 16
  0048a	45 03 d1	 add	 r10d, r9d
  0048d	41 33 ca	 xor	 ecx, r10d
  00490	8b c1		 mov	 eax, ecx
  00492	41 33 c0	 xor	 eax, r8d

; 3889 :   MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);

  00495	45 8d 81 a9 cf
	de 4b		 lea	 r8d, DWORD PTR [r9+1272893353]
  0049c	03 c7		 add	 eax, edi

; 3890 :   MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);

  0049e	45 8d 8a 60 4b
	bb f6		 lea	 r9d, DWORD PTR [r10-155497632]
  004a5	44 03 d8	 add	 r11d, eax
  004a8	41 8b c2	 mov	 eax, r10d
  004ab	41 c1 cb 09	 ror	 r11d, 9
  004af	45 03 da	 add	 r11d, r10d
  004b2	41 33 c3	 xor	 eax, r11d
  004b5	41 33 cb	 xor	 ecx, r11d
  004b8	03 8c 24 88 00
	00 00		 add	 ecx, DWORD PTR tv1985[rsp]
  004bf	03 d1		 add	 edx, ecx

; 3891 :   MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);

  004c1	45 8d 93 70 bc
	bf be		 lea	 r10d, DWORD PTR [r11-1094730640]
  004c8	c1 c2 04	 rol	 edx, 4
  004cb	41 03 d3	 add	 edx, r11d
  004ce	33 c2		 xor	 eax, edx
  004d0	03 44 24 04	 add	 eax, DWORD PTR tv1982[rsp]
  004d4	44 03 c0	 add	 r8d, eax
  004d7	41 c1 c0 0b	 rol	 r8d, 11
  004db	44 03 c2	 add	 r8d, edx
  004de	41 8b c0	 mov	 eax, r8d
  004e1	41 8b c8	 mov	 ecx, r8d
  004e4	41 33 c3	 xor	 eax, r11d

; 3892 :   MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);

  004e7	44 8d 9a c6 7e
	9b 28		 lea	 r11d, DWORD PTR [rdx+681279174]
  004ee	33 c2		 xor	 eax, edx
  004f0	03 c5		 add	 eax, ebp
  004f2	44 03 c8	 add	 r9d, eax
  004f5	41 c1 c1 10	 rol	 r9d, 16
  004f9	45 03 c8	 add	 r9d, r8d
  004fc	41 33 c9	 xor	 ecx, r9d
  004ff	8b c1		 mov	 eax, ecx
  00501	33 c2		 xor	 eax, edx
  00503	41 03 c6	 add	 eax, r14d
  00506	44 03 d0	 add	 r10d, eax

; 3893 :   MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);

  00509	41 8b c1	 mov	 eax, r9d
  0050c	41 c1 ca 09	 ror	 r10d, 9
  00510	45 03 d1	 add	 r10d, r9d
  00513	41 33 c2	 xor	 eax, r10d
  00516	41 33 ca	 xor	 ecx, r10d
  00519	41 03 cf	 add	 ecx, r15d
  0051c	44 03 d9	 add	 r11d, ecx
  0051f	41 c1 c3 04	 rol	 r11d, 4
  00523	45 03 da	 add	 r11d, r10d
  00526	41 33 c3	 xor	 eax, r11d
  00529	05 fa 27 a1 ea	 add	 eax, -358537222		; eaa127faH
  0052e	03 44 24 78	 add	 eax, DWORD PTR tv1986[rsp]
  00532	44 03 c0	 add	 r8d, eax
  00535	41 c1 c0 0b	 rol	 r8d, 11
  00539	45 03 c3	 add	 r8d, r11d

; 3894 :   MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);

  0053c	41 8b c0	 mov	 eax, r8d

; 3895 :   MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);

  0053f	41 8b c8	 mov	 ecx, r8d
  00542	41 33 c2	 xor	 eax, r10d
  00545	41 33 c3	 xor	 eax, r11d
  00548	05 85 30 ef d4	 add	 eax, -722521979		; d4ef3085H
  0054d	03 84 24 80 00
	00 00		 add	 eax, DWORD PTR tv1983[rsp]
  00554	44 03 c8	 add	 r9d, eax
  00557	41 c1 c1 10	 rol	 r9d, 16
  0055b	45 03 c8	 add	 r9d, r8d
  0055e	41 33 c9	 xor	 ecx, r9d
  00561	8b c1		 mov	 eax, ecx
  00563	41 33 c3	 xor	 eax, r11d
  00566	41 8d 92 05 1d
	88 04		 lea	 edx, DWORD PTR [r10+76029189]
  0056d	03 04 24	 add	 eax, DWORD PTR tv1980[rsp]
  00570	03 d0		 add	 edx, eax

; 3896 :   MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
; 3897 :   MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);

  00572	41 8b c1	 mov	 eax, r9d
  00575	c1 ca 09	 ror	 edx, 9
  00578	41 03 d1	 add	 edx, r9d
  0057b	33 c2		 xor	 eax, edx
  0057d	33 ca		 xor	 ecx, edx
  0057f	03 4c 24 10	 add	 ecx, DWORD PTR tv1977[rsp]
  00583	44 8d 91 39 d0
	d4 d9		 lea	 r10d, DWORD PTR [rcx-640364487]
  0058a	41 8d 88 e5 99
	db e6		 lea	 ecx, DWORD PTR [r8-421815835]
  00591	45 03 d3	 add	 r10d, r11d

; 3898 :   MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);

  00594	45 8d 81 f8 7c
	a2 1f		 lea	 r8d, DWORD PTR [r9+530742520]
  0059b	41 c1 c2 04	 rol	 r10d, 4
  0059f	44 03 d2	 add	 r10d, edx

; 3899 :   MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);

  005a2	44 8d 8a 65 56
	ac c4		 lea	 r9d, DWORD PTR [rdx-995338651]
  005a9	41 33 c2	 xor	 eax, r10d
  005ac	03 c6		 add	 eax, esi
  005ae	03 c8		 add	 ecx, eax
  005b0	c1 c1 0b	 rol	 ecx, 11
  005b3	41 03 ca	 add	 ecx, r10d
  005b6	8b c1		 mov	 eax, ecx
  005b8	33 c2		 xor	 eax, edx

; 3900 : 
; 3901 :   MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);

  005ba	41 8d 92 44 22
	29 f4		 lea	 edx, DWORD PTR [r10-198630844]
  005c1	41 33 c2	 xor	 eax, r10d
  005c4	03 c3		 add	 eax, ebx
  005c6	44 03 c0	 add	 r8d, eax
  005c9	8b c1		 mov	 eax, ecx
  005cb	41 c1 c0 10	 rol	 r8d, 16
  005cf	44 03 c1	 add	 r8d, ecx
  005d2	41 33 c0	 xor	 eax, r8d
  005d5	41 33 c2	 xor	 eax, r10d

; 3902 :   MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);

  005d8	44 8d 91 97 ff
	2a 43		 lea	 r10d, DWORD PTR [rcx+1126891415]
  005df	03 44 24 0c	 add	 eax, DWORD PTR tv1984[rsp]
  005e3	44 03 c8	 add	 r9d, eax
  005e6	8b c1		 mov	 eax, ecx
  005e8	f7 d0		 not	 eax
  005ea	41 c1 c9 09	 ror	 r9d, 9
  005ee	45 03 c8	 add	 r9d, r8d

; 3903 :   MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);

  005f1	41 8d 88 a7 23
	94 ab		 lea	 ecx, DWORD PTR [r8-1416354905]
  005f8	41 0b c1	 or	 eax, r9d
  005fb	41 33 c0	 xor	 eax, r8d
  005fe	03 44 24 78	 add	 eax, DWORD PTR tv1986[rsp]
  00602	03 d0		 add	 edx, eax
  00604	41 8b c0	 mov	 eax, r8d
  00607	f7 d0		 not	 eax
  00609	c1 c2 06	 rol	 edx, 6
  0060c	41 03 d1	 add	 edx, r9d

; 3904 :   MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);

  0060f	45 8d 81 39 a0
	93 fc		 lea	 r8d, DWORD PTR [r9-57434055]
  00616	0b c2		 or	 eax, edx
  00618	41 33 c1	 xor	 eax, r9d
  0061b	03 c5		 add	 eax, ebp
  0061d	44 03 d0	 add	 r10d, eax
  00620	41 8b c1	 mov	 eax, r9d
  00623	f7 d0		 not	 eax
  00625	41 c1 c2 0a	 rol	 r10d, 10
  00629	44 03 d2	 add	 r10d, edx

; 3905 :   MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);

  0062c	44 8d 8a c3 59
	5b 65		 lea	 r9d, DWORD PTR [rdx+1700485571]
  00633	41 0b c2	 or	 eax, r10d
  00636	33 c2		 xor	 eax, edx
  00638	03 c7		 add	 eax, edi
  0063a	03 c8		 add	 ecx, eax
  0063c	8b c2		 mov	 eax, edx
  0063e	f7 d0		 not	 eax
  00640	c1 c1 0f	 rol	 ecx, 15
  00643	41 03 ca	 add	 ecx, r10d
  00646	0b c1		 or	 eax, ecx
  00648	41 33 c2	 xor	 eax, r10d
  0064b	41 03 c4	 add	 eax, r12d
  0064e	44 03 c0	 add	 r8d, eax
  00651	41 8b c2	 mov	 eax, r10d
  00654	f7 d0		 not	 eax
  00656	41 c1 c8 0b	 ror	 r8d, 11
  0065a	44 03 c1	 add	 r8d, ecx
  0065d	41 0b c0	 or	 eax, r8d
  00660	33 c1		 xor	 eax, ecx
  00662	03 c6		 add	 eax, esi
  00664	44 03 c8	 add	 r9d, eax
  00667	41 c1 c1 06	 rol	 r9d, 6
  0066b	45 03 c8	 add	 r9d, r8d

; 3906 :   MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);

  0066e	41 8d 92 92 cc
	0c 8f		 lea	 edx, DWORD PTR [r10-1894986606]
  00675	8b c1		 mov	 eax, ecx
  00677	f7 d0		 not	 eax

; 3907 :   MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);

  00679	44 8d 91 7d f4
	ef ff		 lea	 r10d, DWORD PTR [rcx-1051523]
  00680	41 0b c1	 or	 eax, r9d

; 3908 :   MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);

  00683	41 8d 88 d1 5d
	84 85		 lea	 ecx, DWORD PTR [r8-2054922799]
  0068a	41 33 c0	 xor	 eax, r8d
  0068d	03 84 24 80 00
	00 00		 add	 eax, DWORD PTR tv1983[rsp]
  00694	03 d0		 add	 edx, eax
  00696	41 8b c0	 mov	 eax, r8d
  00699	f7 d0		 not	 eax
  0069b	c1 c2 0a	 rol	 edx, 10
  0069e	41 03 d1	 add	 edx, r9d

; 3909 :   MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);

  006a1	45 8d 81 4f 7e
	a8 6f		 lea	 r8d, DWORD PTR [r9+1873313359]
  006a8	0b c2		 or	 eax, edx
  006aa	41 33 c1	 xor	 eax, r9d
  006ad	41 03 c6	 add	 eax, r14d
  006b0	44 03 d0	 add	 r10d, eax
  006b3	41 8b c1	 mov	 eax, r9d
  006b6	f7 d0		 not	 eax
  006b8	41 c1 c2 0f	 rol	 r10d, 15
  006bc	44 03 d2	 add	 r10d, edx
  006bf	41 0b c2	 or	 eax, r10d

; 3910 :   MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);

  006c2	45 8b ca	 mov	 r9d, r10d
  006c5	33 c2		 xor	 eax, edx
  006c7	41 f7 d1	 not	 r9d
  006ca	03 84 24 88 00
	00 00		 add	 eax, DWORD PTR tv1985[rsp]
  006d1	03 c8		 add	 ecx, eax

; 3911 :   MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);

  006d3	45 8d 9a 14 43
	01 a3		 lea	 r11d, DWORD PTR [r10-1560198380]
  006da	8b c2		 mov	 eax, edx
  006dc	c1 c9 0b	 ror	 ecx, 11
  006df	f7 d0		 not	 eax
  006e1	41 03 ca	 add	 ecx, r10d
  006e4	0b c1		 or	 eax, ecx
  006e6	41 33 c2	 xor	 eax, r10d
  006e9	41 03 c5	 add	 eax, r13d
  006ec	44 03 c0	 add	 r8d, eax

; 3912 :   MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);

  006ef	44 8d 91 a1 11
	08 4e		 lea	 r10d, DWORD PTR [rcx+1309151649]
  006f6	41 c1 c0 06	 rol	 r8d, 6
  006fa	8b c1		 mov	 eax, ecx
  006fc	f7 d0		 not	 eax
  006fe	44 03 c1	 add	 r8d, ecx
  00701	45 0b c8	 or	 r9d, r8d
  00704	44 33 c9	 xor	 r9d, ecx
  00707	41 81 c1 e0 e6
	2c fe		 add	 r9d, -30611744		; fe2ce6e0H
  0070e	44 03 cb	 add	 r9d, ebx
  00711	44 03 ca	 add	 r9d, edx
  00714	41 c1 c1 0a	 rol	 r9d, 10
  00718	45 03 c8	 add	 r9d, r8d
  0071b	41 0b c1	 or	 eax, r9d
  0071e	41 33 c0	 xor	 eax, r8d
  00721	03 04 24	 add	 eax, DWORD PTR tv1980[rsp]
  00724	44 03 d8	 add	 r11d, eax

; 3913 :   MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
; 3914 :   MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);

  00727	41 8d 91 35 f2
	3a bd		 lea	 edx, DWORD PTR [r9-1120210379]
  0072e	41 8b c0	 mov	 eax, r8d
  00731	41 c1 c3 0f	 rol	 r11d, 15
  00735	f7 d0		 not	 eax
  00737	45 03 d9	 add	 r11d, r9d
  0073a	41 0b c3	 or	 eax, r11d
  0073d	41 33 c1	 xor	 eax, r9d
  00740	41 03 c7	 add	 eax, r15d
  00743	44 03 d0	 add	 r10d, eax
  00746	41 8b c1	 mov	 eax, r9d
  00749	f7 d0		 not	 eax
  0074b	41 c1 ca 0b	 ror	 r10d, 11
  0074f	45 03 d3	 add	 r10d, r11d
  00752	41 0b c2	 or	 eax, r10d
  00755	41 33 c3	 xor	 eax, r11d
  00758	05 82 7e 53 f7	 add	 eax, -145523070		; f7537e82H
  0075d	03 44 24 04	 add	 eax, DWORD PTR tv1982[rsp]
  00761	44 03 c0	 add	 r8d, eax
  00764	41 8b c3	 mov	 eax, r11d
  00767	f7 d0		 not	 eax
  00769	41 c1 c0 06	 rol	 r8d, 6
  0076d	45 03 c2	 add	 r8d, r10d
  00770	41 0b c0	 or	 eax, r8d
  00773	41 33 c2	 xor	 eax, r10d
  00776	03 44 24 08	 add	 eax, DWORD PTR tv1975[rsp]
  0077a	03 d0		 add	 edx, eax
  0077c	c1 c2 0a	 rol	 edx, 10
  0077f	41 03 d0	 add	 edx, r8d

; 3915 :   MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
; 3916 :   MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);
; 3917 : 
; 3918 :   buf[0] += a;

  00782	4c 8b 4c 24 70	 mov	 r9, QWORD PTR buf$[rsp]
  00787	41 8d 82 91 d3
	86 eb		 lea	 eax, DWORD PTR [r10-343485551]
  0078e	41 8b ca	 mov	 ecx, r10d
  00791	f7 d1		 not	 ecx
  00793	0b ca		 or	 ecx, edx
  00795	45 01 01	 add	 DWORD PTR [r9], r8d
  00798	41 33 c8	 xor	 ecx, r8d
  0079b	81 c1 bb d2 d7
	2a		 add	 ecx, 718787259		; 2ad7d2bbH
  007a1	41 f7 d0	 not	 r8d
  007a4	03 4c 24 0c	 add	 ecx, DWORD PTR tv1984[rsp]
  007a8	41 03 cb	 add	 ecx, r11d
  007ab	c1 c1 0f	 rol	 ecx, 15
  007ae	03 ca		 add	 ecx, edx

; 3919 :   buf[1] += b;
; 3920 :   buf[2] += c;

  007b0	41 01 49 08	 add	 DWORD PTR [r9+8], ecx
  007b4	44 0b c1	 or	 r8d, ecx
  007b7	44 33 c2	 xor	 r8d, edx
  007ba	44 03 44 24 10	 add	 r8d, DWORD PTR tv1977[rsp]
  007bf	41 03 c0	 add	 eax, r8d
  007c2	c1 c8 0b	 ror	 eax, 11
  007c5	41 03 41 04	 add	 eax, DWORD PTR [r9+4]
  007c9	03 c1		 add	 eax, ecx

; 3921 :   buf[3] += d;

  007cb	41 01 51 0c	 add	 DWORD PTR [r9+12], edx
  007cf	41 89 41 04	 mov	 DWORD PTR [r9+4], eax

; 3922 : }

  007d3	48 83 c4 28	 add	 rsp, 40			; 00000028H
  007d7	41 5f		 pop	 r15
  007d9	41 5e		 pop	 r14
  007db	41 5d		 pop	 r13
  007dd	41 5c		 pop	 r12
  007df	5f		 pop	 rdi
  007e0	5e		 pop	 rsi
  007e1	5d		 pop	 rbp
  007e2	5b		 pop	 rbx
  007e3	c3		 ret	 0
mg_md5_transform ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_md5_update
_TEXT	SEGMENT
ctx$ = 48
buf$ = 56
len$ = 64
mg_md5_update PROC					; COMDAT

; 3924 : void mg_md5_update(mg_md5_ctx *ctx, const unsigned char *buf, size_t len) {

$LN17:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	48 8b fa	 mov	 rdi, rdx
  0001c	49 8b d8	 mov	 rbx, r8

; 3925 :   uint32_t t;
; 3926 : 
; 3927 :   t = ctx->bits[0];

  0001f	8b 51 10	 mov	 edx, DWORD PTR [rcx+16]
  00022	48 8b f1	 mov	 rsi, rcx

; 3928 :   if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t) ctx->bits[1]++;

  00025	42 8d 04 c2	 lea	 eax, DWORD PTR [rdx+r8*8]
  00029	89 41 10	 mov	 DWORD PTR [rcx+16], eax
  0002c	3b c2		 cmp	 eax, edx
  0002e	73 03		 jae	 SHORT $LN14@mg_md5_upd
  00030	ff 41 14	 inc	 DWORD PTR [rcx+20]
$LN14@mg_md5_upd:

; 3929 :   ctx->bits[1] += (uint32_t) len >> 29;

  00033	8b c3		 mov	 eax, ebx

; 3930 : 
; 3931 :   t = (t >> 3) & 0x3f;

  00035	c1 ea 03	 shr	 edx, 3
  00038	c1 e8 1d	 shr	 eax, 29
  0003b	01 41 14	 add	 DWORD PTR [rcx+20], eax
  0003e	83 e2 3f	 and	 edx, 63			; 0000003fH

; 3932 : 
; 3933 :   if (t) {

  00041	74 39		 je	 SHORT $LN12@mg_md5_upd

; 3934 :     unsigned char *p = (unsigned char *) ctx->in + t;

  00043	8b ca		 mov	 ecx, edx

; 3935 : 
; 3936 :     t = 64 - t;

  00045	41 be 40 00 00
	00		 mov	 r14d, 64		; 00000040H
  0004b	48 83 c1 18	 add	 rcx, 24
  0004f	44 2b f2	 sub	 r14d, edx
  00052	48 03 ce	 add	 rcx, rsi

; 3937 :     if (len < t) {

  00055	48 8b d7	 mov	 rdx, rdi
  00058	49 3b de	 cmp	 rbx, r14
  0005b	72 74		 jb	 SHORT $LN15@mg_md5_upd

; 3938 :       memcpy(p, buf, len);
; 3939 :       return;
; 3940 :     }
; 3941 :     memcpy(p, buf, t);

  0005d	45 8b c6	 mov	 r8d, r14d
  00060	e8 00 00 00 00	 call	 memcpy

; 3942 :     mg_byte_reverse(ctx->in, 16);
; 3943 :     mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);

  00065	48 8d 6e 18	 lea	 rbp, QWORD PTR [rsi+24]
  00069	48 8b ce	 mov	 rcx, rsi
  0006c	48 8b d5	 mov	 rdx, rbp
  0006f	e8 00 00 00 00	 call	 mg_md5_transform

; 3944 :     buf += t;

  00074	49 03 fe	 add	 rdi, r14

; 3945 :     len -= t;

  00077	49 2b de	 sub	 rbx, r14
  0007a	eb 04		 jmp	 SHORT $LN8@mg_md5_upd
$LN12@mg_md5_upd:
  0007c	48 8d 69 18	 lea	 rbp, QWORD PTR [rcx+24]
$LN8@mg_md5_upd:

; 3946 :   }
; 3947 : 
; 3948 :   while (len >= 64) {

  00080	48 83 fb 40	 cmp	 rbx, 64			; 00000040H
  00084	72 42		 jb	 SHORT $LN3@mg_md5_upd
  00086	4c 8b f3	 mov	 r14, rbx
  00089	49 c1 ee 06	 shr	 r14, 6
  0008d	49 6b c6 c0	 imul	 rax, r14, -64		; ffffffffffffffc0H
  00091	48 03 d8	 add	 rbx, rax
$LL2@mg_md5_upd:

; 3949 :     memcpy(ctx->in, buf, 64);

  00094	0f 10 07	 movups	 xmm0, XMMWORD PTR [rdi]

; 3950 :     mg_byte_reverse(ctx->in, 16);
; 3951 :     mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);

  00097	48 8b d5	 mov	 rdx, rbp
  0009a	48 8b ce	 mov	 rcx, rsi
  0009d	0f 11 45 00	 movups	 XMMWORD PTR [rbp], xmm0
  000a1	0f 10 4f 10	 movups	 xmm1, XMMWORD PTR [rdi+16]
  000a5	0f 11 4d 10	 movups	 XMMWORD PTR [rbp+16], xmm1
  000a9	0f 10 47 20	 movups	 xmm0, XMMWORD PTR [rdi+32]
  000ad	0f 11 45 20	 movups	 XMMWORD PTR [rbp+32], xmm0
  000b1	0f 10 4f 30	 movups	 xmm1, XMMWORD PTR [rdi+48]
  000b5	0f 11 4d 30	 movups	 XMMWORD PTR [rbp+48], xmm1
  000b9	e8 00 00 00 00	 call	 mg_md5_transform

; 3952 :     buf += 64;

  000be	48 83 c7 40	 add	 rdi, 64			; 00000040H
  000c2	49 83 ee 01	 sub	 r14, 1
  000c6	75 cc		 jne	 SHORT $LL2@mg_md5_upd
$LN3@mg_md5_upd:

; 3953 :     len -= 64;
; 3954 :   }
; 3955 : 
; 3956 :   memcpy(ctx->in, buf, len);

  000c8	4c 8b c3	 mov	 r8, rbx
  000cb	48 8b d7	 mov	 rdx, rdi
  000ce	48 8b cd	 mov	 rcx, rbp
$LN15@mg_md5_upd:

; 3957 : }

  000d1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000d6	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000db	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000e0	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000e5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e9	41 5e		 pop	 r14
  000eb	e9 00 00 00 00	 jmp	 memcpy
mg_md5_update ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_md5_final
_TEXT	SEGMENT
ctx$ = 48
digest$ = 56
mg_md5_final PROC					; COMDAT

; 3959 : void mg_md5_final(mg_md5_ctx *ctx, unsigned char digest[16]) {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3960 :   unsigned count;
; 3961 :   unsigned char *p;
; 3962 :   uint32_t *a;
; 3963 : 
; 3964 :   count = (ctx->bits[0] >> 3) & 0x3F;

  0000f	44 8b 41 10	 mov	 r8d, DWORD PTR [rcx+16]
  00013	48 8b d9	 mov	 rbx, rcx
  00016	41 c1 e8 03	 shr	 r8d, 3
  0001a	41 b9 3f 00 00
	00		 mov	 r9d, 63			; 0000003fH
  00020	45 23 c1	 and	 r8d, r9d
  00023	48 8b f2	 mov	 rsi, rdx

; 3965 : 
; 3966 :   p = ctx->in + count;

  00026	41 8b c8	 mov	 ecx, r8d

; 3967 :   *p++ = 0x80;
; 3968 :   count = 64 - 1 - count;

  00029	45 2b c8	 sub	 r9d, r8d
  0002c	48 03 cb	 add	 rcx, rbx

; 3969 :   if (count < 8) {

  0002f	33 d2		 xor	 edx, edx
  00031	c6 41 18 80	 mov	 BYTE PTR [rcx+24], 128	; 00000080H
  00035	48 83 c1 19	 add	 rcx, 25
  00039	41 83 f9 08	 cmp	 r9d, 8
  0003d	73 2d		 jae	 SHORT $LN2@mg_md5_fin

; 3970 :     memset(p, 0, count);

  0003f	45 8b c1	 mov	 r8d, r9d
  00042	e8 00 00 00 00	 call	 memset

; 3971 :     mg_byte_reverse(ctx->in, 16);
; 3972 :     mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);

  00047	48 8d 7b 18	 lea	 rdi, QWORD PTR [rbx+24]
  0004b	48 8b cb	 mov	 rcx, rbx
  0004e	48 8b d7	 mov	 rdx, rdi
  00051	e8 00 00 00 00	 call	 mg_md5_transform
  00056	0f 57 c0	 xorps	 xmm0, xmm0

; 3973 :     memset(ctx->in, 0, 56);

  00059	33 c0		 xor	 eax, eax
  0005b	0f 11 07	 movups	 XMMWORD PTR [rdi], xmm0
  0005e	0f 11 47 10	 movups	 XMMWORD PTR [rdi+16], xmm0
  00062	0f 11 47 20	 movups	 XMMWORD PTR [rdi+32], xmm0
  00066	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax

; 3974 :   } else {

  0006a	eb 0d		 jmp	 SHORT $LN3@mg_md5_fin
$LN2@mg_md5_fin:

; 3975 :     memset(p, 0, count - 8);

  0006c	45 8d 41 f8	 lea	 r8d, DWORD PTR [r9-8]
  00070	e8 00 00 00 00	 call	 memset
  00075	48 8d 7b 18	 lea	 rdi, QWORD PTR [rbx+24]
$LN3@mg_md5_fin:

; 3976 :   }
; 3977 :   mg_byte_reverse(ctx->in, 14);
; 3978 : 
; 3979 :   a = (uint32_t *) ctx->in;
; 3980 :   a[14] = ctx->bits[0];

  00079	8b 43 10	 mov	 eax, DWORD PTR [rbx+16]

; 3981 :   a[15] = ctx->bits[1];
; 3982 : 
; 3983 :   mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);

  0007c	48 8b d7	 mov	 rdx, rdi
  0007f	89 43 50	 mov	 DWORD PTR [rbx+80], eax
  00082	48 8b cb	 mov	 rcx, rbx
  00085	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  00088	89 43 54	 mov	 DWORD PTR [rbx+84], eax
  0008b	e8 00 00 00 00	 call	 mg_md5_transform

; 3984 :   mg_byte_reverse((unsigned char *) ctx->buf, 4);
; 3985 :   memcpy(digest, ctx->buf, 16);

  00090	0f 10 03	 movups	 xmm0, XMMWORD PTR [rbx]

; 3986 :   memset((char *) ctx, 0, sizeof(*ctx));

  00093	33 d2		 xor	 edx, edx
  00095	48 8b cb	 mov	 rcx, rbx
  00098	f3 0f 7f 06	 movdqu	 XMMWORD PTR [rsi], xmm0
  0009c	44 8d 42 58	 lea	 r8d, QWORD PTR [rdx+88]

; 3987 : }

  000a0	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a5	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000aa	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ae	5f		 pop	 rdi

; 3986 :   memset((char *) ctx, 0, sizeof(*ctx));

  000af	e9 00 00 00 00	 jmp	 memset
mg_md5_final ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_mqtt_send_header
_TEXT	SEGMENT
buf$ = 32
c$ = 64
cmd$ = 72
flags$ = 80
len$ = 88
mg_mqtt_send_header PROC				; COMDAT

; 4042 :                          uint32_t len) {

$LN13:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4043 :   uint8_t buf[1 + sizeof(len)], *vlen = &buf[1];
; 4044 :   buf[0] = (uint8_t) ((cmd << 4) | flags);

  00004	c0 e2 04	 shl	 dl, 4
  00007	4c 8d 54 24 21	 lea	 r10, QWORD PTR buf$[rsp+1]
  0000c	41 0a d0	 or	 dl, r8b
  0000f	88 54 24 20	 mov	 BYTE PTR buf$[rsp], dl
$LL4@mg_mqtt_se:

; 4045 :   do {
; 4046 :     *vlen = len % 0x80;

  00013	41 8a c1	 mov	 al, r9b

; 4047 :     len /= 0x80;

  00016	41 c1 e9 07	 shr	 r9d, 7
  0001a	24 7f		 and	 al, 127			; 0000007fH
  0001c	41 88 02	 mov	 BYTE PTR [r10], al
  0001f	8a d0		 mov	 dl, al

; 4048 :     if (len > 0) *vlen |= 0x80;

  00021	45 85 c9	 test	 r9d, r9d
  00024	74 15		 je	 SHORT $LN5@mg_mqtt_se
  00026	80 ca 80	 or	 dl, 128			; 00000080H

; 4050 :   } while (len > 0 && vlen < &buf[sizeof(buf)]);

  00029	48 8d 44 24 25	 lea	 rax, QWORD PTR buf$[rsp+5]
  0002e	41 88 12	 mov	 BYTE PTR [r10], dl
  00031	49 ff c2	 inc	 r10
  00034	4c 3b d0	 cmp	 r10, rax
  00037	72 da		 jb	 SHORT $LL4@mg_mqtt_se
  00039	eb 03		 jmp	 SHORT $LN6@mg_mqtt_se
$LN5@mg_mqtt_se:

; 4049 :     vlen++;

  0003b	49 ff c2	 inc	 r10
$LN6@mg_mqtt_se:

; 4051 :   mg_send(c, buf, (size_t) (vlen - buf));

  0003e	48 8d 44 24 20	 lea	 rax, QWORD PTR buf$[rsp]
  00043	4c 2b d0	 sub	 r10, rax
  00046	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$[rsp]
  0004b	4d 8b c2	 mov	 r8, r10
  0004e	e8 00 00 00 00	 call	 mg_send

; 4052 : }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
mg_mqtt_send_header ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_send_u16
_TEXT	SEGMENT
c$ = 48
value$ = 56
mg_send_u16 PROC					; COMDAT

; 4054 : static void mg_send_u16(struct mg_connection *c, uint16_t value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4055 :   mg_send(c, &value, sizeof(value));

  00009	41 b8 02 00 00
	00		 mov	 r8d, 2
  0000f	48 8d 54 24 38	 lea	 rdx, QWORD PTR value$[rsp]
  00014	e8 00 00 00 00	 call	 mg_send

; 4056 : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
mg_send_u16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_send_u32
_TEXT	SEGMENT
c$ = 48
value$ = 56
mg_send_u32 PROC					; COMDAT

; 4058 : static void mg_send_u32(struct mg_connection *c, uint32_t value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4059 :   mg_send(c, &value, sizeof(value));

  00008	41 b8 04 00 00
	00		 mov	 r8d, 4
  0000e	48 8d 54 24 38	 lea	 rdx, QWORD PTR value$[rsp]
  00013	e8 00 00 00 00	 call	 mg_send

; 4060 : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
mg_send_u32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT varint_size
_TEXT	SEGMENT
length$ = 8
varint_size PROC					; COMDAT

; 4063 :   uint8_t bytes_needed = 0;

  00000	32 c0		 xor	 al, al
$LL4@varint_siz:

; 4064 :   do {
; 4065 :     bytes_needed++;

  00002	fe c0		 inc	 al

; 4066 :     length /= 0x80;

  00004	48 c1 e9 07	 shr	 rcx, 7

; 4067 :   } while (length > 0);

  00008	48 85 c9	 test	 rcx, rcx
  0000b	75 f5		 jne	 SHORT $LL4@varint_siz

; 4068 :   return bytes_needed;
; 4069 : }

  0000d	c3		 ret	 0
varint_size ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT encode_varint
_TEXT	SEGMENT
buf$ = 8
value$ = 16
encode_varint PROC					; COMDAT

; 4071 : static size_t encode_varint(uint8_t *buf, size_t value) {

  00000	4c 8b da	 mov	 r11, rdx

; 4072 :   size_t len = 0;

  00003	45 33 d2	 xor	 r10d, r10d
$LL4@encode_var:

; 4073 : 
; 4074 :   do {
; 4075 :     uint8_t byte = (uint8_t) (value % 128);

  00006	41 8a c3	 mov	 al, r11b

; 4076 :     value /= 128;

  00009	49 c1 eb 07	 shr	 r11, 7
  0000d	24 7f		 and	 al, 127			; 0000007fH
  0000f	44 0f b6 c8	 movzx	 r9d, al

; 4077 :     if (value > 0) byte |= 0x80;
; 4078 :     buf[len++] = byte;

  00013	45 8a c1	 mov	 r8b, r9b
  00016	41 80 c8 80	 or	 r8b, 128		; 00000080H
  0001a	4d 85 db	 test	 r11, r11
  0001d	41 0f b6 d0	 movzx	 edx, r8b
  00021	41 0f 44 d1	 cmove	 edx, r9d
  00025	41 88 14 0a	 mov	 BYTE PTR [r10+rcx], dl
  00029	49 ff c2	 inc	 r10

; 4079 :   } while (value > 0);

  0002c	4d 85 db	 test	 r11, r11
  0002f	75 d5		 jne	 SHORT $LL4@encode_var

; 4080 : 
; 4081 :   return len;

  00031	49 8b c2	 mov	 rax, r10

; 4082 : }

  00034	c3		 ret	 0
encode_varint ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT decode_varint
_TEXT	SEGMENT
buf$ = 8
len$ = 16
value$ = 24
decode_varint PROC					; COMDAT

; 4084 : static size_t decode_varint(const uint8_t *buf, size_t len, size_t *value) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 4085 :   size_t multiplier = 1, offset;
; 4086 :   *value = 0;

  00005	49 83 20 00	 and	 QWORD PTR [r8], 0

; 4087 : 
; 4088 :   for (offset = 0; offset < 4 && offset < len; offset++) {

  00009	45 33 c9	 xor	 r9d, r9d
  0000c	33 db		 xor	 ebx, ebx
  0000e	4d 8b d8	 mov	 r11, r8
  00011	41 ba 01 00 00
	00		 mov	 r10d, 1
$LL4@decode_var:
  00017	4c 3b ca	 cmp	 r9, rdx
  0001a	73 2a		 jae	 SHORT $LN3@decode_var

; 4089 :     uint8_t encoded_byte = buf[offset];

  0001c	45 0f b6 04 09	 movzx	 r8d, BYTE PTR [r9+rcx]

; 4090 :     *value += (encoded_byte & 0x7f) * multiplier;

  00021	41 8b c0	 mov	 eax, r8d
  00024	83 e0 7f	 and	 eax, 127		; 0000007fH
  00027	49 0f af c2	 imul	 rax, r10

; 4091 :     multiplier *= 128;

  0002b	49 c1 e2 07	 shl	 r10, 7
  0002f	48 03 c3	 add	 rax, rbx

; 4092 : 
; 4093 :     if ((encoded_byte & 0x80) == 0) return offset + 1;

  00032	49 ff c1	 inc	 r9
  00035	49 89 03	 mov	 QWORD PTR [r11], rax
  00038	48 8b d8	 mov	 rbx, rax
  0003b	45 84 c0	 test	 r8b, r8b
  0003e	79 0e		 jns	 SHORT $LN8@decode_var

; 4087 : 
; 4088 :   for (offset = 0; offset < 4 && offset < len; offset++) {

  00040	49 83 f9 04	 cmp	 r9, 4
  00044	72 d1		 jb	 SHORT $LL4@decode_var
$LN3@decode_var:

; 4094 :   }
; 4095 : 
; 4096 :   return 0;

  00046	33 c0		 xor	 eax, eax
$LN1@decode_var:

; 4097 : }

  00048	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0004d	c3		 ret	 0
$LN8@decode_var:

; 4092 : 
; 4093 :     if ((encoded_byte & 0x80) == 0) return offset + 1;

  0004e	49 8b c1	 mov	 rax, r9
  00051	eb f5		 jmp	 SHORT $LN1@decode_var
decode_varint ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mqtt_prop_type_by_id
_TEXT	SEGMENT
prop_id$ = 8
mqtt_prop_type_by_id PROC				; COMDAT

; 4100 :   size_t i, num_properties = sizeof(s_prop_map) / sizeof(s_prop_map[0]);
; 4101 :   for (i = 0; i < num_properties; ++i) {

  00000	33 c0		 xor	 eax, eax
  00002	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:s_prop_map
$LL4@mqtt_prop_:

; 4102 :     if (s_prop_map[i].id == prop_id) return s_prop_map[i].type;

  00009	38 0c 42	 cmp	 BYTE PTR [rdx+rax*2], cl
  0000c	74 0d		 je	 SHORT $LN8@mqtt_prop_

; 4100 :   size_t i, num_properties = sizeof(s_prop_map) / sizeof(s_prop_map[0]);
; 4101 :   for (i = 0; i < num_properties; ++i) {

  0000e	48 ff c0	 inc	 rax
  00011	48 83 f8 1b	 cmp	 rax, 27
  00015	72 f2		 jb	 SHORT $LL4@mqtt_prop_

; 4103 :   }
; 4104 :   return -1;  // Property ID not found

  00017	83 c8 ff	 or	 eax, -1

; 4105 : }

  0001a	c3		 ret	 0
$LN8@mqtt_prop_:

; 4102 :     if (s_prop_map[i].id == prop_id) return s_prop_map[i].type;

  0001b	0f b6 44 42 01	 movzx	 eax, BYTE PTR [rdx+rax*2+1]

; 4105 : }

  00020	c3		 ret	 0
mqtt_prop_type_by_id ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT get_properties_length
_TEXT	SEGMENT
props$ = 48
count$ = 56
get_properties_length PROC				; COMDAT

; 4109 : static size_t get_properties_length(struct mg_mqtt_prop *props, size_t count) {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4110 :   size_t i, size = 0;

  00004	45 33 c0	 xor	 r8d, r8d

; 4111 :   for (i = 0; i < count; i++) {

  00007	45 33 d2	 xor	 r10d, r10d
  0000a	4c 8b da	 mov	 r11, rdx
  0000d	48 85 d2	 test	 rdx, rdx
  00010	74 7e		 je	 SHORT $LN28@get_proper
  00012	4c 8d 49 20	 lea	 r9, QWORD PTR [rcx+32]
$LL4@get_proper:

; 4112 :     size++;  // identifier
; 4113 :     switch (mqtt_prop_type_by_id(props[i].id)) {

  00016	41 8a 49 e0	 mov	 cl, BYTE PTR [r9-32]
  0001a	49 ff c0	 inc	 r8
  0001d	e8 00 00 00 00	 call	 mqtt_prop_type_by_id
  00022	8b c8		 mov	 ecx, eax
  00024	85 c0		 test	 eax, eax
  00026	74 54		 je	 SHORT $LN13@get_proper
  00028	83 e9 01	 sub	 ecx, 1
  0002b	74 47		 je	 SHORT $LN8@get_proper
  0002d	83 e9 01	 sub	 ecx, 1
  00030	74 36		 je	 SHORT $LN7@get_proper
  00032	83 e9 01	 sub	 ecx, 1
  00035	74 3d		 je	 SHORT $LN8@get_proper
  00037	83 e9 01	 sub	 ecx, 1
  0003a	74 16		 je	 SHORT $LN10@get_proper
  0003c	83 e9 01	 sub	 ecx, 1
  0003f	74 0a		 je	 SHORT $LN11@get_proper
  00041	83 f9 01	 cmp	 ecx, 1
  00044	75 4a		 jne	 SHORT $LN28@get_proper

; 4130 :       case MQTT_PROP_TYPE_SHORT:
; 4131 :         size += (uint32_t) sizeof(uint16_t);

  00046	8d 41 01	 lea	 eax, QWORD PTR [rcx+1]

; 4132 :         break;

  00049	eb 36		 jmp	 SHORT $LN2@get_proper
$LN11@get_proper:

; 4127 :       case MQTT_PROP_TYPE_INT:
; 4128 :         size += (uint32_t) sizeof(uint32_t);

  0004b	b8 04 00 00 00	 mov	 eax, 4

; 4129 :         break;

  00050	eb 2f		 jmp	 SHORT $LN2@get_proper
$LN10@get_proper:

; 4118 :       case MQTT_PROP_TYPE_STRING:
; 4119 :         size += (uint32_t) (props[i].val.len + sizeof(uint16_t));
; 4120 :         break;
; 4121 :       case MQTT_PROP_TYPE_BINARY_DATA:
; 4122 :         size += (uint32_t) (props[i].val.len + sizeof(uint16_t));
; 4123 :         break;
; 4124 :       case MQTT_PROP_TYPE_VARIABLE_INT:
; 4125 :         size += varint_size((uint32_t) props[i].iv);

  00052	41 8b 41 e4	 mov	 eax, DWORD PTR [r9-28]

; 4063 :   uint8_t bytes_needed = 0;

  00056	32 c9		 xor	 cl, cl
$LL19@get_proper:

; 4064 :   do {
; 4065 :     bytes_needed++;

  00058	fe c1		 inc	 cl

; 4066 :     length /= 0x80;

  0005a	48 c1 e8 07	 shr	 rax, 7

; 4067 :   } while (length > 0);

  0005e	48 85 c0	 test	 rax, rax
  00061	75 f5		 jne	 SHORT $LL19@get_proper

; 4126 :         break;

  00063	0f b6 c1	 movzx	 eax, cl
  00066	eb 19		 jmp	 SHORT $LN2@get_proper
$LN7@get_proper:

; 4114 :       case MQTT_PROP_TYPE_STRING_PAIR:
; 4115 :         size += (uint32_t) (props[i].val.len + props[i].key.len +

  00068	41 8b 01	 mov	 eax, DWORD PTR [r9]
  0006b	83 c0 04	 add	 eax, 4
  0006e	41 03 41 f0	 add	 eax, DWORD PTR [r9-16]

; 4116 :                             2 * sizeof(uint16_t));
; 4117 :         break;

  00072	eb 0d		 jmp	 SHORT $LN2@get_proper
$LN8@get_proper:

; 4111 :   for (i = 0; i < count; i++) {

  00074	41 8b 01	 mov	 eax, DWORD PTR [r9]
  00077	83 c0 02	 add	 eax, 2
  0007a	eb 05		 jmp	 SHORT $LN2@get_proper
$LN13@get_proper:

; 4133 :       case MQTT_PROP_TYPE_BYTE:
; 4134 :         size += (uint32_t) sizeof(uint8_t);

  0007c	b8 01 00 00 00	 mov	 eax, 1
$LN2@get_proper:

; 4111 :   for (i = 0; i < count; i++) {

  00081	4c 03 c0	 add	 r8, rax
  00084	49 ff c2	 inc	 r10
  00087	49 83 c1 28	 add	 r9, 40			; 00000028H
  0008b	4d 3b d3	 cmp	 r10, r11
  0008e	72 86		 jb	 SHORT $LL4@get_proper
$LN28@get_proper:

; 4135 :         break;
; 4136 :       default:
; 4137 :         return size;  // cannot parse further down
; 4138 :     }
; 4139 :   }
; 4140 : 
; 4141 :   return size;
; 4142 : }

  00090	49 8b c0	 mov	 rax, r8
  00093	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00097	c3		 ret	 0
get_properties_length ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT get_props_size
_TEXT	SEGMENT
props$ = 48
count$ = 56
get_props_size PROC					; COMDAT

; 4146 : static size_t get_props_size(struct mg_mqtt_prop *props, size_t count) {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4147 :   size_t size = get_properties_length(props, count);

  00004	e8 00 00 00 00	 call	 get_properties_length
  00009	4c 8b c0	 mov	 r8, rax

; 4148 :   size += varint_size(size);

  0000c	48 8b d0	 mov	 rdx, rax

; 4063 :   uint8_t bytes_needed = 0;

  0000f	32 c9		 xor	 cl, cl
$LL6@get_props_:

; 4064 :   do {
; 4065 :     bytes_needed++;

  00011	fe c1		 inc	 cl

; 4066 :     length /= 0x80;

  00013	48 c1 ea 07	 shr	 rdx, 7

; 4067 :   } while (length > 0);

  00017	48 85 d2	 test	 rdx, rdx
  0001a	75 f5		 jne	 SHORT $LL6@get_props_

; 4148 :   size += varint_size(size);

  0001c	0f b6 c1	 movzx	 eax, cl
  0001f	49 03 c0	 add	 rax, r8

; 4149 :   return size;
; 4150 : }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
get_props_size ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_send_mqtt_properties
_TEXT	SEGMENT
buf_v$ = 32
c$ = 96
props$ = 104
value$ = 112
value$ = 112
value$ = 112
value$ = 112
nprops$ = 112
buf$ = 120
mg_send_mqtt_properties PROC				; COMDAT

; 4153 :                                     struct mg_mqtt_prop *props, size_t nprops) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 55		 push	 r13
  0000a	41 56		 push	 r14
  0000c	48 8b ec	 mov	 rbp, rsp
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fa	 mov	 rdi, rdx
  00016	48 8b f1	 mov	 rsi, rcx

; 4154 :   size_t total_size = get_properties_length(props, nprops);

  00019	48 8b cf	 mov	 rcx, rdi
  0001c	49 8b d0	 mov	 rdx, r8
  0001f	4d 8b f0	 mov	 r14, r8
  00022	e8 00 00 00 00	 call	 get_properties_length

; 4155 :   uint8_t buf_v[4] = {0, 0, 0, 0};

  00027	83 65 f0 00	 and	 DWORD PTR buf_v$[rbp-48], 0

; 4156 :   uint8_t buf[4] = {0, 0, 0, 0};
; 4157 :   size_t i, len = encode_varint(buf, total_size);

  0002b	48 8d 4d 48	 lea	 rcx, QWORD PTR buf$[rbp-48]
  0002f	83 65 48 00	 and	 DWORD PTR buf$[rbp-48], 0
  00033	48 8b d0	 mov	 rdx, rax
  00036	e8 00 00 00 00	 call	 encode_varint

; 4158 : 
; 4159 :   mg_send(c, buf, (size_t) len);

  0003b	4c 8b c0	 mov	 r8, rax
  0003e	48 8d 55 48	 lea	 rdx, QWORD PTR buf$[rbp-48]
  00042	48 8b ce	 mov	 rcx, rsi
  00045	e8 00 00 00 00	 call	 mg_send

; 4160 :   for (i = 0; i < nprops; i++) {

  0004a	4d 85 f6	 test	 r14, r14
  0004d	0f 84 54 01 00
	00		 je	 $LN3@mg_send_mq

; 4154 :   size_t total_size = get_properties_length(props, nprops);

  00053	48 83 c7 20	 add	 rdi, 32			; 00000020H
  00057	41 bd 02 00 00
	00		 mov	 r13d, 2
$LL4@mg_send_mq:

; 4161 :     mg_send(c, &props[i].id, sizeof(props[i].id));

  0005d	41 b8 01 00 00
	00		 mov	 r8d, 1
  00063	48 8d 57 e0	 lea	 rdx, QWORD PTR [rdi-32]
  00067	48 8b ce	 mov	 rcx, rsi
  0006a	e8 00 00 00 00	 call	 mg_send

; 4162 :     switch (mqtt_prop_type_by_id(props[i].id)) {

  0006f	8a 4f e0	 mov	 cl, BYTE PTR [rdi-32]
  00072	e8 00 00 00 00	 call	 mqtt_prop_type_by_id
  00077	85 c0		 test	 eax, eax
  00079	0f 84 08 01 00
	00		 je	 $LN8@mg_send_mq
  0007f	83 e8 01	 sub	 eax, 1
  00082	0f 84 d2 00 00
	00		 je	 $LN12@mg_send_mq
  00088	83 e8 01	 sub	 eax, 1
  0008b	0f 84 94 00 00
	00		 je	 $LN7@mg_send_mq
  00091	83 e8 01	 sub	 eax, 1
  00094	0f 84 c0 00 00
	00		 je	 $LN12@mg_send_mq
  0009a	83 e8 01	 sub	 eax, 1
  0009d	74 71		 je	 SHORT $LN13@mg_send_mq
  0009f	83 e8 01	 sub	 eax, 1
  000a2	74 2b		 je	 SHORT $LN10@mg_send_mq
  000a4	83 f8 01	 cmp	 eax, 1
  000a7	0f 85 ec 00 00
	00		 jne	 $LN2@mg_send_mq

; 13806:   memcpy(&data, &net, sizeof(data));

  000ad	0f b7 47 e4	 movzx	 eax, WORD PTR [rdi-28]

; 4055 :   mg_send(c, &value, sizeof(value));

  000b1	48 8d 55 40	 lea	 rdx, QWORD PTR value$[rbp-48]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  000b5	0f b6 c8	 movzx	 ecx, al

; 4055 :   mg_send(c, &value, sizeof(value));

  000b8	4d 8b c5	 mov	 r8, r13

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  000bb	66 c1 e1 08	 shl	 cx, 8
  000bf	66 c1 e8 08	 shr	 ax, 8
  000c3	66 0b c8	 or	 cx, ax

; 4171 :         break;
; 4172 :       case MQTT_PROP_TYPE_SHORT:
; 4173 :         mg_send_u16(c, mg_htons((uint16_t) props[i].iv));

  000c6	66 89 4d 40	 mov	 WORD PTR value$[rbp-48], cx

; 4174 :         break;

  000ca	e9 c2 00 00 00	 jmp	 $LN43@mg_send_mq
$LN10@mg_send_mq:

; 13799:   memcpy(&data, &net, sizeof(data));

  000cf	8b 47 e4	 mov	 eax, DWORD PTR [rdi-28]

; 13800:   return (((uint32_t) data[3]) << 0) | (((uint32_t) data[2]) << 8) |

  000d2	8b c8		 mov	 ecx, eax
  000d4	c1 e9 08	 shr	 ecx, 8
  000d7	44 0f b6 c1	 movzx	 r8d, cl
  000db	0f b6 c8	 movzx	 ecx, al
  000de	c1 e1 08	 shl	 ecx, 8
  000e1	44 0b c1	 or	 r8d, ecx
  000e4	8b c8		 mov	 ecx, eax
  000e6	41 c1 e0 08	 shl	 r8d, 8
  000ea	c1 e9 10	 shr	 ecx, 16
  000ed	0f b6 d1	 movzx	 edx, cl
  000f0	44 0b c2	 or	 r8d, edx
  000f3	c1 e8 18	 shr	 eax, 24
  000f6	41 c1 e0 08	 shl	 r8d, 8

; 4059 :   mg_send(c, &value, sizeof(value));

  000fa	48 8d 55 40	 lea	 rdx, QWORD PTR value$[rbp-48]

; 13800:   return (((uint32_t) data[3]) << 0) | (((uint32_t) data[2]) << 8) |

  000fe	44 0b c0	 or	 r8d, eax

; 4175 :       case MQTT_PROP_TYPE_INT:
; 4176 :         mg_send_u32(c, mg_htonl((uint32_t) props[i].iv));

  00101	44 89 45 40	 mov	 DWORD PTR value$[rbp-48], r8d

; 4059 :   mg_send(c, &value, sizeof(value));

  00105	41 b8 04 00 00
	00		 mov	 r8d, 4

; 4177 :         break;

  0010b	e9 81 00 00 00	 jmp	 $LN43@mg_send_mq
$LN13@mg_send_mq:

; 4178 :       case MQTT_PROP_TYPE_STRING:
; 4179 :         mg_send_u16(c, mg_htons((uint16_t) props[i].val.len));
; 4180 :         mg_send(c, props[i].val.ptr, props[i].val.len);
; 4181 :         break;
; 4182 :       case MQTT_PROP_TYPE_BINARY_DATA:
; 4183 :         mg_send_u16(c, mg_htons((uint16_t) props[i].val.len));
; 4184 :         mg_send(c, props[i].val.ptr, props[i].val.len);
; 4185 :         break;
; 4186 :       case MQTT_PROP_TYPE_VARIABLE_INT:
; 4187 :         len = encode_varint(buf_v, props[i].iv);

  00110	8b 57 e4	 mov	 edx, DWORD PTR [rdi-28]
  00113	48 8d 4d f0	 lea	 rcx, QWORD PTR buf_v$[rbp-48]
  00117	e8 00 00 00 00	 call	 encode_varint

; 4188 :         mg_send(c, buf_v, (size_t) len);

  0011c	4c 8b c0	 mov	 r8, rax
  0011f	48 8d 55 f0	 lea	 rdx, QWORD PTR buf_v$[rbp-48]
  00123	eb 6c		 jmp	 SHORT $LN43@mg_send_mq
$LN7@mg_send_mq:

; 13806:   memcpy(&data, &net, sizeof(data));

  00125	0f b7 47 f0	 movzx	 eax, WORD PTR [rdi-16]

; 4055 :   mg_send(c, &value, sizeof(value));

  00129	48 8d 55 40	 lea	 rdx, QWORD PTR value$[rbp-48]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  0012d	0f b6 c8	 movzx	 ecx, al

; 4055 :   mg_send(c, &value, sizeof(value));

  00130	4d 8b c5	 mov	 r8, r13

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00133	66 c1 e1 08	 shl	 cx, 8
  00137	66 c1 e8 08	 shr	 ax, 8
  0013b	66 0b c8	 or	 cx, ax

; 4163 :       case MQTT_PROP_TYPE_STRING_PAIR:
; 4164 :         mg_send_u16(c, mg_htons((uint16_t) props[i].key.len));

  0013e	66 89 4d 40	 mov	 WORD PTR value$[rbp-48], cx

; 4055 :   mg_send(c, &value, sizeof(value));

  00142	48 8b ce	 mov	 rcx, rsi
  00145	e8 00 00 00 00	 call	 mg_send

; 4165 :         mg_send(c, props[i].key.ptr, props[i].key.len);

  0014a	4c 8b 47 f0	 mov	 r8, QWORD PTR [rdi-16]
  0014e	48 8b ce	 mov	 rcx, rsi
  00151	48 8b 57 e8	 mov	 rdx, QWORD PTR [rdi-24]
  00155	e8 00 00 00 00	 call	 mg_send
$LN12@mg_send_mq:

; 4160 :   for (i = 0; i < nprops; i++) {

  0015a	0f b7 07	 movzx	 eax, WORD PTR [rdi]
  0015d	48 8d 55 40	 lea	 rdx, QWORD PTR value$[rbp-48]
  00161	0f b6 c8	 movzx	 ecx, al
  00164	4d 8b c5	 mov	 r8, r13
  00167	66 c1 e1 08	 shl	 cx, 8
  0016b	66 c1 e8 08	 shr	 ax, 8
  0016f	66 0b c8	 or	 cx, ax
  00172	66 89 4d 40	 mov	 WORD PTR value$[rbp-48], cx
  00176	48 8b ce	 mov	 rcx, rsi
  00179	e8 00 00 00 00	 call	 mg_send
  0017e	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
  00181	48 8b 57 f8	 mov	 rdx, QWORD PTR [rdi-8]
  00185	eb 0a		 jmp	 SHORT $LN43@mg_send_mq
$LN8@mg_send_mq:

; 4166 :         mg_send_u16(c, mg_htons((uint16_t) props[i].val.len));
; 4167 :         mg_send(c, props[i].val.ptr, props[i].val.len);
; 4168 :         break;
; 4169 :       case MQTT_PROP_TYPE_BYTE:
; 4170 :         mg_send(c, &props[i].iv, sizeof(uint8_t));

  00187	48 8d 57 e4	 lea	 rdx, QWORD PTR [rdi-28]
  0018b	41 b8 01 00 00
	00		 mov	 r8d, 1
$LN43@mg_send_mq:

; 4160 :   for (i = 0; i < nprops; i++) {

  00191	48 8b ce	 mov	 rcx, rsi
  00194	e8 00 00 00 00	 call	 mg_send
$LN2@mg_send_mq:
  00199	48 83 c7 28	 add	 rdi, 40			; 00000028H
  0019d	49 83 ee 01	 sub	 r14, 1
  001a1	0f 85 b6 fe ff
	ff		 jne	 $LL4@mg_send_mq
$LN3@mg_send_mq:

; 4189 :         break;
; 4190 :     }
; 4191 :   }
; 4192 : }

  001a7	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  001ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001b0	41 5e		 pop	 r14
  001b2	41 5d		 pop	 r13
  001b4	5f		 pop	 rdi
  001b5	5e		 pop	 rsi
  001b6	5d		 pop	 rbp
  001b7	c3		 ret	 0
mg_send_mqtt_properties ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_mqtt_next_prop
_TEXT	SEGMENT
msg$ = 48
prop$ = 56
ofs$ = 64
mg_mqtt_next_prop PROC					; COMDAT

; 4195 :                          size_t ofs) {

$LN17:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4196 :   uint8_t *i = (uint8_t *) msg->dgram.ptr + msg->props_start + ofs;

  00006	4c 8b 49 20	 mov	 r9, QWORD PTR [rcx+32]
  0000a	4c 8b da	 mov	 r11, rdx
  0000d	4f 8d 14 01	 lea	 r10, QWORD PTR [r9+r8]

; 4197 :   uint8_t *end = (uint8_t *) msg->dgram.ptr + msg->dgram.len;

  00011	4c 03 49 28	 add	 r9, QWORD PTR [rcx+40]
  00015	4c 03 51 38	 add	 r10, QWORD PTR [rcx+56]

; 4198 :   size_t new_pos = ofs, len;
; 4199 :   prop->id = i[0];

  00019	41 8a 12	 mov	 dl, BYTE PTR [r10]
  0001c	41 88 13	 mov	 BYTE PTR [r11], dl

; 4200 : 
; 4201 :   if (ofs >= msg->dgram.len || ofs >= msg->props_start + msg->props_size)

  0001f	4c 3b 41 28	 cmp	 r8, QWORD PTR [rcx+40]
  00023	0f 83 3d 01 00
	00		 jae	 $LN5@mg_mqtt_ne
  00029	48 8b 41 40	 mov	 rax, QWORD PTR [rcx+64]
  0002d	48 03 41 38	 add	 rax, QWORD PTR [rcx+56]
  00031	4c 3b c0	 cmp	 r8, rax
  00034	0f 83 2c 01 00
	00		 jae	 $LN5@mg_mqtt_ne

; 4203 :   i++, new_pos++;
; 4204 : 
; 4205 :   switch (mqtt_prop_type_by_id(prop->id)) {

  0003a	8a ca		 mov	 cl, dl
  0003c	49 8d 58 01	 lea	 rbx, QWORD PTR [r8+1]
  00040	49 ff c2	 inc	 r10
  00043	e8 00 00 00 00	 call	 mqtt_prop_type_by_id
  00048	8b c8		 mov	 ecx, eax
  0004a	85 c0		 test	 eax, eax
  0004c	0f 84 04 01 00
	00		 je	 $LN7@mg_mqtt_ne
  00052	83 e9 01	 sub	 ecx, 1
  00055	0f 84 d6 00 00
	00		 je	 $LN10@mg_mqtt_ne
  0005b	83 e9 01	 sub	 ecx, 1
  0005e	0f 84 82 00 00
	00		 je	 $LN6@mg_mqtt_ne
  00064	83 e9 01	 sub	 ecx, 1
  00067	0f 84 c4 00 00
	00		 je	 $LN10@mg_mqtt_ne
  0006d	83 e9 01	 sub	 ecx, 1
  00070	74 53		 je	 SHORT $LN12@mg_mqtt_ne
  00072	83 e9 01	 sub	 ecx, 1
  00075	74 23		 je	 SHORT $LN9@mg_mqtt_ne
  00077	83 f9 01	 cmp	 ecx, 1
  0007a	74 07		 je	 SHORT $LN8@mg_mqtt_ne

; 4241 :     default:
; 4242 :       new_pos = 0;

  0007c	33 db		 xor	 ebx, ebx
  0007e	e9 de 00 00 00	 jmp	 $LN2@mg_mqtt_ne
$LN8@mg_mqtt_ne:

; 4217 :       break;
; 4218 :     case MQTT_PROP_TYPE_SHORT:
; 4219 :       prop->iv = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);

  00083	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00087	41 0f b6 42 01	 movzx	 eax, BYTE PTR [r10+1]
  0008c	c1 e1 08	 shl	 ecx, 8
  0008f	0b c8		 or	 ecx, eax

; 4220 :       new_pos += sizeof(uint16_t);

  00091	48 83 c3 02	 add	 rbx, 2

; 4221 :       break;

  00095	e9 c3 00 00 00	 jmp	 $LN15@mg_mqtt_ne
$LN9@mg_mqtt_ne:

; 4222 :     case MQTT_PROP_TYPE_INT:
; 4223 :       prop->iv = ((uint32_t) i[0] << 24) | ((uint32_t) i[1] << 16) |

  0009a	41 0f b6 42 01	 movzx	 eax, BYTE PTR [r10+1]
  0009f	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  000a3	c1 e1 08	 shl	 ecx, 8
  000a6	0b c8		 or	 ecx, eax
  000a8	41 0f b6 42 02	 movzx	 eax, BYTE PTR [r10+2]
  000ad	c1 e1 08	 shl	 ecx, 8
  000b0	0b c8		 or	 ecx, eax
  000b2	41 0f b6 42 03	 movzx	 eax, BYTE PTR [r10+3]
  000b7	c1 e1 08	 shl	 ecx, 8
  000ba	0b c8		 or	 ecx, eax

; 4224 :                  ((uint32_t) i[2] << 8) | i[3];
; 4225 :       new_pos += sizeof(uint32_t);

  000bc	48 83 c3 04	 add	 rbx, 4

; 4226 :       break;

  000c0	e9 98 00 00 00	 jmp	 $LN15@mg_mqtt_ne
$LN12@mg_mqtt_ne:

; 4227 :     case MQTT_PROP_TYPE_STRING:
; 4228 :       prop->val.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);
; 4229 :       prop->val.ptr = (char *) i + 2;
; 4230 :       new_pos += 2 + prop->val.len;
; 4231 :       break;
; 4232 :     case MQTT_PROP_TYPE_BINARY_DATA:
; 4233 :       prop->val.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);
; 4234 :       prop->val.ptr = (char *) i + 2;
; 4235 :       new_pos += 2 + prop->val.len;
; 4236 :       break;
; 4237 :     case MQTT_PROP_TYPE_VARIABLE_INT:
; 4238 :       len = decode_varint(i, (size_t) (end - i), (size_t *) &prop->iv);

  000c5	4d 2b ca	 sub	 r9, r10
  000c8	4d 8d 43 04	 lea	 r8, QWORD PTR [r11+4]
  000cc	49 8b d1	 mov	 rdx, r9
  000cf	49 8b ca	 mov	 rcx, r10
  000d2	e8 00 00 00 00	 call	 decode_varint

; 4239 :       new_pos = (!len) ? 0 : new_pos + len;

  000d7	48 8d 0c 18	 lea	 rcx, QWORD PTR [rax+rbx]
  000db	48 f7 d8	 neg	 rax
  000de	48 1b db	 sbb	 rbx, rbx
  000e1	48 23 d9	 and	 rbx, rcx

; 4240 :       break;

  000e4	eb 7b		 jmp	 SHORT $LN2@mg_mqtt_ne
$LN6@mg_mqtt_ne:

; 4206 :     case MQTT_PROP_TYPE_STRING_PAIR:
; 4207 :       prop->key.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);

  000e6	41 0f b6 42 01	 movzx	 eax, BYTE PTR [r10+1]

; 4208 :       prop->key.ptr = (char *) i + 2;
; 4209 :       i += 2 + prop->key.len;
; 4210 :       prop->val.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);
; 4211 :       prop->val.ptr = (char *) i + 2;
; 4212 :       new_pos += 2 * sizeof(uint16_t) + prop->val.len + prop->key.len;

  000eb	48 83 c3 04	 add	 rbx, 4
  000ef	41 0f b6 12	 movzx	 edx, BYTE PTR [r10]
  000f3	48 c1 e2 08	 shl	 rdx, 8
  000f7	48 0b d0	 or	 rdx, rax
  000fa	49 8d 42 02	 lea	 rax, QWORD PTR [r10+2]
  000fe	49 89 43 08	 mov	 QWORD PTR [r11+8], rax
  00102	49 89 53 10	 mov	 QWORD PTR [r11+16], rdx
  00106	41 0f b6 44 12
	03		 movzx	 eax, BYTE PTR [r10+rdx+3]
  0010c	41 0f b6 4c 12
	02		 movzx	 ecx, BYTE PTR [r10+rdx+2]
  00112	48 c1 e1 08	 shl	 rcx, 8
  00116	48 0b c8	 or	 rcx, rax
  00119	49 8d 42 04	 lea	 rax, QWORD PTR [r10+4]
  0011d	48 03 c2	 add	 rax, rdx
  00120	49 89 4b 20	 mov	 QWORD PTR [r11+32], rcx
  00124	49 89 43 18	 mov	 QWORD PTR [r11+24], rax
  00128	48 8d 04 11	 lea	 rax, QWORD PTR [rcx+rdx]
  0012c	48 03 d8	 add	 rbx, rax

; 4213 :       break;

  0012f	eb 30		 jmp	 SHORT $LN2@mg_mqtt_ne
$LN10@mg_mqtt_ne:

; 4243 :   }
; 4244 : 
; 4245 :   return new_pos;

  00131	41 0f b6 42 01	 movzx	 eax, BYTE PTR [r10+1]
  00136	48 83 c3 02	 add	 rbx, 2
  0013a	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  0013e	48 c1 e1 08	 shl	 rcx, 8
  00142	48 0b c8	 or	 rcx, rax
  00145	49 8d 42 02	 lea	 rax, QWORD PTR [r10+2]
  00149	49 89 43 18	 mov	 QWORD PTR [r11+24], rax
  0014d	48 03 d9	 add	 rbx, rcx
  00150	49 89 4b 20	 mov	 QWORD PTR [r11+32], rcx
  00154	eb 0b		 jmp	 SHORT $LN2@mg_mqtt_ne
$LN7@mg_mqtt_ne:

; 4214 :     case MQTT_PROP_TYPE_BYTE:
; 4215 :       prop->iv = (uint8_t) i[0];

  00156	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]

; 4216 :       new_pos++;

  0015a	48 ff c3	 inc	 rbx
$LN15@mg_mqtt_ne:

; 4243 :   }
; 4244 : 
; 4245 :   return new_pos;

  0015d	41 89 4b 04	 mov	 DWORD PTR [r11+4], ecx
$LN2@mg_mqtt_ne:
  00161	48 8b c3	 mov	 rax, rbx
  00164	eb 02		 jmp	 SHORT $LN1@mg_mqtt_ne
$LN5@mg_mqtt_ne:

; 4202 :     return 0;

  00166	33 c0		 xor	 eax, eax
$LN1@mg_mqtt_ne:

; 4246 : }

  00168	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016c	5b		 pop	 rbx
  0016d	c3		 ret	 0
mg_mqtt_next_prop ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_mqtt_login
_TEXT	SEGMENT
rnd$ = 32
cid$ = 32
client_id$ = 48
value$ = 144
value$ = 144
value$ = 144
value$ = 144
value$ = 144
value$ = 144
c$ = 144
hdr$ = 152
opts$ = 152
mg_mqtt_login PROC					; COMDAT

; 4248 : void mg_mqtt_login(struct mg_connection *c, const struct mg_mqtt_opts *opts) {

$LN77:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 8b ec	 mov	 rbp, rsp
  00013	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 4249 :   char rnd[10], client_id[21];
; 4250 :   struct mg_str cid = opts->client_id;

  00017	0f 10 42 20	 movups	 xmm0, XMMWORD PTR [rdx+32]

; 4251 :   size_t total_len = 7 + 1 + 2 + 2;
; 4252 :   uint8_t hdr[8] = {0, 4, 'M', 'Q', 'T', 'T', opts->version, 0};

  0001b	45 33 ed	 xor	 r13d, r13d
  0001e	c7 45 48 00 04
	4d 51		 mov	 DWORD PTR hdr$[rbp-80], 1364001792 ; 514d0400H
  00025	41 be 0c 00 00
	00		 mov	 r14d, 12
  0002b	66 c7 45 4c 54
	54		 mov	 WORD PTR hdr$[rbp-76], 21588 ; 00005454H
  00031	0f 11 45 d0	 movups	 XMMWORD PTR cid$[rbp-80], xmm0
  00035	48 8b f1	 mov	 rsi, rcx
  00038	8a 4a 51	 mov	 cl, BYTE PTR [rdx+81]

; 4253 : 
; 4254 :   if (cid.len == 0) {

  0003b	66 0f 73 d8 08	 psrldq	 xmm0, 8
  00040	48 8b da	 mov	 rbx, rdx
  00043	66 49 0f 7e c7	 movq	 r15, xmm0
  00048	88 4d 4e	 mov	 BYTE PTR hdr$[rbp-74], cl
  0004b	44 88 6d 4f	 mov	 BYTE PTR hdr$[rbp-73], r13b
  0004f	45 8d 5e f8	 lea	 r11d, QWORD PTR [r14-8]
  00053	4d 85 ff	 test	 r15, r15
  00056	75 58		 jne	 SHORT $LN75@mg_mqtt_lo

; 4255 :     mg_random(rnd, sizeof(rnd));

  00058	45 8d 66 fe	 lea	 r12d, QWORD PTR [r14-2]
  0005c	41 8b fc	 mov	 edi, r12d

; 13767:   unsigned char *p = (unsigned char *) buf;

  0005f	4c 8d 7d d0	 lea	 r15, QWORD PTR rnd$[rbp-80]
$LL27@mg_mqtt_lo:

; 13768: #if MG_ARCH == MG_ARCH_ESP32
; 13769:   while (len--) *p++ = (unsigned char) (esp_random() & 255);
; 13770:   done = true;
; 13771: #elif MG_ARCH == MG_ARCH_WIN32
; 13772: #elif MG_ARCH == MG_ARCH_UNIX
; 13773:   FILE *fp = fopen("/dev/urandom", "rb");
; 13774:   if (fp != NULL) {
; 13775:     if (fread(buf, 1, len, fp) == len) done = true;
; 13776:     fclose(fp);
; 13777:   }
; 13778: #endif
; 13779:   // If everything above did not work, fallback to a pseudo random generator
; 13780:   while (!done && len--) *p++ = (unsigned char) (rand() & 255);

  00063	48 8b c7	 mov	 rax, rdi
  00066	48 ff cf	 dec	 rdi
  00069	48 85 c0	 test	 rax, rax
  0006c	74 0e		 je	 SHORT $LN28@mg_mqtt_lo
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00074	41 88 07	 mov	 BYTE PTR [r15], al
  00077	49 ff c7	 inc	 r15
  0007a	eb e7		 jmp	 SHORT $LL27@mg_mqtt_lo
$LN28@mg_mqtt_lo:

; 4256 :     mg_hex(rnd, sizeof(rnd), client_id);

  0007c	4c 8d 45 e0	 lea	 r8, QWORD PTR client_id$[rbp-80]
  00080	49 8b d4	 mov	 rdx, r12
  00083	48 8d 4d d0	 lea	 rcx, QWORD PTR rnd$[rbp-80]
  00087	e8 00 00 00 00	 call	 mg_hex

; 7840 :   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};

  0008c	48 8d 45 e0	 lea	 rax, QWORD PTR client_id$[rbp-80]

; 4257 :     client_id[sizeof(client_id) - 1] = '\0';

  00090	44 88 6d f4	 mov	 BYTE PTR client_id$[rbp-60], r13b

; 7840 :   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};

  00094	49 83 cf ff	 or	 r15, -1
$LL74@mg_mqtt_lo:
  00098	49 ff c7	 inc	 r15
  0009b	46 38 2c 38	 cmp	 BYTE PTR [rax+r15], r13b
  0009f	75 f7		 jne	 SHORT $LL74@mg_mqtt_lo

; 4258 :     cid = mg_str(client_id);

  000a1	8a 4d 4e	 mov	 cl, BYTE PTR hdr$[rbp-74]
  000a4	4c 8d 65 e0	 lea	 r12, QWORD PTR client_id$[rbp-80]
  000a8	41 bb 04 00 00
	00		 mov	 r11d, 4
  000ae	eb 04		 jmp	 SHORT $LN2@mg_mqtt_lo
$LN75@mg_mqtt_lo:

; 4253 : 
; 4254 :   if (cid.len == 0) {

  000b0	4c 8b 65 d0	 mov	 r12, QWORD PTR cid$[rbp-80]
$LN2@mg_mqtt_lo:

; 4259 :   }
; 4260 : 
; 4261 :   if (hdr[6] == 0) hdr[6] = 4;  // If version is not set, use 4 (3.1.1)

  000b4	84 c9		 test	 cl, cl
  000b6	0f b6 c1	 movzx	 eax, cl

; 4262 :   c->is_mqtt5 = hdr[6] == 5;    // Set version 5 flag

  000b9	41 8b d5	 mov	 edx, r13d
  000bc	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  000c2	41 0f 44 c3	 cmove	 eax, r11d
  000c6	3c 05		 cmp	 al, 5
  000c8	88 45 4e	 mov	 BYTE PTR hdr$[rbp-74], al
  000cb	8b 86 10 01 00
	00		 mov	 eax, DWORD PTR [rsi+272]
  000d1	41 0f 44 d0	 cmove	 edx, r8d
  000d5	0f ba f0 0a	 btr	 eax, 10
  000d9	0b d0		 or	 edx, eax
  000db	89 96 10 01 00
	00		 mov	 DWORD PTR [rsi+272], edx

; 4263 :   hdr[7] = (uint8_t) ((opts->qos & 3) << 3);  // Connection flags

  000e1	40 8a 7b 50	 mov	 dil, BYTE PTR [rbx+80]
  000e5	40 80 e7 03	 and	 dil, 3
  000e9	40 c0 e7 03	 shl	 dil, 3
  000ed	40 88 7d 4f	 mov	 BYTE PTR hdr$[rbp-73], dil

; 4264 :   if (opts->user.len > 0) {

  000f1	4c 39 6b 08	 cmp	 QWORD PTR [rbx+8], r13
  000f5	76 11		 jbe	 SHORT $LN4@mg_mqtt_lo

; 4265 :     total_len += 2 + (uint32_t) opts->user.len;

  000f7	8b 4b 08	 mov	 ecx, DWORD PTR [rbx+8]
  000fa	83 c1 02	 add	 ecx, 2
  000fd	4c 03 f1	 add	 r14, rcx

; 4266 :     hdr[7] |= MQTT_HAS_USER_NAME;

  00100	40 80 cf 80	 or	 dil, 128		; 00000080H
  00104	40 88 7d 4f	 mov	 BYTE PTR hdr$[rbp-73], dil
$LN4@mg_mqtt_lo:

; 4267 :   }
; 4268 :   if (opts->pass.len > 0) {

  00108	4c 39 6b 18	 cmp	 QWORD PTR [rbx+24], r13
  0010c	76 11		 jbe	 SHORT $LN5@mg_mqtt_lo

; 4269 :     total_len += 2 + (uint32_t) opts->pass.len;

  0010e	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  00111	83 c0 02	 add	 eax, 2
  00114	4c 03 f0	 add	 r14, rax

; 4270 :     hdr[7] |= MQTT_HAS_PASSWORD;

  00117	40 80 cf 40	 or	 dil, 64			; 00000040H
  0011b	40 88 7d 4f	 mov	 BYTE PTR hdr$[rbp-73], dil
$LN5@mg_mqtt_lo:

; 4271 :   }
; 4272 :   if (opts->topic.len > 0 && opts->message.len > 0) {

  0011f	4c 39 6b 38	 cmp	 QWORD PTR [rbx+56], r13
  00123	76 19		 jbe	 SHORT $LN6@mg_mqtt_lo
  00125	4c 39 6b 48	 cmp	 QWORD PTR [rbx+72], r13
  00129	76 13		 jbe	 SHORT $LN6@mg_mqtt_lo

; 4273 :     total_len += 4 + (uint32_t) opts->topic.len + (uint32_t) opts->message.len;

  0012b	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  0012e	83 c0 04	 add	 eax, 4
  00131	03 43 48	 add	 eax, DWORD PTR [rbx+72]
  00134	4c 03 f0	 add	 r14, rax

; 4274 :     hdr[7] |= MQTT_HAS_WILL;

  00137	41 0a fb	 or	 dil, r11b
  0013a	40 88 7d 4f	 mov	 BYTE PTR hdr$[rbp-73], dil
$LN6@mg_mqtt_lo:

; 4275 :   }
; 4276 :   if (opts->clean || cid.len == 0) hdr[7] |= MQTT_CLEAN_SESSION;

  0013e	44 38 6b 55	 cmp	 BYTE PTR [rbx+85], r13b
  00142	75 05		 jne	 SHORT $LN8@mg_mqtt_lo
  00144	4d 85 ff	 test	 r15, r15
  00147	75 08		 jne	 SHORT $LN7@mg_mqtt_lo
$LN8@mg_mqtt_lo:
  00149	40 80 cf 02	 or	 dil, 2
  0014d	40 88 7d 4f	 mov	 BYTE PTR hdr$[rbp-73], dil
$LN7@mg_mqtt_lo:

; 4277 :   if (opts->retain) hdr[7] |= MQTT_WILL_RETAIN;

  00151	44 38 6b 54	 cmp	 BYTE PTR [rbx+84], r13b
  00155	74 08		 je	 SHORT $LN9@mg_mqtt_lo
  00157	40 80 cf 20	 or	 dil, 32			; 00000020H
  0015b	40 88 7d 4f	 mov	 BYTE PTR hdr$[rbp-73], dil
$LN9@mg_mqtt_lo:

; 4278 :   total_len += (uint32_t) cid.len;

  0015f	41 8b c7	 mov	 eax, r15d
  00162	4c 03 f0	 add	 r14, rax

; 4279 :   if (c->is_mqtt5) {

  00165	41 85 d0	 test	 edx, r8d
  00168	74 56		 je	 SHORT $LN11@mg_mqtt_lo

; 4147 :   size_t size = get_properties_length(props, count);

  0016a	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  0016e	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00172	e8 00 00 00 00	 call	 get_properties_length

; 4148 :   size += varint_size(size);

  00177	48 8b c8	 mov	 rcx, rax

; 4063 :   uint8_t bytes_needed = 0;

  0017a	41 8a d5	 mov	 dl, r13b
$LL39@mg_mqtt_lo:

; 4064 :   do {
; 4065 :     bytes_needed++;

  0017d	fe c2		 inc	 dl

; 4066 :     length /= 0x80;

  0017f	48 c1 e9 07	 shr	 rcx, 7

; 4067 :   } while (length > 0);

  00183	48 85 c9	 test	 rcx, rcx
  00186	75 f5		 jne	 SHORT $LL39@mg_mqtt_lo

; 4148 :   size += varint_size(size);

  00188	0f b6 ca	 movzx	 ecx, dl

; 4280 :     total_len += get_props_size(opts->props, opts->num_props);

  0018b	48 03 c8	 add	 rcx, rax
  0018e	4c 03 f1	 add	 r14, rcx

; 4281 :     if (hdr[7] & MQTT_HAS_WILL)

  00191	40 f6 c7 04	 test	 dil, 4
  00195	74 29		 je	 SHORT $LN11@mg_mqtt_lo

; 4147 :   size_t size = get_properties_length(props, count);

  00197	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]
  0019b	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  0019f	e8 00 00 00 00	 call	 get_properties_length

; 4148 :   size += varint_size(size);

  001a4	48 8b c8	 mov	 rcx, rax

; 4063 :   uint8_t bytes_needed = 0;

  001a7	45 8a c5	 mov	 r8b, r13b
$LL62@mg_mqtt_lo:

; 4064 :   do {
; 4065 :     bytes_needed++;

  001aa	41 fe c0	 inc	 r8b

; 4066 :     length /= 0x80;

  001ad	48 c1 e9 07	 shr	 rcx, 7

; 4067 :   } while (length > 0);

  001b1	48 85 c9	 test	 rcx, rcx
  001b4	75 f4		 jne	 SHORT $LL62@mg_mqtt_lo

; 4148 :   size += varint_size(size);

  001b6	41 0f b6 c8	 movzx	 ecx, r8b

; 4282 :       total_len += get_props_size(opts->will_props, opts->num_will_props);

  001ba	48 03 c8	 add	 rcx, rax
  001bd	4c 03 f1	 add	 r14, rcx
$LN11@mg_mqtt_lo:

; 4283 :   }
; 4284 : 
; 4285 :   mg_mqtt_send_header(c, MQTT_CMD_CONNECT, 0, (uint32_t) total_len);

  001c0	45 8b ce	 mov	 r9d, r14d
  001c3	45 33 c0	 xor	 r8d, r8d
  001c6	b2 01		 mov	 dl, 1
  001c8	48 8b ce	 mov	 rcx, rsi
  001cb	e8 00 00 00 00	 call	 mg_mqtt_send_header

; 4286 :   mg_send(c, hdr, sizeof(hdr));

  001d0	41 b8 08 00 00
	00		 mov	 r8d, 8
  001d6	48 8d 55 48	 lea	 rdx, QWORD PTR hdr$[rbp-80]
  001da	48 8b ce	 mov	 rcx, rsi
  001dd	e8 00 00 00 00	 call	 mg_send

; 13806:   memcpy(&data, &net, sizeof(data));

  001e2	0f b7 43 52	 movzx	 eax, WORD PTR [rbx+82]

; 4055 :   mg_send(c, &value, sizeof(value));

  001e6	48 8d 55 40	 lea	 rdx, QWORD PTR value$[rbp-80]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  001ea	0f b6 c8	 movzx	 ecx, al

; 4055 :   mg_send(c, &value, sizeof(value));

  001ed	bf 02 00 00 00	 mov	 edi, 2

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  001f2	66 c1 e1 08	 shl	 cx, 8

; 4055 :   mg_send(c, &value, sizeof(value));

  001f6	44 8b c7	 mov	 r8d, edi

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  001f9	66 c1 e8 08	 shr	 ax, 8
  001fd	66 0b c8	 or	 cx, ax

; 4287 :   // keepalive == 0 means "do not disconnect us!"
; 4288 :   mg_send_u16(c, mg_htons((uint16_t) opts->keepalive));

  00200	66 89 4d 40	 mov	 WORD PTR value$[rbp-80], cx

; 4055 :   mg_send(c, &value, sizeof(value));

  00204	48 8b ce	 mov	 rcx, rsi
  00207	e8 00 00 00 00	 call	 mg_send

; 4289 : 
; 4290 :   if (c->is_mqtt5) mg_send_mqtt_properties(c, opts->props, opts->num_props);

  0020c	41 be 00 04 00
	00		 mov	 r14d, 1024		; 00000400H
  00212	44 85 b6 10 01
	00 00		 test	 DWORD PTR [rsi+272], r14d
  00219	74 10		 je	 SHORT $LN12@mg_mqtt_lo
  0021b	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  0021f	48 8b ce	 mov	 rcx, rsi
  00222	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  00226	e8 00 00 00 00	 call	 mg_send_mqtt_properties
$LN12@mg_mqtt_lo:

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  0022b	41 0f b6 cf	 movzx	 ecx, r15b

; 4055 :   mg_send(c, &value, sizeof(value));

  0022f	48 8d 55 40	 lea	 rdx, QWORD PTR value$[rbp-80]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00233	66 c1 e1 08	 shl	 cx, 8
  00237	41 0f b7 c7	 movzx	 eax, r15w
  0023b	66 c1 e8 08	 shr	 ax, 8

; 4055 :   mg_send(c, &value, sizeof(value));

  0023f	4c 8b c7	 mov	 r8, rdi

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00242	66 0b c8	 or	 cx, ax

; 4291 : 
; 4292 :   mg_send_u16(c, mg_htons((uint16_t) cid.len));

  00245	66 89 4d 40	 mov	 WORD PTR value$[rbp-80], cx

; 4055 :   mg_send(c, &value, sizeof(value));

  00249	48 8b ce	 mov	 rcx, rsi
  0024c	e8 00 00 00 00	 call	 mg_send

; 4293 :   mg_send(c, cid.ptr, cid.len);

  00251	4d 8b c7	 mov	 r8, r15
  00254	49 8b d4	 mov	 rdx, r12
  00257	48 8b ce	 mov	 rcx, rsi
  0025a	e8 00 00 00 00	 call	 mg_send

; 4294 : 
; 4295 :   if (hdr[7] & MQTT_HAS_WILL) {

  0025f	f6 45 4f 04	 test	 BYTE PTR hdr$[rbp-73], 4
  00263	0f 84 83 00 00
	00		 je	 $LN13@mg_mqtt_lo

; 4296 :     if (c->is_mqtt5)

  00269	44 85 b6 10 01
	00 00		 test	 DWORD PTR [rsi+272], r14d
  00270	74 10		 je	 SHORT $LN14@mg_mqtt_lo

; 4297 :       mg_send_mqtt_properties(c, opts->will_props, opts->num_will_props);

  00272	4c 8b 43 70	 mov	 r8, QWORD PTR [rbx+112]
  00276	48 8b ce	 mov	 rcx, rsi
  00279	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0027d	e8 00 00 00 00	 call	 mg_send_mqtt_properties
$LN14@mg_mqtt_lo:

; 13806:   memcpy(&data, &net, sizeof(data));

  00282	0f b7 43 38	 movzx	 eax, WORD PTR [rbx+56]

; 4055 :   mg_send(c, &value, sizeof(value));

  00286	48 8d 55 40	 lea	 rdx, QWORD PTR value$[rbp-80]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  0028a	0f b6 c8	 movzx	 ecx, al

; 4055 :   mg_send(c, &value, sizeof(value));

  0028d	4c 8b c7	 mov	 r8, rdi

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00290	66 c1 e1 08	 shl	 cx, 8
  00294	66 c1 e8 08	 shr	 ax, 8
  00298	66 0b c8	 or	 cx, ax

; 4298 : 
; 4299 :     mg_send_u16(c, mg_htons((uint16_t) opts->topic.len));

  0029b	66 89 4d 40	 mov	 WORD PTR value$[rbp-80], cx

; 4055 :   mg_send(c, &value, sizeof(value));

  0029f	48 8b ce	 mov	 rcx, rsi
  002a2	e8 00 00 00 00	 call	 mg_send

; 4300 :     mg_send(c, opts->topic.ptr, opts->topic.len);

  002a7	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  002ab	48 8b ce	 mov	 rcx, rsi
  002ae	48 8b 53 30	 mov	 rdx, QWORD PTR [rbx+48]
  002b2	e8 00 00 00 00	 call	 mg_send

; 13806:   memcpy(&data, &net, sizeof(data));

  002b7	0f b7 43 48	 movzx	 eax, WORD PTR [rbx+72]

; 4055 :   mg_send(c, &value, sizeof(value));

  002bb	48 8d 55 40	 lea	 rdx, QWORD PTR value$[rbp-80]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  002bf	0f b6 c8	 movzx	 ecx, al

; 4055 :   mg_send(c, &value, sizeof(value));

  002c2	4c 8b c7	 mov	 r8, rdi

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  002c5	66 c1 e1 08	 shl	 cx, 8
  002c9	66 c1 e8 08	 shr	 ax, 8
  002cd	66 0b c8	 or	 cx, ax

; 4301 :     mg_send_u16(c, mg_htons((uint16_t) opts->message.len));

  002d0	66 89 4d 40	 mov	 WORD PTR value$[rbp-80], cx

; 4055 :   mg_send(c, &value, sizeof(value));

  002d4	48 8b ce	 mov	 rcx, rsi
  002d7	e8 00 00 00 00	 call	 mg_send

; 4302 :     mg_send(c, opts->message.ptr, opts->message.len);

  002dc	4c 8b 43 48	 mov	 r8, QWORD PTR [rbx+72]
  002e0	48 8b ce	 mov	 rcx, rsi
  002e3	48 8b 53 40	 mov	 rdx, QWORD PTR [rbx+64]
  002e7	e8 00 00 00 00	 call	 mg_send
$LN13@mg_mqtt_lo:

; 4303 :   }
; 4304 :   if (opts->user.len > 0) {

  002ec	4c 39 6b 08	 cmp	 QWORD PTR [rbx+8], r13
  002f0	76 34		 jbe	 SHORT $LN15@mg_mqtt_lo

; 13806:   memcpy(&data, &net, sizeof(data));

  002f2	0f b7 43 08	 movzx	 eax, WORD PTR [rbx+8]

; 4055 :   mg_send(c, &value, sizeof(value));

  002f6	48 8d 55 40	 lea	 rdx, QWORD PTR value$[rbp-80]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  002fa	0f b6 c8	 movzx	 ecx, al

; 4055 :   mg_send(c, &value, sizeof(value));

  002fd	4c 8b c7	 mov	 r8, rdi

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00300	66 c1 e1 08	 shl	 cx, 8
  00304	66 c1 e8 08	 shr	 ax, 8
  00308	66 0b c8	 or	 cx, ax

; 4305 :     mg_send_u16(c, mg_htons((uint16_t) opts->user.len));

  0030b	66 89 4d 40	 mov	 WORD PTR value$[rbp-80], cx

; 4055 :   mg_send(c, &value, sizeof(value));

  0030f	48 8b ce	 mov	 rcx, rsi
  00312	e8 00 00 00 00	 call	 mg_send

; 4306 :     mg_send(c, opts->user.ptr, opts->user.len);

  00317	4c 8b 43 08	 mov	 r8, QWORD PTR [rbx+8]
  0031b	48 8b ce	 mov	 rcx, rsi
  0031e	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00321	e8 00 00 00 00	 call	 mg_send
$LN15@mg_mqtt_lo:

; 4307 :   }
; 4308 :   if (opts->pass.len > 0) {

  00326	4c 39 6b 18	 cmp	 QWORD PTR [rbx+24], r13
  0032a	76 35		 jbe	 SHORT $LN16@mg_mqtt_lo

; 13806:   memcpy(&data, &net, sizeof(data));

  0032c	0f b7 43 18	 movzx	 eax, WORD PTR [rbx+24]

; 4055 :   mg_send(c, &value, sizeof(value));

  00330	48 8d 55 40	 lea	 rdx, QWORD PTR value$[rbp-80]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00334	0f b6 c8	 movzx	 ecx, al

; 4055 :   mg_send(c, &value, sizeof(value));

  00337	4c 8b c7	 mov	 r8, rdi

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  0033a	66 c1 e1 08	 shl	 cx, 8
  0033e	66 c1 e8 08	 shr	 ax, 8
  00342	66 0b c8	 or	 cx, ax

; 4309 :     mg_send_u16(c, mg_htons((uint16_t) opts->pass.len));

  00345	66 89 4d 40	 mov	 WORD PTR value$[rbp-80], cx

; 4055 :   mg_send(c, &value, sizeof(value));

  00349	48 8b ce	 mov	 rcx, rsi
  0034c	e8 00 00 00 00	 call	 mg_send

; 4310 :     mg_send(c, opts->pass.ptr, opts->pass.len);

  00351	4c 8b 43 18	 mov	 r8, QWORD PTR [rbx+24]
  00355	48 8b ce	 mov	 rcx, rsi
  00358	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]
  0035c	e8 00 00 00 00	 call	 mg_send
$LN16@mg_mqtt_lo:

; 4311 :   }
; 4312 : }

  00361	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]
  00369	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0036d	41 5f		 pop	 r15
  0036f	41 5e		 pop	 r14
  00371	41 5d		 pop	 r13
  00373	41 5c		 pop	 r12
  00375	5f		 pop	 rdi
  00376	5e		 pop	 rsi
  00377	5d		 pop	 rbp
  00378	c3		 ret	 0
mg_mqtt_login ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_mqtt_pub
_TEXT	SEGMENT
value$ = 96
value$ = 96
c$ = 96
opts$ = 104
mg_mqtt_pub PROC					; COMDAT

; 4314 : void mg_mqtt_pub(struct mg_connection *c, const struct mg_mqtt_opts *opts) {

$LN34:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 55		 push	 r13
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 4315 :   uint8_t flags = (uint8_t) (((opts->qos & 3) << 1) | (opts->retain ? 1 : 0));

  00016	80 7a 54 00	 cmp	 BYTE PTR [rdx+84], 0
  0001a	48 8b da	 mov	 rbx, rdx
  0001d	8a 42 50	 mov	 al, BYTE PTR [rdx+80]
  00020	48 8b f9	 mov	 rdi, rcx

; 4316 :   size_t len = 2 + opts->topic.len + opts->message.len;

  00023	48 8b 6a 38	 mov	 rbp, QWORD PTR [rdx+56]
  00027	41 0f 95 c7	 setne	 r15b
  0002b	48 03 6a 48	 add	 rbp, QWORD PTR [rdx+72]
  0002f	24 03		 and	 al, 3
  00031	02 c0		 add	 al, al
  00033	44 0a f8	 or	 r15b, al

; 4317 :   MG_DEBUG(("%lu [%.*s] -> [%.*s]", c->id, (int) opts->topic.len,

  00036	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR mg_log_level, 3
  0003d	7c 3e		 jl	 SHORT $LN31@mg_mqtt_pu
  0003f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0M@JCOIBNAC@mg_mqtt_pub@
  00046	b9 03 00 00 00	 mov	 ecx, 3
  0004b	41 b8 df 10 00
	00		 mov	 r8d, 4319		; 000010dfH
  00051	e8 00 00 00 00	 call	 mg_log_prefix
  00056	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@LDABDMHN@?$CFlu?5?$FL?$CF?4?$CKs?$FN?5?9?$DO?5?$FL?$CF?4?$CKs?$FN@
  00061	4c 8b 4b 30	 mov	 r9, QWORD PTR [rbx+48]
  00065	44 8b 43 38	 mov	 r8d, DWORD PTR [rbx+56]
  00069	8b 57 40	 mov	 edx, DWORD PTR [rdi+64]
  0006c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00071	8b 43 48	 mov	 eax, DWORD PTR [rbx+72]
  00074	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00078	e8 00 00 00 00	 call	 mg_log
$LN31@mg_mqtt_pu:

; 4318 :             (char *) opts->topic.ptr, (int) opts->message.len,
; 4319 :             (char *) opts->message.ptr));
; 4320 :   if (opts->qos > 0) len += 2;
; 4321 :   if (c->is_mqtt5) len += get_props_size(opts->props, opts->num_props);

  0007d	80 7b 50 00	 cmp	 BYTE PTR [rbx+80], 0
  00081	be 04 00 00 00	 mov	 esi, 4
  00086	44 8d 6e fe	 lea	 r13d, QWORD PTR [rsi-2]
  0008a	41 0f 46 f5	 cmovbe	 esi, r13d
  0008e	48 03 f5	 add	 rsi, rbp
  00091	bd 00 04 00 00	 mov	 ebp, 1024		; 00000400H
  00096	85 af 10 01 00
	00		 test	 DWORD PTR [rdi+272], ebp
  0009c	74 28		 je	 SHORT $LN32@mg_mqtt_pu

; 4147 :   size_t size = get_properties_length(props, count);

  0009e	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  000a2	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  000a6	e8 00 00 00 00	 call	 get_properties_length

; 4148 :   size += varint_size(size);

  000ab	48 8b c8	 mov	 rcx, rax

; 4063 :   uint8_t bytes_needed = 0;

  000ae	32 d2		 xor	 dl, dl
$LL22@mg_mqtt_pu:

; 4064 :   do {
; 4065 :     bytes_needed++;

  000b0	fe c2		 inc	 dl

; 4066 :     length /= 0x80;

  000b2	48 c1 e9 07	 shr	 rcx, 7

; 4067 :   } while (length > 0);

  000b6	48 85 c9	 test	 rcx, rcx
  000b9	75 f5		 jne	 SHORT $LL22@mg_mqtt_pu

; 4148 :   size += varint_size(size);

  000bb	0f b6 ca	 movzx	 ecx, dl

; 4318 :             (char *) opts->topic.ptr, (int) opts->message.len,
; 4319 :             (char *) opts->message.ptr));
; 4320 :   if (opts->qos > 0) len += 2;
; 4321 :   if (c->is_mqtt5) len += get_props_size(opts->props, opts->num_props);

  000be	48 03 ce	 add	 rcx, rsi
  000c1	48 03 c8	 add	 rcx, rax
  000c4	eb 03		 jmp	 SHORT $LN7@mg_mqtt_pu
$LN32@mg_mqtt_pu:
  000c6	48 8b ce	 mov	 rcx, rsi
$LN7@mg_mqtt_pu:

; 4322 : 
; 4323 :   mg_mqtt_send_header(c, MQTT_CMD_PUBLISH, flags, (uint32_t) len);

  000c9	44 8b c9	 mov	 r9d, ecx
  000cc	45 8a c7	 mov	 r8b, r15b
  000cf	48 8b cf	 mov	 rcx, rdi
  000d2	b2 03		 mov	 dl, 3
  000d4	e8 00 00 00 00	 call	 mg_mqtt_send_header

; 13806:   memcpy(&data, &net, sizeof(data));

  000d9	0f b7 43 38	 movzx	 eax, WORD PTR [rbx+56]

; 4055 :   mg_send(c, &value, sizeof(value));

  000dd	48 8d 54 24 60	 lea	 rdx, QWORD PTR value$[rsp]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  000e2	0f b6 c8	 movzx	 ecx, al

; 4055 :   mg_send(c, &value, sizeof(value));

  000e5	4d 8b c5	 mov	 r8, r13

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  000e8	66 c1 e1 08	 shl	 cx, 8
  000ec	66 c1 e8 08	 shr	 ax, 8
  000f0	66 0b c8	 or	 cx, ax

; 4324 :   mg_send_u16(c, mg_htons((uint16_t) opts->topic.len));

  000f3	66 89 4c 24 60	 mov	 WORD PTR value$[rsp], cx

; 4055 :   mg_send(c, &value, sizeof(value));

  000f8	48 8b cf	 mov	 rcx, rdi
  000fb	e8 00 00 00 00	 call	 mg_send

; 4325 :   mg_send(c, opts->topic.ptr, opts->topic.len);

  00100	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  00104	48 8b cf	 mov	 rcx, rdi
  00107	48 8b 53 30	 mov	 rdx, QWORD PTR [rbx+48]
  0010b	e8 00 00 00 00	 call	 mg_send

; 4326 :   if (opts->qos > 0) {

  00110	80 7b 50 00	 cmp	 BYTE PTR [rbx+80], 0
  00114	76 3e		 jbe	 SHORT $LN26@mg_mqtt_pu

; 4327 :     if (++c->mgr->mqtt_id == 0) ++c->mgr->mqtt_id;

  00116	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  0011a	66 83 40 48 01	 add	 WORD PTR [rax+72], 1
  0011f	75 08		 jne	 SHORT $LN9@mg_mqtt_pu
  00121	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00125	66 ff 40 48	 inc	 WORD PTR [rax+72]
$LN9@mg_mqtt_pu:

; 13806:   memcpy(&data, &net, sizeof(data));

  00129	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]

; 4055 :   mg_send(c, &value, sizeof(value));

  0012d	48 8d 54 24 60	 lea	 rdx, QWORD PTR value$[rsp]
  00132	4d 8b c5	 mov	 r8, r13

; 13806:   memcpy(&data, &net, sizeof(data));

  00135	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00139	0f b6 c8	 movzx	 ecx, al
  0013c	66 c1 e1 08	 shl	 cx, 8
  00140	66 c1 e8 08	 shr	 ax, 8
  00144	66 0b c8	 or	 cx, ax

; 4328 :     mg_send_u16(c, mg_htons(c->mgr->mqtt_id));

  00147	66 89 4c 24 60	 mov	 WORD PTR value$[rsp], cx

; 4055 :   mg_send(c, &value, sizeof(value));

  0014c	48 8b cf	 mov	 rcx, rdi
  0014f	e8 00 00 00 00	 call	 mg_send
$LN26@mg_mqtt_pu:

; 4329 :   }
; 4330 : 
; 4331 :   if (c->is_mqtt5) mg_send_mqtt_properties(c, opts->props, opts->num_props);

  00154	85 af 10 01 00
	00		 test	 DWORD PTR [rdi+272], ebp
  0015a	74 10		 je	 SHORT $LN10@mg_mqtt_pu
  0015c	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  00160	48 8b cf	 mov	 rcx, rdi
  00163	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  00167	e8 00 00 00 00	 call	 mg_send_mqtt_properties
$LN10@mg_mqtt_pu:

; 4332 : 
; 4333 :   if (opts->message.len > 0) mg_send(c, opts->message.ptr, opts->message.len);

  0016c	4c 8b 43 48	 mov	 r8, QWORD PTR [rbx+72]
  00170	4d 85 c0	 test	 r8, r8
  00173	74 0c		 je	 SHORT $LN11@mg_mqtt_pu
  00175	48 8b 53 40	 mov	 rdx, QWORD PTR [rbx+64]
  00179	48 8b cf	 mov	 rcx, rdi
  0017c	e8 00 00 00 00	 call	 mg_send
$LN11@mg_mqtt_pu:

; 4334 : }

  00181	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  00186	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  0018b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0018f	41 5f		 pop	 r15
  00191	41 5e		 pop	 r14
  00193	41 5d		 pop	 r13
  00195	5f		 pop	 rdi
  00196	5e		 pop	 rsi
  00197	c3		 ret	 0
mg_mqtt_pub ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_mqtt_sub
_TEXT	SEGMENT
qos_$ = 48
c$ = 48
value$ = 56
value$ = 56
opts$ = 56
mg_mqtt_sub PROC					; COMDAT

; 4336 : void mg_mqtt_sub(struct mg_connection *c, const struct mg_mqtt_opts *opts) {

$LN26:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4337 :   uint8_t qos_ = opts->qos & 3;

  0000f	8a 42 50	 mov	 al, BYTE PTR [rdx+80]
  00012	48 8b fa	 mov	 rdi, rdx
  00015	24 03		 and	 al, 3
  00017	48 8b d9	 mov	 rbx, rcx

; 4338 :   size_t plen = c->is_mqtt5 ? get_props_size(opts->props, opts->num_props) : 0;

  0001a	f7 81 10 01 00
	00 00 04 00 00	 test	 DWORD PTR [rcx+272], 1024 ; 00000400H
  00024	be 01 00 00 00	 mov	 esi, 1
  00029	88 44 24 30	 mov	 BYTE PTR qos_$[rsp], al
  0002d	74 2a		 je	 SHORT $LN5@mg_mqtt_su

; 4147 :   size_t size = get_properties_length(props, count);

  0002f	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  00033	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00037	e8 00 00 00 00	 call	 get_properties_length

; 4063 :   uint8_t bytes_needed = 0;

  0003c	33 c9		 xor	 ecx, ecx

; 4148 :   size += varint_size(size);

  0003e	48 8b d0	 mov	 rdx, rax

; 4063 :   uint8_t bytes_needed = 0;

  00041	44 8a c1	 mov	 r8b, cl
$LL20@mg_mqtt_su:

; 4064 :   do {
; 4065 :     bytes_needed++;

  00044	44 02 c6	 add	 r8b, sil

; 4066 :     length /= 0x80;

  00047	48 c1 ea 07	 shr	 rdx, 7

; 4067 :   } while (length > 0);

  0004b	48 85 d2	 test	 rdx, rdx
  0004e	75 f4		 jne	 SHORT $LL20@mg_mqtt_su

; 4148 :   size += varint_size(size);

  00050	41 0f b6 c8	 movzx	 ecx, r8b
  00054	48 03 c8	 add	 rcx, rax

; 4338 :   size_t plen = c->is_mqtt5 ? get_props_size(opts->props, opts->num_props) : 0;

  00057	eb 02		 jmp	 SHORT $LN6@mg_mqtt_su
$LN5@mg_mqtt_su:
  00059	33 c9		 xor	 ecx, ecx
$LN6@mg_mqtt_su:

; 4339 :   size_t len = 2 + opts->topic.len + 2 + 1 + plen;

  0005b	44 8b 4f 38	 mov	 r9d, DWORD PTR [rdi+56]

; 4340 : 
; 4341 :   mg_mqtt_send_header(c, MQTT_CMD_SUBSCRIBE, 2, (uint32_t) len);

  0005f	41 b0 02	 mov	 r8b, 2
  00062	41 83 c1 05	 add	 r9d, 5
  00066	b2 08		 mov	 dl, 8
  00068	44 03 c9	 add	 r9d, ecx
  0006b	48 8b cb	 mov	 rcx, rbx
  0006e	e8 00 00 00 00	 call	 mg_mqtt_send_header

; 4342 :   if (++c->mgr->mqtt_id == 0) ++c->mgr->mqtt_id;

  00073	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00077	66 01 70 48	 add	 WORD PTR [rax+72], si
  0007b	75 08		 jne	 SHORT $LN2@mg_mqtt_su
  0007d	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00081	66 01 70 48	 add	 WORD PTR [rax+72], si
$LN2@mg_mqtt_su:

; 13806:   memcpy(&data, &net, sizeof(data));

  00085	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]

; 4055 :   mg_send(c, &value, sizeof(value));

  00089	48 8d 54 24 38	 lea	 rdx, QWORD PTR value$[rsp]
  0008e	41 b8 02 00 00
	00		 mov	 r8d, 2

; 13806:   memcpy(&data, &net, sizeof(data));

  00094	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00098	0f b6 c8	 movzx	 ecx, al
  0009b	66 c1 e1 08	 shl	 cx, 8
  0009f	66 c1 e8 08	 shr	 ax, 8
  000a3	66 0b c8	 or	 cx, ax

; 4343 :   mg_send_u16(c, mg_htons(c->mgr->mqtt_id));

  000a6	66 89 4c 24 38	 mov	 WORD PTR value$[rsp], cx

; 4055 :   mg_send(c, &value, sizeof(value));

  000ab	48 8b cb	 mov	 rcx, rbx
  000ae	e8 00 00 00 00	 call	 mg_send

; 4344 :   if (c->is_mqtt5) mg_send_mqtt_properties(c, opts->props, opts->num_props);

  000b3	f7 83 10 01 00
	00 00 04 00 00	 test	 DWORD PTR [rbx+272], 1024 ; 00000400H
  000bd	74 10		 je	 SHORT $LN3@mg_mqtt_su
  000bf	4c 8b 47 60	 mov	 r8, QWORD PTR [rdi+96]
  000c3	48 8b cb	 mov	 rcx, rbx
  000c6	48 8b 57 58	 mov	 rdx, QWORD PTR [rdi+88]
  000ca	e8 00 00 00 00	 call	 mg_send_mqtt_properties
$LN3@mg_mqtt_su:

; 13806:   memcpy(&data, &net, sizeof(data));

  000cf	0f b7 47 38	 movzx	 eax, WORD PTR [rdi+56]

; 4055 :   mg_send(c, &value, sizeof(value));

  000d3	48 8d 54 24 38	 lea	 rdx, QWORD PTR value$[rsp]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  000d8	0f b6 c8	 movzx	 ecx, al

; 4055 :   mg_send(c, &value, sizeof(value));

  000db	41 b8 02 00 00
	00		 mov	 r8d, 2

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  000e1	66 c1 e1 08	 shl	 cx, 8
  000e5	66 c1 e8 08	 shr	 ax, 8
  000e9	66 0b c8	 or	 cx, ax

; 4345 : 
; 4346 :   mg_send_u16(c, mg_htons((uint16_t) opts->topic.len));

  000ec	66 89 4c 24 38	 mov	 WORD PTR value$[rsp], cx

; 4055 :   mg_send(c, &value, sizeof(value));

  000f1	48 8b cb	 mov	 rcx, rbx
  000f4	e8 00 00 00 00	 call	 mg_send

; 4347 :   mg_send(c, opts->topic.ptr, opts->topic.len);

  000f9	4c 8b 47 38	 mov	 r8, QWORD PTR [rdi+56]
  000fd	48 8b cb	 mov	 rcx, rbx
  00100	48 8b 57 30	 mov	 rdx, QWORD PTR [rdi+48]
  00104	e8 00 00 00 00	 call	 mg_send

; 4348 :   mg_send(c, &qos_, sizeof(qos_));

  00109	4c 8b c6	 mov	 r8, rsi
  0010c	48 8d 54 24 30	 lea	 rdx, QWORD PTR qos_$[rsp]
  00111	48 8b cb	 mov	 rcx, rbx
  00114	e8 00 00 00 00	 call	 mg_send

; 4349 : }

  00119	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0011e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00123	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00127	5f		 pop	 rdi
  00128	c3		 ret	 0
mg_mqtt_sub ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_mqtt_parse
_TEXT	SEGMENT
buf$ = 64
len$ = 72
version$ = 80
m$ = 88
mg_mqtt_parse PROC					; COMDAT

; 4352 :                   struct mg_mqtt_message *m) {

$LN51:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00018	48 8b da	 mov	 rbx, rdx
  0001b	41 8a e8	 mov	 bpl, r8b

; 4353 :   uint8_t lc = 0, *p, *end;
; 4354 :   uint32_t n = 0, len_len = 0;
; 4355 : 
; 4356 :   memset(m, 0, sizeof(*m));

  0001e	33 d2		 xor	 edx, edx
  00020	4c 8b f1	 mov	 r14, rcx
  00023	49 8b c9	 mov	 rcx, r9
  00026	49 8b f9	 mov	 rdi, r9
  00029	44 8d 42 48	 lea	 r8d, QWORD PTR [rdx+72]
  0002d	e8 00 00 00 00	 call	 memset

; 4357 :   m->dgram.ptr = (char *) buf;

  00032	4c 89 77 20	 mov	 QWORD PTR [rdi+32], r14

; 4358 :   if (len < 2) return MQTT_INCOMPLETE;

  00036	41 bb 01 00 00
	00		 mov	 r11d, 1
  0003c	48 83 fb 02	 cmp	 rbx, 2
  00040	0f 82 95 01 00
	00		 jb	 $LN10@mg_mqtt_pa

; 4359 :   m->cmd = (uint8_t) (buf[0] >> 4);

  00046	41 8a 06	 mov	 al, BYTE PTR [r14]

; 4360 :   m->qos = (buf[0] >> 1) & 3;
; 4361 : 
; 4362 :   n = len_len = 0;
; 4363 :   p = (uint8_t *) buf + 1;

  00049	49 8d 56 01	 lea	 rdx, QWORD PTR [r14+1]
  0004d	c0 e8 04	 shr	 al, 4
  00050	45 33 d2	 xor	 r10d, r10d
  00053	88 47 32	 mov	 BYTE PTR [rdi+50], al
  00056	45 8b c3	 mov	 r8d, r11d
  00059	41 8a 06	 mov	 al, BYTE PTR [r14]
  0005c	d0 e8		 shr	 al, 1
  0005e	24 03		 and	 al, 3
  00060	88 47 33	 mov	 BYTE PTR [rdi+51], al
  00063	33 c9		 xor	 ecx, ecx
$LL2@mg_mqtt_pa:

; 4365 :     lc = *((uint8_t *) p++);

  00065	44 0f b6 0a	 movzx	 r9d, BYTE PTR [rdx]
  00069	4d 03 c3	 add	 r8, r11

; 4366 :     n += (uint32_t) ((lc & 0x7f) << 7 * len_len);

  0006c	41 8b c1	 mov	 eax, r9d
  0006f	49 03 d3	 add	 rdx, r11
  00072	83 e0 7f	 and	 eax, 127		; 0000007fH
  00075	d3 e0		 shl	 eax, cl

; 4367 :     len_len++;

  00077	83 c1 07	 add	 ecx, 7
  0007a	44 03 d0	 add	 r10d, eax

; 4368 :     if (!(lc & 0x80)) break;

  0007d	45 84 c9	 test	 r9b, r9b
  00080	79 0e		 jns	 SHORT $LN3@mg_mqtt_pa

; 4369 :     if (len_len >= 4) return MQTT_MALFORMED;

  00082	83 f9 1c	 cmp	 ecx, 28
  00085	0f 83 33 01 00
	00		 jae	 $LN39@mg_mqtt_pa

; 4364 :   while ((size_t) (p - buf) < len) {

  0008b	4c 3b c3	 cmp	 r8, rbx
  0008e	72 d5		 jb	 SHORT $LL2@mg_mqtt_pa
$LN3@mg_mqtt_pa:

; 4370 :   }
; 4371 :   end = p + n;

  00090	45 8b c2	 mov	 r8d, r10d
  00093	49 8d 34 12	 lea	 rsi, QWORD PTR [r10+rdx]

; 4372 :   if ((lc & 0x80) || (end > buf + len)) return MQTT_INCOMPLETE;

  00097	45 84 c9	 test	 r9b, r9b
  0009a	0f 88 3b 01 00
	00		 js	 $LN10@mg_mqtt_pa
  000a0	49 8d 04 1e	 lea	 rax, QWORD PTR [r14+rbx]
  000a4	48 3b f0	 cmp	 rsi, rax
  000a7	0f 87 2e 01 00
	00		 ja	 $LN10@mg_mqtt_pa

; 4373 :   m->dgram.len = (size_t) (end - buf);
; 4374 : 
; 4375 :   switch (m->cmd) {

  000ad	0f b6 4f 32	 movzx	 ecx, BYTE PTR [rdi+50]
  000b1	48 8b c6	 mov	 rax, rsi
  000b4	49 2b c6	 sub	 rax, r14
  000b7	48 89 47 28	 mov	 QWORD PTR [rdi+40], rax
  000bb	83 f9 07	 cmp	 ecx, 7
  000be	0f 87 e8 00 00
	00		 ja	 $LN33@mg_mqtt_pa
  000c4	0f 84 eb 00 00
	00		 je	 $LN13@mg_mqtt_pa
  000ca	83 e9 02	 sub	 ecx, 2
  000cd	0f 84 cb 00 00
	00		 je	 $LN11@mg_mqtt_pa
  000d3	41 2b cb	 sub	 ecx, r11d
  000d6	74 20		 je	 SHORT $LN22@mg_mqtt_pa
$LN49@mg_mqtt_pa:
  000d8	41 2b cb	 sub	 ecx, r11d
  000db	0f 84 d4 00 00
	00		 je	 $LN13@mg_mqtt_pa
  000e1	41 2b cb	 sub	 ecx, r11d
  000e4	0f 84 cb 00 00
	00		 je	 $LN13@mg_mqtt_pa
  000ea	41 3b cb	 cmp	 ecx, r11d
  000ed	0f 84 c2 00 00
	00		 je	 $LN13@mg_mqtt_pa
  000f3	e9 df 00 00 00	 jmp	 $LN31@mg_mqtt_pa
$LN22@mg_mqtt_pa:

; 4390 :       p += 2;
; 4391 :       break;
; 4392 :     case MQTT_CMD_PUBLISH: {
; 4393 :       if (p + 2 > end) return MQTT_MALFORMED;

  000f8	4c 8d 42 02	 lea	 r8, QWORD PTR [rdx+2]
  000fc	4c 3b c6	 cmp	 r8, rsi
  000ff	0f 87 b9 00 00
	00		 ja	 $LN39@mg_mqtt_pa

; 4394 :       m->topic.len = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);

  00105	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00108	0f b6 4a 01	 movzx	 ecx, BYTE PTR [rdx+1]
  0010c	48 c1 e0 08	 shl	 rax, 8
  00110	48 0b c8	 or	 rcx, rax

; 4395 :       m->topic.ptr = (char *) p + 2;

  00113	4c 89 07	 mov	 QWORD PTR [rdi], r8
  00116	48 89 4f 08	 mov	 QWORD PTR [rdi+8], rcx

; 4396 :       p += 2 + m->topic.len;

  0011a	48 8d 59 02	 lea	 rbx, QWORD PTR [rcx+2]
  0011e	48 03 da	 add	 rbx, rdx

; 4397 :       if (p > end) return MQTT_MALFORMED;

  00121	48 3b de	 cmp	 rbx, rsi
  00124	0f 87 94 00 00
	00		 ja	 $LN39@mg_mqtt_pa

; 4398 :       if (m->qos > 0) {

  0012a	80 7f 33 00	 cmp	 BYTE PTR [rdi+51], 0
  0012e	76 22		 jbe	 SHORT $LN27@mg_mqtt_pa

; 4399 :         if (p + 2 > end) return MQTT_MALFORMED;

  00130	48 8d 53 02	 lea	 rdx, QWORD PTR [rbx+2]
  00134	48 3b d6	 cmp	 rdx, rsi
  00137	0f 87 81 00 00
	00		 ja	 $LN39@mg_mqtt_pa

; 4400 :         m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);

  0013d	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00140	0f b6 4b 01	 movzx	 ecx, BYTE PTR [rbx+1]

; 4401 :         p += 2;

  00144	48 8b da	 mov	 rbx, rdx
  00147	66 c1 e0 08	 shl	 ax, 8
  0014b	66 0b c8	 or	 cx, ax
  0014e	66 89 4f 30	 mov	 WORD PTR [rdi+48], cx
$LN27@mg_mqtt_pa:

; 4402 :       }
; 4403 :       if (p > end) return MQTT_MALFORMED;
; 4404 :       if (version == 5 && p + 2 < end) {

  00152	40 80 fd 05	 cmp	 bpl, 5
  00156	75 39		 jne	 SHORT $LN30@mg_mqtt_pa
  00158	48 8d 43 02	 lea	 rax, QWORD PTR [rbx+2]
  0015c	48 3b c6	 cmp	 rax, rsi
  0015f	73 30		 jae	 SHORT $LN30@mg_mqtt_pa

; 4405 :         len_len =

  00161	48 8b d6	 mov	 rdx, rsi
  00164	4c 8d 47 40	 lea	 r8, QWORD PTR [rdi+64]
  00168	48 2b d3	 sub	 rdx, rbx
  0016b	48 8b cb	 mov	 rcx, rbx
  0016e	e8 00 00 00 00	 call	 decode_varint

; 4406 :             (uint32_t) decode_varint(p, (size_t) (end - p), &m->props_size);
; 4407 :         if (!len_len) return MQTT_MALFORMED;

  00173	85 c0		 test	 eax, eax
  00175	74 47		 je	 SHORT $LN39@mg_mqtt_pa

; 4408 :         m->props_start = (size_t) (p + len_len - buf);

  00177	8b c8		 mov	 ecx, eax

; 4409 :         p += len_len + m->props_size;

  00179	48 03 4f 40	 add	 rcx, QWORD PTR [rdi+64]
  0017d	8b c0		 mov	 eax, eax
  0017f	49 2b c6	 sub	 rax, r14
  00182	48 03 c3	 add	 rax, rbx
  00185	48 03 d9	 add	 rbx, rcx
  00188	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 4410 :       }
; 4411 :       if (p > end) return MQTT_MALFORMED;

  0018c	48 3b de	 cmp	 rbx, rsi
  0018f	77 2d		 ja	 SHORT $LN39@mg_mqtt_pa
$LN30@mg_mqtt_pa:

; 4412 :       m->data.ptr = (char *) p;
; 4413 :       m->data.len = (size_t) (end - p);

  00191	48 2b f3	 sub	 rsi, rbx
  00194	48 89 5f 10	 mov	 QWORD PTR [rdi+16], rbx
  00198	48 89 77 18	 mov	 QWORD PTR [rdi+24], rsi

; 4414 :       break;

  0019c	eb 39		 jmp	 SHORT $LN31@mg_mqtt_pa
$LN11@mg_mqtt_pa:

; 4376 :     case MQTT_CMD_CONNACK:
; 4377 :       if (end - p < 2) return MQTT_MALFORMED;

  0019e	49 83 f8 02	 cmp	 r8, 2
  001a2	72 1a		 jb	 SHORT $LN39@mg_mqtt_pa

; 4378 :       m->ack = p[1];

  001a4	8a 42 01	 mov	 al, BYTE PTR [rdx+1]
  001a7	88 47 34	 mov	 BYTE PTR [rdi+52], al

; 4379 :       break;

  001aa	eb 2b		 jmp	 SHORT $LN31@mg_mqtt_pa
$LN33@mg_mqtt_pa:

; 4373 :   m->dgram.len = (size_t) (end - buf);
; 4374 : 
; 4375 :   switch (m->cmd) {

  001ac	83 e9 08	 sub	 ecx, 8
  001af	0f 85 23 ff ff
	ff		 jne	 $LN49@mg_mqtt_pa
$LN13@mg_mqtt_pa:

; 4380 :     case MQTT_CMD_PUBACK:
; 4381 :     case MQTT_CMD_PUBREC:
; 4382 :     case MQTT_CMD_PUBREL:
; 4383 :     case MQTT_CMD_PUBCOMP:
; 4384 :     case MQTT_CMD_SUBSCRIBE:
; 4385 :     case MQTT_CMD_SUBACK:
; 4386 :     case MQTT_CMD_UNSUBSCRIBE:
; 4387 :     case MQTT_CMD_UNSUBACK:
; 4388 :       if (p + 2 > end) return MQTT_MALFORMED;

  001b5	48 8d 42 02	 lea	 rax, QWORD PTR [rdx+2]
  001b9	48 3b c6	 cmp	 rax, rsi
  001bc	76 07		 jbe	 SHORT $LN21@mg_mqtt_pa
$LN39@mg_mqtt_pa:
  001be	b8 02 00 00 00	 mov	 eax, 2
  001c3	eb 19		 jmp	 SHORT $LN1@mg_mqtt_pa
$LN21@mg_mqtt_pa:

; 4389 :       m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);

  001c5	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  001c8	0f b6 4a 01	 movzx	 ecx, BYTE PTR [rdx+1]
  001cc	66 c1 e0 08	 shl	 ax, 8
  001d0	66 0b c8	 or	 cx, ax
  001d3	66 89 4f 30	 mov	 WORD PTR [rdi+48], cx
$LN31@mg_mqtt_pa:

; 4415 :     }
; 4416 :     default:
; 4417 :       break;
; 4418 :   }
; 4419 :   return MQTT_OK;

  001d7	33 c0		 xor	 eax, eax
  001d9	eb 03		 jmp	 SHORT $LN1@mg_mqtt_pa
$LN10@mg_mqtt_pa:

; 4372 :   if ((lc & 0x80) || (end > buf + len)) return MQTT_INCOMPLETE;

  001db	41 8b c3	 mov	 eax, r11d
$LN1@mg_mqtt_pa:

; 4420 : }

  001de	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001e3	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001e8	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001ed	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001f1	41 5f		 pop	 r15
  001f3	41 5e		 pop	 r14
  001f5	5f		 pop	 rdi
  001f6	c3		 ret	 0
mg_mqtt_parse ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mqtt_cb
_TEXT	SEGMENT
mm$1 = 48
c$ = 160
id$2 = 168
id$3 = 168
ev$ = 168
ev_data$ = 176
zero$4 = 184
mqtt_cb	PROC						; COMDAT

; 4423 :   if (ev == MG_EV_READ) {

  00000	83 fa 07	 cmp	 edx, 7
  00003	0f 85 b9 02 00
	00		 jne	 $LN51@mqtt_cb
  00009	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  0000e	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	41 57		 push	 r15
  00017	48 8b ec	 mov	 rbp, rsp
  0001a	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 4424 :     for (;;) {
; 4425 :       uint8_t version = c->is_mqtt5 ? 5 : 4;

  00021	44 8b 81 10 01
	00 00		 mov	 r8d, DWORD PTR [rcx+272]

; 4426 :       struct mg_mqtt_message mm;
; 4427 :       int rc = mg_mqtt_parse(c->recv.buf, c->recv.len, version, &mm);

  00028	48 8d 79 48	 lea	 rdi, QWORD PTR [rcx+72]
  0002c	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  00030	4c 8d 4d b0	 lea	 r9, QWORD PTR mm$1[rbp-128]
  00034	41 c1 e8 0a	 shr	 r8d, 10
  00038	48 8b d9	 mov	 rbx, rcx
  0003b	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0003e	41 80 e0 01	 and	 r8b, 1
  00042	41 80 c8 04	 or	 r8b, 4
  00046	e8 00 00 00 00	 call	 mg_mqtt_parse

; 4428 :       if (rc == MQTT_MALFORMED) {

  0004b	be 02 00 00 00	 mov	 esi, 2
  00050	3b c6		 cmp	 eax, esi
  00052	0f 84 1c 02 00
	00		 je	 $LN45@mqtt_cb
  00058	45 33 ff	 xor	 r15d, r15d
$LL2@mqtt_cb:

; 4431 :         break;
; 4432 :       } else if (rc == MQTT_OK) {

  0005b	85 c0		 test	 eax, eax
  0005d	0f 85 48 02 00
	00		 jne	 $LN23@mqtt_cb

; 4433 :         MG_VERBOSE(("%lu MQTT CMD %d len %d [%.*s]", c->id, mm.cmd,

  00063	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR mg_log_level, 4
  0006a	7c 3d		 jl	 SHORT $LN8@mqtt_cb
  0006c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_07IJPJCEBD@mqtt_cb@
  00073	41 b8 52 11 00
	00		 mov	 r8d, 4434		; 00001152H
  00079	8d 48 04	 lea	 ecx, QWORD PTR [rax+4]
  0007c	e8 00 00 00 00	 call	 mg_log_prefix
  00081	48 8b 45 c0	 mov	 rax, QWORD PTR mm$1[rbp-112]
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@KABHPGHA@?$CFlu?5MQTT?5CMD?5?$CFd?5len?5?$CFd?5?$FL?$CF?4?$CKs?$FN@
  0008c	44 0f b6 45 e2	 movzx	 r8d, BYTE PTR mm$1[rbp-78]
  00091	44 8b 4d d8	 mov	 r9d, DWORD PTR mm$1[rbp-88]
  00095	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  00098	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0009d	8b 45 c8	 mov	 eax, DWORD PTR mm$1[rbp-104]
  000a0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000a4	e8 00 00 00 00	 call	 mg_log
$LN8@mqtt_cb:

; 4434 :                     (int) mm.dgram.len, (int) mm.data.len, mm.data.ptr));
; 4435 :         switch (mm.cmd) {

  000a9	0f b6 4d e2	 movzx	 ecx, BYTE PTR mm$1[rbp-78]
  000ad	2b ce		 sub	 ecx, esi
  000af	0f 84 f1 00 00
	00		 je	 $LN26@mqtt_cb
  000b5	83 e9 01	 sub	 ecx, 1
  000b8	74 60		 je	 SHORT $LN31@mqtt_cb
  000ba	2b ce		 sub	 ecx, esi
  000bc	74 43		 je	 SHORT $LN35@mqtt_cb
  000be	83 f9 01	 cmp	 ecx, 1
  000c1	0f 85 63 01 00
	00		 jne	 $LN28@mqtt_cb

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  000c7	0f b7 45 e0	 movzx	 eax, WORD PTR mm$1[rbp-80]

; 4473 :           }
; 4474 :           case MQTT_CMD_PUBREL: {  // MQTT5: 3.6.2-1 TODO(): variable header rc
; 4475 :             uint16_t id = mg_ntohs(mm.id);
; 4476 :             uint32_t remaining_len = sizeof(id);  // MQTT5 3.7.2-1
; 4477 :             mg_mqtt_send_header(c, MQTT_CMD_PUBCOMP, 0, remaining_len);

  000cb	b2 07		 mov	 dl, 7

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  000cd	0f b6 c8	 movzx	 ecx, al
  000d0	66 c1 e1 08	 shl	 cx, 8
  000d4	66 c1 e8 08	 shr	 ax, 8
  000d8	66 0b c8	 or	 cx, ax

; 4473 :           }
; 4474 :           case MQTT_CMD_PUBREL: {  // MQTT5: 3.6.2-1 TODO(): variable header rc
; 4475 :             uint16_t id = mg_ntohs(mm.id);
; 4476 :             uint32_t remaining_len = sizeof(id);  // MQTT5 3.7.2-1
; 4477 :             mg_mqtt_send_header(c, MQTT_CMD_PUBCOMP, 0, remaining_len);

  000db	45 33 c0	 xor	 r8d, r8d
$LN53@mqtt_cb:

; 4478 :             mg_send(c, &id, sizeof(id));
; 4479 :             break;
; 4480 :           }
; 4481 :         }
; 4482 :         mg_call(c, MG_EV_MQTT_CMD, &mm);

  000de	66 89 4d 28	 mov	 WORD PTR id$2[rbp-128], cx
  000e2	44 8b ce	 mov	 r9d, esi
  000e5	48 8b cb	 mov	 rcx, rbx
  000e8	e8 00 00 00 00	 call	 mg_mqtt_send_header
  000ed	4c 8b c6	 mov	 r8, rsi
  000f0	48 8d 55 28	 lea	 rdx, QWORD PTR id$2[rbp-128]
  000f4	48 8b cb	 mov	 rcx, rbx
  000f7	e8 00 00 00 00	 call	 mg_send
  000fc	e9 29 01 00 00	 jmp	 $LN28@mqtt_cb
$LN35@mqtt_cb:

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00101	0f b7 45 e0	 movzx	 eax, WORD PTR mm$1[rbp-80]

; 4466 :           }
; 4467 :           case MQTT_CMD_PUBREC: {  // MQTT5: 3.5.2-1 TODO(): variable header rc
; 4468 :             uint16_t id = mg_ntohs(mm.id);
; 4469 :             uint32_t remaining_len = sizeof(id);  // MQTT5 3.6.2-1
; 4470 :             mg_mqtt_send_header(c, MQTT_CMD_PUBREL, 2, remaining_len);

  00105	44 8a c6	 mov	 r8b, sil

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00108	0f b6 c8	 movzx	 ecx, al

; 4466 :           }
; 4467 :           case MQTT_CMD_PUBREC: {  // MQTT5: 3.5.2-1 TODO(): variable header rc
; 4468 :             uint16_t id = mg_ntohs(mm.id);
; 4469 :             uint32_t remaining_len = sizeof(id);  // MQTT5 3.6.2-1
; 4470 :             mg_mqtt_send_header(c, MQTT_CMD_PUBREL, 2, remaining_len);

  0010b	b2 06		 mov	 dl, 6

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  0010d	66 c1 e1 08	 shl	 cx, 8
  00111	66 c1 e8 08	 shr	 ax, 8
  00115	66 0b c8	 or	 cx, ax

; 4471 :             mg_send(c, &id, sizeof(id));  // MQTT5 3.6.1-1, flags = 2
; 4472 :             break;

  00118	eb c4		 jmp	 SHORT $LN53@mqtt_cb
$LN31@mqtt_cb:

; 4443 :             }
; 4444 :             break;
; 4445 :           case MQTT_CMD_PUBLISH: {
; 4446 :             /*MG_DEBUG(("%lu [%.*s] -> [%.*s]", c->id, (int) mm.topic.len,
; 4447 :                       mm.topic.ptr, (int) mm.data.len, mm.data.ptr));*/
; 4448 :             if (mm.qos > 0) {

  0011a	8a 55 e3	 mov	 dl, BYTE PTR mm$1[rbp-77]
  0011d	84 d2		 test	 dl, dl
  0011f	74 6f		 je	 SHORT $LN34@mqtt_cb

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00121	0f b7 45 e0	 movzx	 eax, WORD PTR mm$1[rbp-80]
  00125	0f b6 c8	 movzx	 ecx, al
  00128	66 c1 e8 08	 shr	 ax, 8
  0012c	66 c1 e1 08	 shl	 cx, 8
  00130	66 0b c8	 or	 cx, ax

; 4449 :               uint16_t id = mg_ntohs(mm.id);
; 4450 :               uint32_t remaining_len = sizeof(id);
; 4451 :               if (c->is_mqtt5) remaining_len += 2;  // 3.4.2

  00133	8b 83 10 01 00
	00		 mov	 eax, DWORD PTR [rbx+272]
  00139	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0013e	66 89 4d 28	 mov	 WORD PTR id$3[rbp-128], cx

; 4452 : 
; 4453 :               mg_mqtt_send_header(

  00142	f7 d8		 neg	 eax
  00144	48 8b cb	 mov	 rcx, rbx
  00147	45 1b c9	 sbb	 r9d, r9d
  0014a	44 23 ce	 and	 r9d, esi
  0014d	44 03 ce	 add	 r9d, esi
  00150	40 3a d6	 cmp	 dl, sil
  00153	0f 94 c2	 sete	 dl
  00156	45 33 c0	 xor	 r8d, r8d
  00159	80 c2 04	 add	 dl, 4
  0015c	e8 00 00 00 00	 call	 mg_mqtt_send_header

; 4454 :                   c,
; 4455 :                   (uint8_t) (mm.qos == 2 ? MQTT_CMD_PUBREC : MQTT_CMD_PUBACK),
; 4456 :                   0, remaining_len);
; 4457 :               mg_send(c, &id, sizeof(id));

  00161	4c 8b c6	 mov	 r8, rsi
  00164	48 8d 55 28	 lea	 rdx, QWORD PTR id$3[rbp-128]
  00168	48 8b cb	 mov	 rcx, rbx
  0016b	e8 00 00 00 00	 call	 mg_send

; 4458 : 
; 4459 :               if (c->is_mqtt5) {

  00170	f7 83 10 01 00
	00 00 04 00 00	 test	 DWORD PTR [rbx+272], 1024 ; 00000400H
  0017a	74 14		 je	 SHORT $LN34@mqtt_cb

; 4460 :                 uint16_t zero = 0;
; 4461 :                 mg_send(c, &zero, sizeof(zero));

  0017c	4c 8b c6	 mov	 r8, rsi
  0017f	66 44 89 7d 38	 mov	 WORD PTR zero$4[rbp-128], r15w
  00184	48 8d 55 38	 lea	 rdx, QWORD PTR zero$4[rbp-128]
  00188	48 8b cb	 mov	 rcx, rbx
  0018b	e8 00 00 00 00	 call	 mg_send
$LN34@mqtt_cb:

; 4462 :               }
; 4463 :             }
; 4464 :             mg_call(c, MG_EV_MQTT_MSG, &mm);  // let the app handle qos stuff

  00190	4c 8d 45 b0	 lea	 r8, QWORD PTR mm$1[rbp-128]
  00194	ba 0f 00 00 00	 mov	 edx, 15
  00199	48 8b cb	 mov	 rcx, rbx
  0019c	e8 00 00 00 00	 call	 mg_call

; 4465 :             break;

  001a1	e9 84 00 00 00	 jmp	 $LN28@mqtt_cb
$LN26@mqtt_cb:

; 4436 :           case MQTT_CMD_CONNACK:
; 4437 :             mg_call(c, MG_EV_MQTT_OPEN, &mm.ack);

  001a6	4c 8d 45 e4	 lea	 r8, QWORD PTR mm$1[rbp-76]
  001aa	ba 10 00 00 00	 mov	 edx, 16
  001af	48 8b cb	 mov	 rcx, rbx
  001b2	e8 00 00 00 00	 call	 mg_call

; 4438 :             if (mm.ack == 0) {

  001b7	44 38 7d e4	 cmp	 BYTE PTR mm$1[rbp-76], r15b
  001bb	75 31		 jne	 SHORT $LN18@mqtt_cb

; 4439 :               MG_DEBUG(("%lu Connected", c->id));

  001bd	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR mg_log_level, 3
  001c4	7c 64		 jl	 SHORT $LN28@mqtt_cb
  001c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_07IJPJCEBD@mqtt_cb@
  001cd	b9 03 00 00 00	 mov	 ecx, 3
  001d2	41 b8 57 11 00
	00		 mov	 r8d, 4439		; 00001157H
  001d8	e8 00 00 00 00	 call	 mg_log_prefix
  001dd	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MHLPOCL@?$CFlu?5Connected@
  001e7	e8 00 00 00 00	 call	 mg_log
  001ec	eb 3c		 jmp	 SHORT $LN28@mqtt_cb
$LN18@mqtt_cb:

; 4440 :             } else {
; 4441 :               MG_ERROR(("%lu MQTT auth failed, code %d", c->id, mm.ack));

  001ee	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR mg_log_level, 1
  001f5	7c 2b		 jl	 SHORT $LN16@mqtt_cb
  001f7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_07IJPJCEBD@mqtt_cb@
  001fe	b9 01 00 00 00	 mov	 ecx, 1
  00203	41 b8 59 11 00
	00		 mov	 r8d, 4441		; 00001159H
  00209	e8 00 00 00 00	 call	 mg_log_prefix
  0020e	44 0f b6 45 e4	 movzx	 r8d, BYTE PTR mm$1[rbp-76]
  00213	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@FOKBBNGE@?$CFlu?5MQTT?5auth?5failed?0?5code?5?$CFd@
  0021a	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  0021d	e8 00 00 00 00	 call	 mg_log
$LN16@mqtt_cb:

; 4442 :               c->is_closing = 1;

  00222	0f ba ab 10 01
	00 00 0d	 bts	 DWORD PTR [rbx+272], 13
$LN28@mqtt_cb:

; 4478 :             mg_send(c, &id, sizeof(id));
; 4479 :             break;
; 4480 :           }
; 4481 :         }
; 4482 :         mg_call(c, MG_EV_MQTT_CMD, &mm);

  0022a	4c 8d 45 b0	 lea	 r8, QWORD PTR mm$1[rbp-128]
  0022e	ba 0e 00 00 00	 mov	 edx, 14
  00233	48 8b cb	 mov	 rcx, rbx
  00236	e8 00 00 00 00	 call	 mg_call

; 4483 :         mg_iobuf_del(&c->recv, 0, mm.dgram.len);

  0023b	4c 8b 45 d8	 mov	 r8, QWORD PTR mm$1[rbp-88]
  0023f	33 d2		 xor	 edx, edx
  00241	48 8b cf	 mov	 rcx, rdi
  00244	e8 00 00 00 00	 call	 mg_iobuf_del
  00249	44 8b 83 10 01
	00 00		 mov	 r8d, DWORD PTR [rbx+272]
  00250	4c 8d 4d b0	 lea	 r9, QWORD PTR mm$1[rbp-128]
  00254	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  00258	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0025b	41 c1 e8 0a	 shr	 r8d, 10
  0025f	41 80 e0 01	 and	 r8b, 1
  00263	41 80 c8 04	 or	 r8b, 4
  00267	e8 00 00 00 00	 call	 mg_mqtt_parse
  0026c	3b c6		 cmp	 eax, esi
  0026e	0f 85 e7 fd ff
	ff		 jne	 $LL2@mqtt_cb
$LN45@mqtt_cb:

; 4429 :         MG_ERROR(("%lu MQTT malformed message", c->id));

  00274	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR mg_log_level, 1
  0027b	7c 26		 jl	 SHORT $LN5@mqtt_cb
  0027d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_07IJPJCEBD@mqtt_cb@
  00284	b9 01 00 00 00	 mov	 ecx, 1
  00289	41 b8 4d 11 00
	00		 mov	 r8d, 4429		; 0000114dH
  0028f	e8 00 00 00 00	 call	 mg_log_prefix
  00294	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  00297	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@MPELNGON@?$CFlu?5MQTT?5malformed?5message@
  0029e	e8 00 00 00 00	 call	 mg_log
$LN5@mqtt_cb:

; 4430 :         c->is_closing = 1;

  002a3	0f ba ab 10 01
	00 00 0d	 bts	 DWORD PTR [rbx+272], 13
$LN23@mqtt_cb:

; 4484 :       } else {
; 4485 :         break;
; 4486 :       }
; 4487 :     }
; 4488 :   }
; 4489 :   (void) ev_data;
; 4490 : }

  002ab	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  002b3	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  002b7	49 8b 73 30	 mov	 rsi, QWORD PTR [r11+48]
  002bb	49 8b e3	 mov	 rsp, r11
  002be	41 5f		 pop	 r15
  002c0	5f		 pop	 rdi
  002c1	5d		 pop	 rbp
$LN51@mqtt_cb:
  002c2	c3		 ret	 0
mqtt_cb	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_mqtt_ping
_TEXT	SEGMENT
nc$ = 8
mg_mqtt_ping PROC					; COMDAT

; 4493 :   mg_mqtt_send_header(nc, MQTT_CMD_PINGREQ, 0, 0);

  00000	45 33 c9	 xor	 r9d, r9d
  00003	45 33 c0	 xor	 r8d, r8d
  00006	b2 0c		 mov	 dl, 12
  00008	e9 00 00 00 00	 jmp	 mg_mqtt_send_header
mg_mqtt_ping ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_mqtt_pong
_TEXT	SEGMENT
nc$ = 8
mg_mqtt_pong PROC					; COMDAT

; 4497 :   mg_mqtt_send_header(nc, MQTT_CMD_PINGRESP, 0, 0);

  00000	45 33 c9	 xor	 r9d, r9d
  00003	45 33 c0	 xor	 r8d, r8d
  00006	b2 0d		 mov	 dl, 13
  00008	e9 00 00 00 00	 jmp	 mg_mqtt_send_header
mg_mqtt_pong ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_mqtt_disconnect
_TEXT	SEGMENT
zero$1 = 48
c$ = 48
opts$ = 56
mg_mqtt_disconnect PROC					; COMDAT

; 4501 :                         const struct mg_mqtt_opts *opts) {

$LN17:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4502 :   size_t len = 0;

  0000f	33 c0		 xor	 eax, eax

; 4503 :   if (c->is_mqtt5) len = 1 + get_props_size(opts->props, opts->num_props);

  00011	48 8d 5a 60	 lea	 rbx, QWORD PTR [rdx+96]
  00015	f7 81 10 01 00
	00 00 04 00 00	 test	 DWORD PTR [rcx+272], 1024 ; 00000400H
  0001f	48 8d 7a 58	 lea	 rdi, QWORD PTR [rdx+88]
  00023	48 8b f1	 mov	 rsi, rcx
  00026	74 24		 je	 SHORT $LN15@mg_mqtt_di

; 4147 :   size_t size = get_properties_length(props, count);

  00028	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  0002b	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0002e	e8 00 00 00 00	 call	 get_properties_length

; 4148 :   size += varint_size(size);

  00033	48 8b c8	 mov	 rcx, rax

; 4063 :   uint8_t bytes_needed = 0;

  00036	32 d2		 xor	 dl, dl
$LL10@mg_mqtt_di:

; 4064 :   do {
; 4065 :     bytes_needed++;

  00038	fe c2		 inc	 dl

; 4066 :     length /= 0x80;

  0003a	48 c1 e9 07	 shr	 rcx, 7

; 4067 :   } while (length > 0);

  0003e	48 85 c9	 test	 rcx, rcx
  00041	75 f5		 jne	 SHORT $LL10@mg_mqtt_di

; 4148 :   size += varint_size(size);

  00043	0f b6 ca	 movzx	 ecx, dl

; 4503 :   if (c->is_mqtt5) len = 1 + get_props_size(opts->props, opts->num_props);

  00046	48 ff c0	 inc	 rax
  00049	48 03 c1	 add	 rax, rcx
$LN15@mg_mqtt_di:

; 4504 :   mg_mqtt_send_header(c, MQTT_CMD_DISCONNECT, 0, (uint32_t) len);

  0004c	44 8b c8	 mov	 r9d, eax
  0004f	45 33 c0	 xor	 r8d, r8d
  00052	b2 0e		 mov	 dl, 14
  00054	48 8b ce	 mov	 rcx, rsi
  00057	e8 00 00 00 00	 call	 mg_mqtt_send_header

; 4505 : 
; 4506 :   if (c->is_mqtt5) {

  0005c	f7 86 10 01 00
	00 00 04 00 00	 test	 DWORD PTR [rsi+272], 1024 ; 00000400H
  00066	74 26		 je	 SHORT $LN3@mg_mqtt_di

; 4507 :     uint8_t zero = 0;
; 4508 :     mg_send(c, &zero, sizeof(zero));  // reason code

  00068	41 b8 01 00 00
	00		 mov	 r8d, 1
  0006e	c6 44 24 30 00	 mov	 BYTE PTR zero$1[rsp], 0
  00073	48 8d 54 24 30	 lea	 rdx, QWORD PTR zero$1[rsp]
  00078	48 8b ce	 mov	 rcx, rsi
  0007b	e8 00 00 00 00	 call	 mg_send

; 4509 :     mg_send_mqtt_properties(c, opts->props, opts->num_props);

  00080	4c 8b 03	 mov	 r8, QWORD PTR [rbx]
  00083	48 8b ce	 mov	 rcx, rsi
  00086	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00089	e8 00 00 00 00	 call	 mg_send_mqtt_properties
$LN3@mg_mqtt_di:

; 4510 :   }
; 4511 : }

  0008e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00093	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00098	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009c	5f		 pop	 rdi
  0009d	c3		 ret	 0
mg_mqtt_disconnect ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_mqtt_connect
_TEXT	SEGMENT
empty$1 = 32
mgr$ = 176
url$ = 184
opts$ = 192
fn$ = 200
fn_data$ = 208
mg_mqtt_connect PROC					; COMDAT

; 4515 :                                       mg_event_handler_t fn, void *fn_data) {

$LN5:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  0000d	49 8b c1	 mov	 rax, r9
  00010	49 8b f8	 mov	 rdi, r8

; 4516 :   struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);

  00013	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR fn_data$[rsp]
  0001b	4c 8b c0	 mov	 r8, rax
  0001e	e8 00 00 00 00	 call	 mg_connect
  00023	48 8b d8	 mov	 rbx, rax

; 4517 :   if (c != NULL) {

  00026	48 85 c0	 test	 rax, rax
  00029	74 32		 je	 SHORT $LN2@mg_mqtt_co

; 4518 :     struct mg_mqtt_opts empty;
; 4519 :     memset(&empty, 0, sizeof(empty));

  0002b	33 d2		 xor	 edx, edx
  0002d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR empty$1[rsp]
  00032	44 8d 42 78	 lea	 r8d, QWORD PTR [rdx+120]
  00036	e8 00 00 00 00	 call	 memset

; 4520 :     mg_mqtt_login(c, opts == NULL ? &empty : opts);

  0003b	48 85 ff	 test	 rdi, rdi
  0003e	48 8d 54 24 20	 lea	 rdx, QWORD PTR empty$1[rsp]
  00043	48 8b cb	 mov	 rcx, rbx
  00046	48 0f 45 d7	 cmovne	 rdx, rdi
  0004a	e8 00 00 00 00	 call	 mg_mqtt_login

; 4521 :     c->pfn = mqtt_cb;

  0004f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:mqtt_cb
  00056	48 89 83 d8 00
	00 00		 mov	 QWORD PTR [rbx+216], rax
$LN2@mg_mqtt_co:

; 4522 :   }
; 4523 :   return c;

  0005d	48 8b c3	 mov	 rax, rbx

; 4524 : }

  00060	48 8b 9c 24 b0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+176]
  00068	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  0006f	5f		 pop	 rdi
  00070	c3		 ret	 0
mg_mqtt_connect ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_mqtt_listen
_TEXT	SEGMENT
mgr$ = 48
url$ = 56
fn$ = 64
fn_data$ = 72
mg_mqtt_listen PROC					; COMDAT

; 4527 :                                      mg_event_handler_t fn, void *fn_data) {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 4528 :   struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);

  00009	e8 00 00 00 00	 call	 mg_listen

; 4529 :   if (c != NULL) c->pfn = mqtt_cb, c->pfn_data = mgr;

  0000e	48 85 c0	 test	 rax, rax
  00011	74 15		 je	 SHORT $LN2@mg_mqtt_li
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mqtt_cb
  0001a	48 89 98 e0 00
	00 00		 mov	 QWORD PTR [rax+224], rbx
  00021	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx
$LN2@mg_mqtt_li:

; 4530 :   return c;
; 4531 : }

  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5b		 pop	 rbx
  0002d	c3		 ret	 0
mg_mqtt_listen ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_vprintf
_TEXT	SEGMENT
c$ = 48
fmt$ = 56
ap$ = 64
mg_vprintf PROC						; COMDAT

; 5655 : size_t mg_vprintf(struct mg_connection *c, const char *fmt, va_list *ap) {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5656 :   size_t old = c->send.len;

  0000a	48 8b 59 78	 mov	 rbx, QWORD PTR [rcx+120]
  0000e	48 8b c2	 mov	 rax, rdx

; 5657 :   mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);

  00011	48 8d 51 68	 lea	 rdx, QWORD PTR [rcx+104]
  00015	48 8b f9	 mov	 rdi, rcx
  00018	4d 8b c8	 mov	 r9, r8
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mg_pfn_iobuf
  00022	4c 8b c0	 mov	 r8, rax
  00025	e8 00 00 00 00	 call	 mg_vxprintf

; 5658 :   return c->send.len - old;

  0002a	48 8b 47 78	 mov	 rax, QWORD PTR [rdi+120]
  0002e	48 2b c3	 sub	 rax, rbx

; 5659 : }

  00031	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
mg_vprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_printf
_TEXT	SEGMENT
c$ = 64
fmt$ = 72
mg_printf PROC						; COMDAT

; 5661 : size_t mg_printf(struct mg_connection *c, const char *fmt, ...) {

$LN4:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 53 10	 mov	 QWORD PTR [r11+16], rdx
  00007	4d 89 43 18	 mov	 QWORD PTR [r11+24], r8
  0000b	4d 89 4b 20	 mov	 QWORD PTR [r11+32], r9
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5662 :   size_t len = 0;
; 5663 :   va_list ap;
; 5664 :   va_start(ap, fmt);

  00013	49 8d 43 18	 lea	 rax, QWORD PTR [r11+24]

; 5665 :   len = mg_vprintf(c, fmt, &ap);

  00017	4d 8d 43 e8	 lea	 r8, QWORD PTR [r11-24]
  0001b	49 89 43 e8	 mov	 QWORD PTR [r11-24], rax
  0001f	e8 00 00 00 00	 call	 mg_vprintf

; 5666 :   va_end(ap);
; 5667 :   return len;
; 5668 : }

  00024	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00028	c3		 ret	 0
mg_printf ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_atonl
_TEXT	SEGMENT
str$ = 48
addr$ = 56
mg_atonl PROC						; COMDAT

; 5670 : static bool mg_atonl(struct mg_str str, struct mg_addr *addr) {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 5671 :   uint32_t localhost = mg_htonl(0x7f000001);
; 5672 :   if (mg_vcasecmp(&str, "localhost") != 0) return false;

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09IPAEKDAI@localhost@
  00010	e8 00 00 00 00	 call	 mg_vcasecmp
  00015	85 c0		 test	 eax, eax
  00017	74 04		 je	 SHORT $LN2@mg_atonl
  00019	32 c0		 xor	 al, al
  0001b	eb 0c		 jmp	 SHORT $LN1@mg_atonl
$LN2@mg_atonl:

; 5673 :   memcpy(addr->ip, &localhost, sizeof(uint32_t));

  0001d	c7 03 7f 00 00
	01		 mov	 DWORD PTR [rbx], 16777343 ; 0100007fH

; 5674 :   addr->is_ip6 = false;
; 5675 :   return true;

  00023	b0 01		 mov	 al, 1
  00025	c6 43 13 00	 mov	 BYTE PTR [rbx+19], 0
$LN1@mg_atonl:

; 5676 : }

  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5b		 pop	 rbx
  0002e	c3		 ret	 0
mg_atonl ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_atone
_TEXT	SEGMENT
str$ = 8
addr$ = 16
mg_atone PROC						; COMDAT

; 5679 :   if (str.len > 0) return false;

  00000	48 83 79 08 00	 cmp	 QWORD PTR [rcx+8], 0
  00005	76 03		 jbe	 SHORT $LN2@mg_atone
  00007	32 c0		 xor	 al, al

; 5683 : }

  00009	c3		 ret	 0
$LN2@mg_atone:
  0000a	0f 57 c0	 xorps	 xmm0, xmm0

; 5680 :   memset(addr->ip, 0, sizeof(addr->ip));
; 5681 :   addr->is_ip6 = false;
; 5682 :   return true;

  0000d	b0 01		 mov	 al, 1
  0000f	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00012	c6 42 13 00	 mov	 BYTE PTR [rdx+19], 0

; 5683 : }

  00016	c3		 ret	 0
mg_atone ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_aton4
_TEXT	SEGMENT
data$ = 8
str$ = 8
addr$ = 16
mg_aton4 PROC						; COMDAT

; 5686 :   uint8_t data[4] = {0, 0, 0, 0};

  00000	83 64 24 08 00	 and	 DWORD PTR data$[rsp], 0

; 5687 :   size_t i, num_dots = 0;

  00005	45 33 c9	 xor	 r9d, r9d

; 5688 :   for (i = 0; i < str.len; i++) {

  00008	4c 8b 59 08	 mov	 r11, QWORD PTR [rcx+8]
  0000c	45 33 c0	 xor	 r8d, r8d
  0000f	4d 85 db	 test	 r11, r11
  00012	74 6f		 je	 SHORT $LN13@mg_aton4

; 5689 :     if (str.ptr[i] >= '0' && str.ptr[i] <= '9') {

  00014	4c 8b 11	 mov	 r10, QWORD PTR [rcx]
$LL4@mg_aton4:
  00017	43 8a 04 02	 mov	 al, BYTE PTR [r10+r8]
  0001b	2c 30		 sub	 al, 48			; 00000030H
  0001d	3c 09		 cmp	 al, 9
  0001f	77 22		 ja	 SHORT $LN5@mg_aton4

; 5690 :       int octet = data[num_dots] * 10 + (str.ptr[i] - '0');

  00021	42 0f b6 44 0c
	08		 movzx	 eax, BYTE PTR data$[rsp+r9]
  00027	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]
  0002a	43 0f be 04 02	 movsx	 eax, BYTE PTR [r10+r8]
  0002f	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  00032	83 c0 d0	 add	 eax, -48		; ffffffffffffffd0H

; 5691 :       if (octet > 255) return false;

  00035	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0003a	7f 47		 jg	 SHORT $LN13@mg_aton4

; 5692 :       data[num_dots] = (uint8_t) octet;

  0003c	42 88 44 0c 08	 mov	 BYTE PTR data$[rsp+r9], al
  00041	eb 1d		 jmp	 SHORT $LN2@mg_aton4
$LN5@mg_aton4:

; 5693 :     } else if (str.ptr[i] == '.') {

  00043	43 80 3c 02 2e	 cmp	 BYTE PTR [r10+r8], 46	; 0000002eH
  00048	75 39		 jne	 SHORT $LN13@mg_aton4

; 5694 :       if (num_dots >= 3 || i == 0 || str.ptr[i - 1] == '.') return false;

  0004a	49 83 f9 03	 cmp	 r9, 3
  0004e	73 33		 jae	 SHORT $LN13@mg_aton4
  00050	4d 85 c0	 test	 r8, r8
  00053	74 2e		 je	 SHORT $LN13@mg_aton4
  00055	43 80 7c 02 ff
	2e		 cmp	 BYTE PTR [r10+r8-1], 46	; 0000002eH
  0005b	74 26		 je	 SHORT $LN13@mg_aton4

; 5695 :       num_dots++;

  0005d	49 ff c1	 inc	 r9
$LN2@mg_aton4:

; 5688 :   for (i = 0; i < str.len; i++) {

  00060	49 ff c0	 inc	 r8
  00063	4d 3b c3	 cmp	 r8, r11
  00066	72 af		 jb	 SHORT $LL4@mg_aton4

; 5696 :     } else {
; 5697 :       return false;
; 5698 :     }
; 5699 :   }
; 5700 :   if (num_dots != 3 || str.ptr[i - 1] == '.') return false;

  00068	49 83 f9 03	 cmp	 r9, 3
  0006c	75 15		 jne	 SHORT $LN13@mg_aton4
  0006e	43 80 7c 02 ff
	2e		 cmp	 BYTE PTR [r10+r8-1], 46	; 0000002eH
  00074	74 0d		 je	 SHORT $LN13@mg_aton4

; 5701 :   memcpy(&addr->ip, data, sizeof(data));

  00076	8b 4c 24 08	 mov	 ecx, DWORD PTR data$[rsp]

; 5702 :   addr->is_ip6 = false;
; 5703 :   return true;

  0007a	b0 01		 mov	 al, 1
  0007c	89 0a		 mov	 DWORD PTR [rdx], ecx
  0007e	c6 42 13 00	 mov	 BYTE PTR [rdx+19], 0

; 5704 : }

  00082	c3		 ret	 0
$LN13@mg_aton4:

; 5696 :     } else {
; 5697 :       return false;
; 5698 :     }
; 5699 :   }
; 5700 :   if (num_dots != 3 || str.ptr[i - 1] == '.') return false;

  00083	32 c0		 xor	 al, al

; 5704 : }

  00085	c3		 ret	 0
mg_aton4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_v4mapped
_TEXT	SEGMENT
$T1 = 32
str$ = 64
addr$ = 72
mg_v4mapped PROC					; COMDAT

; 5706 : static bool mg_v4mapped(struct mg_str str, struct mg_addr *addr) {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5707 :   int i;
; 5708 :   uint32_t ipv4;
; 5709 :   if (str.len < 14) return false;

  00004	4c 8b 49 08	 mov	 r9, QWORD PTR [rcx+8]
  00008	49 83 f9 0e	 cmp	 r9, 14
  0000c	72 65		 jb	 SHORT $LN7@mg_v4mappe

; 5710 :   if (str.ptr[0] != ':' || str.ptr[1] != ':' || str.ptr[6] != ':') return false;

  0000e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00011	b0 3a		 mov	 al, 58			; 0000003aH
  00013	38 01		 cmp	 BYTE PTR [rcx], al
  00015	75 5c		 jne	 SHORT $LN7@mg_v4mappe
  00017	38 41 01	 cmp	 BYTE PTR [rcx+1], al
  0001a	75 57		 jne	 SHORT $LN7@mg_v4mappe
  0001c	38 41 06	 cmp	 BYTE PTR [rcx+6], al
  0001f	75 52		 jne	 SHORT $LN7@mg_v4mappe

; 5712 :     if (str.ptr[i] != 'f' && str.ptr[i] != 'F') return false;

  00021	41 b8 02 00 00
	00		 mov	 r8d, 2
$LL4@mg_v4mappe:
  00027	41 8a 04 08	 mov	 al, BYTE PTR [r8+rcx]
  0002b	2c 46		 sub	 al, 70			; 00000046H
  0002d	a8 df		 test	 al, 223			; 000000dfH
  0002f	75 42		 jne	 SHORT $LN7@mg_v4mappe

; 5711 :   for (i = 2; i < 6; i++) {

  00031	49 ff c0	 inc	 r8
  00034	49 83 f8 06	 cmp	 r8, 6
  00038	7c ed		 jl	 SHORT $LL4@mg_v4mappe

; 5713 :   }
; 5714 :   // struct mg_str s = mg_str_n(&str.ptr[7], str.len - 7);
; 5715 :   if (!mg_aton4(mg_str_n(&str.ptr[7], str.len - 7), addr)) return false;

  0003a	48 8d 41 07	 lea	 rax, QWORD PTR [rcx+7]
  0003e	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00043	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00048	49 8d 41 f9	 lea	 rax, QWORD PTR [r9-7]
  0004c	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp+8], rax
  00051	e8 00 00 00 00	 call	 mg_aton4
  00056	84 c0		 test	 al, al
  00058	74 19		 je	 SHORT $LN7@mg_v4mappe

; 5716 :   memcpy(&ipv4, addr->ip, sizeof(ipv4));

  0005a	8b 0a		 mov	 ecx, DWORD PTR [rdx]
  0005c	0f 57 c0	 xorps	 xmm0, xmm0

; 5717 :   memset(addr->ip, 0, sizeof(addr->ip));

  0005f	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0

; 5718 :   addr->ip[10] = addr->ip[11] = 255;

  00062	66 81 4a 0a ff
	ff		 or	 WORD PTR [rdx+10], 65535 ; 0000ffffH

; 5719 :   memcpy(&addr->ip[12], &ipv4, 4);
; 5720 :   addr->is_ip6 = true;
; 5721 :   return true;

  00068	b0 01		 mov	 al, 1
  0006a	89 4a 0c	 mov	 DWORD PTR [rdx+12], ecx
  0006d	c6 42 13 01	 mov	 BYTE PTR [rdx+19], 1
  00071	eb 02		 jmp	 SHORT $LN1@mg_v4mappe
$LN7@mg_v4mappe:

; 5710 :   if (str.ptr[0] != ':' || str.ptr[1] != ':' || str.ptr[6] != ':') return false;

  00073	32 c0		 xor	 al, al
$LN1@mg_v4mappe:

; 5722 : }

  00075	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00079	c3		 ret	 0
mg_v4mapped ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_aton6
_TEXT	SEGMENT
$T1 = 32
str$ = 96
addr$ = 104
mg_aton6 PROC						; COMDAT

; 5724 : static bool mg_aton6(struct mg_str str, struct mg_addr *addr) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 5725 :   size_t i, j = 0, n = 0, dc = 42;

  0001c	45 33 ed	 xor	 r13d, r13d
  0001f	33 f6		 xor	 esi, esi
  00021	48 8b f9	 mov	 rdi, rcx

; 5726 :   addr->scope_id = 0;

  00024	40 88 72 12	 mov	 BYTE PTR [rdx+18], sil

; 5727 :   if (str.len > 2 && str.ptr[0] == '[') str.ptr++, str.len -= 2;

  00028	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0002c	48 8b ea	 mov	 rbp, rdx
  0002f	45 8d 75 2a	 lea	 r14d, QWORD PTR [r13+42]
  00033	48 83 f9 02	 cmp	 rcx, 2
  00037	76 16		 jbe	 SHORT $LN8@mg_aton6
  00039	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0003c	80 38 5b	 cmp	 BYTE PTR [rax], 91	; 0000005bH
  0003f	75 0e		 jne	 SHORT $LN8@mg_aton6
  00041	48 ff c0	 inc	 rax
  00044	48 89 07	 mov	 QWORD PTR [rdi], rax
  00047	48 8d 41 fe	 lea	 rax, QWORD PTR [rcx-2]
  0004b	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
$LN8@mg_aton6:

; 5728 :   if (mg_v4mapped(str, addr)) return true;

  0004f	0f 28 07	 movaps	 xmm0, XMMWORD PTR [rdi]
  00052	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00057	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR $T1[rsp], xmm0
  0005d	e8 00 00 00 00	 call	 mg_v4mapped
  00062	84 c0		 test	 al, al
  00064	74 04		 je	 SHORT $LN9@mg_aton6
$LN47@mg_aton6:

; 5767 : }

  00066	b0 01		 mov	 al, 1
  00068	eb 5d		 jmp	 SHORT $LN1@mg_aton6
$LN9@mg_aton6:

; 5729 :   for (i = 0; i < str.len; i++) {

  0006a	4c 8b 67 08	 mov	 r12, QWORD PTR [rdi+8]
  0006e	33 db		 xor	 ebx, ebx
  00070	4d 85 e4	 test	 r12, r12
  00073	74 50		 je	 SHORT $LN43@mg_aton6

; 5730 :     if ((str.ptr[i] >= '0' && str.ptr[i] <= '9') ||
; 5731 :         (str.ptr[i] >= 'a' && str.ptr[i] <= 'f') ||

  00075	4c 8b 3f	 mov	 r15, QWORD PTR [rdi]
  00078	8d 7b 0e	 lea	 edi, QWORD PTR [rbx+14]
$LL4@mg_aton6:
  0007b	41 8a 0c 1f	 mov	 cl, BYTE PTR [r15+rbx]
  0007f	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  00082	3c 09		 cmp	 al, 9
  00084	0f 86 9e 00 00
	00		 jbe	 $LN12@mg_aton6
  0008a	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  0008d	3c 05		 cmp	 al, 5
  0008f	0f 86 93 00 00
	00		 jbe	 $LN12@mg_aton6
  00095	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  00098	3c 05		 cmp	 al, 5
  0009a	0f 86 88 00 00
	00		 jbe	 $LN12@mg_aton6

; 5739 :     } else if (str.ptr[i] == ':') {

  000a0	80 f9 3a	 cmp	 cl, 58			; 0000003aH
  000a3	75 4f		 jne	 SHORT $LN16@mg_aton6

; 5740 :       j = i + 1;

  000a5	4c 8d 6b 01	 lea	 r13, QWORD PTR [rbx+1]

; 5741 :       if (i > 0 && str.ptr[i - 1] == ':') {

  000a9	48 85 db	 test	 rbx, rbx
  000ac	74 3a		 je	 SHORT $LN21@mg_aton6
  000ae	41 38 4c 1f ff	 cmp	 BYTE PTR [r15+rbx-1], cl
  000b3	75 2f		 jne	 SHORT $LN18@mg_aton6

; 5742 :         dc = n;  // Double colon

  000b5	4c 8b f6	 mov	 r14, rsi

; 5743 :         if (i > 1 && str.ptr[i - 2] == ':') return false;

  000b8	48 83 fb 01	 cmp	 rbx, 1
  000bc	76 2a		 jbe	 SHORT $LN21@mg_aton6
  000be	41 38 4c 1f fe	 cmp	 BYTE PTR [r15+rbx-2], cl
  000c3	75 23		 jne	 SHORT $LN21@mg_aton6
$LN43@mg_aton6:

; 5754 :       }
; 5755 :     } else {
; 5756 :       return false;
; 5757 :     }
; 5758 :   }
; 5759 :   if (n < 14 && dc == 42) return false;

  000c5	32 c0		 xor	 al, al
$LN1@mg_aton6:

; 5767 : }

  000c7	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000cc	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  000d1	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  000d6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000da	41 5f		 pop	 r15
  000dc	41 5e		 pop	 r14
  000de	41 5d		 pop	 r13
  000e0	41 5c		 pop	 r12
  000e2	5f		 pop	 rdi
  000e3	c3		 ret	 0
$LN18@mg_aton6:

; 5744 :       } else if (i > 0) {
; 5745 :         n += 2;

  000e4	48 83 c6 02	 add	 rsi, 2
$LN21@mg_aton6:

; 5746 :       }
; 5747 :       if (n > 14) return false;

  000e8	48 3b f7	 cmp	 rsi, rdi
  000eb	77 d8		 ja	 SHORT $LN43@mg_aton6

; 5748 :       addr->ip[n] = addr->ip[n + 1] = 0;  // For trailing ::

  000ed	66 83 24 2e 00	 and	 WORD PTR [rsi+rbp], 0
  000f2	eb 5b		 jmp	 SHORT $LN2@mg_aton6
$LN16@mg_aton6:

; 5749 :     } else if (str.ptr[i] == '%') {       // Scope ID

  000f4	80 f9 25	 cmp	 cl, 37			; 00000025H
  000f7	75 cc		 jne	 SHORT $LN43@mg_aton6

; 5750 :       for (i = i + 1; i < str.len; i++) {

  000f9	eb 23		 jmp	 SHORT $LN46@mg_aton6
$LL7@mg_aton6:

; 5751 :         if (str.ptr[i] < '0' || str.ptr[i] > '9') return false;

  000fb	41 8a 04 1f	 mov	 al, BYTE PTR [r15+rbx]
  000ff	2c 30		 sub	 al, 48			; 00000030H
  00101	3c 09		 cmp	 al, 9
  00103	77 c0		 ja	 SHORT $LN43@mg_aton6

; 5752 :         addr->scope_id = (uint8_t) (addr->scope_id * 10);

  00105	8a 4d 12	 mov	 cl, BYTE PTR [rbp+18]
  00108	8a c1		 mov	 al, cl
  0010a	c0 e0 02	 shl	 al, 2
  0010d	02 c8		 add	 cl, al
  0010f	02 c9		 add	 cl, cl
  00111	88 4d 12	 mov	 BYTE PTR [rbp+18], cl

; 5753 :         addr->scope_id = (uint8_t) (addr->scope_id + (str.ptr[i] - '0'));

  00114	80 e9 30	 sub	 cl, 48			; 00000030H
  00117	41 02 0c 1f	 add	 cl, BYTE PTR [r15+rbx]
  0011b	88 4d 12	 mov	 BYTE PTR [rbp+18], cl
$LN46@mg_aton6:

; 5750 :       for (i = i + 1; i < str.len; i++) {

  0011e	48 ff c3	 inc	 rbx
  00121	49 3b dc	 cmp	 rbx, r12
  00124	72 d5		 jb	 SHORT $LL7@mg_aton6
  00126	eb 27		 jmp	 SHORT $LN2@mg_aton6
$LN12@mg_aton6:

; 5732 :         (str.ptr[i] >= 'A' && str.ptr[i] <= 'F')) {
; 5733 :       unsigned long val;
; 5734 :       if (i > j + 3) return false;

  00128	49 8d 45 03	 lea	 rax, QWORD PTR [r13+3]
  0012c	48 3b d8	 cmp	 rbx, rax
  0012f	77 94		 ja	 SHORT $LN43@mg_aton6

; 5735 :       // MG_DEBUG(("%lu %lu [%.*s]", i, j, (int) (i - j + 1), &str.ptr[j]));
; 5736 :       val = mg_unhexn(&str.ptr[j], i - j + 1);

  00131	48 8b d3	 mov	 rdx, rbx
  00134	4b 8d 0c 2f	 lea	 rcx, QWORD PTR [r15+r13]
  00138	49 2b d5	 sub	 rdx, r13
  0013b	48 ff c2	 inc	 rdx
  0013e	e8 00 00 00 00	 call	 mg_unhexn

; 5737 :       addr->ip[n] = (uint8_t) ((val >> 8) & 255);

  00143	8b c8		 mov	 ecx, eax

; 5738 :       addr->ip[n + 1] = (uint8_t) (val & 255);

  00145	88 44 2e 01	 mov	 BYTE PTR [rsi+rbp+1], al
  00149	c1 e9 08	 shr	 ecx, 8
  0014c	88 0c 2e	 mov	 BYTE PTR [rsi+rbp], cl
$LN2@mg_aton6:

; 5729 :   for (i = 0; i < str.len; i++) {

  0014f	48 ff c3	 inc	 rbx
  00152	49 3b dc	 cmp	 rbx, r12
  00155	0f 82 20 ff ff
	ff		 jb	 $LL4@mg_aton6

; 5754 :       }
; 5755 :     } else {
; 5756 :       return false;
; 5757 :     }
; 5758 :   }
; 5759 :   if (n < 14 && dc == 42) return false;

  0015b	48 3b f7	 cmp	 rsi, rdi
  0015e	73 3a		 jae	 SHORT $LN28@mg_aton6
  00160	49 83 fe 2a	 cmp	 r14, 42			; 0000002aH
  00164	0f 84 5b ff ff
	ff		 je	 $LN43@mg_aton6

; 5760 :   if (n < 14) {
; 5761 :     memmove(&addr->ip[dc + (14 - n)], &addr->ip[dc], n - dc + 2);

  0016a	49 8d 1c 2e	 lea	 rbx, QWORD PTR [r14+rbp]
  0016e	4c 8b c6	 mov	 r8, rsi
  00171	4d 2b c6	 sub	 r8, r14
  00174	48 8d 4d 0e	 lea	 rcx, QWORD PTR [rbp+14]
  00178	4c 2b f6	 sub	 r14, rsi
  0017b	49 83 c0 02	 add	 r8, 2
  0017f	49 03 ce	 add	 rcx, r14
  00182	48 8b d3	 mov	 rdx, rbx
  00185	e8 00 00 00 00	 call	 memmove

; 5762 :     memset(&addr->ip[dc], 0, 14 - n);

  0018a	48 2b fe	 sub	 rdi, rsi
  0018d	33 d2		 xor	 edx, edx
  0018f	4c 8b c7	 mov	 r8, rdi
  00192	48 8b cb	 mov	 rcx, rbx
  00195	e8 00 00 00 00	 call	 memset
$LN28@mg_aton6:

; 5763 :   }
; 5764 : 
; 5765 :   addr->is_ip6 = true;

  0019a	c6 45 13 01	 mov	 BYTE PTR [rbp+19], 1

; 5766 :   return true;

  0019e	e9 c3 fe ff ff	 jmp	 $LN47@mg_aton6
mg_aton6 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_aton
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
str$ = 64
addr$ = 72
mg_aton	PROC						; COMDAT

; 5769 : bool mg_aton(struct mg_str str, struct mg_addr *addr) {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 5770 :   // MG_INFO(("[%.*s]", (int) str.len, str.ptr));
; 5771 :   return mg_atone(str, addr) || mg_atonl(str, addr) || mg_aton4(str, addr) ||

  0000f	0f 28 01	 movaps	 xmm0, XMMWORD PTR [rcx]

; 5679 :   if (str.len > 0) return false;

  00012	33 db		 xor	 ebx, ebx
  00014	66 0f 73 d8 08	 psrldq	 xmm0, 8

; 5769 : bool mg_aton(struct mg_str str, struct mg_addr *addr) {

  00019	48 8b fa	 mov	 rdi, rdx

; 5679 :   if (str.len > 0) return false;

  0001c	66 48 0f 7e c0	 movq	 rax, xmm0

; 5769 : bool mg_aton(struct mg_str str, struct mg_addr *addr) {

  00021	48 8b f1	 mov	 rsi, rcx

; 5679 :   if (str.len > 0) return false;

  00024	48 85 c0	 test	 rax, rax
  00027	75 0b		 jne	 SHORT $LN8@mg_aton
  00029	0f 57 c0	 xorps	 xmm0, xmm0

; 5680 :   memset(addr->ip, 0, sizeof(addr->ip));

  0002c	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0

; 5681 :   addr->is_ip6 = false;

  0002f	88 5a 13	 mov	 BYTE PTR [rdx+19], bl

; 5770 :   // MG_INFO(("[%.*s]", (int) str.len, str.ptr));
; 5771 :   return mg_atone(str, addr) || mg_atonl(str, addr) || mg_aton4(str, addr) ||

  00032	eb 48		 jmp	 SHORT $LN3@mg_aton
$LN8@mg_aton:
  00034	0f 28 01	 movaps	 xmm0, XMMWORD PTR [rcx]
  00037	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T3[rsp]
  0003c	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR $T3[rsp], xmm0
  00042	e8 00 00 00 00	 call	 mg_atonl
  00047	84 c0		 test	 al, al
  00049	75 31		 jne	 SHORT $LN3@mg_aton
  0004b	0f 28 06	 movaps	 xmm0, XMMWORD PTR [rsi]
  0004e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T2[rsp]
  00053	48 8b d7	 mov	 rdx, rdi
  00056	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR $T2[rsp], xmm0
  0005c	e8 00 00 00 00	 call	 mg_aton4
  00061	84 c0		 test	 al, al
  00063	75 17		 jne	 SHORT $LN3@mg_aton
  00065	0f 28 06	 movaps	 xmm0, XMMWORD PTR [rsi]
  00068	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  0006d	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR $T1[rsp], xmm0
  00073	e8 00 00 00 00	 call	 mg_aton6
  00078	84 c0		 test	 al, al
  0007a	74 02		 je	 SHORT $LN4@mg_aton
$LN3@mg_aton:
  0007c	b3 01		 mov	 bl, 1
$LN4@mg_aton:

; 5772 :          mg_aton6(str, addr);
; 5773 : }

  0007e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00083	8a c3		 mov	 al, bl
  00085	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0008a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
mg_aton	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_alloc_conn
_TEXT	SEGMENT
mgr$ = 48
mg_alloc_conn PROC					; COMDAT

; 5775 : struct mg_connection *mg_alloc_conn(struct mg_mgr *mgr) {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5776 :   struct mg_connection *c =

  00006	48 8b 51 70	 mov	 rdx, QWORD PTR [rcx+112]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	48 81 c2 18 01
	00 00		 add	 rdx, 280		; 00000118H
  00014	b9 01 00 00 00	 mov	 ecx, 1
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc

; 5777 :       (struct mg_connection *) calloc(1, sizeof(*c) + mgr->extraconnsize);
; 5778 :   if (c != NULL) {

  0001f	48 85 c0	 test	 rax, rax
  00022	74 24		 je	 SHORT $LN2@mg_alloc_c

; 5779 :     c->mgr = mgr;
; 5780 :     c->send.align = c->recv.align = c->rtls.align = MG_IO_SIZE;

  00024	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00029	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  0002d	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx
  00034	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx
  00038	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 5781 :     c->id = ++mgr->nextid;

  0003f	ff 43 30	 inc	 DWORD PTR [rbx+48]
  00042	8b 4b 30	 mov	 ecx, DWORD PTR [rbx+48]
  00045	89 48 40	 mov	 DWORD PTR [rax+64], ecx
$LN2@mg_alloc_c:

; 5782 :     MG_PROF_INIT(c);
; 5783 :   }
; 5784 :   return c;
; 5785 : }

  00048	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004c	5b		 pop	 rbx
  0004d	c3		 ret	 0
mg_alloc_conn ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_close_conn
_TEXT	SEGMENT
c$ = 48
mg_close_conn PROC					; COMDAT

; 5787 : void mg_close_conn(struct mg_connection *c) {

$LN35:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 5788 :   mg_resolve_cancel(c);  // Close any pending DNS query

  00009	e8 00 00 00 00	 call	 mg_resolve_cancel

; 5789 :   LIST_DELETE(struct mg_connection, &c->mgr->conns, c);

  0000e	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00012	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00015	48 3b cb	 cmp	 rcx, rbx
  00018	74 0e		 je	 SHORT $LN6@mg_close_c
$LL5@mg_close_c:
  0001a	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0001d	48 8b d1	 mov	 rdx, rcx
  00020	48 8b c8	 mov	 rcx, rax
  00023	48 3b c3	 cmp	 rax, rbx
  00026	75 f2		 jne	 SHORT $LL5@mg_close_c
$LN6@mg_close_c:
  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 89 02	 mov	 QWORD PTR [rdx], rax

; 5790 :   if (c == c->mgr->dns4.c) c->mgr->dns4.c = NULL;

  0002e	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00032	48 3b 58 10	 cmp	 rbx, QWORD PTR [rax+16]
  00036	75 05		 jne	 SHORT $LN10@mg_close_c
  00038	48 83 60 10 00	 and	 QWORD PTR [rax+16], 0
$LN10@mg_close_c:

; 5791 :   if (c == c->mgr->dns6.c) c->mgr->dns6.c = NULL;

  0003d	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00041	48 3b 58 20	 cmp	 rbx, QWORD PTR [rax+32]
  00045	75 05		 jne	 SHORT $LN11@mg_close_c
  00047	48 83 60 20 00	 and	 QWORD PTR [rax+32], 0
$LN11@mg_close_c:

; 5792 :   // Order of operations is important. `MG_EV_CLOSE` event must be fired
; 5793 :   // before we deallocate received data, see #1331
; 5794 :   mg_call(c, MG_EV_CLOSE, NULL);

  0004c	45 33 c0	 xor	 r8d, r8d
  0004f	48 8b cb	 mov	 rcx, rbx
  00052	41 8d 50 09	 lea	 edx, QWORD PTR [r8+9]
  00056	e8 00 00 00 00	 call	 mg_call

; 5795 :   MG_DEBUG(("%lu %ld closed", c->id, c->fd));

  0005b	b9 03 00 00 00	 mov	 ecx, 3
  00060	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  00066	7c 25		 jl	 SHORT $LN7@mg_close_c
  00068	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0O@KLFCDPFL@mg_close_conn@
  0006f	41 b8 a3 16 00
	00		 mov	 r8d, 5795		; 000016a3H
  00075	e8 00 00 00 00	 call	 mg_log_prefix
  0007a	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@KGEINCCM@?$CFlu?5?$CFld?5closed@
  00085	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  00088	e8 00 00 00 00	 call	 mg_log
$LN7@mg_close_c:

; 5796 :   MG_PROF_DUMP(c);
; 5797 :   MG_PROF_FREE(c);
; 5798 : 
; 5799 :   mg_tls_free(c);
; 5800 :   mg_iobuf_free(&c->recv);

  0008d	48 8d 4b 48	 lea	 rcx, QWORD PTR [rbx+72]

; 3346 :   mg_iobuf_resize(io, 0);

  00091	33 d2		 xor	 edx, edx
  00093	e8 00 00 00 00	 call	 mg_iobuf_resize

; 5801 :   mg_iobuf_free(&c->send);

  00098	48 8d 4b 68	 lea	 rcx, QWORD PTR [rbx+104]

; 3346 :   mg_iobuf_resize(io, 0);

  0009c	33 d2		 xor	 edx, edx
  0009e	e8 00 00 00 00	 call	 mg_iobuf_resize

; 5802 :   mg_iobuf_free(&c->rtls);

  000a3	48 8d 8b a8 00
	00 00		 lea	 rcx, QWORD PTR [rbx+168]

; 3346 :   mg_iobuf_resize(io, 0);

  000aa	33 d2		 xor	 edx, edx
  000ac	e8 00 00 00 00	 call	 mg_iobuf_resize

; 5803 :   mg_bzero((unsigned char *) c, sizeof(*c));

  000b1	b8 18 01 00 00	 mov	 eax, 280		; 00000118H
  000b6	48 8b cb	 mov	 rcx, rbx
$LL21@mg_close_c:

; 13759:     while (len--) *buf++ = 0;

  000b9	c6 01 00	 mov	 BYTE PTR [rcx], 0
  000bc	48 ff c1	 inc	 rcx
  000bf	48 83 e8 01	 sub	 rax, 1
  000c3	75 f4		 jne	 SHORT $LL21@mg_close_c

; 5804 :   free(c);

  000c5	48 8b cb	 mov	 rcx, rbx

; 5805 : }

  000c8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cc	5b		 pop	 rbx

; 5804 :   free(c);

  000cd	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_free
mg_close_conn ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_connect
_TEXT	SEGMENT
mgr$ = 48
url$ = 56
fn$ = 64
fn_data$ = 72
mg_connect PROC						; COMDAT

; 5808 :                                  mg_event_handler_t fn, void *fn_data) {

$LN25:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5809 :   struct mg_connection *c = NULL;

  00019	33 db		 xor	 ebx, ebx
  0001b	49 8b e9	 mov	 rbp, r9
  0001e	4d 8b f0	 mov	 r14, r8
  00021	48 8b fa	 mov	 rdi, rdx
  00024	48 8b f1	 mov	 rsi, rcx

; 5810 :   if (url == NULL || url[0] == '\0') {

  00027	48 85 d2	 test	 rdx, rdx
  0002a	0f 84 e8 00 00
	00		 je	 $LN4@mg_connect
  00030	38 1a		 cmp	 BYTE PTR [rdx], bl
  00032	0f 84 e0 00 00
	00		 je	 $LN4@mg_connect

; 5812 :   } else if ((c = mg_alloc_conn(mgr)) == NULL) {

  00038	e8 00 00 00 00	 call	 mg_alloc_conn
  0003d	48 8b d8	 mov	 rbx, rax
  00040	48 85 c0	 test	 rax, rax
  00043	75 2e		 jne	 SHORT $LN10@mg_connect

; 5813 :     MG_ERROR(("OOM"));

  00045	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR mg_log_level, 1
  0004c	0f 8c f2 00 00
	00		 jl	 $LN2@mg_connect
  00052	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0L@KLLEPGGK@mg_connect@
  00059	41 b8 b5 16 00
	00		 mov	 r8d, 5813		; 000016b5H
  0005f	8d 48 01	 lea	 ecx, QWORD PTR [rax+1]
  00062	e8 00 00 00 00	 call	 mg_log_prefix
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03CDNNJDDN@OOM@

; 5814 :   } else {

  0006e	e9 cc 00 00 00	 jmp	 $LN23@mg_connect
$LN10@mg_connect:

; 5815 :     LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);

  00073	48 8b 06	 mov	 rax, QWORD PTR [rsi]

; 5816 :     c->is_udp = (strncmp(url, "udp:", 4) == 0);

  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04MNPDLBCA@udp?3@
  0007d	48 89 03	 mov	 QWORD PTR [rbx], rax
  00080	41 b8 04 00 00
	00		 mov	 r8d, 4
  00086	48 8b cf	 mov	 rcx, rdi
  00089	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp

; 5817 :     c->fd = (void *) (size_t) MG_INVALID_SOCKET;

  00092	48 83 4b 38 ff	 or	 QWORD PTR [rbx+56], -1
  00097	f7 d8		 neg	 eax

; 5818 :     c->fn = fn;

  00099	4c 89 b3 c8 00
	00 00		 mov	 QWORD PTR [rbx+200], r14
  000a0	8b 83 10 01 00
	00		 mov	 eax, DWORD PTR [rbx+272]
  000a6	1b c9		 sbb	 ecx, ecx

; 5819 :     c->is_client = true;
; 5820 :     c->fn_data = fn_data;

  000a8	48 89 ab d0 00
	00 00		 mov	 QWORD PTR [rbx+208], rbp
  000af	f7 d1		 not	 ecx
  000b1	0f ba f0 08	 btr	 eax, 8
  000b5	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  000bb	0b c8		 or	 ecx, eax
  000bd	83 c9 02	 or	 ecx, 2
  000c0	89 8b 10 01 00
	00		 mov	 DWORD PTR [rbx+272], ecx

; 5821 :     MG_DEBUG(("%lu %ld %s", c->id, c->fd, url));

  000c6	b9 03 00 00 00	 mov	 ecx, 3
  000cb	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  000d1	7c 28		 jl	 SHORT $LN11@mg_connect
  000d3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0L@KLLEPGGK@mg_connect@
  000da	41 b8 bd 16 00
	00		 mov	 r8d, 5821		; 000016bdH
  000e0	e8 00 00 00 00	 call	 mg_log_prefix
  000e5	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@PPINGECD@?$CFlu?5?$CFld?5?$CFs@
  000f0	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  000f3	4c 8b cf	 mov	 r9, rdi
  000f6	e8 00 00 00 00	 call	 mg_log
$LN11@mg_connect:

; 5822 :     mg_call(c, MG_EV_OPEN, (void *) url);

  000fb	4c 8b c7	 mov	 r8, rdi
  000fe	ba 01 00 00 00	 mov	 edx, 1
  00103	48 8b cb	 mov	 rcx, rbx
  00106	e8 00 00 00 00	 call	 mg_call

; 5823 :     mg_resolve(c, url);

  0010b	48 8b d7	 mov	 rdx, rdi
  0010e	48 8b cb	 mov	 rcx, rbx
  00111	e8 00 00 00 00	 call	 mg_resolve
  00116	eb 2c		 jmp	 SHORT $LN2@mg_connect
$LN4@mg_connect:

; 5811 :     MG_ERROR(("null url"));

  00118	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR mg_log_level, 1
  0011f	7c 23		 jl	 SHORT $LN2@mg_connect
  00121	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0L@KLLEPGGK@mg_connect@
  00128	b9 01 00 00 00	 mov	 ecx, 1
  0012d	41 b8 b3 16 00
	00		 mov	 r8d, 5811		; 000016b3H
  00133	e8 00 00 00 00	 call	 mg_log_prefix
  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08FJNKCABM@null?5url@
$LN23@mg_connect:

; 5824 :   }
; 5825 :   return c;

  0013f	e8 00 00 00 00	 call	 mg_log
$LN2@mg_connect:

; 5826 : }

  00144	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00149	48 8b c3	 mov	 rax, rbx
  0014c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00151	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00156	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0015b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0015f	41 5e		 pop	 r14
  00161	c3		 ret	 0
mg_connect ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_listen
_TEXT	SEGMENT
mgr$ = 48
url$ = 56
fn$ = 64
fn_data$ = 72
mg_listen PROC						; COMDAT

; 5829 :                                 mg_event_handler_t fn, void *fn_data) {

$LN24:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	49 8b e9	 mov	 rbp, r9
  0001c	4d 8b f0	 mov	 r14, r8
  0001f	48 8b fa	 mov	 rdi, rdx
  00022	48 8b f1	 mov	 rsi, rcx

; 5830 :   struct mg_connection *c = NULL;
; 5831 :   if ((c = mg_alloc_conn(mgr)) == NULL) {

  00025	e8 00 00 00 00	 call	 mg_alloc_conn
  0002a	48 8b d8	 mov	 rbx, rax
  0002d	48 85 c0	 test	 rax, rax
  00030	75 36		 jne	 SHORT $LN14@mg_listen

; 5832 :     MG_ERROR(("OOM %s", url));

  00032	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR mg_log_level, 1
  00039	0f 8c 25 01 00
	00		 jl	 $LN12@mg_listen
  0003f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_09MIIPHL@mg_listen@
  00046	41 b8 c8 16 00
	00		 mov	 r8d, 5832		; 000016c8H
  0004c	8d 48 01	 lea	 ecx, QWORD PTR [rax+1]
  0004f	e8 00 00 00 00	 call	 mg_log_prefix
  00054	48 8b d7	 mov	 rdx, rdi
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06BEBLAAFA@OOM?5?$CFs@
  0005e	e8 00 00 00 00	 call	 mg_log

; 5833 :   } else if (!mg_open_listener(c, url)) {

  00063	e9 fc 00 00 00	 jmp	 $LN12@mg_listen
$LN14@mg_listen:
  00068	48 8b d7	 mov	 rdx, rdi
  0006b	48 8b cb	 mov	 rcx, rbx
  0006e	e8 00 00 00 00	 call	 mg_open_listener
  00073	84 c0		 test	 al, al
  00075	75 48		 jne	 SHORT $LN17@mg_listen

; 5834 :     MG_ERROR(("Failed: %s, errno %d", url, errno));

  00077	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR mg_log_level, 1
  0007e	7c 2f		 jl	 SHORT $LN5@mg_listen
  00080	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_09MIIPHL@mg_listen@
  00087	b9 01 00 00 00	 mov	 ecx, 1
  0008c	41 b8 ca 16 00
	00		 mov	 r8d, 5834		; 000016caH
  00092	e8 00 00 00 00	 call	 mg_log_prefix
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0009d	48 8b d7	 mov	 rdx, rdi
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@LPNPPMDI@Failed?3?5?$CFs?0?5errno?5?$CFd@
  000a7	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000aa	e8 00 00 00 00	 call	 mg_log
$LN5@mg_listen:

; 5835 :     MG_PROF_FREE(c);
; 5836 :     free(c);

  000af	48 8b cb	 mov	 rcx, rbx
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5837 :     c = NULL;

  000b8	33 db		 xor	 ebx, ebx

; 5838 :   } else {

  000ba	e9 a5 00 00 00	 jmp	 $LN12@mg_listen
$LN17@mg_listen:

; 5839 :     c->is_listening = 1;

  000bf	83 8b 10 01 00
	00 01		 or	 DWORD PTR [rbx+272], 1

; 5840 :     c->is_udp = strncmp(url, "udp:", 4) == 0;

  000c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04MNPDLBCA@udp?3@
  000cd	41 b8 04 00 00
	00		 mov	 r8d, 4
  000d3	48 8b cf	 mov	 rcx, rdi
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  000dc	0f ba b3 10 01
	00 00 08	 btr	 DWORD PTR [rbx+272], 8
  000e4	f7 d8		 neg	 eax
  000e6	1b c9		 sbb	 ecx, ecx

; 5841 :     LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);
; 5842 :     c->fn = fn;
; 5843 :     c->fn_data = fn_data;
; 5844 :     mg_call(c, MG_EV_OPEN, NULL);

  000e8	45 33 c0	 xor	 r8d, r8d
  000eb	f7 d1		 not	 ecx
  000ed	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  000f3	09 8b 10 01 00
	00		 or	 DWORD PTR [rbx+272], ecx
  000f9	48 8b cb	 mov	 rcx, rbx
  000fc	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000ff	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00103	48 89 03	 mov	 QWORD PTR [rbx], rax
  00106	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  00109	4c 89 b3 c8 00
	00 00		 mov	 QWORD PTR [rbx+200], r14
  00110	48 89 ab d0 00
	00 00		 mov	 QWORD PTR [rbx+208], rbp
  00117	e8 00 00 00 00	 call	 mg_call

; 5845 :     if (mg_url_is_ssl(url)) c->is_tls = 1;  // Accepted connection must

  0011c	48 8b cf	 mov	 rcx, rdi
  0011f	e8 00 00 00 00	 call	 mg_url_is_ssl
  00124	85 c0		 test	 eax, eax
  00126	74 07		 je	 SHORT $LN13@mg_listen
  00128	83 8b 10 01 00
	00 40		 or	 DWORD PTR [rbx+272], 64	; 00000040H
$LN13@mg_listen:

; 5846 :     MG_DEBUG(("%lu %ld %s", c->id, c->fd, url));

  0012f	b9 03 00 00 00	 mov	 ecx, 3
  00134	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  0013a	7c 28		 jl	 SHORT $LN12@mg_listen
  0013c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_09MIIPHL@mg_listen@
  00143	41 b8 d6 16 00
	00		 mov	 r8d, 5846		; 000016d6H
  00149	e8 00 00 00 00	 call	 mg_log_prefix
  0014e	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  00152	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@PPINGECD@?$CFlu?5?$CFld?5?$CFs@
  00159	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  0015c	4c 8b cf	 mov	 r9, rdi
  0015f	e8 00 00 00 00	 call	 mg_log
$LN12@mg_listen:

; 5847 :   }
; 5848 :   return c;
; 5849 : }

  00164	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00169	48 8b c3	 mov	 rax, rbx
  0016c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00171	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00176	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0017b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0017f	41 5e		 pop	 r14
  00181	c3		 ret	 0
mg_listen ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_wrapfd
_TEXT	SEGMENT
mgr$ = 48
fd$ = 56
fn$dead$ = 64
fn_data$dead$ = 72
mg_wrapfd PROC						; COMDAT

; 5852 :                                 mg_event_handler_t fn, void *fn_data) {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 63 f2	 movsxd	 rsi, edx
  00012	48 8b f9	 mov	 rdi, rcx

; 5853 :   struct mg_connection *c = mg_alloc_conn(mgr);

  00015	e8 00 00 00 00	 call	 mg_alloc_conn
  0001a	48 8b d8	 mov	 rbx, rax

; 5854 :   if (c != NULL) {

  0001d	48 85 c0	 test	 rax, rax
  00020	74 32		 je	 SHORT $LN3@mg_wrapfd

; 5855 :     c->fd = (void *) (size_t) fd;
; 5856 :     c->fn = fn;
; 5857 :     c->fn_data = fn_data;

  00022	48 83 a3 d0 00
	00 00 00	 and	 QWORD PTR [rbx+208], 0

; 5858 :     MG_EPOLL_ADD(c);
; 5859 :     mg_call(c, MG_EV_OPEN, NULL);

  0002a	45 33 c0	 xor	 r8d, r8d
  0002d	48 89 70 38	 mov	 QWORD PTR [rax+56], rsi
  00031	48 8b cb	 mov	 rcx, rbx
  00034	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:wufn
  0003b	48 89 83 c8 00
	00 00		 mov	 QWORD PTR [rbx+200], rax
  00042	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00046	e8 00 00 00 00	 call	 mg_call

; 5860 :     LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);

  0004b	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0004e	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  00051	48 89 1f	 mov	 QWORD PTR [rdi], rbx
$LN3@mg_wrapfd:

; 5861 :   }
; 5862 :   return c;
; 5863 : }

  00054	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00059	48 8b c3	 mov	 rax, rbx
  0005c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5f		 pop	 rdi
  00066	c3		 ret	 0
mg_wrapfd ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_timer_add
_TEXT	SEGMENT
mgr$ = 48
milliseconds$ = 56
flags$ = 64
fn$ = 72
arg$ = 80
mg_timer_add PROC					; COMDAT

; 5866 :                               unsigned flags, void (*fn)(void *), void *arg) {

$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b ea	 mov	 rbp, rdx
  00017	48 8b d9	 mov	 rbx, rcx

; 5867 :   struct mg_timer *t = (struct mg_timer *) calloc(1, sizeof(*t));

  0001a	ba 38 00 00 00	 mov	 edx, 56			; 00000038H
  0001f	49 8b f9	 mov	 rdi, r9
  00022	41 8b f0	 mov	 esi, r8d
  00025	8d 4a c9	 lea	 ecx, QWORD PTR [rdx-55]
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0002e	4c 8b d0	 mov	 r10, rax

; 5868 :   if (t != NULL) {

  00031	48 85 c0	 test	 rax, rax
  00034	74 31		 je	 SHORT $LN2@mg_timer_a

; 8046 :   t->id = 0, t->period_ms = ms, t->expire = 0;

  00036	83 20 00	 and	 DWORD PTR [rax], 0
  00039	48 83 60 10 00	 and	 QWORD PTR [rax+16], 0

; 8047 :   t->flags = flags, t->fn = fn, t->arg = arg, t->next = *head;

  0003e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR arg$[rsp]
  00043	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx
  00047	48 89 68 08	 mov	 QWORD PTR [rax+8], rbp
  0004b	89 70 18	 mov	 DWORD PTR [rax+24], esi
  0004e	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00052	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00056	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 8048 :   *head = t;

  0005a	48 89 43 58	 mov	 QWORD PTR [rbx+88], rax

; 5869 :     mg_timer_init(&mgr->timers, t, milliseconds, flags, fn, arg);
; 5870 :     t->id = mgr->timerid++;

  0005e	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  00061	41 89 02	 mov	 DWORD PTR [r10], eax
  00064	ff 43 34	 inc	 DWORD PTR [rbx+52]
$LN2@mg_timer_a:

; 5871 :   }
; 5872 :   return t;
; 5873 : }

  00067	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006c	49 8b c2	 mov	 rax, r10
  0006f	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00074	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00079	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007d	5f		 pop	 rdi
  0007e	c3		 ret	 0
mg_timer_add ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_io_recv
_TEXT	SEGMENT
c$ = 48
buf$ = 56
len$ = 64
mg_io_recv PROC						; COMDAT

; 5875 : long mg_io_recv(struct mg_connection *c, void *buf, size_t len) {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5876 :   if (c->rtls.len == 0) return MG_IO_WAIT;

  0000a	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00011	49 8b f8	 mov	 rdi, r8
  00014	4c 8b ca	 mov	 r9, rdx
  00017	48 85 c0	 test	 rax, rax
  0001a	75 07		 jne	 SHORT $LN2@mg_io_recv
  0001c	b8 fe ff ff ff	 mov	 eax, -2
  00021	eb 2b		 jmp	 SHORT $LN1@mg_io_recv
$LN2@mg_io_recv:

; 5877 :   if (len > c->rtls.len) len = c->rtls.len;
; 5878 :   memcpy(buf, c->rtls.buf, len);

  00023	48 8d 99 a8 00
	00 00		 lea	 rbx, QWORD PTR [rcx+168]
  0002a	48 3b f8	 cmp	 rdi, rax
  0002d	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00030	49 8b c9	 mov	 rcx, r9
  00033	48 0f 47 f8	 cmova	 rdi, rax
  00037	4c 8b c7	 mov	 r8, rdi
  0003a	e8 00 00 00 00	 call	 memcpy

; 5879 :   mg_iobuf_del(&c->rtls, 0, len);

  0003f	4c 8b c7	 mov	 r8, rdi
  00042	33 d2		 xor	 edx, edx
  00044	48 8b cb	 mov	 rcx, rbx
  00047	e8 00 00 00 00	 call	 mg_iobuf_del

; 5880 :   return (long) len;

  0004c	8b c7		 mov	 eax, edi
$LN1@mg_io_recv:

; 5881 : }

  0004e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
mg_io_recv ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_mgr_free
_TEXT	SEGMENT
mgr$ = 48
mg_mgr_free PROC					; COMDAT

; 5883 : void mg_mgr_free(struct mg_mgr *mgr) {

$LN22:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 5884 :   struct mg_connection *c;
; 5885 :   struct mg_timer *tmp, *t = mgr->timers;

  0000d	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]

; 5886 :   while (t != NULL) tmp = t->next, free(t), t = tmp;

  00011	48 85 c9	 test	 rcx, rcx
  00014	74 12		 je	 SHORT $LN3@mg_mgr_fre
$LL2@mg_mgr_fre:
  00016	48 8b 59 30	 mov	 rbx, QWORD PTR [rcx+48]
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00020	48 8b cb	 mov	 rcx, rbx
  00023	48 85 db	 test	 rbx, rbx
  00026	75 ee		 jne	 SHORT $LL2@mg_mgr_fre
$LN3@mg_mgr_fre:

; 5887 :   mgr->timers = NULL;  // Important. Next call to poll won't touch timers

  00028	48 83 67 58 00	 and	 QWORD PTR [rdi+88], 0

; 5888 :   for (c = mgr->conns; c != NULL; c = c->next) c->is_closing = 1;

  0002d	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00030	eb 0b		 jmp	 SHORT $LN20@mg_mgr_fre
$LL6@mg_mgr_fre:
  00032	0f ba a8 10 01
	00 00 0d	 bts	 DWORD PTR [rax+272], 13
  0003a	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN20@mg_mgr_fre:
  0003d	48 85 c0	 test	 rax, rax
  00040	75 f0		 jne	 SHORT $LL6@mg_mgr_fre

; 5889 :   mg_mgr_poll(mgr, 0);

  00042	33 d2		 xor	 edx, edx
  00044	48 8b cf	 mov	 rcx, rdi
  00047	e8 00 00 00 00	 call	 mg_mgr_poll

; 5890 : #if MG_ENABLE_FREERTOS_TCP
; 5891 :   FreeRTOS_DeleteSocketSet(mgr->ss);
; 5892 : #endif
; 5893 :   MG_DEBUG(("All connections closed"));

  0004c	b9 03 00 00 00	 mov	 ecx, 3
  00051	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  00057	7c 1e		 jl	 SHORT $LN7@mg_mgr_fre
  00059	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0M@HDNIMCKK@mg_mgr_free@
  00060	41 b8 05 17 00
	00		 mov	 r8d, 5893		; 00001705H
  00066	e8 00 00 00 00	 call	 mg_log_prefix
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@JCIDLGBI@All?5connections?5closed@
  00072	e8 00 00 00 00	 call	 mg_log
$LN7@mg_mgr_fre:

; 5894 : #if MG_ENABLE_EPOLL
; 5895 :   if (mgr->epoll_fd >= 0) close(mgr->epoll_fd), mgr->epoll_fd = -1;
; 5896 : #endif
; 5897 :   mg_tls_ctx_free(mgr);
; 5898 : }

  00077	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
mg_mgr_free ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_mgr_init
_TEXT	SEGMENT
data$1 = 32
mgr$ = 464
mg_mgr_init PROC					; COMDAT

; 5900 : void mg_mgr_init(struct mg_mgr *mgr) {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 81 ec c0 01
	00 00		 sub	 rsp, 448		; 000001c0H

; 5901 :   memset(mgr, 0, sizeof(*mgr));

  00009	33 d2		 xor	 edx, edx
  0000b	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	e8 00 00 00 00	 call	 memset

; 5902 : #if MG_ENABLE_EPOLL
; 5903 :   if ((mgr->epoll_fd = epoll_create1(EPOLL_CLOEXEC)) < 0)
; 5904 :     MG_ERROR(("epoll_create1 errno %d", errno));
; 5905 : #else
; 5906 :   mgr->epoll_fd = -1;

  00019	83 4b 60 ff	 or	 DWORD PTR [rbx+96], -1

; 5907 : #endif
; 5908 : #if MG_ARCH == MG_ARCH_WIN32 && MG_ENABLE_WINSOCK
; 5909 :   // clang-format off
; 5910 :   { WSADATA data; WSAStartup(MAKEWORD(2, 2), &data); }

  0001d	48 8d 54 24 20	 lea	 rdx, QWORD PTR data$1[rsp]
  00022	b9 02 02 00 00	 mov	 ecx, 514		; 00000202H
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAStartup

; 5911 :   // clang-format on
; 5912 : #elif MG_ENABLE_FREERTOS_TCP
; 5913 :   mgr->ss = FreeRTOS_CreateSocketSet();
; 5914 : #elif defined(__unix) || defined(__unix__) || defined(__APPLE__)
; 5915 :   // Ignore SIGPIPE signal, so if client cancels the request, it
; 5916 :   // won't kill the whole process.
; 5917 :   signal(SIGPIPE, SIG_IGN);
; 5918 : #endif
; 5919 :   mgr->pipe = MG_INVALID_SOCKET;

  0002d	48 83 4b 78 ff	 or	 QWORD PTR [rbx+120], -1

; 5920 :   mgr->dnstimeout = 3000;
; 5921 :   mgr->dns4.url = "udp://8.8.8.8:53";

  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BB@OGCNOFJ@udp?3?1?18?48?48?48?353@
  00039	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 5922 :   mgr->dns6.url = "udp://[2001:4860:4860::8888]:53";

  0003d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CA@BFGPOJEH@udp?3?1?1?$FL2001?34860?34860?3?38888?$FN?353@
  00044	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
  00048	c7 43 28 b8 0b
	00 00		 mov	 DWORD PTR [rbx+40], 3000 ; 00000bb8H

; 5923 :   mg_tls_ctx_init(mgr);
; 5924 : }

  0004f	48 81 c4 c0 01
	00 00		 add	 rsp, 448		; 000001c0H
  00056	5b		 pop	 rbx
  00057	c3		 ret	 0
mg_mgr_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ota_begin
_TEXT	SEGMENT
new_firmware_size$dead$ = 8
mg_ota_begin PROC					; COMDAT

; 5934 :   (void) new_firmware_size;
; 5935 :   return true;

  00000	b0 01		 mov	 al, 1

; 5936 : }

  00002	c3		 ret	 0
mg_ota_begin ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ota_write
_TEXT	SEGMENT
buf$dead$ = 8
len$dead$ = 16
mg_ota_write PROC					; COMDAT

; 5938 :   (void) buf, (void) len;
; 5939 :   return true;

  00000	b0 01		 mov	 al, 1

; 5940 : }

  00002	c3		 ret	 0
mg_ota_write ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ota_end
_TEXT	SEGMENT
mg_ota_end PROC						; COMDAT

; 5942 :   return true;

  00000	b0 01		 mov	 al, 1

; 5943 : }

  00002	c3		 ret	 0
mg_ota_end ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ota_commit
_TEXT	SEGMENT
mg_ota_commit PROC					; COMDAT

; 5945 :   return true;

  00000	b0 01		 mov	 al, 1

; 5946 : }

  00002	c3		 ret	 0
mg_ota_commit ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ota_rollback
_TEXT	SEGMENT
mg_ota_rollback PROC					; COMDAT

; 5948 :   return true;

  00000	b0 01		 mov	 al, 1

; 5949 : }

  00002	c3		 ret	 0
mg_ota_rollback ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ota_status
_TEXT	SEGMENT
fw$dead$ = 8
mg_ota_status PROC					; COMDAT

; 5951 :   (void) fw;
; 5952 :   return 0;

  00000	33 c0		 xor	 eax, eax

; 5953 : }

  00002	c3		 ret	 0
mg_ota_status ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ota_crc32
_TEXT	SEGMENT
fw$dead$ = 8
mg_ota_crc32 PROC					; COMDAT

; 5955 :   (void) fw;
; 5956 :   return 0;

  00000	33 c0		 xor	 eax, eax

; 5957 : }

  00002	c3		 ret	 0
mg_ota_crc32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ota_timestamp
_TEXT	SEGMENT
fw$dead$ = 8
mg_ota_timestamp PROC					; COMDAT

; 5959 :   (void) fw;
; 5960 :   return 0;

  00000	33 c0		 xor	 eax, eax

; 5961 : }

  00002	c3		 ret	 0
mg_ota_timestamp ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ota_size
_TEXT	SEGMENT
fw$dead$ = 8
mg_ota_size PROC					; COMDAT

; 5963 :   (void) fw;
; 5964 :   return 0;

  00000	33 c0		 xor	 eax, eax

; 5965 : }

  00002	c3		 ret	 0
mg_ota_size ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ota_boot
_TEXT	SEGMENT
mg_ota_boot PROC					; COMDAT

; 5967 : }

  00000	c2 00 00	 ret	 0
mg_ota_boot ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_queue_vprintf
_TEXT	SEGMENT
q$ = 48
fmt$ = 56
ap$ = 64
buf$ = 72
mg_queue_vprintf PROC					; COMDAT

; 6180 : size_t mg_queue_vprintf(struct mg_queue *q, const char *fmt, va_list *ap) {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	49 8b f0	 mov	 rsi, r8

; 6181 :   size_t len = mg_snprintf(NULL, 0, fmt, ap);

  00017	4d 8b c8	 mov	 r9, r8
  0001a	4c 8b c2	 mov	 r8, rdx
  0001d	48 8b ea	 mov	 rbp, rdx
  00020	48 8b d9	 mov	 rbx, rcx
  00023	33 d2		 xor	 edx, edx
  00025	33 c9		 xor	 ecx, ecx
  00027	e8 00 00 00 00	 call	 mg_snprintf

; 6182 :   char *buf;
; 6183 :   if (len == 0 || mg_queue_book(q, &buf, len + 1) < len + 1) {

  0002c	48 85 c0	 test	 rax, rax
  0002f	74 4c		 je	 SHORT $LN4@mg_queue_v
  00031	48 8d 78 01	 lea	 rdi, QWORD PTR [rax+1]
  00035	48 8b cb	 mov	 rcx, rbx
  00038	4c 8b c7	 mov	 r8, rdi
  0003b	48 8d 54 24 48	 lea	 rdx, QWORD PTR buf$[rsp]
  00040	e8 00 00 00 00	 call	 mg_queue_book
  00045	48 3b c7	 cmp	 rax, rdi
  00048	72 33		 jb	 SHORT $LN4@mg_queue_v

; 6185 :   } else {
; 6186 :     len = mg_vsnprintf((char *) buf, len + 1, fmt, ap);

  0004a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf$[rsp]
  0004f	4c 8b ce	 mov	 r9, rsi
  00052	4c 8b c5	 mov	 r8, rbp
  00055	48 8b d7	 mov	 rdx, rdi
  00058	e8 00 00 00 00	 call	 mg_vsnprintf

; 6406 :   memcpy(q->buf + q->head, &n, sizeof(n));

  0005d	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  00061	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00064	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 6407 :   MG_MEMORY_BARRIER();

  00067	f0 83 0c 24 00	 lock or DWORD PTR [rsp], 0

; 6441 :   q->head += len + sizeof(uint32_t);

  0006c	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  00070	48 83 c2 04	 add	 rdx, 4
  00074	48 03 d0	 add	 rdx, rax
  00077	48 89 53 18	 mov	 QWORD PTR [rbx+24], rdx
  0007b	eb 02		 jmp	 SHORT $LN6@mg_queue_v
$LN4@mg_queue_v:

; 6184 :     len = 0;  // Nah. Not enough space

  0007d	33 c0		 xor	 eax, eax
$LN6@mg_queue_v:

; 6187 :     mg_queue_add(q, len);
; 6188 :   }
; 6189 :   return len;
; 6190 : }

  0007f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00084	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00089	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0008e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00092	5f		 pop	 rdi
  00093	c3		 ret	 0
mg_queue_vprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_queue_printf
_TEXT	SEGMENT
q$ = 64
fmt$ = 72
mg_queue_printf PROC					; COMDAT

; 6192 : size_t mg_queue_printf(struct mg_queue *q, const char *fmt, ...) {

$LN4:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 53 10	 mov	 QWORD PTR [r11+16], rdx
  00007	4d 89 43 18	 mov	 QWORD PTR [r11+24], r8
  0000b	4d 89 4b 20	 mov	 QWORD PTR [r11+32], r9
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6193 :   va_list ap;
; 6194 :   size_t len;
; 6195 :   va_start(ap, fmt);

  00013	49 8d 43 18	 lea	 rax, QWORD PTR [r11+24]

; 6196 :   len = mg_queue_vprintf(q, fmt, &ap);

  00017	4d 8d 43 e8	 lea	 r8, QWORD PTR [r11-24]
  0001b	49 89 43 e8	 mov	 QWORD PTR [r11-24], rax
  0001f	e8 00 00 00 00	 call	 mg_queue_vprintf

; 6197 :   va_end(ap);
; 6198 :   return len;
; 6199 : }

  00024	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00028	c3		 ret	 0
mg_queue_printf ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_pfn_iobuf_private
_TEXT	SEGMENT
ch$ = 48
param$ = 56
expand$ = 64
mg_pfn_iobuf_private PROC				; COMDAT

; 6201 : static void mg_pfn_iobuf_private(char ch, void *param, bool expand) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	40 8a f9	 mov	 dil, cl

; 6202 :   struct mg_iobuf *io = (struct mg_iobuf *) param;
; 6203 :   if (expand && io->len + 2 > io->size) mg_iobuf_resize(io, io->len + 2);

  00010	45 84 c0	 test	 r8b, r8b
  00013	74 16		 je	 SHORT $LN2@mg_pfn_iob
  00015	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00019	48 83 c2 02	 add	 rdx, 2
  0001d	48 3b 53 08	 cmp	 rdx, QWORD PTR [rbx+8]
  00021	76 08		 jbe	 SHORT $LN2@mg_pfn_iob
  00023	48 8b cb	 mov	 rcx, rbx
  00026	e8 00 00 00 00	 call	 mg_iobuf_resize
$LN2@mg_pfn_iob:

; 6204 :   if (io->len + 2 <= io->size) {

  0002b	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0002f	48 8d 41 02	 lea	 rax, QWORD PTR [rcx+2]
  00033	48 3b 43 08	 cmp	 rax, QWORD PTR [rbx+8]
  00037	77 18		 ja	 SHORT $LN3@mg_pfn_iob

; 6205 :     io->buf[io->len++] = (uint8_t) ch;

  00039	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003c	40 88 3c 01	 mov	 BYTE PTR [rcx+rax], dil
  00040	48 ff 43 10	 inc	 QWORD PTR [rbx+16]
  00044	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]

; 6206 :     io->buf[io->len] = 0;

  00048	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0004b	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  0004f	eb 11		 jmp	 SHORT $LN5@mg_pfn_iob
$LN3@mg_pfn_iob:

; 6207 :   } else if (io->len < io->size) {

  00051	48 3b 4b 08	 cmp	 rcx, QWORD PTR [rbx+8]
  00055	73 0b		 jae	 SHORT $LN5@mg_pfn_iob

; 6208 :     io->buf[io->len++] = 0;  // Guarantee to 0-terminate

  00057	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0005a	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  0005e	48 ff 43 10	 inc	 QWORD PTR [rbx+16]
$LN5@mg_pfn_iob:

; 6209 :   }
; 6210 : }

  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5f		 pop	 rdi
  0006c	c3		 ret	 0
mg_pfn_iobuf_private ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_putchar_iobuf_static
_TEXT	SEGMENT
ch$ = 8
param$ = 16
mg_putchar_iobuf_static PROC				; COMDAT

; 6213 :   mg_pfn_iobuf_private(ch, param, false);

  00000	45 33 c0	 xor	 r8d, r8d
  00003	e9 00 00 00 00	 jmp	 mg_pfn_iobuf_private
mg_putchar_iobuf_static ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_pfn_iobuf
_TEXT	SEGMENT
ch$ = 8
param$ = 16
mg_pfn_iobuf PROC					; COMDAT

; 6217 :   mg_pfn_iobuf_private(ch, param, true);

  00000	41 b0 01	 mov	 r8b, 1
  00003	e9 00 00 00 00	 jmp	 mg_pfn_iobuf_private
mg_pfn_iobuf ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_vsnprintf
_TEXT	SEGMENT
buf$ = 80
len$ = 88
fmt$ = 96
ap$ = 104
mg_vsnprintf PROC					; COMDAT

; 6220 : size_t mg_vsnprintf(char *buf, size_t len, const char *fmt, va_list *ap) {

$LN5:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	57		 push	 rdi
  00008	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 6221 :   struct mg_iobuf io = {(uint8_t *) buf, len, 0, 0};

  0000c	48 83 60 e8 00	 and	 QWORD PTR [rax-24], 0
  00011	48 8b da	 mov	 rbx, rdx
  00014	48 83 60 f0 00	 and	 QWORD PTR [rax-16], 0
  00019	48 8b f9	 mov	 rdi, rcx
  0001c	48 89 48 d8	 mov	 QWORD PTR [rax-40], rcx

; 6222 :   size_t n = mg_vxprintf(mg_putchar_iobuf_static, &io, fmt, ap);

  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mg_putchar_iobuf_static
  00027	48 89 50 e0	 mov	 QWORD PTR [rax-32], rdx
  0002b	48 8d 50 d8	 lea	 rdx, QWORD PTR [rax-40]
  0002f	e8 00 00 00 00	 call	 mg_vxprintf

; 6223 :   if (n < len) buf[n] = '\0';

  00034	48 3b c3	 cmp	 rax, rbx
  00037	73 04		 jae	 SHORT $LN2@mg_vsnprin
  00039	c6 04 38 00	 mov	 BYTE PTR [rax+rdi], 0
$LN2@mg_vsnprin:

; 6224 :   return n;
; 6225 : }

  0003d	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00042	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
mg_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_snprintf
_TEXT	SEGMENT
buf$ = 64
len$ = 72
fmt$ = 80
mg_snprintf PROC					; COMDAT

; 6227 : size_t mg_snprintf(char *buf, size_t len, const char *fmt, ...) {

$LN4:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	4d 89 43 18	 mov	 QWORD PTR [r11+24], r8
  00007	4d 89 4b 20	 mov	 QWORD PTR [r11+32], r9
  0000b	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6228 :   va_list ap;
; 6229 :   size_t n;
; 6230 :   va_start(ap, fmt);

  0000f	49 8d 43 20	 lea	 rax, QWORD PTR [r11+32]

; 6231 :   n = mg_vsnprintf(buf, len, fmt, &ap);

  00013	4d 8d 4b e8	 lea	 r9, QWORD PTR [r11-24]
  00017	49 89 43 e8	 mov	 QWORD PTR [r11-24], rax
  0001b	e8 00 00 00 00	 call	 mg_vsnprintf

; 6232 :   va_end(ap);
; 6233 :   return n;
; 6234 : }

  00020	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00024	c3		 ret	 0
mg_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_vmprintf
_TEXT	SEGMENT
io$ = 32
fmt$ = 80
ap$ = 88
mg_vmprintf PROC					; COMDAT

; 6236 : char *mg_vmprintf(const char *fmt, va_list *ap) {

$LN4:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 6237 :   struct mg_iobuf io = {0, 0, 0, 256};

  00007	33 c0		 xor	 eax, eax
  00009	49 c7 43 f0 00
	01 00 00	 mov	 QWORD PTR [r11-16], 256	; 00000100H

; 6238 :   mg_vxprintf(mg_pfn_iobuf, &io, fmt, ap);

  00011	4c 8b ca	 mov	 r9, rdx
  00014	49 89 43 d8	 mov	 QWORD PTR [r11-40], rax
  00018	4c 8b c1	 mov	 r8, rcx
  0001b	49 89 43 e0	 mov	 QWORD PTR [r11-32], rax
  0001f	49 8d 53 d8	 lea	 rdx, QWORD PTR [r11-40]
  00023	49 89 43 e8	 mov	 QWORD PTR [r11-24], rax
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mg_pfn_iobuf
  0002e	e8 00 00 00 00	 call	 mg_vxprintf

; 6239 :   return (char *) io.buf;

  00033	48 8b 44 24 20	 mov	 rax, QWORD PTR io$[rsp]

; 6240 : }

  00038	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0003c	c3		 ret	 0
mg_vmprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_mprintf
_TEXT	SEGMENT
fmt$ = 64
mg_mprintf PROC						; COMDAT

; 6242 : char *mg_mprintf(const char *fmt, ...) {

$LN4:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 4b 08	 mov	 QWORD PTR [r11+8], rcx
  00007	49 89 53 10	 mov	 QWORD PTR [r11+16], rdx
  0000b	4d 89 43 18	 mov	 QWORD PTR [r11+24], r8
  0000f	4d 89 4b 20	 mov	 QWORD PTR [r11+32], r9
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6243 :   char *s;
; 6244 :   va_list ap;
; 6245 :   va_start(ap, fmt);

  00017	49 8d 43 10	 lea	 rax, QWORD PTR [r11+16]

; 6246 :   s = mg_vmprintf(fmt, &ap);

  0001b	49 8d 53 e8	 lea	 rdx, QWORD PTR [r11-24]
  0001f	49 89 43 e8	 mov	 QWORD PTR [r11-24], rax
  00023	e8 00 00 00 00	 call	 mg_vmprintf

; 6247 :   va_end(ap);
; 6248 :   return s;
; 6249 : }

  00028	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002c	c3		 ret	 0
mg_mprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_pfn_stdout
_TEXT	SEGMENT
c$ = 8
param$ = 16
mg_pfn_stdout PROC					; COMDAT

; 6252 :   putchar(c);

  00000	0f be c9	 movsx	 ecx, cl
  00003	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_putchar
mg_pfn_stdout ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT print_ip4
_TEXT	SEGMENT
out$ = 80
arg$ = 88
p$ = 96
print_ip4 PROC						; COMDAT

; 6256 : static size_t print_ip4(void (*out)(char, void *), void *arg, uint8_t *p) {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 6257 :   return mg_xprintf(out, arg, "%d.%d.%d.%d", p[0], p[1], p[2], p[3]);

  00004	41 0f b6 40 03	 movzx	 eax, BYTE PTR [r8+3]
  00009	45 0f b6 50 02	 movzx	 r10d, BYTE PTR [r8+2]
  0000e	45 0f b6 58 01	 movzx	 r11d, BYTE PTR [r8+1]
  00013	45 0f b6 08	 movzx	 r9d, BYTE PTR [r8]
  00017	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd@
  0001e	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00022	44 89 54 24 28	 mov	 DWORD PTR [rsp+40], r10d
  00027	44 89 5c 24 20	 mov	 DWORD PTR [rsp+32], r11d
  0002c	e8 00 00 00 00	 call	 mg_xprintf

; 6258 : }

  00031	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00035	c3		 ret	 0
print_ip4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT print_ip6
_TEXT	SEGMENT
out$ = 160
arg$ = 168
p$ = 176
print_ip6 PROC						; COMDAT

; 6260 : static size_t print_ip6(void (*out)(char, void *), void *arg, uint16_t *p) {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 54		 push	 r12
  00014	41 55		 push	 r13
  00016	41 56		 push	 r14
  00018	41 57		 push	 r15
  0001a	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 13806:   memcpy(&data, &net, sizeof(data));

  0001e	45 0f b7 48 0e	 movzx	 r9d, WORD PTR [r8+14]
  00023	45 0f b7 50 0c	 movzx	 r10d, WORD PTR [r8+12]
  00028	45 0f b7 58 0a	 movzx	 r11d, WORD PTR [r8+10]
  0002d	41 0f b7 58 08	 movzx	 ebx, WORD PTR [r8+8]
  00032	41 0f b7 70 06	 movzx	 esi, WORD PTR [r8+6]
  00037	45 0f b7 70 04	 movzx	 r14d, WORD PTR [r8+4]
  0003c	45 0f b7 78 02	 movzx	 r15d, WORD PTR [r8+2]
  00041	45 0f b7 28	 movzx	 r13d, WORD PTR [r8]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00045	41 0f b6 c1	 movzx	 eax, r9b
  00049	66 c1 e0 08	 shl	 ax, 8
  0004d	44 0f b7 e0	 movzx	 r12d, ax
  00051	41 0f b6 c2	 movzx	 eax, r10b
  00055	66 c1 e0 08	 shl	 ax, 8
  00059	0f b7 e8	 movzx	 ebp, ax
  0005c	41 0f b6 c3	 movzx	 eax, r11b
  00060	66 c1 e0 08	 shl	 ax, 8
  00064	0f b7 f8	 movzx	 edi, ax
  00067	0f b6 c3	 movzx	 eax, bl
  0006a	66 c1 e0 08	 shl	 ax, 8
  0006e	41 c1 ea 08	 shr	 r10d, 8
  00072	41 0b ea	 or	 ebp, r10d
  00075	41 c1 e9 08	 shr	 r9d, 8
  00079	44 0f b7 d0	 movzx	 r10d, ax
  0007d	45 0b e1	 or	 r12d, r9d

; 6261 :   return mg_xprintf(out, arg, "[%x:%x:%x:%x:%x:%x:%x:%x]", mg_ntohs(p[0]),

  00080	44 89 64 24 50	 mov	 DWORD PTR [rsp+80], r12d
  00085	89 6c 24 48	 mov	 DWORD PTR [rsp+72], ebp

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00089	40 0f b6 c6	 movzx	 eax, sil
  0008d	66 c1 e0 08	 shl	 ax, 8
  00091	44 0f b7 c0	 movzx	 r8d, ax
  00095	41 0f b6 c6	 movzx	 eax, r14b
  00099	66 c1 e0 08	 shl	 ax, 8
  0009d	0f b7 d0	 movzx	 edx, ax
  000a0	41 0f b6 c7	 movzx	 eax, r15b
  000a4	66 c1 e0 08	 shl	 ax, 8
  000a8	0f b7 c8	 movzx	 ecx, ax
  000ab	41 0f b6 c5	 movzx	 eax, r13b
  000af	41 c1 eb 08	 shr	 r11d, 8
  000b3	c1 eb 08	 shr	 ebx, 8
  000b6	41 0b fb	 or	 edi, r11d

; 6261 :   return mg_xprintf(out, arg, "[%x:%x:%x:%x:%x:%x:%x:%x]", mg_ntohs(p[0]),

  000b9	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  000bd	44 0b d3	 or	 r10d, ebx

; 6261 :   return mg_xprintf(out, arg, "[%x:%x:%x:%x:%x:%x:%x:%x]", mg_ntohs(p[0]),

  000c0	44 89 54 24 38	 mov	 DWORD PTR [rsp+56], r10d

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  000c5	c1 ee 08	 shr	 esi, 8
  000c8	44 0b c6	 or	 r8d, esi
  000cb	41 c1 ee 08	 shr	 r14d, 8

; 6261 :   return mg_xprintf(out, arg, "[%x:%x:%x:%x:%x:%x:%x:%x]", mg_ntohs(p[0]),

  000cf	44 89 44 24 30	 mov	 DWORD PTR [rsp+48], r8d

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  000d4	41 0b d6	 or	 edx, r14d

; 6261 :   return mg_xprintf(out, arg, "[%x:%x:%x:%x:%x:%x:%x:%x]", mg_ntohs(p[0]),

  000d7	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  000db	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BK@HMDKCEIC@?$FL?$CFx?3?$CFx?3?$CFx?3?$CFx?3?$CFx?3?$CFx?3?$CFx?3?$CFx?$FN@
  000e2	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR arg$[rsp]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  000ea	41 c1 ef 08	 shr	 r15d, 8
  000ee	41 0b cf	 or	 ecx, r15d
  000f1	66 c1 e0 08	 shl	 ax, 8
  000f5	44 0f b7 c8	 movzx	 r9d, ax
  000f9	41 c1 ed 08	 shr	 r13d, 8

; 6261 :   return mg_xprintf(out, arg, "[%x:%x:%x:%x:%x:%x:%x:%x]", mg_ntohs(p[0]),

  000fd	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00101	45 0b cd	 or	 r9d, r13d

; 6261 :   return mg_xprintf(out, arg, "[%x:%x:%x:%x:%x:%x:%x:%x]", mg_ntohs(p[0]),

  00104	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  0010c	e8 00 00 00 00	 call	 mg_xprintf

; 6262 :                     mg_ntohs(p[1]), mg_ntohs(p[2]), mg_ntohs(p[3]),
; 6263 :                     mg_ntohs(p[4]), mg_ntohs(p[5]), mg_ntohs(p[6]),
; 6264 :                     mg_ntohs(p[7]));
; 6265 : }

  00111	48 8b 9c 24 b0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+176]
  00119	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0011d	41 5f		 pop	 r15
  0011f	41 5e		 pop	 r14
  00121	41 5d		 pop	 r13
  00123	41 5c		 pop	 r12
  00125	5f		 pop	 rdi
  00126	5e		 pop	 rsi
  00127	5d		 pop	 rbp
  00128	c3		 ret	 0
print_ip6 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_print_ip4
_TEXT	SEGMENT
out$ = 8
arg$ = 16
ap$ = 24
mg_print_ip4 PROC					; COMDAT

; 6267 : size_t mg_print_ip4(void (*out)(char, void *), void *arg, va_list *ap) {

  00000	4d 8b c8	 mov	 r9, r8

; 6268 :   uint8_t *p = va_arg(*ap, uint8_t *);

  00003	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00006	49 8d 40 08	 lea	 rax, QWORD PTR [r8+8]
  0000a	49 89 01	 mov	 QWORD PTR [r9], rax

; 6269 :   return print_ip4(out, arg, p);

  0000d	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00010	e9 00 00 00 00	 jmp	 print_ip4
mg_print_ip4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_print_ip6
_TEXT	SEGMENT
out$ = 8
arg$ = 16
ap$ = 24
mg_print_ip6 PROC					; COMDAT

; 6272 : size_t mg_print_ip6(void (*out)(char, void *), void *arg, va_list *ap) {

  00000	4d 8b c8	 mov	 r9, r8

; 6273 :   uint16_t *p = va_arg(*ap, uint16_t *);

  00003	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00006	49 8d 40 08	 lea	 rax, QWORD PTR [r8+8]
  0000a	49 89 01	 mov	 QWORD PTR [r9], rax

; 6274 :   return print_ip6(out, arg, p);

  0000d	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00010	e9 00 00 00 00	 jmp	 print_ip6
mg_print_ip6 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_print_ip
_TEXT	SEGMENT
out$ = 8
arg$ = 16
ap$ = 24
mg_print_ip PROC					; COMDAT

; 6278 :   struct mg_addr *addr = va_arg(*ap, struct mg_addr *);

  00000	4d 8b 08	 mov	 r9, QWORD PTR [r8]
  00003	49 8d 41 08	 lea	 rax, QWORD PTR [r9+8]
  00007	49 89 00	 mov	 QWORD PTR [r8], rax
  0000a	4d 8b 01	 mov	 r8, QWORD PTR [r9]

; 6279 :   if (addr->is_ip6) return print_ip6(out, arg, (uint16_t *) addr->ip);

  0000d	41 80 78 13 00	 cmp	 BYTE PTR [r8+19], 0
  00012	0f 85 00 00 00
	00		 jne	 print_ip6
$LN2@mg_print_i:

; 6280 :   return print_ip4(out, arg, (uint8_t *) &addr->ip);

  00018	e9 00 00 00 00	 jmp	 print_ip4
mg_print_ip ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_print_ip_port
_TEXT	SEGMENT
out$ = 64
arg$ = 72
ap$ = 80
mg_print_ip_port PROC					; COMDAT

; 6283 : size_t mg_print_ip_port(void (*out)(char, void *), void *arg, va_list *ap) {

$LN6:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6284 :   struct mg_addr *a = va_arg(*ap, struct mg_addr *);

  00004	4d 8b 08	 mov	 r9, QWORD PTR [r8]
  00007	49 8d 41 08	 lea	 rax, QWORD PTR [r9+8]
  0000b	49 89 00	 mov	 QWORD PTR [r8], rax
  0000e	4d 8b 11	 mov	 r10, QWORD PTR [r9]

; 13806:   memcpy(&data, &net, sizeof(data));

  00011	45 0f b7 4a 10	 movzx	 r9d, WORD PTR [r10+16]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00016	41 0f b6 c1	 movzx	 eax, r9b
  0001a	41 c1 e9 08	 shr	 r9d, 8
  0001e	66 c1 e0 08	 shl	 ax, 8
  00022	44 0f b7 c0	 movzx	 r8d, ax
  00026	45 0b c1	 or	 r8d, r9d

; 6285 :   return mg_xprintf(out, arg, "%M:%hu", mg_print_ip, a, mg_ntohs(a->port));

  00029	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:mg_print_ip
  00030	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  00035	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06CECBMHAI@?$CFM?3?$CFhu@
  0003c	4c 89 54 24 20	 mov	 QWORD PTR [rsp+32], r10
  00041	e8 00 00 00 00	 call	 mg_xprintf

; 6286 : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
mg_print_ip_port ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_print_mac
_TEXT	SEGMENT
out$ = 96
arg$ = 104
ap$ = 112
mg_print_mac PROC					; COMDAT

; 6288 : size_t mg_print_mac(void (*out)(char, void *), void *arg, va_list *ap) {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 6289 :   uint8_t *p = va_arg(*ap, uint8_t *);

  0000a	4d 8b 08	 mov	 r9, QWORD PTR [r8]
  0000d	49 8d 41 08	 lea	 rax, QWORD PTR [r9+8]
  00011	49 89 00	 mov	 QWORD PTR [r8], rax
  00014	49 8b 01	 mov	 rax, QWORD PTR [r9]

; 6290 :   return mg_xprintf(out, arg, "%02x:%02x:%02x:%02x:%02x:%02x", p[0], p[1], p[2],

  00017	44 0f b6 40 05	 movzx	 r8d, BYTE PTR [rax+5]
  0001c	44 0f b6 50 04	 movzx	 r10d, BYTE PTR [rax+4]
  00021	44 0f b6 58 03	 movzx	 r11d, BYTE PTR [rax+3]
  00026	0f b6 58 02	 movzx	 ebx, BYTE PTR [rax+2]
  0002a	0f b6 78 01	 movzx	 edi, BYTE PTR [rax+1]
  0002e	44 0f b6 08	 movzx	 r9d, BYTE PTR [rax]
  00032	44 89 44 24 40	 mov	 DWORD PTR [rsp+64], r8d
  00037	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BO@ONJEFEPB@?$CF02x?3?$CF02x?3?$CF02x?3?$CF02x?3?$CF02x?3?$CF02x@
  0003e	44 89 54 24 38	 mov	 DWORD PTR [rsp+56], r10d
  00043	44 89 5c 24 30	 mov	 DWORD PTR [rsp+48], r11d
  00048	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  0004c	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  00050	e8 00 00 00 00	 call	 mg_xprintf

; 6291 :                     p[3], p[4], p[5]);
; 6292 : }

  00055	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0005a	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0005e	5f		 pop	 rdi
  0005f	c3		 ret	 0
mg_print_mac ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_esc
_TEXT	SEGMENT
c$ = 8
esc$dead$ = 16
mg_esc	PROC						; COMDAT

; 6295 :   const char *p, *esc1 = "\b\f\n\r\t\\\"", *esc2 = "bfnrt\\\"";
; 6296 :   for (p = esc ? esc1 : esc2; *p != '\0'; p++) {

  00000	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07GIIPGIPO@?$AI?$AM?6?$AN?7?2?$CC@
  00007	b0 08		 mov	 al, 8
  00009	49 8b d0	 mov	 rdx, r8
$LL4@mg_esc:

; 6297 :     if (*p == c) return esc ? esc2[p - esc1] : esc1[p - esc2];

  0000c	0f be c0	 movsx	 eax, al
  0000f	3b c1		 cmp	 eax, ecx
  00011	74 0a		 je	 SHORT $LN14@mg_esc

; 6295 :   const char *p, *esc1 = "\b\f\n\r\t\\\"", *esc2 = "bfnrt\\\"";
; 6296 :   for (p = esc ? esc1 : esc2; *p != '\0'; p++) {

  00013	48 ff c2	 inc	 rdx
  00016	8a 02		 mov	 al, BYTE PTR [rdx]
  00018	84 c0		 test	 al, al
  0001a	75 f0		 jne	 SHORT $LL4@mg_esc

; 6298 :   }
; 6299 :   return 0;
; 6300 : }

  0001c	c3		 ret	 0
$LN14@mg_esc:

; 6297 :     if (*p == c) return esc ? esc2[p - esc1] : esc1[p - esc2];

  0001d	49 2b d0	 sub	 rdx, r8
  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07HHNAIFDF@bfnrt?2?$CC@
  00027	8a 04 02	 mov	 al, BYTE PTR [rdx+rax]

; 6298 :   }
; 6299 :   return 0;
; 6300 : }

  0002a	c3		 ret	 0
mg_esc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_escape
_TEXT	SEGMENT
c$ = 8
mg_escape PROC						; COMDAT

; 6303 :   return mg_esc(c, true);

  00000	e9 00 00 00 00	 jmp	 mg_esc
mg_escape ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT qcpy
_TEXT	SEGMENT
out$ = 64
ptr$ = 72
buf$ = 80
len$ = 88
qcpy	PROC						; COMDAT

; 6307 :                    size_t len) {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	41 56		 push	 r14
  00017	41 57		 push	 r15
  00019	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 6308 :   size_t i = 0, extra = 0;

  0001d	33 ff		 xor	 edi, edi

; 6309 :   for (i = 0; i < len && buf[i] != '\0'; i++) {

  0001f	33 db		 xor	 ebx, ebx
  00021	4d 8b f9	 mov	 r15, r9
  00024	4d 8b e0	 mov	 r12, r8
  00027	48 8b f2	 mov	 rsi, rdx
  0002a	48 8b e9	 mov	 rbp, rcx
  0002d	4d 85 c9	 test	 r9, r9
  00030	74 37		 je	 SHORT $LN3@qcpy
$LL4@qcpy:
  00032	46 0f be 0c 23	 movsx	 r9d, BYTE PTR [rbx+r12]
  00037	45 84 c9	 test	 r9b, r9b
  0003a	74 2d		 je	 SHORT $LN3@qcpy

; 6310 :     char c = mg_escape(buf[i]);

  0003c	41 8b c9	 mov	 ecx, r9d

; 6303 :   return mg_esc(c, true);

  0003f	e8 00 00 00 00	 call	 mg_esc
  00044	44 8a f0	 mov	 r14b, al

; 6311 :     if (c) {

  00047	48 8b d6	 mov	 rdx, rsi
  0004a	84 c0		 test	 al, al
  0004c	74 11		 je	 SHORT $LN5@qcpy

; 6312 :       out('\\', ptr), out(c, ptr), extra++;

  0004e	b1 5c		 mov	 cl, 92			; 0000005cH
  00050	ff d5		 call	 rbp
  00052	48 8b d6	 mov	 rdx, rsi
  00055	41 8a ce	 mov	 cl, r14b
  00058	ff d5		 call	 rbp
  0005a	48 ff c7	 inc	 rdi

; 6313 :     } else {

  0005d	eb 02		 jmp	 SHORT $LN2@qcpy
$LN5@qcpy:

; 6314 :       out(buf[i], ptr);

  0005f	ff d5		 call	 rbp
$LN2@qcpy:

; 6309 :   for (i = 0; i < len && buf[i] != '\0'; i++) {

  00061	48 ff c3	 inc	 rbx
  00064	49 3b df	 cmp	 rbx, r15
  00067	72 c9		 jb	 SHORT $LL4@qcpy
$LN3@qcpy:

; 6315 :     }
; 6316 :   }
; 6317 :   return i + extra;
; 6318 : }

  00069	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0006e	48 8d 04 1f	 lea	 rax, QWORD PTR [rdi+rbx]
  00072	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00077	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0007c	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00081	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00085	41 5f		 pop	 r15
  00087	41 5e		 pop	 r14
  00089	41 5c		 pop	 r12
  0008b	c3		 ret	 0
qcpy	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT bcpy
_TEXT	SEGMENT
tv492 = 32
out$ = 112
arg$ = 120
buf$ = 128
tmp$1 = 136
len$ = 136
bcpy	PROC						; COMDAT

; 6321 :                    size_t len) {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 55		 push	 r13
  00011	41 56		 push	 r14
  00013	41 57		 push	 r15
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 6322 :   size_t i, j, n = 0;

  00019	45 33 f6	 xor	 r14d, r14d
  0001c	49 8b f1	 mov	 rsi, r9
  0001f	4d 8b f8	 mov	 r15, r8
  00022	4c 8b ea	 mov	 r13, rdx

; 6323 :   const char *t =
; 6324 :       "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
; 6325 :   for (i = 0; i < len; i += 3) {

  00025	4d 85 c9	 test	 r9, r9
  00028	0f 84 07 01 00
	00		 je	 $LN3@bcpy

; 6322 :   size_t i, j, n = 0;

  0002e	49 ff c9	 dec	 r9
  00031	49 8d 58 02	 lea	 rbx, QWORD PTR [r8+2]
  00035	48 b8 ab aa aa
	aa aa aa aa aa	 mov	 rax, -6148914691236517205 ; aaaaaaaaaaaaaaabH
  0003f	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:??_C@_0EB@NFPJKBDG@ABCDEFGHIJKLMNOPQRSTUVWXYZabcde@
  00046	49 f7 e1	 mul	 r9
  00049	4d 8b e0	 mov	 r12, r8
  0004c	48 8b ea	 mov	 rbp, rdx
  0004f	49 f7 d4	 not	 r12
  00052	48 d1 ed	 shr	 rbp, 1
  00055	48 ff c5	 inc	 rbp
  00058	4c 89 64 24 20	 mov	 QWORD PTR tv492[rsp], r12
$LL4@bcpy:

; 6326 :     uint8_t c1 = buf[i], c2 = i + 1 < len ? buf[i + 1] : 0,

  0005d	4d 8d 14 1c	 lea	 r10, QWORD PTR [r12+rbx]
  00061	4c 3b d6	 cmp	 r10, rsi
  00064	73 05		 jae	 SHORT $LN11@bcpy
  00066	8a 53 ff	 mov	 dl, BYTE PTR [rbx-1]
  00069	eb 02		 jmp	 SHORT $LN12@bcpy
$LN11@bcpy:
  0006b	32 d2		 xor	 dl, dl
$LN12@bcpy:

; 6327 :             c3 = i + 2 < len ? buf[i + 2] : 0;

  0006d	4c 8b c3	 mov	 r8, rbx
  00070	4d 2b c7	 sub	 r8, r15
  00073	4c 3b c6	 cmp	 r8, rsi
  00076	73 05		 jae	 SHORT $LN13@bcpy
  00078	44 8a 0b	 mov	 r9b, BYTE PTR [rbx]
  0007b	eb 03		 jmp	 SHORT $LN14@bcpy
$LN13@bcpy:
  0007d	45 32 c9	 xor	 r9b, r9b
$LN14@bcpy:

; 6328 :     char tmp[4] = {t[c1 >> 2], t[(c1 & 3) << 4 | (c2 >> 4)], '=', '='};

  00080	0f b6 4b fe	 movzx	 ecx, BYTE PTR [rbx-2]
  00084	8b c1		 mov	 eax, ecx
  00086	0f b6 d2	 movzx	 edx, dl
  00089	48 c1 e8 02	 shr	 rax, 2
  0008d	83 e1 03	 and	 ecx, 3
  00090	48 c1 e1 04	 shl	 rcx, 4
  00094	66 c7 84 24 8a
	00 00 00 3d 3d	 mov	 WORD PTR tmp$1[rsp+2], 15677 ; 00003d3dH
  0009e	42 8a 04 18	 mov	 al, BYTE PTR [rax+r11]
  000a2	88 84 24 88 00
	00 00		 mov	 BYTE PTR tmp$1[rsp], al
  000a9	8b c2		 mov	 eax, edx
  000ab	48 c1 e8 04	 shr	 rax, 4
  000af	48 0b c1	 or	 rax, rcx
  000b2	42 8a 04 18	 mov	 al, BYTE PTR [rax+r11]
  000b6	88 84 24 89 00
	00 00		 mov	 BYTE PTR tmp$1[rsp+1], al

; 6329 :     if (i + 1 < len) tmp[2] = t[(c2 & 15) << 2 | (c3 >> 6)];

  000bd	4c 3b d6	 cmp	 r10, rsi
  000c0	73 1e		 jae	 SHORT $LN8@bcpy
  000c2	83 e2 0f	 and	 edx, 15
  000c5	41 0f b6 c1	 movzx	 eax, r9b
  000c9	c1 e2 02	 shl	 edx, 2
  000cc	48 c1 e8 06	 shr	 rax, 6
  000d0	8b ca		 mov	 ecx, edx
  000d2	48 0b c8	 or	 rcx, rax
  000d5	42 8a 04 19	 mov	 al, BYTE PTR [rcx+r11]
  000d9	88 84 24 8a 00
	00 00		 mov	 BYTE PTR tmp$1[rsp+2], al
$LN8@bcpy:

; 6330 :     if (i + 2 < len) tmp[3] = t[c3 & 63];

  000e0	4c 3b c6	 cmp	 r8, rsi
  000e3	73 12		 jae	 SHORT $LN9@bcpy
  000e5	41 0f b6 c1	 movzx	 eax, r9b
  000e9	83 e0 3f	 and	 eax, 63			; 0000003fH
  000ec	42 8a 04 18	 mov	 al, BYTE PTR [rax+r11]
  000f0	88 84 24 8b 00
	00 00		 mov	 BYTE PTR tmp$1[rsp+3], al
$LN9@bcpy:

; 6331 :     for (j = 0; j < sizeof(tmp) && tmp[j] != '\0'; j++) out(tmp[j], arg);

  000f7	4c 8b 64 24 70	 mov	 r12, QWORD PTR out$[rsp]
  000fc	33 ff		 xor	 edi, edi
$LL7@bcpy:
  000fe	8a 8c 3c 88 00
	00 00		 mov	 cl, BYTE PTR tmp$1[rsp+rdi]
  00105	84 c9		 test	 cl, cl
  00107	74 0f		 je	 SHORT $LN6@bcpy
  00109	49 8b d5	 mov	 rdx, r13
  0010c	41 ff d4	 call	 r12
  0010f	48 ff c7	 inc	 rdi
  00112	48 83 ff 04	 cmp	 rdi, 4
  00116	72 e6		 jb	 SHORT $LL7@bcpy
$LN6@bcpy:

; 6323 :   const char *t =
; 6324 :       "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
; 6325 :   for (i = 0; i < len; i += 3) {

  00118	4c 8b 64 24 20	 mov	 r12, QWORD PTR tv492[rsp]
  0011d	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:??_C@_0EB@NFPJKBDG@ABCDEFGHIJKLMNOPQRSTUVWXYZabcde@

; 6332 :     n += j;

  00124	4c 03 f7	 add	 r14, rdi
  00127	48 83 c3 03	 add	 rbx, 3
  0012b	48 83 ed 01	 sub	 rbp, 1
  0012f	0f 85 28 ff ff
	ff		 jne	 $LL4@bcpy
$LN3@bcpy:

; 6333 :   }
; 6334 :   return n;
; 6335 : }

  00135	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  0013a	49 8b c6	 mov	 rax, r14
  0013d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00141	41 5f		 pop	 r15
  00143	41 5e		 pop	 r14
  00145	41 5d		 pop	 r13
  00147	41 5c		 pop	 r12
  00149	5f		 pop	 rdi
  0014a	5e		 pop	 rsi
  0014b	5d		 pop	 rbp
  0014c	c3		 ret	 0
bcpy	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_print_hex
_TEXT	SEGMENT
out$ = 64
arg$ = 72
ap$ = 80
mg_print_hex PROC					; COMDAT

; 6337 : size_t mg_print_hex(void (*out)(char, void *), void *arg, va_list *ap) {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 6338 :   size_t bl = (size_t) va_arg(*ap, int);

  00018	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0001b	48 8b ea	 mov	 rbp, rdx
  0001e	4c 8b f1	 mov	 r14, rcx
  00021	4c 8d 48 08	 lea	 r9, QWORD PTR [rax+8]
  00025	4d 89 08	 mov	 QWORD PTR [r8], r9
  00028	48 63 18	 movsxd	 rbx, DWORD PTR [rax]

; 6339 :   uint8_t *p = va_arg(*ap, uint8_t *);

  0002b	49 8d 41 08	 lea	 rax, QWORD PTR [r9+8]
  0002f	49 89 00	 mov	 QWORD PTR [r8], rax
  00032	49 8b 39	 mov	 rdi, QWORD PTR [r9]

; 6340 :   const char *hex = "0123456789abcdef";
; 6341 :   size_t j;
; 6342 :   for (j = 0; j < bl; j++) {

  00035	48 85 db	 test	 rbx, rbx
  00038	74 34		 je	 SHORT $LN3@mg_print_h

; 6338 :   size_t bl = (size_t) va_arg(*ap, int);

  0003a	48 8b f3	 mov	 rsi, rbx
  0003d	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:??_C@_0BB@JCEFLFJE@0123456789abcdef@
$LL4@mg_print_h:

; 6343 :     out(hex[(p[j] >> 4) & 0x0F], arg);

  00044	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  00047	48 8b d5	 mov	 rdx, rbp
  0004a	48 c1 e8 04	 shr	 rax, 4
  0004e	42 8a 0c 38	 mov	 cl, BYTE PTR [rax+r15]
  00052	41 ff d6	 call	 r14

; 6344 :     out(hex[p[j] & 0x0F], arg);

  00055	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  00058	48 8b d5	 mov	 rdx, rbp
  0005b	83 e0 0f	 and	 eax, 15
  0005e	42 8a 0c 38	 mov	 cl, BYTE PTR [rax+r15]
  00062	41 ff d6	 call	 r14
  00065	48 ff c7	 inc	 rdi
  00068	48 83 ee 01	 sub	 rsi, 1
  0006c	75 d6		 jne	 SHORT $LL4@mg_print_h
$LN3@mg_print_h:

; 6345 :   }
; 6346 :   return 2 * bl;
; 6347 : }

  0006e	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00073	48 8d 04 1b	 lea	 rax, QWORD PTR [rbx+rbx]
  00077	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0007c	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00081	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00085	41 5f		 pop	 r15
  00087	41 5e		 pop	 r14
  00089	5f		 pop	 rdi
  0008a	c3		 ret	 0
mg_print_hex ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_print_base64
_TEXT	SEGMENT
out$ = 8
arg$ = 16
ap$ = 24
mg_print_base64 PROC					; COMDAT

; 6349 :   size_t len = (size_t) va_arg(*ap, int);

  00000	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00003	4d 8b d0	 mov	 r10, r8
  00006	4c 8d 40 08	 lea	 r8, QWORD PTR [rax+8]
  0000a	4d 89 02	 mov	 QWORD PTR [r10], r8
  0000d	4c 63 08	 movsxd	 r9, DWORD PTR [rax]

; 6350 :   uint8_t *buf = va_arg(*ap, uint8_t *);

  00010	49 8d 40 08	 lea	 rax, QWORD PTR [r8+8]
  00014	49 89 02	 mov	 QWORD PTR [r10], rax

; 6351 :   return bcpy(out, arg, buf, len);

  00017	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  0001a	e9 00 00 00 00	 jmp	 bcpy
mg_print_base64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_print_esc
_TEXT	SEGMENT
out$ = 8
arg$ = 16
ap$ = 24
mg_print_esc PROC					; COMDAT

; 6355 :   size_t len = (size_t) va_arg(*ap, int);

  00000	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00003	4c 8d 48 08	 lea	 r9, QWORD PTR [rax+8]
  00007	4d 89 08	 mov	 QWORD PTR [r8], r9
  0000a	4c 63 10	 movsxd	 r10, DWORD PTR [rax]

; 6356 :   char *p = va_arg(*ap, char *);

  0000d	49 8d 41 08	 lea	 rax, QWORD PTR [r9+8]
  00011	49 89 00	 mov	 QWORD PTR [r8], rax
  00014	4d 8b 01	 mov	 r8, QWORD PTR [r9]

; 6357 :   if (len == 0) len = p == NULL ? 0 : strlen(p);

  00017	4d 85 d2	 test	 r10, r10
  0001a	75 13		 jne	 SHORT $LN5@mg_print_e
  0001c	4d 85 c0	 test	 r8, r8
  0001f	74 0e		 je	 SHORT $LN5@mg_print_e
$LN4@mg_print_e:
  00021	49 83 ca ff	 or	 r10, -1
$LL6@mg_print_e:
  00025	49 ff c2	 inc	 r10
  00028	43 80 3c 10 00	 cmp	 BYTE PTR [r8+r10], 0
  0002d	75 f6		 jne	 SHORT $LL6@mg_print_e
$LN5@mg_print_e:

; 6358 :   return qcpy(out, arg, p, len);

  0002f	4d 8b ca	 mov	 r9, r10
  00032	e9 00 00 00 00	 jmp	 qcpy
mg_print_esc ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_queue_init
_TEXT	SEGMENT
q$ = 8
buf$ = 16
size$ = 24
mg_queue_init PROC					; COMDAT

; 6391 :   q->size = size;

  00000	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 6392 :   q->buf = buf;

  00004	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 6393 :   q->head = q->tail = 0;

  00007	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0
  0000f	48 c7 41 18 00
	00 00 00	 mov	 QWORD PTR [rcx+24], 0

; 6394 : }

  00017	c3		 ret	 0
mg_queue_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_queue_read_len
_TEXT	SEGMENT
q$ = 8
mg_queue_read_len PROC					; COMDAT

; 6397 :   uint32_t n = 0;
; 6398 :   MG_MEMORY_BARRIER();

  00000	f0 83 0c 24 00	 lock or DWORD PTR [rsp], 0

; 6399 :   memcpy(&n, q->buf + q->tail, sizeof(n));

  00005	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  00009	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 6400 :   assert(q->tail + n + sizeof(n) <= q->size);
; 6401 :   return n;

  0000c	8b 04 02	 mov	 eax, DWORD PTR [rdx+rax]

; 6402 : }

  0000f	c3		 ret	 0
mg_queue_read_len ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_queue_write_len
_TEXT	SEGMENT
q$ = 8
len$ = 16
mg_queue_write_len PROC					; COMDAT

; 6405 :   uint32_t n = (uint32_t) len;
; 6406 :   memcpy(q->buf + q->head, &n, sizeof(n));

  00000	4c 8b 41 18	 mov	 r8, QWORD PTR [rcx+24]
  00004	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00007	41 89 14 00	 mov	 DWORD PTR [r8+rax], edx

; 6407 :   MG_MEMORY_BARRIER();

  0000b	f0 83 0c 24 00	 lock or DWORD PTR [rsp], 0

; 6408 : }

  00010	c3		 ret	 0
mg_queue_write_len ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_queue_book
_TEXT	SEGMENT
q$ = 8
buf$ = 16
len$ = 24
mg_queue_book PROC					; COMDAT

; 6410 : size_t mg_queue_book(struct mg_queue *q, char **buf, size_t len) {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 6411 :   size_t space = 0, hs = sizeof(uint32_t) * 2;  // *2 is for the 0 marker
; 6412 :   if (q->head >= q->tail && q->head + len + hs <= q->size) {

  00005	4c 8b 49 18	 mov	 r9, QWORD PTR [rcx+24]
  00009	48 8b da	 mov	 rbx, rdx
  0000c	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00010	33 d2		 xor	 edx, edx
  00012	4c 8b d1	 mov	 r10, rcx
  00015	44 8b da	 mov	 r11d, edx
  00018	4c 3b c8	 cmp	 r9, rax
  0001b	72 24		 jb	 SHORT $LN2@mg_queue_b
  0001d	4c 8b 49 18	 mov	 r9, QWORD PTR [rcx+24]
  00021	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00025	49 83 c1 08	 add	 r9, 8
  00029	4d 03 c8	 add	 r9, r8
  0002c	4c 3b c9	 cmp	 r9, rcx
  0002f	77 10		 ja	 SHORT $LN2@mg_queue_b

; 6413 :     space = q->size - q->head - hs;  // There is enough space

  00031	49 8b 42 18	 mov	 rax, QWORD PTR [r10+24]
  00035	4c 8b d9	 mov	 r11, rcx
  00038	4c 2b d8	 sub	 r11, rax
  0003b	49 83 eb 08	 sub	 r11, 8
  0003f	eb 29		 jmp	 SHORT $LN4@mg_queue_b
$LN2@mg_queue_b:

; 6414 :   } else if (q->head >= q->tail && q->tail > hs) {

  00041	49 8b 4a 18	 mov	 rcx, QWORD PTR [r10+24]
  00045	49 8b 42 10	 mov	 rax, QWORD PTR [r10+16]
  00049	48 3b c8	 cmp	 rcx, rax
  0004c	72 1c		 jb	 SHORT $LN4@mg_queue_b
  0004e	49 8b 42 10	 mov	 rax, QWORD PTR [r10+16]
  00052	48 83 f8 08	 cmp	 rax, 8
  00056	76 12		 jbe	 SHORT $LN4@mg_queue_b

; 6406 :   memcpy(q->buf + q->head, &n, sizeof(n));

  00058	49 8b 4a 18	 mov	 rcx, QWORD PTR [r10+24]
  0005c	49 8b 02	 mov	 rax, QWORD PTR [r10]
  0005f	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 6407 :   MG_MEMORY_BARRIER();

  00062	f0 09 14 24	 lock or DWORD PTR [rsp], edx

; 6415 :     mg_queue_write_len(q, 0);  // Not enough space ahead
; 6416 :     q->head = 0;               // Wrap head to the beginning

  00066	49 89 52 18	 mov	 QWORD PTR [r10+24], rdx
$LN4@mg_queue_b:

; 6417 :   }
; 6418 :   if (q->head + hs + len < q->tail) space = q->tail - q->head - hs;

  0006a	49 8b 4a 18	 mov	 rcx, QWORD PTR [r10+24]
  0006e	49 8b 42 10	 mov	 rax, QWORD PTR [r10+16]
  00072	48 83 c1 08	 add	 rcx, 8
  00076	49 03 c8	 add	 rcx, r8
  00079	48 3b c8	 cmp	 rcx, rax
  0007c	73 0f		 jae	 SHORT $LN5@mg_queue_b
  0007e	4d 8b 5a 10	 mov	 r11, QWORD PTR [r10+16]
  00082	49 8b 4a 18	 mov	 rcx, QWORD PTR [r10+24]
  00086	49 83 eb 08	 sub	 r11, 8
  0008a	4c 2b d9	 sub	 r11, rcx
$LN5@mg_queue_b:

; 6419 :   if (buf != NULL) *buf = q->buf + q->head + sizeof(uint32_t);

  0008d	48 85 db	 test	 rbx, rbx
  00090	74 0e		 je	 SHORT $LN6@mg_queue_b
  00092	49 8b 52 18	 mov	 rdx, QWORD PTR [r10+24]
  00096	48 83 c2 04	 add	 rdx, 4
  0009a	49 03 12	 add	 rdx, QWORD PTR [r10]
  0009d	48 89 13	 mov	 QWORD PTR [rbx], rdx
$LN6@mg_queue_b:

; 6420 :   return space;
; 6421 : }

  000a0	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  000a5	49 8b c3	 mov	 rax, r11
  000a8	c3		 ret	 0
mg_queue_book ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_queue_next
_TEXT	SEGMENT
q$ = 8
buf$ = 16
mg_queue_next PROC					; COMDAT

; 6424 :   size_t len = 0;
; 6425 :   if (q->tail != q->head) {

  00000	4c 8b 41 18	 mov	 r8, QWORD PTR [rcx+24]
  00004	4c 8b da	 mov	 r11, rdx
  00007	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0000b	33 d2		 xor	 edx, edx
  0000d	4c 8b c9	 mov	 r9, rcx
  00010	44 8b d2	 mov	 r10d, edx
  00013	49 3b c0	 cmp	 rax, r8
  00016	74 34		 je	 SHORT $LN4@mg_queue_n

; 6398 :   MG_MEMORY_BARRIER();

  00018	f0 09 14 24	 lock or DWORD PTR [rsp], edx

; 6399 :   memcpy(&n, q->buf + q->tail, sizeof(n));

  0001c	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00020	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 6400 :   assert(q->tail + n + sizeof(n) <= q->size);
; 6401 :   return n;

  00023	45 8b 14 00	 mov	 r10d, DWORD PTR [r8+rax]

; 6426 :     len = mg_queue_read_len(q);
; 6427 :     if (len == 0) {  // Zero (head wrapped) ?

  00027	4d 85 d2	 test	 r10, r10
  0002a	75 20		 jne	 SHORT $LN4@mg_queue_n

; 6428 :       q->tail = 0;   // Reset tail to the start

  0002c	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx

; 6429 :       if (q->head > q->tail) len = mg_queue_read_len(q);  // Read again

  00030	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00034	49 8b 41 10	 mov	 rax, QWORD PTR [r9+16]
  00038	48 3b c8	 cmp	 rcx, rax
  0003b	76 0f		 jbe	 SHORT $LN4@mg_queue_n

; 6398 :   MG_MEMORY_BARRIER();

  0003d	f0 09 14 24	 lock or DWORD PTR [rsp], edx

; 6399 :   memcpy(&n, q->buf + q->tail, sizeof(n));

  00041	49 8b 49 10	 mov	 rcx, QWORD PTR [r9+16]
  00045	49 8b 01	 mov	 rax, QWORD PTR [r9]

; 6400 :   assert(q->tail + n + sizeof(n) <= q->size);
; 6401 :   return n;

  00048	44 8b 14 01	 mov	 r10d, DWORD PTR [rcx+rax]
$LN4@mg_queue_n:

; 6430 :     }
; 6431 :   }
; 6432 :   if (buf != NULL) *buf = q->buf + q->tail + sizeof(uint32_t);

  0004c	4d 85 db	 test	 r11, r11
  0004f	74 0e		 je	 SHORT $LN5@mg_queue_n
  00051	49 8b 51 10	 mov	 rdx, QWORD PTR [r9+16]
  00055	48 83 c2 04	 add	 rdx, 4
  00059	49 03 11	 add	 rdx, QWORD PTR [r9]
  0005c	49 89 13	 mov	 QWORD PTR [r11], rdx
$LN5@mg_queue_n:

; 6433 :   assert(q->tail + len <= q->size);
; 6434 :   return len;

  0005f	49 8b c2	 mov	 rax, r10

; 6435 : }

  00062	c3		 ret	 0
mg_queue_next ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_queue_add
_TEXT	SEGMENT
q$ = 8
len$ = 16
mg_queue_add PROC					; COMDAT

; 6406 :   memcpy(q->buf + q->head, &n, sizeof(n));

  00000	4c 8b 41 18	 mov	 r8, QWORD PTR [rcx+24]
  00004	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00007	41 89 14 00	 mov	 DWORD PTR [r8+rax], edx

; 6407 :   MG_MEMORY_BARRIER();

  0000b	f0 83 0c 24 00	 lock or DWORD PTR [rsp], 0

; 6438 :   assert(len > 0);
; 6439 :   mg_queue_write_len(q, len);
; 6440 :   assert(q->head + sizeof(uint32_t) * 2 + len <= q->size);
; 6441 :   q->head += len + sizeof(uint32_t);

  00010	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00014	48 83 c2 04	 add	 rdx, 4
  00018	48 03 d0	 add	 rdx, rax
  0001b	48 89 51 18	 mov	 QWORD PTR [rcx+24], rdx

; 6442 : }

  0001f	c3		 ret	 0
mg_queue_add ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_queue_del
_TEXT	SEGMENT
q$ = 8
len$ = 16
mg_queue_del PROC					; COMDAT

; 6445 :   q->tail += len + sizeof(uint32_t);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 83 c2 04	 add	 rdx, 4
  00008	48 03 d0	 add	 rdx, rax
  0000b	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx

; 6446 :   assert(q->tail + sizeof(uint32_t) <= q->size);
; 6447 : }

  0000f	c3		 ret	 0
mg_queue_del ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_rpc_add
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
head$ = 80
method$ = 88
fn$ = 96
fn_data$ = 104
mg_rpc_add PROC						; COMDAT

; 6456 :                 void (*fn)(struct mg_rpc_req *), void *fn_data) {

$LN5:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	4c 8b f2	 mov	 r14, rdx
  0001c	48 8b f9	 mov	 rdi, rcx

; 6457 :   struct mg_rpc *rpc = (struct mg_rpc *) calloc(1, sizeof(*rpc));

  0001f	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00024	49 8b f1	 mov	 rsi, r9
  00027	49 8b e8	 mov	 rbp, r8
  0002a	8d 4a d9	 lea	 ecx, QWORD PTR [rdx-39]
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00033	48 8b d8	 mov	 rbx, rax

; 6458 :   if (rpc != NULL) {

  00036	48 85 c0	 test	 rax, rax
  00039	74 32		 je	 SHORT $LN2@mg_rpc_add

; 6459 :     rpc->method = mg_strdup(method), rpc->fn = fn, rpc->fn_data = fn_data;

  0003b	41 0f 10 06	 movups	 xmm0, XMMWORD PTR [r14]
  0003f	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00044	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  00049	f3 0f 7f 44 24
	20		 movdqu	 XMMWORD PTR $T1[rsp], xmm0
  0004f	e8 00 00 00 00	 call	 mg_strdup
  00054	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00057	48 89 6b 18	 mov	 QWORD PTR [rbx+24], rbp
  0005b	48 89 73 20	 mov	 QWORD PTR [rbx+32], rsi
  0005f	f3 0f 7f 43 08	 movdqu	 XMMWORD PTR [rbx+8], xmm0

; 6460 :     rpc->next = *head, *head = rpc;

  00064	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00067	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  0006a	48 89 1f	 mov	 QWORD PTR [rdi], rbx
$LN2@mg_rpc_add:

; 6461 :   }
; 6462 : }

  0006d	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00072	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00077	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0007c	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  00081	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00085	41 5e		 pop	 r14
  00087	c3		 ret	 0
mg_rpc_add ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_rpc_del
_TEXT	SEGMENT
head$ = 48
fn$ = 56
mg_rpc_del PROC						; COMDAT

; 6464 : void mg_rpc_del(struct mg_rpc **head, void (*fn)(struct mg_rpc_req *)) {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 6465 :   struct mg_rpc *r;
; 6466 :   while ((r = *head) != NULL) {

  0000f	48 8b 19	 mov	 rbx, QWORD PTR [rcx]
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b f9	 mov	 rdi, rcx
  00018	eb 2c		 jmp	 SHORT $LN11@mg_rpc_del
$LL2@mg_rpc_del:

; 6467 :     if (r->fn == fn || fn == NULL) {

  0001a	48 39 73 18	 cmp	 QWORD PTR [rbx+24], rsi
  0001e	74 0a		 je	 SHORT $LN6@mg_rpc_del
  00020	48 85 f6	 test	 rsi, rsi
  00023	74 05		 je	 SHORT $LN6@mg_rpc_del

; 6471 :     } else {
; 6472 :       head = &(*head)->next;

  00025	48 8b 3f	 mov	 rdi, QWORD PTR [rdi]
  00028	eb 19		 jmp	 SHORT $LN5@mg_rpc_del
$LN6@mg_rpc_del:

; 6468 :       *head = r->next;

  0002a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002d	48 89 07	 mov	 QWORD PTR [rdi], rax

; 6469 :       free((void *) r->method.ptr);

  00030	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6470 :       free(r);

  0003a	48 8b cb	 mov	 rcx, rbx
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@mg_rpc_del:

; 6465 :   struct mg_rpc *r;
; 6466 :   while ((r = *head) != NULL) {

  00043	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
$LN11@mg_rpc_del:
  00046	48 85 db	 test	 rbx, rbx
  00049	75 cf		 jne	 SHORT $LL2@mg_rpc_del

; 6473 :     }
; 6474 :   }
; 6475 : }

  0004b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00050	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
mg_rpc_del ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_rpc_call
_TEXT	SEGMENT
$T1 = 48
$T2 = 64
r$ = 96
method$ = 104
mg_rpc_call PROC					; COMDAT

; 6477 : static void mg_rpc_call(struct mg_rpc_req *r, struct mg_str method) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 6478 :   struct mg_rpc *h = r->head == NULL ? NULL : *r->head;

  0000f	48 8b 19	 mov	 rbx, QWORD PTR [rcx]
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b f9	 mov	 rdi, rcx
  00018	48 85 db	 test	 rbx, rbx
  0001b	75 56		 jne	 SHORT $LN15@mg_rpc_cal
$LN4@mg_rpc_cal:

; 6484 :     mg_rpc_err(r, -32601, "\"%.*s not found\"", (int) method.len, method.ptr);

  0001d	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00020	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BB@KBBHFJEB@?$CC?$CF?4?$CKs?5not?5found?$CC@
  00027	44 8b 4e 08	 mov	 r9d, DWORD PTR [rsi+8]
  0002b	ba a7 80 ff ff	 mov	 edx, -32601		; ffffffffffff80a7H
  00030	48 8b cf	 mov	 rcx, rdi
  00033	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00038	e8 00 00 00 00	 call	 mg_rpc_err
$LN5@mg_rpc_cal:

; 6485 :   }
; 6486 : }

  0003d	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00042	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00047	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
$LL2@mg_rpc_cal:

; 6479 :   while (h != NULL && !mg_match(method, h->method, NULL)) h = h->next;

  0004d	0f 10 43 08	 movups	 xmm0, XMMWORD PTR [rbx+8]
  00051	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  00056	0f 28 0e	 movaps	 xmm1, XMMWORD PTR [rsi]
  00059	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  0005e	f3 0f 7f 44 24
	30		 movdqu	 XMMWORD PTR $T1[rsp], xmm0
  00064	66 0f 7f 4c 24
	40		 movdqa	 XMMWORD PTR $T2[rsp], xmm1
  0006a	e8 00 00 00 00	 call	 mg_match
  0006f	84 c0		 test	 al, al
  00071	75 0a		 jne	 SHORT $LN13@mg_rpc_cal
$LN15@mg_rpc_cal:
  00073	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
  00076	48 85 db	 test	 rbx, rbx
  00079	75 d2		 jne	 SHORT $LL2@mg_rpc_cal
  0007b	eb a0		 jmp	 SHORT $LN4@mg_rpc_cal
$LN13@mg_rpc_cal:

; 6480 :   if (h != NULL) {
; 6481 :     r->rpc = h;
; 6482 :     h->fn(r);

  0007d	48 8b cf	 mov	 rcx, rdi
  00080	48 89 5f 08	 mov	 QWORD PTR [rdi+8], rbx
  00084	ff 53 18	 call	 QWORD PTR [rbx+24]

; 6483 :   } else {

  00087	eb b4		 jmp	 SHORT $LN5@mg_rpc_cal
mg_rpc_call ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_rpc_process
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
len$ = 80
r$ = 80
mg_rpc_process PROC					; COMDAT

; 6488 : void mg_rpc_process(struct mg_rpc_req *r) {

$LN18:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	48 8b ec	 mov	 rbp, rsp
  00009	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 6489 :   int len, off = mg_json_get(r->frame, "$.method", &len);

  0000d	0f 10 41 28	 movups	 xmm0, XMMWORD PTR [rcx+40]
  00011	48 8b d9	 mov	 rbx, rcx
  00014	4c 8d 45 10	 lea	 r8, QWORD PTR len$[rbp-64]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08CIJFEAAL@$?4method@
  0001f	48 8d 4d f0	 lea	 rcx, QWORD PTR $T5[rbp-64]
  00023	f3 0f 7f 45 f0	 movdqu	 XMMWORD PTR $T5[rbp-64], xmm0
  00028	e8 00 00 00 00	 call	 mg_json_get

; 6490 :   if (off > 0 && r->frame.ptr[off] == '"') {

  0002d	85 c0		 test	 eax, eax
  0002f	7e 27		 jle	 SHORT $LN15@mg_rpc_pro
  00031	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
  00035	48 63 c8	 movsxd	 rcx, eax
  00038	80 3c 11 22	 cmp	 BYTE PTR [rcx+rdx], 34	; 00000022H
  0003c	75 1a		 jne	 SHORT $LN15@mg_rpc_pro

; 6491 :     struct mg_str method = mg_str_n(&r->frame.ptr[off + 1], (size_t) len - 2);

  0003e	ff c0		 inc	 eax
  00040	48 63 c8	 movsxd	 rcx, eax
  00043	48 63 45 10	 movsxd	 rax, DWORD PTR len$[rbp-64]
  00047	48 03 ca	 add	 rcx, rdx
  0004a	48 83 e8 02	 sub	 rax, 2

; 6492 :     mg_rpc_call(r, method);

  0004e	48 89 4d f0	 mov	 QWORD PTR $T4[rbp-64], rcx
  00052	48 89 45 f8	 mov	 QWORD PTR $T4[rbp-56], rax
  00056	eb 7f		 jmp	 SHORT $LN16@mg_rpc_pro
$LN15@mg_rpc_pro:

; 6493 :   } else if ((off = mg_json_get(r->frame, "$.result", &len)) > 0 ||

  00058	0f 10 43 28	 movups	 xmm0, XMMWORD PTR [rbx+40]
  0005c	4c 8d 45 10	 lea	 r8, QWORD PTR len$[rbp-64]
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OBNEFDHG@$?4result@
  00067	48 8d 4d f0	 lea	 rcx, QWORD PTR $T3[rbp-64]
  0006b	f3 0f 7f 45 f0	 movdqu	 XMMWORD PTR $T3[rbp-64], xmm0
  00070	e8 00 00 00 00	 call	 mg_json_get
  00075	85 c0		 test	 eax, eax
  00077	7f 4e		 jg	 SHORT $LN6@mg_rpc_pro
  00079	0f 10 43 28	 movups	 xmm0, XMMWORD PTR [rbx+40]
  0007d	4c 8d 45 10	 lea	 r8, QWORD PTR len$[rbp-64]
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07DMPMNMMD@$?4error@
  00088	48 8d 4d f0	 lea	 rcx, QWORD PTR $T2[rbp-64]
  0008c	f3 0f 7f 45 f0	 movdqu	 XMMWORD PTR $T2[rbp-64], xmm0
  00091	e8 00 00 00 00	 call	 mg_json_get
  00096	85 c0		 test	 eax, eax
  00098	7f 2d		 jg	 SHORT $LN6@mg_rpc_pro

; 6496 :   } else {
; 6497 :     mg_rpc_err(r, -32700, "%m", mg_print_esc, (int) r->frame.len,

  0009a	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  0009e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:mg_print_esc
  000a5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02OOGLLHAM@?$CFm@
  000b1	8b 43 30	 mov	 eax, DWORD PTR [rbx+48]
  000b4	ba 44 80 ff ff	 mov	 edx, -32700		; ffffffffffff8044H
  000b9	48 8b cb	 mov	 rcx, rbx
  000bc	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000c0	e8 00 00 00 00	 call	 mg_rpc_err
  000c5	eb 1c		 jmp	 SHORT $LN5@mg_rpc_pro
$LN6@mg_rpc_pro:

; 6494 :              (off = mg_json_get(r->frame, "$.error", &len)) > 0) {
; 6495 :     mg_rpc_call(r, mg_str(""));  // JSON response! call "" method handler

  000c7	48 83 65 f8 00	 and	 QWORD PTR $T1[rbp-56], 0
  000cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
  000d3	48 89 45 f0	 mov	 QWORD PTR $T1[rbp-64], rax
$LN16@mg_rpc_pro:

; 6498 :                r->frame.ptr);  // Invalid
; 6499 :   }
; 6500 : }

  000d7	48 8d 55 f0	 lea	 rdx, QWORD PTR $T1[rbp-64]
  000db	48 8b cb	 mov	 rcx, rbx
  000de	e8 00 00 00 00	 call	 mg_rpc_call
$LN5@mg_rpc_pro:
  000e3	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000e8	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ec	5d		 pop	 rbp
  000ed	c3		 ret	 0
mg_rpc_process ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_rpc_vok
_TEXT	SEGMENT
len$ = 128
r$ = 128
fmt$ = 136
ap$ = 144
mg_rpc_vok PROC						; COMDAT

; 6502 : void mg_rpc_vok(struct mg_rpc_req *r, const char *fmt, va_list *ap) {

$LN5:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00007	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 6503 :   int len, off = mg_json_get(r->frame, "$.id", &len);

  00010	0f 10 41 28	 movups	 xmm0, XMMWORD PTR [rcx+40]
  00014	49 8b f0	 mov	 rsi, r8
  00017	48 8b fa	 mov	 rdi, rdx
  0001a	48 8b d9	 mov	 rbx, rcx
  0001d	4c 8d 40 08	 lea	 r8, QWORD PTR [rax+8]
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04LOGAHCH@$?4id@
  00028	48 8d 48 e8	 lea	 rcx, QWORD PTR [rax-24]
  0002c	f3 0f 7f 40 e8	 movdqu	 XMMWORD PTR [rax-24], xmm0
  00031	e8 00 00 00 00	 call	 mg_json_get

; 6504 :   if (off > 0) {

  00036	85 c0		 test	 eax, eax
  00038	0f 8e 8f 00 00
	00		 jle	 $LN2@mg_rpc_vok

; 6505 :     mg_xprintf(r->pfn, r->pfn_data, "{%m:%.*s,%m:", mg_print_esc, 0, "id", len,

  0003e	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06KJFADLGN@result@
  00049	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0004e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:mg_print_esc
  00055	48 83 64 24 48
	00		 and	 QWORD PTR [rsp+72], 0
  0005b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@PNCPKKEK@?$HL?$CFm?3?$CF?4?$CKs?0?$CFm?3@
  00062	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00066	4c 89 4c 24 40	 mov	 QWORD PTR [rsp+64], r9
  0006b	48 98		 cdqe
  0006d	48 03 43 28	 add	 rax, QWORD PTR [rbx+40]
  00071	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00076	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0007d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00081	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02EGCJHIOB@id@
  00088	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0008d	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00093	e8 00 00 00 00	 call	 mg_xprintf

; 6506 :                &r->frame.ptr[off], mg_print_esc, 0, "result");
; 6507 :     mg_vxprintf(r->pfn, r->pfn_data, fmt == NULL ? "null" : fmt, ap);

  00098	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  0009c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04MLLLIHIP@null@
  000a3	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  000a7	48 85 ff	 test	 rdi, rdi
  000aa	4c 8b ce	 mov	 r9, rsi
  000ad	48 0f 44 f8	 cmove	 rdi, rax
  000b1	4c 8b c7	 mov	 r8, rdi
  000b4	e8 00 00 00 00	 call	 mg_vxprintf

; 6508 :     mg_xprintf(r->pfn, r->pfn_data, "}");

  000b9	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  000bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01CELHOKLL@?$HN@
  000c4	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  000c8	e8 00 00 00 00	 call	 mg_xprintf
$LN2@mg_rpc_vok:

; 6509 :   }
; 6510 : }

  000cd	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  000d2	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  000d6	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  000da	49 8b e3	 mov	 rsp, r11
  000dd	5f		 pop	 rdi
  000de	c3		 ret	 0
mg_rpc_vok ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_rpc_ok
_TEXT	SEGMENT
r$ = 64
fmt$ = 72
mg_rpc_ok PROC						; COMDAT

; 6512 : void mg_rpc_ok(struct mg_rpc_req *r, const char *fmt, ...) {

$LN4:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 53 10	 mov	 QWORD PTR [r11+16], rdx
  00007	4d 89 43 18	 mov	 QWORD PTR [r11+24], r8
  0000b	4d 89 4b 20	 mov	 QWORD PTR [r11+32], r9
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6513 :   va_list ap;
; 6514 :   va_start(ap, fmt);

  00013	49 8d 43 18	 lea	 rax, QWORD PTR [r11+24]

; 6515 :   mg_rpc_vok(r, fmt, &ap);

  00017	4d 8d 43 e8	 lea	 r8, QWORD PTR [r11-24]
  0001b	49 89 43 e8	 mov	 QWORD PTR [r11-24], rax
  0001f	e8 00 00 00 00	 call	 mg_rpc_vok

; 6516 :   va_end(ap);
; 6517 : }

  00024	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00028	c3		 ret	 0
mg_rpc_ok ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_rpc_verr
_TEXT	SEGMENT
len$ = 160
r$ = 160
code$ = 168
fmt$ = 176
ap$ = 184
mg_rpc_verr PROC					; COMDAT

; 6519 : void mg_rpc_verr(struct mg_rpc_req *r, int code, const char *fmt, va_list *ap) {

$LN5:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00007	48 89 68 18	 mov	 QWORD PTR [rax+24], rbp
  0000b	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 56		 push	 r14
  00014	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 6520 :   int len, off = mg_json_get(r->frame, "$.id", &len);

  0001b	0f 10 41 28	 movups	 xmm0, XMMWORD PTR [rcx+40]
  0001f	49 8b f0	 mov	 rsi, r8
  00022	44 8b f2	 mov	 r14d, edx
  00025	48 8b d9	 mov	 rbx, rcx
  00028	4c 8d 40 08	 lea	 r8, QWORD PTR [rax+8]
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04LOGAHCH@$?4id@
  00033	49 8b e9	 mov	 rbp, r9
  00036	48 8d 48 d8	 lea	 rcx, QWORD PTR [rax-40]
  0003a	f3 0f 7f 40 d8	 movdqu	 XMMWORD PTR [rax-40], xmm0
  0003f	e8 00 00 00 00	 call	 mg_json_get

; 6521 :   mg_xprintf(r->pfn, r->pfn_data, "{");

  00044	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  00048	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01HCONENDN@?$HL@
  0004f	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00053	48 63 f8	 movsxd	 rdi, eax
  00056	e8 00 00 00 00	 call	 mg_xprintf

; 6522 :   if (off > 0) {

  0005b	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:mg_print_esc
  00062	85 ff		 test	 edi, edi
  00064	7e 40		 jle	 SHORT $LN2@mg_rpc_ver

; 6523 :     mg_xprintf(r->pfn, r->pfn_data, "%m:%.*s,", mg_print_esc, 0, "id", len,

  00066	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  0006a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08BPPEJENG@?$CFm?3?$CF?4?$CKs?0@
  00071	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00075	48 8b c7	 mov	 rax, rdi
  00078	48 03 43 28	 add	 rax, QWORD PTR [rbx+40]
  0007c	4d 8b cc	 mov	 r9, r12
  0007f	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00084	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0008b	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0008f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02EGCJHIOB@id@
  00096	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0009b	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  000a1	e8 00 00 00 00	 call	 mg_xprintf
$LN2@mg_rpc_ver:

; 6524 :                &r->frame.ptr[off]);
; 6525 :   }
; 6526 :   mg_xprintf(r->pfn, r->pfn_data, "%m:{%m:%d,%m:", mg_print_esc, 0, "error",

  000a6	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  000aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07ONPBMBOP@message@
  000b1	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  000b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@OFIPIANJ@?$CFm?3?$HL?$CFm?3?$CFd?0?$CFm?3@
  000bc	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  000c1	4d 8b cc	 mov	 r9, r12
  000c4	48 83 64 24 58
	00		 and	 QWORD PTR [rsp+88], 0
  000ca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04NDFOBODE@code@
  000d1	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  000d6	44 89 74 24 48	 mov	 DWORD PTR [rsp+72], r14d
  000db	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05KKCIMGE@error@
  000e7	48 83 64 24 38
	00		 and	 QWORD PTR [rsp+56], 0
  000ed	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  000f2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f7	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  000fd	e8 00 00 00 00	 call	 mg_xprintf

; 6527 :              mg_print_esc, 0, "code", code, mg_print_esc, 0, "message");
; 6528 :   mg_vxprintf(r->pfn, r->pfn_data, fmt == NULL ? "null" : fmt, ap);

  00102	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  00106	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04MLLLIHIP@null@
  0010d	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00111	48 85 f6	 test	 rsi, rsi
  00114	4c 8b cd	 mov	 r9, rbp
  00117	48 0f 44 f0	 cmove	 rsi, rax
  0011b	4c 8b c6	 mov	 r8, rsi
  0011e	e8 00 00 00 00	 call	 mg_vxprintf

; 6529 :   mg_xprintf(r->pfn, r->pfn_data, "}}");

  00123	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  00127	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02MGAGNKFF@?$HN?$HN@
  0012e	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]

; 6530 : }

  00132	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  0013a	49 8b 5b 28	 mov	 rbx, QWORD PTR [r11+40]
  0013e	49 8b 6b 30	 mov	 rbp, QWORD PTR [r11+48]
  00142	49 8b 73 38	 mov	 rsi, QWORD PTR [r11+56]
  00146	49 8b e3	 mov	 rsp, r11
  00149	41 5e		 pop	 r14
  0014b	41 5c		 pop	 r12
  0014d	5f		 pop	 rdi

; 6529 :   mg_xprintf(r->pfn, r->pfn_data, "}}");

  0014e	e9 00 00 00 00	 jmp	 mg_xprintf
mg_rpc_verr ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_rpc_err
_TEXT	SEGMENT
r$ = 64
code$ = 72
fmt$ = 80
mg_rpc_err PROC						; COMDAT

; 6532 : void mg_rpc_err(struct mg_rpc_req *r, int code, const char *fmt, ...) {

$LN4:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	4d 89 43 18	 mov	 QWORD PTR [r11+24], r8
  00007	4d 89 4b 20	 mov	 QWORD PTR [r11+32], r9
  0000b	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6533 :   va_list ap;
; 6534 :   va_start(ap, fmt);

  0000f	49 8d 43 20	 lea	 rax, QWORD PTR [r11+32]

; 6535 :   mg_rpc_verr(r, code, fmt, &ap);

  00013	4d 8d 4b e8	 lea	 r9, QWORD PTR [r11-24]
  00017	49 89 43 e8	 mov	 QWORD PTR [r11-24], rax
  0001b	e8 00 00 00 00	 call	 mg_rpc_verr

; 6536 :   va_end(ap);
; 6537 : }

  00020	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00024	c3		 ret	 0
mg_rpc_err ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT print_methods
_TEXT	SEGMENT
pfn$ = 80
pfn_data$ = 88
ap$ = 96
print_methods PROC					; COMDAT

; 6539 : static size_t print_methods(mg_pfn_t pfn, void *pfn_data, va_list *ap) {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 6540 :   struct mg_rpc *h, **head = (struct mg_rpc **) va_arg(*ap, void **);

  00019	4d 8b 08	 mov	 r9, QWORD PTR [r8]
  0001c	48 8b ea	 mov	 rbp, rdx
  0001f	4c 8b f1	 mov	 r14, rcx

; 6541 :   size_t len = 0;

  00022	33 ff		 xor	 edi, edi
  00024	49 8d 41 08	 lea	 rax, QWORD PTR [r9+8]
  00028	49 89 00	 mov	 QWORD PTR [r8], rax
  0002b	49 8b 31	 mov	 rsi, QWORD PTR [r9]

; 6542 :   for (h = *head; h != NULL; h = h->next) {

  0002e	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
  00031	eb 50		 jmp	 SHORT $LN11@print_meth
$LL4@print_meth:

; 6543 :     if (h->method.len == 0) continue;  // Ignore response handler

  00033	48 83 7b 10 00	 cmp	 QWORD PTR [rbx+16], 0
  00038	74 46		 je	 SHORT $LN2@print_meth

; 6544 :     len += mg_xprintf(pfn, pfn_data, "%s%m", h == *head ? "" : ",",

  0003a	48 3b 1e	 cmp	 rbx, QWORD PTR [rsi]
  0003d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
  00044	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01IHBHIGKO@?0@
  0004b	48 8b d5	 mov	 rdx, rbp
  0004e	4c 0f 44 c8	 cmove	 r9, rax
  00052	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04KHKDDGAF@?$CFs?$CFm@
  00059	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0005d	49 8b ce	 mov	 rcx, r14
  00060	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00065	8b 43 10	 mov	 eax, DWORD PTR [rbx+16]
  00068	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0006c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:mg_print_esc
  00073	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00078	e8 00 00 00 00	 call	 mg_xprintf
  0007d	48 03 f8	 add	 rdi, rax
$LN2@print_meth:

; 6542 :   for (h = *head; h != NULL; h = h->next) {

  00080	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN11@print_meth:
  00083	48 85 db	 test	 rbx, rbx
  00086	75 ab		 jne	 SHORT $LL4@print_meth

; 6545 :                       mg_print_esc, (int) h->method.len, h->method.ptr);
; 6546 :   }
; 6547 :   return len;
; 6548 : }

  00088	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0008d	48 8b c7	 mov	 rax, rdi
  00090	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  00095	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  0009a	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0009f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000a3	41 5e		 pop	 r14
  000a5	c3		 ret	 0
print_methods ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_rpc_list
_TEXT	SEGMENT
r$ = 8
mg_rpc_list PROC					; COMDAT

; 6551 :   mg_rpc_ok(r, "[%M]", print_methods, r->head);

  00000	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00003	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:print_methods
  0000a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04JGKFJELO@?$FL?$CFM?$FN@
  00011	e9 00 00 00 00	 jmp	 mg_rpc_ok
mg_rpc_list ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT blk0
_TEXT	SEGMENT
block$ = 8
i$ = 16
blk0	PROC						; COMDAT

; 6570 :   if (MG_BIG_ENDIAN) {
; 6571 :   } else {
; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00000	4c 63 c2	 movsxd	 r8, edx
  00003	42 8b 14 81	 mov	 edx, DWORD PTR [rcx+r8*4]
  00007	8b c2		 mov	 eax, edx
  00009	c1 c8 08	 ror	 eax, 8
  0000c	c1 c2 08	 rol	 edx, 8
  0000f	25 00 ff 00 ff	 and	 eax, -16711936		; ff00ff00H
  00014	81 e2 ff 00 ff
	00		 and	 edx, 16711935		; 00ff00ffH
  0001a	0b c2		 or	 eax, edx
  0001c	42 89 04 81	 mov	 DWORD PTR [rcx+r8*4], eax

; 6573 :                   (rol(block->l[i], 8) & 0x00FF00FF);
; 6574 :   }
; 6575 :   return block->l[i];
; 6576 : }

  00020	c3		 ret	 0
blk0	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_sha1_transform
_TEXT	SEGMENT
tv5375 = 0
tv5347 = 0
tv5339 = 0
tv5329 = 0
tv5313 = 0
tv5352 = 4
tv5331 = 4
tv5315 = 4
tv5359 = 8
tv5334 = 8
tv5318 = 8
tv5379 = 12
tv5345 = 12
tv5342 = 12
tv5325 = 12
tv5307 = 12
tv5376 = 16
tv5344 = 16
tv5336 = 16
tv5320 = 16
tv5382 = 20
tv5341 = 20
tv5330 = 20
tv5312 = 20
tv5370 = 24
tv5343 = 24
tv5328 = 24
tv5314 = 24
tv5369 = 28
tv5337 = 28
tv5321 = 28
tv5384 = 32
tv5346 = 32
tv5326 = 32
tv5380 = 36
tv5340 = 36
tv5324 = 36
tv5308 = 36
tv5374 = 40
tv5355 = 40
tv5322 = 40
tv5306 = 40
tv5338 = 44
tv5323 = 44
tv5378 = 48
tv5327 = 48
tv5310 = 48
tv5319 = 52
state$ = 144
tv5349 = 152
tv5317 = 152
buffer$ = 152
tv5353 = 160
tv5316 = 160
tv5356 = 168
tv5335 = 168
tv5311 = 168
mg_sha1_transform PROC					; COMDAT

; 6607 :                               const unsigned char *buffer) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 6608 :   uint32_t a, b, c, d, e;
; 6609 :   union char64long16 block[1];
; 6610 : 
; 6611 :   memcpy(block, buffer, 64);

  00015	0f 10 0a	 movups	 xmm1, XMMWORD PTR [rdx]

; 6614 :   c = state[2];
; 6615 :   d = state[3];

  00018	44 8b 59 0c	 mov	 r11d, DWORD PTR [rcx+12]
  0001c	48 8b f9	 mov	 rdi, rcx
  0001f	8b 59 08	 mov	 ebx, DWORD PTR [rcx+8]

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00022	41 be 00 ff 00
	ff		 mov	 r14d, -16711936		; ff00ff00H

; 6612 :   a = state[0];
; 6613 :   b = state[1];

  00028	44 8b 41 04	 mov	 r8d, DWORD PTR [rcx+4]

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0002c	66 48 0f 7e c8	 movq	 rax, xmm1

; 6616 :   e = state[4];

  00031	44 8b 49 10	 mov	 r9d, DWORD PTR [rcx+16]

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00035	bd ff 00 ff 00	 mov	 ebp, 16711935		; 00ff00ffH

; 6608 :   uint32_t a, b, c, d, e;
; 6609 :   union char64long16 block[1];
; 6610 : 
; 6611 :   memcpy(block, buffer, 64);

  0003a	0f 10 52 10	 movups	 xmm2, XMMWORD PTR [rdx+16]

; 6617 :   R0(a, b, c, d, e, 0);

  0003e	41 81 c1 99 79
	82 5a		 add	 r9d, 1518500249		; 5a827999H
  00045	45 8b d3	 mov	 r10d, r11d
  00048	0f 10 5a 20	 movups	 xmm3, XMMWORD PTR [rdx+32]
  0004c	44 33 d3	 xor	 r10d, ebx
  0004f	0f 10 62 30	 movups	 xmm4, XMMWORD PTR [rdx+48]

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00053	8b d0		 mov	 edx, eax

; 6617 :   R0(a, b, c, d, e, 0);

  00055	45 23 d0	 and	 r10d, r8d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00058	c1 c0 08	 rol	 eax, 8

; 6617 :   R0(a, b, c, d, e, 0);

  0005b	45 33 d3	 xor	 r10d, r11d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0005e	23 c5		 and	 eax, ebp
  00060	c1 ca 08	 ror	 edx, 8
  00063	41 23 d6	 and	 edx, r14d

; 6617 :   R0(a, b, c, d, e, 0);

  00066	41 c1 c8 02	 ror	 r8d, 2

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0006a	0b d0		 or	 edx, eax
  0006c	66 0f 6f c1	 movdqa	 xmm0, xmm1

; 6617 :   R0(a, b, c, d, e, 0);

  00070	8b 01		 mov	 eax, DWORD PTR [rcx]

; 6618 :   R0(e, a, b, c, d, 1);

  00072	41 81 c3 99 79
	82 5a		 add	 r11d, 1518500249	; 5a827999H
  00079	c1 c0 05	 rol	 eax, 5
  0007c	8b cb		 mov	 ecx, ebx
  0007e	03 c2		 add	 eax, edx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00080	89 54 24 08	 mov	 DWORD PTR tv5359[rsp], edx

; 6617 :   R0(a, b, c, d, e, 0);

  00084	44 03 d0	 add	 r10d, eax

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00087	66 0f 73 d8 04	 psrldq	 xmm0, 4

; 6617 :   R0(a, b, c, d, e, 0);

  0008c	45 03 d1	 add	 r10d, r9d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0008f	66 0f 7e c0	 movd	 eax, xmm0

; 6618 :   R0(e, a, b, c, d, 1);

  00093	41 33 c8	 xor	 ecx, r8d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00096	66 0f 6f c1	 movdqa	 xmm0, xmm1

; 6618 :   R0(e, a, b, c, d, 1);

  0009a	23 0f		 and	 ecx, DWORD PTR [rdi]

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0009c	8b d0		 mov	 edx, eax
  0009e	66 0f 73 d8 08	 psrldq	 xmm0, 8
  000a3	c1 c0 08	 rol	 eax, 8

; 6618 :   R0(e, a, b, c, d, 1);

  000a6	33 cb		 xor	 ecx, ebx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  000a8	23 c5		 and	 eax, ebp
  000aa	c1 ca 08	 ror	 edx, 8
  000ad	41 23 d6	 and	 edx, r14d
  000b0	66 0f 73 d9 0c	 psrldq	 xmm1, 12
  000b5	0b d0		 or	 edx, eax

; 6619 :   R0(d, e, a, b, c, 2);

  000b7	81 c3 99 79 82
	5a		 add	 ebx, 1518500249		; 5a827999H
  000bd	41 8b c2	 mov	 eax, r10d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  000c0	89 54 24 30	 mov	 DWORD PTR tv5378[rsp], edx

; 6618 :   R0(e, a, b, c, d, 1);

  000c4	c1 c0 05	 rol	 eax, 5
  000c7	03 c2		 add	 eax, edx
  000c9	8b 17		 mov	 edx, DWORD PTR [rdi]
  000cb	03 c8		 add	 ecx, eax
  000cd	c1 ca 02	 ror	 edx, 2
  000d0	44 03 d9	 add	 r11d, ecx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  000d3	66 48 0f 7e c0	 movq	 rax, xmm0
  000d8	44 8b c8	 mov	 r9d, eax

; 6619 :   R0(d, e, a, b, c, 2);

  000db	41 8b c8	 mov	 ecx, r8d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  000de	c1 c0 08	 rol	 eax, 8

; 6619 :   R0(d, e, a, b, c, 2);

  000e1	33 ca		 xor	 ecx, edx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  000e3	23 c5		 and	 eax, ebp
  000e5	41 c1 c9 08	 ror	 r9d, 8
  000e9	45 23 ce	 and	 r9d, r14d

; 6619 :   R0(d, e, a, b, c, 2);

  000ec	41 23 ca	 and	 ecx, r10d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  000ef	44 0b c8	 or	 r9d, eax

; 6619 :   R0(d, e, a, b, c, 2);

  000f2	41 c1 ca 02	 ror	 r10d, 2

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  000f6	44 89 4c 24 28	 mov	 DWORD PTR tv5374[rsp], r9d

; 6619 :   R0(d, e, a, b, c, 2);

  000fb	41 33 c8	 xor	 ecx, r8d
  000fe	41 8b c3	 mov	 eax, r11d
  00101	c1 c0 05	 rol	 eax, 5
  00104	41 03 c1	 add	 eax, r9d
  00107	03 c8		 add	 ecx, eax

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00109	66 0f 7e c8	 movd	 eax, xmm1

; 6619 :   R0(d, e, a, b, c, 2);

  0010d	03 d9		 add	 ebx, ecx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0010f	44 8b c8	 mov	 r9d, eax
  00112	c1 c0 08	 rol	 eax, 8
  00115	41 c1 c9 08	 ror	 r9d, 8
  00119	23 c5		 and	 eax, ebp
  0011b	45 23 ce	 and	 r9d, r14d
  0011e	44 0b c8	 or	 r9d, eax

; 6620 :   R0(c, d, e, a, b, 3);

  00121	41 81 c0 99 79
	82 5a		 add	 r8d, 1518500249		; 5a827999H

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00128	44 89 8c 24 a8
	00 00 00	 mov	 DWORD PTR tv5356[rsp], r9d

; 6620 :   R0(c, d, e, a, b, 3);

  00130	8b c3		 mov	 eax, ebx
  00132	41 8b ca	 mov	 ecx, r10d
  00135	33 ca		 xor	 ecx, edx
  00137	c1 c0 05	 rol	 eax, 5
  0013a	44 03 c8	 add	 r9d, eax
  0013d	41 23 cb	 and	 ecx, r11d
  00140	33 ca		 xor	 ecx, edx
  00142	41 c1 cb 02	 ror	 r11d, 2
  00146	44 03 c9	 add	 r9d, ecx

; 6621 :   R0(b, c, d, e, a, 4);

  00149	81 c2 99 79 82
	5a		 add	 edx, 1518500249		; 5a827999H
  0014f	45 03 c8	 add	 r9d, r8d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00152	66 48 0f 7e d0	 movq	 rax, xmm2
  00157	44 8b c0	 mov	 r8d, eax

; 6621 :   R0(b, c, d, e, a, 4);

  0015a	41 8b ca	 mov	 ecx, r10d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0015d	c1 c0 08	 rol	 eax, 8

; 6621 :   R0(b, c, d, e, a, 4);

  00160	41 33 cb	 xor	 ecx, r11d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00163	23 c5		 and	 eax, ebp
  00165	41 c1 c8 08	 ror	 r8d, 8

; 6621 :   R0(b, c, d, e, a, 4);

  00169	23 cb		 and	 ecx, ebx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0016b	45 23 c6	 and	 r8d, r14d
  0016e	44 0b c0	 or	 r8d, eax

; 6621 :   R0(b, c, d, e, a, 4);

  00171	c1 cb 02	 ror	 ebx, 2
  00174	41 33 ca	 xor	 ecx, r10d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00177	44 89 44 24 0c	 mov	 DWORD PTR tv5379[rsp], r8d

; 6621 :   R0(b, c, d, e, a, 4);

  0017c	41 8b c1	 mov	 eax, r9d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0017f	66 0f 6f c2	 movdqa	 xmm0, xmm2

; 6621 :   R0(b, c, d, e, a, 4);

  00183	c1 c0 05	 rol	 eax, 5
  00186	44 03 c0	 add	 r8d, eax

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00189	66 0f 73 d8 04	 psrldq	 xmm0, 4

; 6621 :   R0(b, c, d, e, a, 4);

  0018e	44 03 c1	 add	 r8d, ecx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00191	66 0f 7e c0	 movd	 eax, xmm0

; 6621 :   R0(b, c, d, e, a, 4);

  00195	44 03 c2	 add	 r8d, edx

; 6622 :   R0(a, b, c, d, e, 5);

  00198	41 8b cb	 mov	 ecx, r11d
  0019b	33 cb		 xor	 ecx, ebx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0019d	66 0f 6f c2	 movdqa	 xmm0, xmm2
  001a1	8b d0		 mov	 edx, eax
  001a3	66 0f 73 d8 08	 psrldq	 xmm0, 8
  001a8	c1 c0 08	 rol	 eax, 8

; 6622 :   R0(a, b, c, d, e, 5);

  001ab	41 23 c9	 and	 ecx, r9d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  001ae	23 c5		 and	 eax, ebp
  001b0	c1 ca 08	 ror	 edx, 8
  001b3	41 23 d6	 and	 edx, r14d

; 6622 :   R0(a, b, c, d, e, 5);

  001b6	41 c1 c9 02	 ror	 r9d, 2

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  001ba	0b d0		 or	 edx, eax
  001bc	66 0f 73 da 0c	 psrldq	 xmm2, 12
  001c1	89 54 24 20	 mov	 DWORD PTR tv5384[rsp], edx

; 6622 :   R0(a, b, c, d, e, 5);

  001c5	41 33 cb	 xor	 ecx, r11d
  001c8	81 c2 99 79 82
	5a		 add	 edx, 1518500249		; 5a827999H
  001ce	41 8b c0	 mov	 eax, r8d
  001d1	c1 c0 05	 rol	 eax, 5
  001d4	03 c2		 add	 eax, edx
  001d6	03 c8		 add	 ecx, eax

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  001d8	66 48 0f 7e c0	 movq	 rax, xmm0
  001dd	8b d0		 mov	 edx, eax

; 6622 :   R0(a, b, c, d, e, 5);

  001df	44 03 d1	 add	 r10d, ecx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  001e2	c1 c0 08	 rol	 eax, 8

; 6623 :   R0(e, a, b, c, d, 6);

  001e5	8b cb		 mov	 ecx, ebx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  001e7	23 c5		 and	 eax, ebp
  001e9	c1 ca 08	 ror	 edx, 8
  001ec	41 23 d6	 and	 edx, r14d

; 6623 :   R0(e, a, b, c, d, 6);

  001ef	41 33 c9	 xor	 ecx, r9d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  001f2	0b d0		 or	 edx, eax

; 6623 :   R0(e, a, b, c, d, 6);

  001f4	41 23 c8	 and	 ecx, r8d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  001f7	89 94 24 a0 00
	00 00		 mov	 DWORD PTR tv5353[rsp], edx

; 6623 :   R0(e, a, b, c, d, 6);

  001fe	33 cb		 xor	 ecx, ebx
  00200	81 c2 99 79 82
	5a		 add	 edx, 1518500249		; 5a827999H
  00206	41 c1 c8 02	 ror	 r8d, 2
  0020a	41 8b c2	 mov	 eax, r10d
  0020d	c1 c0 05	 rol	 eax, 5
  00210	03 c2		 add	 eax, edx
  00212	03 c8		 add	 ecx, eax

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00214	66 0f 7e d0	 movd	 eax, xmm2

; 6623 :   R0(e, a, b, c, d, 6);

  00218	44 03 d9	 add	 r11d, ecx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0021b	8b d0		 mov	 edx, eax
  0021d	c1 c0 08	 rol	 eax, 8
  00220	c1 ca 08	 ror	 edx, 8
  00223	23 c5		 and	 eax, ebp
  00225	41 23 d6	 and	 edx, r14d
  00228	0b d0		 or	 edx, eax

; 6624 :   R0(d, e, a, b, c, 7);

  0022a	41 8b c9	 mov	 ecx, r9d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0022d	89 54 24 04	 mov	 DWORD PTR tv5352[rsp], edx

; 6624 :   R0(d, e, a, b, c, 7);

  00231	41 33 c8	 xor	 ecx, r8d
  00234	81 c3 99 79 82
	5a		 add	 ebx, 1518500249		; 5a827999H
  0023a	41 23 ca	 and	 ecx, r10d
  0023d	41 8b c3	 mov	 eax, r11d
  00240	c1 c0 05	 rol	 eax, 5
  00243	41 33 c9	 xor	 ecx, r9d
  00246	03 d0		 add	 edx, eax
  00248	41 c1 ca 02	 ror	 r10d, 2

; 6625 :   R0(c, d, e, a, b, 8);

  0024c	41 81 c1 99 79
	82 5a		 add	 r9d, 1518500249		; 5a827999H

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00253	66 0f 7e d8	 movd	 eax, xmm3

; 6624 :   R0(d, e, a, b, c, 7);

  00257	03 d1		 add	 edx, ecx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00259	66 0f 6f c3	 movdqa	 xmm0, xmm3

; 6624 :   R0(d, e, a, b, c, 7);

  0025d	03 d3		 add	 edx, ebx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0025f	66 0f 73 d8 04	 psrldq	 xmm0, 4
  00264	44 8b f8	 mov	 r15d, eax

; 6625 :   R0(c, d, e, a, b, 8);

  00267	41 8b da	 mov	 ebx, r10d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0026a	c1 c0 08	 rol	 eax, 8

; 6625 :   R0(c, d, e, a, b, 8);

  0026d	41 33 d8	 xor	 ebx, r8d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00270	23 c5		 and	 eax, ebp
  00272	41 c1 cf 08	 ror	 r15d, 8

; 6625 :   R0(c, d, e, a, b, 8);

  00276	41 23 db	 and	 ebx, r11d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00279	45 23 fe	 and	 r15d, r14d
  0027c	44 0b f8	 or	 r15d, eax

; 6625 :   R0(c, d, e, a, b, 8);

  0027f	41 c1 cb 02	 ror	 r11d, 2
  00283	41 33 d8	 xor	 ebx, r8d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00286	44 89 7c 24 24	 mov	 DWORD PTR tv5380[rsp], r15d

; 6625 :   R0(c, d, e, a, b, 8);

  0028b	8b c2		 mov	 eax, edx

; 6626 :   R0(b, c, d, e, a, 9);

  0028d	41 81 c0 99 79
	82 5a		 add	 r8d, 1518500249		; 5a827999H
  00294	c1 c0 05	 rol	 eax, 5
  00297	41 8b ca	 mov	 ecx, r10d
  0029a	41 03 c7	 add	 eax, r15d
  0029d	41 33 cb	 xor	 ecx, r11d
  002a0	03 d8		 add	 ebx, eax
  002a2	23 ca		 and	 ecx, edx
  002a4	41 03 d9	 add	 ebx, r9d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  002a7	66 0f 7e c0	 movd	 eax, xmm0
  002ab	66 0f 6f c3	 movdqa	 xmm0, xmm3

; 6626 :   R0(b, c, d, e, a, 9);

  002af	c1 ca 02	 ror	 edx, 2
  002b2	41 33 ca	 xor	 ecx, r10d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  002b5	66 0f 73 d8 08	 psrldq	 xmm0, 8
  002ba	44 8b c8	 mov	 r9d, eax
  002bd	66 0f 73 db 0c	 psrldq	 xmm3, 12
  002c2	c1 c0 08	 rol	 eax, 8

; 6627 :   R0(a, b, c, d, e, 10);

  002c5	41 8b fb	 mov	 edi, r11d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  002c8	23 c5		 and	 eax, ebp
  002ca	41 c1 c9 08	 ror	 r9d, 8
  002ce	45 23 ce	 and	 r9d, r14d

; 6627 :   R0(a, b, c, d, e, 10);

  002d1	33 fa		 xor	 edi, edx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  002d3	44 0b c8	 or	 r9d, eax

; 6627 :   R0(a, b, c, d, e, 10);

  002d6	23 fb		 and	 edi, ebx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  002d8	44 89 0c 24	 mov	 DWORD PTR tv5375[rsp], r9d

; 6627 :   R0(a, b, c, d, e, 10);

  002dc	41 33 fb	 xor	 edi, r11d
  002df	8b c3		 mov	 eax, ebx
  002e1	c1 cb 02	 ror	 ebx, 2
  002e4	c1 c0 05	 rol	 eax, 5
  002e7	41 03 c1	 add	 eax, r9d
  002ea	03 c8		 add	 ecx, eax

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  002ec	66 0f 7e c0	 movd	 eax, xmm0

; 6626 :   R0(b, c, d, e, a, 9);

  002f0	44 03 c1	 add	 r8d, ecx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  002f3	44 8b c8	 mov	 r9d, eax
  002f6	c1 c0 08	 rol	 eax, 8
  002f9	23 c5		 and	 eax, ebp
  002fb	41 c1 c9 08	 ror	 r9d, 8
  002ff	45 23 ce	 and	 r9d, r14d
  00302	44 0b c8	 or	 r9d, eax

; 6627 :   R0(a, b, c, d, e, 10);

  00305	41 8b c0	 mov	 eax, r8d
  00308	c1 c0 05	 rol	 eax, 5

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0030b	44 89 8c 24 98
	00 00 00	 mov	 DWORD PTR tv5349[rsp], r9d

; 6627 :   R0(a, b, c, d, e, 10);

  00313	41 81 c1 99 79
	82 5a		 add	 r9d, 1518500249		; 5a827999H
  0031a	41 03 c1	 add	 eax, r9d
  0031d	03 f8		 add	 edi, eax

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0031f	66 0f 7e d8	 movd	 eax, xmm3

; 6627 :   R0(a, b, c, d, e, 10);

  00323	41 03 fa	 add	 edi, r10d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00326	8b f0		 mov	 esi, eax
  00328	c1 c0 08	 rol	 eax, 8
  0032b	c1 ce 08	 ror	 esi, 8
  0032e	23 c5		 and	 eax, ebp
  00330	41 23 f6	 and	 esi, r14d
  00333	0b f0		 or	 esi, eax

; 6628 :   R0(e, a, b, c, d, 11);

  00335	44 8b ca	 mov	 r9d, edx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00338	89 74 24 10	 mov	 DWORD PTR tv5376[rsp], esi

; 6628 :   R0(e, a, b, c, d, 11);

  0033c	44 33 cb	 xor	 r9d, ebx

; 6629 :   R0(d, e, a, b, c, 12);

  0033f	44 8b d3	 mov	 r10d, ebx
  00342	45 23 c8	 and	 r9d, r8d
  00345	8b c7		 mov	 eax, edi
  00347	c1 c0 05	 rol	 eax, 5
  0034a	44 33 ca	 xor	 r9d, edx
  0034d	05 99 79 82 5a	 add	 eax, 1518500249		; 5a827999H
  00352	41 c1 c8 02	 ror	 r8d, 2
  00356	03 c6		 add	 eax, esi
  00358	45 33 d0	 xor	 r10d, r8d
  0035b	44 03 c8	 add	 r9d, eax
  0035e	44 23 d7	 and	 r10d, edi
  00361	45 03 cb	 add	 r9d, r11d
  00364	c1 cf 02	 ror	 edi, 2
  00367	44 33 d3	 xor	 r10d, ebx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0036a	66 0f 7e e0	 movd	 eax, xmm4

; 6630 :   R0(c, d, e, a, b, 13);

  0036e	81 c3 99 79 82
	5a		 add	 ebx, 1518500249		; 5a827999H

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00374	66 0f 6f c4	 movdqa	 xmm0, xmm4
  00378	66 0f 73 d8 04	 psrldq	 xmm0, 4

; 6630 :   R0(c, d, e, a, b, 13);

  0037d	44 8b df	 mov	 r11d, edi

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00380	44 8b e8	 mov	 r13d, eax

; 6630 :   R0(c, d, e, a, b, 13);

  00383	45 33 d8	 xor	 r11d, r8d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00386	c1 c0 08	 rol	 eax, 8

; 6630 :   R0(c, d, e, a, b, 13);

  00389	45 23 d9	 and	 r11d, r9d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0038c	23 c5		 and	 eax, ebp
  0038e	41 c1 cd 08	 ror	 r13d, 8
  00392	45 23 ee	 and	 r13d, r14d

; 6630 :   R0(c, d, e, a, b, 13);

  00395	45 33 d8	 xor	 r11d, r8d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00398	44 0b e8	 or	 r13d, eax

; 6631 :   R0(b, c, d, e, a, 14);

  0039b	41 81 c0 99 79
	82 5a		 add	 r8d, 1518500249		; 5a827999H
  003a2	41 8b c1	 mov	 eax, r9d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  003a5	44 89 6c 24 1c	 mov	 DWORD PTR tv5369[rsp], r13d

; 6629 :   R0(d, e, a, b, c, 12);

  003aa	c1 c0 05	 rol	 eax, 5
  003ad	05 99 79 82 5a	 add	 eax, 1518500249		; 5a827999H

; 6630 :   R0(c, d, e, a, b, 13);

  003b2	41 c1 c9 02	 ror	 r9d, 2
  003b6	41 03 c5	 add	 eax, r13d
  003b9	44 03 d0	 add	 r10d, eax

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  003bc	66 0f 7e c0	 movd	 eax, xmm0

; 6629 :   R0(d, e, a, b, c, 12);

  003c0	44 03 d2	 add	 r10d, edx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  003c3	66 0f 6f c4	 movdqa	 xmm0, xmm4
  003c7	66 0f 73 d8 08	 psrldq	 xmm0, 8

; 6631 :   R0(b, c, d, e, a, 14);

  003cc	8b d7		 mov	 edx, edi

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  003ce	44 8b e0	 mov	 r12d, eax
  003d1	66 0f 73 dc 0c	 psrldq	 xmm4, 12
  003d6	c1 c0 08	 rol	 eax, 8

; 6631 :   R0(b, c, d, e, a, 14);

  003d9	41 33 d1	 xor	 edx, r9d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  003dc	23 c5		 and	 eax, ebp
  003de	41 c1 cc 08	 ror	 r12d, 8
  003e2	45 23 e6	 and	 r12d, r14d

; 6631 :   R0(b, c, d, e, a, 14);

  003e5	41 23 d2	 and	 edx, r10d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  003e8	44 0b e0	 or	 r12d, eax

; 6631 :   R0(b, c, d, e, a, 14);

  003eb	33 d7		 xor	 edx, edi
  003ed	41 8b c2	 mov	 eax, r10d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  003f0	44 89 64 24 18	 mov	 DWORD PTR tv5370[rsp], r12d

; 6630 :   R0(c, d, e, a, b, 13);

  003f5	c1 c0 05	 rol	 eax, 5
  003f8	41 03 c4	 add	 eax, r12d

; 6631 :   R0(b, c, d, e, a, 14);

  003fb	41 c1 ca 02	 ror	 r10d, 2
  003ff	44 03 d8	 add	 r11d, eax

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00402	66 0f 7e c0	 movd	 eax, xmm0

; 6630 :   R0(c, d, e, a, b, 13);

  00406	44 03 db	 add	 r11d, ebx

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00409	bb 00 ff 00 ff	 mov	 ebx, -16711936		; ff00ff00H
  0040e	44 8b f0	 mov	 r14d, eax
  00411	c1 c0 08	 rol	 eax, 8
  00414	23 c5		 and	 eax, ebp
  00416	41 c1 ce 08	 ror	 r14d, 8
  0041a	44 23 f3	 and	 r14d, ebx
  0041d	44 0b f0	 or	 r14d, eax

; 6631 :   R0(b, c, d, e, a, 14);

  00420	41 8b c3	 mov	 eax, r11d
  00423	c1 c0 05	 rol	 eax, 5
  00426	41 03 c6	 add	 eax, r14d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00429	44 89 74 24 14	 mov	 DWORD PTR tv5382[rsp], r14d

; 6631 :   R0(b, c, d, e, a, 14);

  0042e	03 d0		 add	 edx, eax

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00430	66 0f 7e e0	 movd	 eax, xmm4

; 6631 :   R0(b, c, d, e, a, 14);

  00434	41 03 d0	 add	 edx, r8d

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  00437	8b e8		 mov	 ebp, eax
  00439	c1 c0 08	 rol	 eax, 8
  0043c	c1 cd 08	 ror	 ebp, 8
  0043f	23 eb		 and	 ebp, ebx
  00441	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH

; 6632 :   R0(a, b, c, d, e, 15);
; 6633 :   R1(e, a, b, c, d, 16);

  00446	8b 5c 24 08	 mov	 ebx, DWORD PTR tv5359[rsp]

; 6572 :     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |

  0044a	0b e8		 or	 ebp, eax

; 6632 :   R0(a, b, c, d, e, 15);
; 6633 :   R1(e, a, b, c, d, 16);

  0044c	41 33 df	 xor	 ebx, r15d
  0044f	8b c2		 mov	 eax, edx
  00451	33 5c 24 28	 xor	 ebx, DWORD PTR tv5374[rsp]
  00455	45 8b c1	 mov	 r8d, r9d

; 6634 :   R1(d, e, a, b, c, 17);

  00458	44 8b bc 24 a8
	00 00 00	 mov	 r15d, DWORD PTR tv5356[rsp]
  00460	45 33 c2	 xor	 r8d, r10d
  00463	44 33 7c 24 30	 xor	 r15d, DWORD PTR tv5378[rsp]
  00468	41 33 dc	 xor	 ebx, r12d
  0046b	c1 c0 05	 rol	 eax, 5
  0046e	45 23 c3	 and	 r8d, r11d
  00471	05 99 79 82 5a	 add	 eax, 1518500249		; 5a827999H
  00476	d1 c3		 rol	 ebx, 1
  00478	03 c5		 add	 eax, ebp
  0047a	89 5c 24 08	 mov	 DWORD PTR tv5359[rsp], ebx
  0047e	81 c3 99 79 82
	5a		 add	 ebx, 1518500249		; 5a827999H
  00484	41 c1 cb 02	 ror	 r11d, 2
  00488	45 33 c1	 xor	 r8d, r9d
  0048b	41 8b ca	 mov	 ecx, r10d
  0048e	41 33 cb	 xor	 ecx, r11d
  00491	44 03 c0	 add	 r8d, eax
  00494	23 ca		 and	 ecx, edx
  00496	44 03 c7	 add	 r8d, edi

; 6635 :   R1(c, d, e, a, b, 18);
; 6636 :   R1(b, c, d, e, a, 19);

  00499	8b bc 24 a8 00
	00 00		 mov	 edi, DWORD PTR tv5356[rsp]
  004a0	41 33 ca	 xor	 ecx, r10d
  004a3	33 7c 24 08	 xor	 edi, DWORD PTR tv5359[rsp]
  004a7	45 33 fe	 xor	 r15d, r14d
  004aa	33 7c 24 20	 xor	 edi, DWORD PTR tv5384[rsp]
  004ae	41 8b c0	 mov	 eax, r8d
  004b1	44 33 3c 24	 xor	 r15d, DWORD PTR tv5375[rsp]
  004b5	33 fe		 xor	 edi, esi
  004b7	c1 c0 05	 rol	 eax, 5
  004ba	03 c3		 add	 eax, ebx
  004bc	c1 ca 02	 ror	 edx, 2
  004bf	8b 9c 24 98 00
	00 00		 mov	 ebx, DWORD PTR tv5349[rsp]
  004c6	03 c8		 add	 ecx, eax
  004c8	33 5c 24 0c	 xor	 ebx, DWORD PTR tv5379[rsp]
  004cc	44 03 c9	 add	 r9d, ecx
  004cf	d1 c7		 rol	 edi, 1
  004d1	33 dd		 xor	 ebx, ebp
  004d3	33 5c 24 28	 xor	 ebx, DWORD PTR tv5374[rsp]
  004d7	41 8b c1	 mov	 eax, r9d
  004da	c1 c0 05	 rol	 eax, 5
  004dd	41 8b cb	 mov	 ecx, r11d
  004e0	33 ca		 xor	 ecx, edx
  004e2	89 bc 24 a8 00
	00 00		 mov	 DWORD PTR tv5356[rsp], edi
  004e9	41 23 c8	 and	 ecx, r8d
  004ec	41 d1 c7	 rol	 r15d, 1
  004ef	41 33 cb	 xor	 ecx, r11d
  004f2	41 c1 c8 02	 ror	 r8d, 2
  004f6	05 99 79 82 5a	 add	 eax, 1518500249		; 5a827999H
  004fb	d1 c3		 rol	 ebx, 1
  004fd	41 03 c7	 add	 eax, r15d
  00500	81 c7 99 79 82
	5a		 add	 edi, 1518500249		; 5a827999H
  00506	03 c8		 add	 ecx, eax
  00508	44 03 d1	 add	 r10d, ecx
  0050b	41 8b c8	 mov	 ecx, r8d
  0050e	33 ca		 xor	 ecx, edx
  00510	41 8b c2	 mov	 eax, r10d
  00513	41 23 c9	 and	 ecx, r9d
  00516	c1 c0 05	 rol	 eax, 5
  00519	33 ca		 xor	 ecx, edx
  0051b	41 c1 c9 02	 ror	 r9d, 2
  0051f	05 99 79 82 5a	 add	 eax, 1518500249		; 5a827999H
  00524	03 c3		 add	 eax, ebx
  00526	03 c8		 add	 ecx, eax
  00528	44 03 d9	 add	 r11d, ecx
  0052b	41 8b c8	 mov	 ecx, r8d
  0052e	41 33 c9	 xor	 ecx, r9d
  00531	41 8b c3	 mov	 eax, r11d
  00534	41 23 ca	 and	 ecx, r10d
  00537	c1 c0 05	 rol	 eax, 5
  0053a	03 c7		 add	 eax, edi
  0053c	41 c1 ca 02	 ror	 r10d, 2

; 6637 :   R2(a, b, c, d, e, 20);

  00540	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR tv5353[rsp]
  00547	41 33 c8	 xor	 ecx, r8d
  0054a	33 7c 24 0c	 xor	 edi, DWORD PTR tv5379[rsp]
  0054e	03 c8		 add	 ecx, eax
  00550	03 d1		 add	 edx, ecx
  00552	41 33 ff	 xor	 edi, r15d
  00555	8b c2		 mov	 eax, edx
  00557	41 8b c9	 mov	 ecx, r9d
  0055a	c1 c0 05	 rol	 eax, 5
  0055d	41 33 ca	 xor	 ecx, r10d
  00560	05 a1 eb d9 6e	 add	 eax, 1859775393		; 6ed9eba1H
  00565	41 33 cb	 xor	 ecx, r11d
  00568	41 c1 cb 02	 ror	 r11d, 2
  0056c	41 33 fd	 xor	 edi, r13d
  0056f	d1 c7		 rol	 edi, 1

; 6638 :   R2(e, a, b, c, d, 21);

  00571	8b f3		 mov	 esi, ebx
  00573	33 74 24 04	 xor	 esi, DWORD PTR tv5352[rsp]
  00577	03 c7		 add	 eax, edi
  00579	03 c8		 add	 ecx, eax
  0057b	33 74 24 20	 xor	 esi, DWORD PTR tv5384[rsp]
  0057f	44 03 c1	 add	 r8d, ecx
  00582	89 7c 24 28	 mov	 DWORD PTR tv5355[rsp], edi
  00586	41 33 f4	 xor	 esi, r12d
  00589	41 8b ca	 mov	 ecx, r10d
  0058c	41 33 cb	 xor	 ecx, r11d
  0058f	d1 c6		 rol	 esi, 1
  00591	33 ca		 xor	 ecx, edx
  00593	41 8b c0	 mov	 eax, r8d
  00596	c1 c0 05	 rol	 eax, 5

; 6639 :   R2(d, e, a, b, c, 22);
; 6640 :   R2(c, d, e, a, b, 23);
; 6641 :   R2(b, c, d, e, a, 24);
; 6642 :   R2(a, b, c, d, e, 25);

  00599	45 8b e7	 mov	 r12d, r15d
  0059c	05 a1 eb d9 6e	 add	 eax, 1859775393		; 6ed9eba1H
  005a1	c1 ca 02	 ror	 edx, 2
  005a4	03 c6		 add	 eax, esi
  005a6	03 c8		 add	 ecx, eax
  005a8	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv5353[rsp]
  005af	33 44 24 24	 xor	 eax, DWORD PTR tv5380[rsp]
  005b3	44 03 c9	 add	 r9d, ecx
  005b6	41 33 c6	 xor	 eax, r14d
  005b9	41 8b c8	 mov	 ecx, r8d
  005bc	33 84 24 a8 00
	00 00		 xor	 eax, DWORD PTR tv5356[rsp]
  005c3	41 33 cb	 xor	 ecx, r11d
  005c6	d1 c0		 rol	 eax, 1
  005c8	33 ca		 xor	 ecx, edx
  005ca	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv5353[rsp], eax
  005d1	41 8b c1	 mov	 eax, r9d
  005d4	44 33 a4 24 a0
	00 00 00	 xor	 r12d, DWORD PTR tv5353[rsp]
  005dc	44 8b b4 24 a0
	00 00 00	 mov	 r14d, DWORD PTR tv5353[rsp]
  005e4	44 33 24 24	 xor	 r12d, DWORD PTR tv5375[rsp]
  005e8	41 81 c6 a1 eb
	d9 6e		 add	 r14d, 1859775393	; 6ed9eba1H
  005ef	44 33 64 24 10	 xor	 r12d, DWORD PTR tv5376[rsp]
  005f4	c1 c0 05	 rol	 eax, 5
  005f7	41 03 c6	 add	 eax, r14d
  005fa	41 c1 c8 02	 ror	 r8d, 2
  005fe	44 8b 74 24 04	 mov	 r14d, DWORD PTR tv5352[rsp]
  00603	03 c8		 add	 ecx, eax
  00605	44 03 d1	 add	 r10d, ecx
  00608	44 33 f7	 xor	 r14d, edi
  0060b	44 33 f5	 xor	 r14d, ebp
  0060e	41 8b c2	 mov	 eax, r10d
  00611	44 33 34 24	 xor	 r14d, DWORD PTR tv5375[rsp]
  00615	41 8b c8	 mov	 ecx, r8d
  00618	41 d1 c6	 rol	 r14d, 1
  0061b	41 33 c9	 xor	 ecx, r9d
  0061e	33 ca		 xor	 ecx, edx
  00620	44 89 74 24 04	 mov	 DWORD PTR tv5352[rsp], r14d
  00625	41 81 c6 a1 eb
	d9 6e		 add	 r14d, 1859775393	; 6ed9eba1H
  0062c	c1 c0 05	 rol	 eax, 5
  0062f	41 03 c6	 add	 eax, r14d
  00632	41 c1 c9 02	 ror	 r9d, 2
  00636	44 8b b4 24 98
	00 00 00	 mov	 r14d, DWORD PTR tv5349[rsp]
  0063e	03 c8		 add	 ecx, eax
  00640	44 33 74 24 24	 xor	 r14d, DWORD PTR tv5380[rsp]
  00645	44 03 d9	 add	 r11d, ecx
  00648	44 33 74 24 08	 xor	 r14d, DWORD PTR tv5359[rsp]
  0064d	41 8b c3	 mov	 eax, r11d
  00650	c1 c0 05	 rol	 eax, 5
  00653	44 33 f6	 xor	 r14d, esi
  00656	05 a1 eb d9 6e	 add	 eax, 1859775393		; 6ed9eba1H
  0065b	41 d1 c6	 rol	 r14d, 1
  0065e	41 03 c6	 add	 eax, r14d
  00661	41 8b c8	 mov	 ecx, r8d
  00664	41 33 c9	 xor	 ecx, r9d
  00667	41 33 ca	 xor	 ecx, r10d
  0066a	41 c1 ca 02	 ror	 r10d, 2
  0066e	03 c8		 add	 ecx, eax
  00670	03 d1		 add	 edx, ecx
  00672	41 d1 c4	 rol	 r12d, 1
  00675	8b c2		 mov	 eax, edx
  00677	41 8b c9	 mov	 ecx, r9d
  0067a	c1 c0 05	 rol	 eax, 5
  0067d	41 33 ca	 xor	 ecx, r10d
  00680	05 a1 eb d9 6e	 add	 eax, 1859775393		; 6ed9eba1H
  00685	41 33 cb	 xor	 ecx, r11d
  00688	41 03 c4	 add	 eax, r12d
  0068b	41 c1 cb 02	 ror	 r11d, 2
  0068f	03 c8		 add	 ecx, eax

; 6643 :   R2(e, a, b, c, d, 26);

  00691	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv5349[rsp]
  00698	33 c3		 xor	 eax, ebx
  0069a	44 03 c1	 add	 r8d, ecx
  0069d	33 44 24 04	 xor	 eax, DWORD PTR tv5352[rsp]
  006a1	41 8b ca	 mov	 ecx, r10d
  006a4	41 33 c5	 xor	 eax, r13d
  006a7	41 33 cb	 xor	 ecx, r11d
  006aa	d1 c0		 rol	 eax, 1
  006ac	33 ca		 xor	 ecx, edx
  006ae	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv5349[rsp], eax
  006b5	41 8b c0	 mov	 eax, r8d
  006b8	44 8b ac 24 98
	00 00 00	 mov	 r13d, DWORD PTR tv5349[rsp]
  006c0	c1 c0 05	 rol	 eax, 5
  006c3	41 81 c5 a1 eb
	d9 6e		 add	 r13d, 1859775393	; 6ed9eba1H
  006ca	41 03 c5	 add	 eax, r13d
  006cd	c1 ca 02	 ror	 edx, 2
  006d0	03 c8		 add	 ecx, eax

; 6644 :   R2(d, e, a, b, c, 27);

  006d2	45 8b ee	 mov	 r13d, r14d
  006d5	44 33 ac 24 a8
	00 00 00	 xor	 r13d, DWORD PTR tv5356[rsp]
  006dd	44 03 c9	 add	 r9d, ecx
  006e0	44 33 6c 24 10	 xor	 r13d, DWORD PTR tv5376[rsp]
  006e5	41 8b c1	 mov	 eax, r9d
  006e8	44 33 6c 24 18	 xor	 r13d, DWORD PTR tv5370[rsp]
  006ed	41 8b c8	 mov	 ecx, r8d
  006f0	c1 c0 05	 rol	 eax, 5
  006f3	41 33 cb	 xor	 ecx, r11d
  006f6	05 a1 eb d9 6e	 add	 eax, 1859775393		; 6ed9eba1H
  006fb	41 d1 c5	 rol	 r13d, 1
  006fe	41 03 c5	 add	 eax, r13d
  00701	41 c1 c8 02	 ror	 r8d, 2
  00705	33 ca		 xor	 ecx, edx
  00707	03 c8		 add	 ecx, eax

; 6645 :   R2(c, d, e, a, b, 28);

  00709	8b 44 24 14	 mov	 eax, DWORD PTR tv5382[rsp]
  0070d	41 33 c4	 xor	 eax, r12d
  00710	44 03 d1	 add	 r10d, ecx
  00713	33 c7		 xor	 eax, edi
  00715	41 8b c8	 mov	 ecx, r8d
  00718	33 44 24 1c	 xor	 eax, DWORD PTR tv5369[rsp]
  0071c	41 33 c9	 xor	 ecx, r9d
  0071f	d1 c0		 rol	 eax, 1
  00721	33 ca		 xor	 ecx, edx
  00723	89 04 24	 mov	 DWORD PTR tv5347[rsp], eax
  00726	41 8b c2	 mov	 eax, r10d
  00729	8b 3c 24	 mov	 edi, DWORD PTR tv5347[rsp]
  0072c	c1 c0 05	 rol	 eax, 5
  0072f	81 c7 a1 eb d9
	6e		 add	 edi, 1859775393		; 6ed9eba1H
  00735	03 c7		 add	 eax, edi
  00737	41 c1 c9 02	 ror	 r9d, 2

; 6646 :   R2(b, c, d, e, a, 29);

  0073b	8b bc 24 98 00
	00 00		 mov	 edi, DWORD PTR tv5349[rsp]
  00742	03 c8		 add	 ecx, eax
  00744	44 03 d9	 add	 r11d, ecx
  00747	33 fe		 xor	 edi, esi
  00749	33 fd		 xor	 edi, ebp
  0074b	41 8b c3	 mov	 eax, r11d
  0074e	33 7c 24 18	 xor	 edi, DWORD PTR tv5370[rsp]
  00752	41 8b c8	 mov	 ecx, r8d
  00755	c1 c0 05	 rol	 eax, 5
  00758	41 33 c9	 xor	 ecx, r9d
  0075b	d1 c7		 rol	 edi, 1
  0075d	41 33 ca	 xor	 ecx, r10d
  00760	89 7c 24 20	 mov	 DWORD PTR tv5346[rsp], edi
  00764	81 c7 a1 eb d9
	6e		 add	 edi, 1859775393		; 6ed9eba1H
  0076a	03 c7		 add	 eax, edi
  0076c	41 c1 ca 02	 ror	 r10d, 2
  00770	03 c8		 add	 ecx, eax

; 6647 :   R2(a, b, c, d, e, 30);

  00772	8b 44 24 08	 mov	 eax, DWORD PTR tv5359[rsp]
  00776	41 33 c5	 xor	 eax, r13d
  00779	03 d1		 add	 edx, ecx
  0077b	33 44 24 14	 xor	 eax, DWORD PTR tv5382[rsp]
  0077f	33 84 24 a0 00
	00 00		 xor	 eax, DWORD PTR tv5353[rsp]
  00786	d1 c0		 rol	 eax, 1
  00788	89 44 24 0c	 mov	 DWORD PTR tv5345[rsp], eax
  0078c	8b 7c 24 0c	 mov	 edi, DWORD PTR tv5345[rsp]
  00790	8b c2		 mov	 eax, edx
  00792	c1 c0 05	 rol	 eax, 5
  00795	81 c7 a1 eb d9
	6e		 add	 edi, 1859775393		; 6ed9eba1H
  0079b	03 c7		 add	 eax, edi
  0079d	41 8b c9	 mov	 ecx, r9d
  007a0	41 33 ca	 xor	 ecx, r10d

; 6648 :   R2(e, a, b, c, d, 31);

  007a3	41 8b ff	 mov	 edi, r15d
  007a6	33 3c 24	 xor	 edi, DWORD PTR tv5347[rsp]
  007a9	41 33 cb	 xor	 ecx, r11d
  007ac	33 7c 24 04	 xor	 edi, DWORD PTR tv5352[rsp]
  007b0	03 c8		 add	 ecx, eax
  007b2	44 03 c1	 add	 r8d, ecx
  007b5	41 c1 cb 02	 ror	 r11d, 2
  007b9	33 fd		 xor	 edi, ebp
  007bb	41 8b ca	 mov	 ecx, r10d
  007be	41 33 cb	 xor	 ecx, r11d
  007c1	d1 c7		 rol	 edi, 1
  007c3	33 ca		 xor	 ecx, edx
  007c5	89 7c 24 10	 mov	 DWORD PTR tv5344[rsp], edi
  007c9	81 c7 a1 eb d9
	6e		 add	 edi, 1859775393		; 6ed9eba1H
  007cf	c1 ca 02	 ror	 edx, 2

; 6649 :   R2(d, e, a, b, c, 32);

  007d2	8b eb		 mov	 ebp, ebx
  007d4	41 8b c0	 mov	 eax, r8d
  007d7	33 6c 24 20	 xor	 ebp, DWORD PTR tv5346[rsp]
  007db	33 6c 24 08	 xor	 ebp, DWORD PTR tv5359[rsp]
  007df	c1 c0 05	 rol	 eax, 5
  007e2	41 33 ee	 xor	 ebp, r14d
  007e5	03 c7		 add	 eax, edi
  007e7	d1 c5		 rol	 ebp, 1
  007e9	03 c8		 add	 ecx, eax
  007eb	89 6c 24 18	 mov	 DWORD PTR tv5343[rsp], ebp
  007ef	44 03 c9	 add	 r9d, ecx
  007f2	81 c5 a1 eb d9
	6e		 add	 ebp, 1859775393		; 6ed9eba1H
  007f8	41 8b c1	 mov	 eax, r9d
  007fb	41 8b c8	 mov	 ecx, r8d
  007fe	41 33 cb	 xor	 ecx, r11d
  00801	c1 c0 05	 rol	 eax, 5
  00804	33 ca		 xor	 ecx, edx
  00806	41 c1 c8 02	 ror	 r8d, 2
  0080a	03 c5		 add	 eax, ebp

; 6650 :   R2(c, d, e, a, b, 33);

  0080c	8b 6c 24 0c	 mov	 ebp, DWORD PTR tv5345[rsp]
  00810	03 c8		 add	 ecx, eax
  00812	8b fd		 mov	 edi, ebp
  00814	44 03 d1	 add	 r10d, ecx
  00817	41 33 ff	 xor	 edi, r15d

; 6651 :   R2(b, c, d, e, a, 34);

  0081a	44 8b 7c 24 10	 mov	 r15d, DWORD PTR tv5344[rsp]
  0081f	41 33 fc	 xor	 edi, r12d
  00822	33 bc 24 a8 00
	00 00		 xor	 edi, DWORD PTR tv5356[rsp]
  00829	44 33 fb	 xor	 r15d, ebx
  0082c	44 33 bc 24 98
	00 00 00	 xor	 r15d, DWORD PTR tv5349[rsp]
  00834	41 8b c2	 mov	 eax, r10d
  00837	44 33 7c 24 28	 xor	 r15d, DWORD PTR tv5355[rsp]
  0083c	41 8b c8	 mov	 ecx, r8d

; 6652 :   R2(a, b, c, d, e, 35);

  0083f	8b 5c 24 18	 mov	 ebx, DWORD PTR tv5343[rsp]
  00843	41 33 c9	 xor	 ecx, r9d
  00846	33 ca		 xor	 ecx, edx
  00848	c1 c0 05	 rol	 eax, 5
  0084b	05 a1 eb d9 6e	 add	 eax, 1859775393		; 6ed9eba1H
  00850	d1 c7		 rol	 edi, 1
  00852	03 c7		 add	 eax, edi
  00854	41 d1 c7	 rol	 r15d, 1
  00857	03 c8		 add	 ecx, eax
  00859	41 c1 c9 02	 ror	 r9d, 2
  0085d	44 03 d9	 add	 r11d, ecx
  00860	44 89 7c 24 14	 mov	 DWORD PTR tv5341[rsp], r15d
  00865	41 33 dd	 xor	 ebx, r13d
  00868	89 7c 24 0c	 mov	 DWORD PTR tv5342[rsp], edi
  0086c	41 81 c7 a1 eb
	d9 6e		 add	 r15d, 1859775393	; 6ed9eba1H
  00873	33 de		 xor	 ebx, esi
  00875	33 9c 24 a8 00
	00 00		 xor	 ebx, DWORD PTR tv5356[rsp]
  0087c	41 8b c3	 mov	 eax, r11d
  0087f	c1 c0 05	 rol	 eax, 5
  00882	41 8b c8	 mov	 ecx, r8d
  00885	41 33 c9	 xor	 ecx, r9d
  00888	41 03 c7	 add	 eax, r15d
  0088b	41 33 ca	 xor	 ecx, r10d
  0088e	41 c1 ca 02	 ror	 r10d, 2
  00892	03 c8		 add	 ecx, eax
  00894	03 d1		 add	 edx, ecx
  00896	d1 c3		 rol	 ebx, 1

; 6653 :   R2(e, a, b, c, d, 36);

  00898	44 8b 3c 24	 mov	 r15d, DWORD PTR tv5347[rsp]
  0089c	8b c2		 mov	 eax, edx
  0089e	c1 c0 05	 rol	 eax, 5
  008a1	41 8b c9	 mov	 ecx, r9d
  008a4	05 a1 eb d9 6e	 add	 eax, 1859775393		; 6ed9eba1H
  008a9	89 5c 24 24	 mov	 DWORD PTR tv5340[rsp], ebx
  008ad	03 c3		 add	 eax, ebx
  008af	41 33 ca	 xor	 ecx, r10d
  008b2	41 33 cb	 xor	 ecx, r11d

; 6654 :   R2(d, e, a, b, c, 37);
; 6655 :   R2(c, d, e, a, b, 38);

  008b5	33 dd		 xor	 ebx, ebp
  008b7	03 c8		 add	 ecx, eax
  008b9	41 c1 cb 02	 ror	 r11d, 2
  008bd	44 03 c1	 add	 r8d, ecx
  008c0	41 33 de	 xor	 ebx, r14d
  008c3	33 9c 24 a0 00
	00 00		 xor	 ebx, DWORD PTR tv5353[rsp]
  008ca	8b c7		 mov	 eax, edi
  008cc	41 33 c7	 xor	 eax, r15d
  008cf	d1 c3		 rol	 ebx, 1
  008d1	33 84 24 a0 00
	00 00		 xor	 eax, DWORD PTR tv5353[rsp]
  008d8	41 8b ca	 mov	 ecx, r10d
  008db	33 44 24 28	 xor	 eax, DWORD PTR tv5355[rsp]
  008df	41 33 cb	 xor	 ecx, r11d
  008e2	d1 c0		 rol	 eax, 1
  008e4	33 ca		 xor	 ecx, edx
  008e6	89 04 24	 mov	 DWORD PTR tv5339[rsp], eax
  008e9	41 8b c0	 mov	 eax, r8d
  008ec	8b 3c 24	 mov	 edi, DWORD PTR tv5339[rsp]
  008ef	c1 c0 05	 rol	 eax, 5
  008f2	81 c7 a1 eb d9
	6e		 add	 edi, 1859775393		; 6ed9eba1H
  008f8	03 c7		 add	 eax, edi
  008fa	89 5c 24 1c	 mov	 DWORD PTR tv5337[rsp], ebx
  008fe	8b 7c 24 20	 mov	 edi, DWORD PTR tv5346[rsp]
  00902	03 c8		 add	 ecx, eax
  00904	8b 44 24 14	 mov	 eax, DWORD PTR tv5341[rsp]
  00908	44 03 c9	 add	 r9d, ecx
  0090b	33 c7		 xor	 eax, edi
  0090d	c1 ca 02	 ror	 edx, 2
  00910	33 44 24 04	 xor	 eax, DWORD PTR tv5352[rsp]
  00914	81 c3 a1 eb d9
	6e		 add	 ebx, 1859775393		; 6ed9eba1H
  0091a	33 c6		 xor	 eax, esi
  0091c	41 8b c8	 mov	 ecx, r8d
  0091f	d1 c0		 rol	 eax, 1
  00921	41 33 cb	 xor	 ecx, r11d
  00924	89 44 24 2c	 mov	 DWORD PTR tv5338[rsp], eax
  00928	33 ca		 xor	 ecx, edx
  0092a	8b 74 24 2c	 mov	 esi, DWORD PTR tv5338[rsp]
  0092e	41 8b c1	 mov	 eax, r9d
  00931	c1 c0 05	 rol	 eax, 5
  00934	81 c6 a1 eb d9
	6e		 add	 esi, 1859775393		; 6ed9eba1H
  0093a	03 c6		 add	 eax, esi
  0093c	41 c1 c8 02	 ror	 r8d, 2

; 6656 :   R2(b, c, d, e, a, 39);

  00940	8b 74 24 10	 mov	 esi, DWORD PTR tv5344[rsp]
  00944	03 c8		 add	 ecx, eax
  00946	44 03 d1	 add	 r10d, ecx
  00949	41 8b c8	 mov	 ecx, r8d
  0094c	41 33 c9	 xor	 ecx, r9d
  0094f	41 8b c2	 mov	 eax, r10d
  00952	33 ca		 xor	 ecx, edx
  00954	c1 c0 05	 rol	 eax, 5
  00957	03 c3		 add	 eax, ebx
  00959	41 c1 c9 02	 ror	 r9d, 2
  0095d	8b 1c 24	 mov	 ebx, DWORD PTR tv5339[rsp]
  00960	03 c8		 add	 ecx, eax
  00962	33 de		 xor	 ebx, esi
  00964	44 03 d9	 add	 r11d, ecx
  00967	41 33 dc	 xor	 ebx, r12d
  0096a	81 c2 a1 eb d9
	6e		 add	 edx, 1859775393		; 6ed9eba1H
  00970	33 5c 24 04	 xor	 ebx, DWORD PTR tv5352[rsp]
  00974	41 8b c3	 mov	 eax, r11d
  00977	d1 c3		 rol	 ebx, 1
  00979	41 8b c8	 mov	 ecx, r8d
  0097c	c1 c0 05	 rol	 eax, 5
  0097f	41 33 c9	 xor	 ecx, r9d
  00982	89 5c 24 10	 mov	 DWORD PTR tv5336[rsp], ebx
  00986	41 33 ca	 xor	 ecx, r10d
  00989	03 d8		 add	 ebx, eax
  0098b	41 c1 ca 02	 ror	 r10d, 2

; 6657 :   R3(a, b, c, d, e, 40);

  0098f	8b 44 24 2c	 mov	 eax, DWORD PTR tv5338[rsp]
  00993	03 d9		 add	 ebx, ecx
  00995	03 da		 add	 ebx, edx
  00997	33 44 24 18	 xor	 eax, DWORD PTR tv5343[rsp]
  0099b	33 84 24 98 00
	00 00		 xor	 eax, DWORD PTR tv5349[rsp]
  009a2	41 8b ca	 mov	 ecx, r10d
  009a5	41 33 c6	 xor	 eax, r14d
  009a8	41 0b cb	 or	 ecx, r11d

; 6658 :   R3(e, a, b, c, d, 41);

  009ab	44 8b 74 24 0c	 mov	 r14d, DWORD PTR tv5342[rsp]
  009b0	41 23 c9	 and	 ecx, r9d
  009b3	d1 c0		 rol	 eax, 1
  009b5	8b d3		 mov	 edx, ebx
  009b7	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv5335[rsp], eax
  009be	41 8b c2	 mov	 eax, r10d
  009c1	41 23 c3	 and	 eax, r11d
  009c4	c1 c2 05	 rol	 edx, 5
  009c7	0b c8		 or	 ecx, eax
  009c9	41 c1 cb 02	 ror	 r11d, 2
  009cd	03 8c 24 a8 00
	00 00		 add	 ecx, DWORD PTR tv5335[rsp]
  009d4	8b 44 24 1c	 mov	 eax, DWORD PTR tv5337[rsp]
  009d8	41 03 c8	 add	 ecx, r8d
  009db	41 33 c6	 xor	 eax, r14d
  009de	44 8d 82 dc bc
	1b 8f		 lea	 r8d, DWORD PTR [rdx-1894007588]
  009e5	41 33 c5	 xor	 eax, r13d
  009e8	44 03 c1	 add	 r8d, ecx
  009eb	41 33 c4	 xor	 eax, r12d
  009ee	41 8b cb	 mov	 ecx, r11d

; 6659 :   R3(d, e, a, b, c, 42);

  009f1	44 8b 64 24 14	 mov	 r12d, DWORD PTR tv5341[rsp]
  009f6	0b cb		 or	 ecx, ebx
  009f8	d1 c0		 rol	 eax, 1
  009fa	41 23 ca	 and	 ecx, r10d
  009fd	89 44 24 08	 mov	 DWORD PTR tv5334[rsp], eax
  00a01	41 8b d0	 mov	 edx, r8d
  00a04	c1 c2 05	 rol	 edx, 5
  00a07	41 8b c3	 mov	 eax, r11d
  00a0a	23 c3		 and	 eax, ebx
  00a0c	c1 cb 02	 ror	 ebx, 2
  00a0f	0b c8		 or	 ecx, eax
  00a11	8b 44 24 10	 mov	 eax, DWORD PTR tv5336[rsp]
  00a15	03 4c 24 08	 add	 ecx, DWORD PTR tv5334[rsp]
  00a19	41 33 c4	 xor	 eax, r12d
  00a1c	41 03 c9	 add	 ecx, r9d
  00a1f	41 33 c7	 xor	 eax, r15d
  00a22	33 84 24 98 00
	00 00		 xor	 eax, DWORD PTR tv5349[rsp]
  00a29	44 8d 8a dc bc
	1b 8f		 lea	 r9d, DWORD PTR [rdx-1894007588]
  00a30	44 03 c9	 add	 r9d, ecx
  00a33	d1 c0		 rol	 eax, 1
  00a35	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv5317[rsp], eax
  00a3c	41 8b c8	 mov	 ecx, r8d
  00a3f	0b cb		 or	 ecx, ebx
  00a41	41 8b c0	 mov	 eax, r8d
  00a44	23 c3		 and	 eax, ebx
  00a46	41 c1 c8 02	 ror	 r8d, 2
  00a4a	41 23 cb	 and	 ecx, r11d
  00a4d	41 8b d1	 mov	 edx, r9d
  00a50	0b c8		 or	 ecx, eax
  00a52	c1 c2 05	 rol	 edx, 5
  00a55	03 8c 24 98 00
	00 00		 add	 ecx, DWORD PTR tv5317[rsp]

; 6660 :   R3(c, d, e, a, b, 43);

  00a5c	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv5335[rsp]
  00a63	41 03 ca	 add	 ecx, r10d
  00a66	33 44 24 24	 xor	 eax, DWORD PTR tv5340[rsp]
  00a6a	33 c7		 xor	 eax, edi
  00a6c	44 8d 92 dc bc
	1b 8f		 lea	 r10d, DWORD PTR [rdx-1894007588]
  00a73	41 33 c5	 xor	 eax, r13d
  00a76	44 03 d1	 add	 r10d, ecx

; 6661 :   R3(b, c, d, e, a, 44);

  00a79	44 8b 2c 24	 mov	 r13d, DWORD PTR tv5339[rsp]
  00a7d	41 8b c8	 mov	 ecx, r8d
  00a80	d1 c0		 rol	 eax, 1
  00a82	41 0b c9	 or	 ecx, r9d
  00a85	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv5316[rsp], eax
  00a8c	23 cb		 and	 ecx, ebx
  00a8e	41 8b c0	 mov	 eax, r8d
  00a91	41 8b d2	 mov	 edx, r10d
  00a94	41 23 c1	 and	 eax, r9d
  00a97	c1 c2 05	 rol	 edx, 5
  00a9a	0b c8		 or	 ecx, eax
  00a9c	41 c1 c9 02	 ror	 r9d, 2
  00aa0	03 8c 24 a0 00
	00 00		 add	 ecx, DWORD PTR tv5316[rsp]
  00aa7	8b 44 24 08	 mov	 eax, DWORD PTR tv5334[rsp]
  00aab	41 03 cb	 add	 ecx, r11d
  00aae	41 33 c5	 xor	 eax, r13d
  00ab1	44 8d 9a dc bc
	1b 8f		 lea	 r11d, DWORD PTR [rdx-1894007588]
  00ab8	44 03 d9	 add	 r11d, ecx
  00abb	33 c5		 xor	 eax, ebp
  00abd	41 33 c7	 xor	 eax, r15d

; 6662 :   R3(a, b, c, d, e, 45);

  00ac0	44 8b bc 24 98
	00 00 00	 mov	 r15d, DWORD PTR tv5317[rsp]
  00ac8	41 8b c9	 mov	 ecx, r9d
  00acb	44 33 7c 24 2c	 xor	 r15d, DWORD PTR tv5338[rsp]
  00ad0	41 0b ca	 or	 ecx, r10d
  00ad3	41 23 c8	 and	 ecx, r8d
  00ad6	d1 c0		 rol	 eax, 1
  00ad8	44 33 fe	 xor	 r15d, esi
  00adb	89 44 24 04	 mov	 DWORD PTR tv5331[rsp], eax
  00adf	44 33 ff	 xor	 r15d, edi
  00ae2	41 8b c1	 mov	 eax, r9d

; 6663 :   R3(e, a, b, c, d, 46);

  00ae5	8b 7c 24 18	 mov	 edi, DWORD PTR tv5343[rsp]
  00ae9	41 23 c2	 and	 eax, r10d
  00aec	0b c8		 or	 ecx, eax
  00aee	41 d1 c7	 rol	 r15d, 1
  00af1	03 4c 24 04	 add	 ecx, DWORD PTR tv5331[rsp]
  00af5	41 8b d3	 mov	 edx, r11d
  00af8	03 cb		 add	 ecx, ebx
  00afa	c1 c2 05	 rol	 edx, 5
  00afd	41 c1 ca 02	 ror	 r10d, 2
  00b01	44 89 7c 24 14	 mov	 DWORD PTR tv5330[rsp], r15d
  00b06	41 8b c2	 mov	 eax, r10d
  00b09	41 23 c3	 and	 eax, r11d
  00b0c	8d 9a dc bc 1b
	8f		 lea	 ebx, DWORD PTR [rdx-1894007588]
  00b12	03 d9		 add	 ebx, ecx
  00b14	41 8b ca	 mov	 ecx, r10d
  00b17	41 0b cb	 or	 ecx, r11d
  00b1a	8b d3		 mov	 edx, ebx
  00b1c	41 23 c9	 and	 ecx, r9d
  00b1f	c1 c2 05	 rol	 edx, 5
  00b22	0b c8		 or	 ecx, eax
  00b24	41 c1 cb 02	 ror	 r11d, 2
  00b28	41 03 cf	 add	 ecx, r15d
  00b2b	41 8b c3	 mov	 eax, r11d
  00b2e	44 8b bc 24 a0
	00 00 00	 mov	 r15d, DWORD PTR tv5316[rsp]
  00b36	41 03 c8	 add	 ecx, r8d
  00b39	44 33 7c 24 1c	 xor	 r15d, DWORD PTR tv5337[rsp]
  00b3e	44 8d 82 dc bc
	1b 8f		 lea	 r8d, DWORD PTR [rdx-1894007588]
  00b45	44 03 c1	 add	 r8d, ecx
  00b48	23 c3		 and	 eax, ebx
  00b4a	44 33 ff	 xor	 r15d, edi
  00b4d	41 8b d0	 mov	 edx, r8d
  00b50	44 33 fd	 xor	 r15d, ebp
  00b53	c1 c2 05	 rol	 edx, 5

; 6664 :   R3(d, e, a, b, c, 47);

  00b56	8b 6c 24 10	 mov	 ebp, DWORD PTR tv5336[rsp]
  00b5a	41 8b cb	 mov	 ecx, r11d
  00b5d	0b cb		 or	 ecx, ebx
  00b5f	41 d1 c7	 rol	 r15d, 1
  00b62	41 23 ca	 and	 ecx, r10d
  00b65	c1 cb 02	 ror	 ebx, 2
  00b68	0b c8		 or	 ecx, eax
  00b6a	44 89 3c 24	 mov	 DWORD PTR tv5329[rsp], r15d
  00b6e	41 03 cf	 add	 ecx, r15d
  00b71	41 33 ee	 xor	 ebp, r14d
  00b74	41 03 c9	 add	 ecx, r9d
  00b77	33 ee		 xor	 ebp, esi
  00b79	33 6c 24 04	 xor	 ebp, DWORD PTR tv5331[rsp]
  00b7d	44 8d 8a dc bc
	1b 8f		 lea	 r9d, DWORD PTR [rdx-1894007588]

; 6665 :   R3(c, d, e, a, b, 48);

  00b84	8b b4 24 a8 00
	00 00		 mov	 esi, DWORD PTR tv5335[rsp]
  00b8b	44 03 c9	 add	 r9d, ecx
  00b8e	41 33 f4	 xor	 esi, r12d
  00b91	d1 c5		 rol	 ebp, 1
  00b93	33 f7		 xor	 esi, edi
  00b95	89 6c 24 18	 mov	 DWORD PTR tv5328[rsp], ebp
  00b99	33 74 24 14	 xor	 esi, DWORD PTR tv5330[rsp]
  00b9d	41 8b c8	 mov	 ecx, r8d
  00ba0	0b cb		 or	 ecx, ebx
  00ba2	d1 c6		 rol	 esi, 1
  00ba4	41 23 cb	 and	 ecx, r11d
  00ba7	89 74 24 30	 mov	 DWORD PTR tv5327[rsp], esi
  00bab	41 8b c0	 mov	 eax, r8d
  00bae	41 8b d1	 mov	 edx, r9d
  00bb1	c1 c2 05	 rol	 edx, 5
  00bb4	23 c3		 and	 eax, ebx
  00bb6	0b c8		 or	 ecx, eax
  00bb8	41 c1 c8 02	 ror	 r8d, 2
  00bbc	03 cd		 add	 ecx, ebp
  00bbe	41 03 ca	 add	 ecx, r10d
  00bc1	44 8d 92 dc bc
	1b 8f		 lea	 r10d, DWORD PTR [rdx-1894007588]
  00bc8	44 03 d1	 add	 r10d, ecx
  00bcb	41 8b d2	 mov	 edx, r10d
  00bce	c1 c2 05	 rol	 edx, 5

; 6666 :   R3(b, c, d, e, a, 49);

  00bd1	44 8b 7c 24 08	 mov	 r15d, DWORD PTR tv5334[rsp]
  00bd6	41 8b c8	 mov	 ecx, r8d
  00bd9	44 33 7c 24 24	 xor	 r15d, DWORD PTR tv5340[rsp]
  00bde	41 0b c9	 or	 ecx, r9d

; 6667 :   R3(a, b, c, d, e, 50);

  00be1	8b ac 24 98 00
	00 00		 mov	 ebp, DWORD PTR tv5317[rsp]
  00be8	23 cb		 and	 ecx, ebx

; 6668 :   R3(e, a, b, c, d, 51);

  00bea	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR tv5316[rsp]
  00bf1	45 33 fe	 xor	 r15d, r14d
  00bf4	44 33 3c 24	 xor	 r15d, DWORD PTR tv5329[rsp]
  00bf8	41 33 ed	 xor	 ebp, r13d
  00bfb	44 8b 74 24 2c	 mov	 r14d, DWORD PTR tv5338[rsp]
  00c00	41 33 ec	 xor	 ebp, r12d
  00c03	33 6c 24 18	 xor	 ebp, DWORD PTR tv5328[rsp]
  00c07	41 8b c0	 mov	 eax, r8d

; 6669 :   R3(d, e, a, b, c, 52);

  00c0a	44 8b 64 24 1c	 mov	 r12d, DWORD PTR tv5337[rsp]
  00c0f	41 23 c1	 and	 eax, r9d
  00c12	0b c8		 or	 ecx, eax
  00c14	41 c1 c9 02	 ror	 r9d, 2
  00c18	03 ce		 add	 ecx, esi
  00c1a	41 d1 c7	 rol	 r15d, 1
  00c1d	41 03 cb	 add	 ecx, r11d
  00c20	d1 c5		 rol	 ebp, 1
  00c22	44 8d 9a dc bc
	1b 8f		 lea	 r11d, DWORD PTR [rdx-1894007588]
  00c29	44 89 7c 24 20	 mov	 DWORD PTR tv5326[rsp], r15d
  00c2e	44 03 d9	 add	 r11d, ecx
  00c31	89 6c 24 0c	 mov	 DWORD PTR tv5325[rsp], ebp
  00c35	41 33 fe	 xor	 edi, r14d
  00c38	41 8b c9	 mov	 ecx, r9d
  00c3b	33 7c 24 24	 xor	 edi, DWORD PTR tv5340[rsp]
  00c3f	41 0b ca	 or	 ecx, r10d
  00c42	41 23 c8	 and	 ecx, r8d
  00c45	41 8b c1	 mov	 eax, r9d
  00c48	41 23 c2	 and	 eax, r10d
  00c4b	45 33 e5	 xor	 r12d, r13d
  00c4e	0b c8		 or	 ecx, eax
  00c50	41 c1 ca 02	 ror	 r10d, 2
  00c54	41 03 cf	 add	 ecx, r15d
  00c57	41 8b d3	 mov	 edx, r11d
  00c5a	03 cb		 add	 ecx, ebx
  00c5c	c1 c2 05	 rol	 edx, 5
  00c5f	45 33 e7	 xor	 r12d, r15d
  00c62	33 fe		 xor	 edi, esi
  00c64	44 33 64 24 04	 xor	 r12d, DWORD PTR tv5331[rsp]
  00c69	41 8b c2	 mov	 eax, r10d
  00c6c	41 23 c3	 and	 eax, r11d
  00c6f	d1 c7		 rol	 edi, 1
  00c71	8d 9a dc bc 1b
	8f		 lea	 ebx, DWORD PTR [rdx-1894007588]
  00c77	41 d1 c4	 rol	 r12d, 1
  00c7a	03 d9		 add	 ebx, ecx
  00c7c	89 7c 24 24	 mov	 DWORD PTR tv5324[rsp], edi
  00c80	8b d3		 mov	 edx, ebx
  00c82	44 89 64 24 2c	 mov	 DWORD PTR tv5323[rsp], r12d
  00c87	c1 c2 05	 rol	 edx, 5
  00c8a	41 8b ca	 mov	 ecx, r10d
  00c8d	41 0b cb	 or	 ecx, r11d
  00c90	41 c1 cb 02	 ror	 r11d, 2
  00c94	41 23 c9	 and	 ecx, r9d
  00c97	0b c8		 or	 ecx, eax
  00c99	41 8b c3	 mov	 eax, r11d
  00c9c	03 cd		 add	 ecx, ebp
  00c9e	23 c3		 and	 eax, ebx
  00ca0	41 03 c8	 add	 ecx, r8d
  00ca3	44 8d 82 dc bc
	1b 8f		 lea	 r8d, DWORD PTR [rdx-1894007588]
  00caa	44 03 c1	 add	 r8d, ecx
  00cad	41 8b cb	 mov	 ecx, r11d
  00cb0	0b cb		 or	 ecx, ebx
  00cb2	41 8b d0	 mov	 edx, r8d
  00cb5	41 23 ca	 and	 ecx, r10d
  00cb8	c1 c2 05	 rol	 edx, 5
  00cbb	0b c8		 or	 ecx, eax
  00cbd	c1 cb 02	 ror	 ebx, 2
  00cc0	03 cf		 add	 ecx, edi
  00cc2	41 8b c0	 mov	 eax, r8d
  00cc5	41 03 c9	 add	 ecx, r9d
  00cc8	44 8d 8a dc bc
	1b 8f		 lea	 r9d, DWORD PTR [rdx-1894007588]
  00ccf	44 03 c9	 add	 r9d, ecx
  00cd2	41 8b c8	 mov	 ecx, r8d
  00cd5	41 8b d1	 mov	 edx, r9d
  00cd8	0b cb		 or	 ecx, ebx
  00cda	c1 c2 05	 rol	 edx, 5
  00cdd	41 23 cb	 and	 ecx, r11d

; 6670 :   R3(c, d, e, a, b, 53);

  00ce0	44 8b 7c 24 10	 mov	 r15d, DWORD PTR tv5336[rsp]
  00ce5	23 c3		 and	 eax, ebx
  00ce7	0b c8		 or	 ecx, eax

; 6671 :   R3(b, c, d, e, a, 54);
; 6672 :   R3(a, b, c, d, e, 55);
; 6673 :   R3(e, a, b, c, d, 56);

  00ce9	44 8b ac 24 98
	00 00 00	 mov	 r13d, DWORD PTR tv5317[rsp]
  00cf1	44 33 ac 24 a8
	00 00 00	 xor	 r13d, DWORD PTR tv5335[rsp]
  00cf9	41 03 cc	 add	 ecx, r12d
  00cfc	41 03 ca	 add	 ecx, r10d
  00cff	41 c1 c8 02	 ror	 r8d, 2
  00d03	45 33 fe	 xor	 r15d, r14d
  00d06	44 8d 92 dc bc
	1b 8f		 lea	 r10d, DWORD PTR [rdx-1894007588]
  00d0d	44 8b b4 24 a8
	00 00 00	 mov	 r14d, DWORD PTR tv5335[rsp]
  00d15	44 03 d1	 add	 r10d, ecx
  00d18	44 33 74 24 1c	 xor	 r14d, DWORD PTR tv5337[rsp]
  00d1d	44 33 fd	 xor	 r15d, ebp
  00d20	44 33 7c 24 14	 xor	 r15d, DWORD PTR tv5330[rsp]
  00d25	44 33 f7	 xor	 r14d, edi
  00d28	44 33 34 24	 xor	 r14d, DWORD PTR tv5329[rsp]
  00d2c	41 8b c8	 mov	 ecx, r8d
  00d2f	8b 6c 24 08	 mov	 ebp, DWORD PTR tv5334[rsp]
  00d33	41 0b c9	 or	 ecx, r9d
  00d36	33 6c 24 10	 xor	 ebp, DWORD PTR tv5336[rsp]
  00d3a	23 cb		 and	 ecx, ebx
  00d3c	81 c3 dc bc 1b
	8f		 add	 ebx, -1894007588	; 8f1bbcdcH
  00d42	41 d1 c7	 rol	 r15d, 1
  00d45	41 d1 c6	 rol	 r14d, 1
  00d48	41 33 ec	 xor	 ebp, r12d
  00d4b	33 6c 24 18	 xor	 ebp, DWORD PTR tv5328[rsp]
  00d4f	41 8b c0	 mov	 eax, r8d
  00d52	41 23 c1	 and	 eax, r9d
  00d55	d1 c5		 rol	 ebp, 1
  00d57	0b c8		 or	 ecx, eax
  00d59	41 c1 c9 02	 ror	 r9d, 2
  00d5d	81 c1 dc bc 1b
	8f		 add	 ecx, -1894007588	; 8f1bbcdcH
  00d63	44 89 7c 24 28	 mov	 DWORD PTR tv5322[rsp], r15d
  00d68	41 03 cf	 add	 ecx, r15d
  00d6b	44 89 74 24 1c	 mov	 DWORD PTR tv5321[rsp], r14d
  00d70	44 03 d9	 add	 r11d, ecx
  00d73	89 6c 24 10	 mov	 DWORD PTR tv5320[rsp], ebp
  00d77	45 33 ef	 xor	 r13d, r15d
  00d7a	41 8b c9	 mov	 ecx, r9d
  00d7d	41 0b ca	 or	 ecx, r10d
  00d80	41 8b d2	 mov	 edx, r10d
  00d83	41 23 c8	 and	 ecx, r8d
  00d86	c1 c2 05	 rol	 edx, 5
  00d89	44 03 da	 add	 r11d, edx
  00d8c	41 8b c1	 mov	 eax, r9d
  00d8f	41 23 c2	 and	 eax, r10d
  00d92	41 8b fb	 mov	 edi, r11d
  00d95	0b c8		 or	 ecx, eax
  00d97	41 c1 ca 02	 ror	 r10d, 2
  00d9b	41 03 ce	 add	 ecx, r14d
  00d9e	c1 c7 05	 rol	 edi, 5
  00da1	03 cb		 add	 ecx, ebx
  00da3	41 81 c0 dc bc
	1b 8f		 add	 r8d, -1894007588	; 8f1bbcdcH
  00daa	03 f9		 add	 edi, ecx
  00dac	44 33 ee	 xor	 r13d, esi
  00daf	41 d1 c5	 rol	 r13d, 1
  00db2	41 8b ca	 mov	 ecx, r10d
  00db5	41 0b cb	 or	 ecx, r11d
  00db8	44 89 6c 24 34	 mov	 DWORD PTR tv5319[rsp], r13d
  00dbd	41 23 c9	 and	 ecx, r9d
  00dc0	41 8b c2	 mov	 eax, r10d
  00dc3	41 23 c3	 and	 eax, r11d
  00dc6	8b df		 mov	 ebx, edi
  00dc8	0b c8		 or	 ecx, eax
  00dca	41 c1 cb 02	 ror	 r11d, 2
  00dce	03 cd		 add	 ecx, ebp
  00dd0	c1 c3 05	 rol	 ebx, 5
  00dd3	41 03 c8	 add	 ecx, r8d
  00dd6	41 8b c3	 mov	 eax, r11d
  00dd9	03 d9		 add	 ebx, ecx
  00ddb	23 c7		 and	 eax, edi
  00ddd	41 8b cb	 mov	 ecx, r11d
  00de0	8b d3		 mov	 edx, ebx
  00de2	0b cf		 or	 ecx, edi
  00de4	c1 c2 05	 rol	 edx, 5
  00de7	41 23 ca	 and	 ecx, r10d
  00dea	0b c8		 or	 ecx, eax
  00dec	41 03 cd	 add	 ecx, r13d
  00def	41 03 c9	 add	 ecx, r9d
  00df2	44 8d 8a dc bc
	1b 8f		 lea	 r9d, DWORD PTR [rdx-1894007588]

; 6674 :   R3(d, e, a, b, c, 57);

  00df9	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR tv5316[rsp]
  00e01	44 03 c9	 add	 r9d, ecx
  00e04	41 8b f0	 mov	 esi, r8d
  00e07	c1 cf 02	 ror	 edi, 2
  00e0a	33 74 24 08	 xor	 esi, DWORD PTR tv5334[rsp]

; 6675 :   R3(c, d, e, a, b, 58);
; 6676 :   R3(b, c, d, e, a, 59);

  00e0e	45 33 c5	 xor	 r8d, r13d
  00e11	44 33 44 24 24	 xor	 r8d, DWORD PTR tv5324[rsp]
  00e16	41 33 f6	 xor	 esi, r14d
  00e19	44 33 44 24 14	 xor	 r8d, DWORD PTR tv5330[rsp]
  00e1e	8b cb		 mov	 ecx, ebx
  00e20	33 74 24 20	 xor	 esi, DWORD PTR tv5326[rsp]
  00e24	0b cf		 or	 ecx, edi
  00e26	41 23 cb	 and	 ecx, r11d
  00e29	41 d1 c0	 rol	 r8d, 1
  00e2c	d1 c6		 rol	 esi, 1
  00e2e	8b c3		 mov	 eax, ebx
  00e30	23 c7		 and	 eax, edi
  00e32	c1 cb 02	 ror	 ebx, 2
  00e35	0b c8		 or	 ecx, eax
  00e37	44 89 84 24 a0
	00 00 00	 mov	 DWORD PTR tv5316[rsp], r8d
  00e3f	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv5317[rsp]
  00e46	03 ce		 add	 ecx, esi
  00e48	33 c5		 xor	 eax, ebp
  00e4a	89 74 24 08	 mov	 DWORD PTR tv5318[rsp], esi
  00e4e	33 44 24 0c	 xor	 eax, DWORD PTR tv5325[rsp]
  00e52	41 03 ca	 add	 ecx, r10d
  00e55	33 44 24 04	 xor	 eax, DWORD PTR tv5331[rsp]
  00e59	41 8b d1	 mov	 edx, r9d
  00e5c	d1 c0		 rol	 eax, 1

; 6677 :   R4(a, b, c, d, e, 60);

  00e5e	8b ee		 mov	 ebp, esi
  00e60	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv5317[rsp], eax
  00e67	41 33 ec	 xor	 ebp, r12d
  00e6a	33 2c 24	 xor	 ebp, DWORD PTR tv5329[rsp]
  00e6d	8b c3		 mov	 eax, ebx
  00e6f	33 6c 24 04	 xor	 ebp, DWORD PTR tv5331[rsp]
  00e73	41 23 c1	 and	 eax, r9d

; 6678 :   R4(e, a, b, c, d, 61);

  00e76	44 8b a4 24 98
	00 00 00	 mov	 r12d, DWORD PTR tv5317[rsp]
  00e7e	c1 c2 05	 rol	 edx, 5
  00e81	45 33 e7	 xor	 r12d, r15d
  00e84	d1 c5		 rol	 ebp, 1
  00e86	89 6c 24 04	 mov	 DWORD PTR tv5315[rsp], ebp
  00e8a	44 8d 92 dc bc
	1b 8f		 lea	 r10d, DWORD PTR [rdx-1894007588]
  00e91	44 03 d1	 add	 r10d, ecx
  00e94	8b cb		 mov	 ecx, ebx
  00e96	41 0b c9	 or	 ecx, r9d
  00e99	41 8b d2	 mov	 edx, r10d
  00e9c	23 cf		 and	 ecx, edi
  00e9e	c1 c2 05	 rol	 edx, 5
  00ea1	0b c8		 or	 ecx, eax
  00ea3	41 c1 c9 02	 ror	 r9d, 2
  00ea7	03 8c 24 98 00
	00 00		 add	 ecx, DWORD PTR tv5317[rsp]
  00eae	41 8b c1	 mov	 eax, r9d
  00eb1	41 03 cb	 add	 ecx, r11d
  00eb4	41 23 c2	 and	 eax, r10d
  00eb7	44 8d 9a dc bc
	1b 8f		 lea	 r11d, DWORD PTR [rdx-1894007588]
  00ebe	44 03 d9	 add	 r11d, ecx
  00ec1	41 8b c9	 mov	 ecx, r9d
  00ec4	41 0b ca	 or	 ecx, r10d
  00ec7	41 8b d3	 mov	 edx, r11d
  00eca	c1 c2 05	 rol	 edx, 5
  00ecd	23 cb		 and	 ecx, ebx
  00ecf	0b c8		 or	 ecx, eax
  00ed1	41 c1 ca 02	 ror	 r10d, 2
  00ed5	41 03 c8	 add	 ecx, r8d
  00ed8	41 8b c1	 mov	 eax, r9d
  00edb	41 33 c2	 xor	 eax, r10d
  00ede	03 cf		 add	 ecx, edi
  00ee0	8b 7c 24 18	 mov	 edi, DWORD PTR tv5328[rsp]
  00ee4	44 8d 82 dc bc
	1b 8f		 lea	 r8d, DWORD PTR [rdx-1894007588]
  00eeb	41 33 c3	 xor	 eax, r11d
  00eee	44 03 c1	 add	 r8d, ecx
  00ef1	05 d6 c1 62 ca	 add	 eax, -899497514		; ca62c1d6H
  00ef6	41 c1 cb 02	 ror	 r11d, 2
  00efa	03 c5		 add	 eax, ebp
  00efc	44 33 e7	 xor	 r12d, edi
  00eff	44 33 64 24 14	 xor	 r12d, DWORD PTR tv5330[rsp]
  00f04	03 c3		 add	 eax, ebx
  00f06	41 8b d0	 mov	 edx, r8d
  00f09	c1 c2 05	 rol	 edx, 5
  00f0c	03 d0		 add	 edx, eax
  00f0e	41 d1 c4	 rol	 r12d, 1

; 6679 :   R4(d, e, a, b, c, 62);

  00f11	44 8b bc 24 a0
	00 00 00	 mov	 r15d, DWORD PTR tv5316[rsp]
  00f19	41 8b c2	 mov	 eax, r10d
  00f1c	41 33 c3	 xor	 eax, r11d
  00f1f	44 89 64 24 18	 mov	 DWORD PTR tv5314[rsp], r12d
  00f24	41 33 c0	 xor	 eax, r8d
  00f27	45 33 fe	 xor	 r15d, r14d
  00f2a	44 33 7c 24 30	 xor	 r15d, DWORD PTR tv5327[rsp]
  00f2f	41 03 c4	 add	 eax, r12d
  00f32	44 33 3c 24	 xor	 r15d, DWORD PTR tv5329[rsp]
  00f36	41 03 c1	 add	 eax, r9d
  00f39	41 c1 c8 02	 ror	 r8d, 2
  00f3d	8b ca		 mov	 ecx, edx
  00f3f	c1 c1 05	 rol	 ecx, 5

; 6680 :   R4(c, d, e, a, b, 63);

  00f42	44 8b f5	 mov	 r14d, ebp
  00f45	44 33 74 24 10	 xor	 r14d, DWORD PTR tv5320[rsp]
  00f4a	44 33 74 24 20	 xor	 r14d, DWORD PTR tv5326[rsp]
  00f4f	44 33 f7	 xor	 r14d, edi
  00f52	41 d1 c7	 rol	 r15d, 1
  00f55	44 8d 89 d6 c1
	62 ca		 lea	 r9d, DWORD PTR [rcx-899497514]
  00f5c	41 d1 c6	 rol	 r14d, 1
  00f5f	44 03 c8	 add	 r9d, eax
  00f62	44 89 3c 24	 mov	 DWORD PTR tv5313[rsp], r15d
  00f66	8b c2		 mov	 eax, edx
  00f68	44 89 74 24 14	 mov	 DWORD PTR tv5312[rsp], r14d
  00f6d	41 33 c3	 xor	 eax, r11d
  00f70	c1 ca 02	 ror	 edx, 2
  00f73	41 33 c0	 xor	 eax, r8d
  00f76	41 8b c9	 mov	 ecx, r9d
  00f79	41 03 c7	 add	 eax, r15d
  00f7c	c1 c1 05	 rol	 ecx, 5
  00f7f	41 03 c2	 add	 eax, r10d

; 6681 :   R4(b, c, d, e, a, 64);

  00f82	41 8b fc	 mov	 edi, r12d
  00f85	41 33 fd	 xor	 edi, r13d

; 6682 :   R4(a, b, c, d, e, 65);

  00f88	41 8b df	 mov	 ebx, r15d
  00f8b	33 7c 24 0c	 xor	 edi, DWORD PTR tv5325[rsp]
  00f8f	33 de		 xor	 ebx, esi
  00f91	33 7c 24 30	 xor	 edi, DWORD PTR tv5327[rsp]
  00f95	44 8d 91 d6 c1
	62 ca		 lea	 r10d, DWORD PTR [rcx-899497514]
  00f9c	33 5c 24 24	 xor	 ebx, DWORD PTR tv5324[rsp]
  00fa0	44 03 d0	 add	 r10d, eax
  00fa3	33 5c 24 20	 xor	 ebx, DWORD PTR tv5326[rsp]
  00fa7	8b c2		 mov	 eax, edx
  00fa9	41 33 c1	 xor	 eax, r9d
  00fac	d1 c7		 rol	 edi, 1
  00fae	41 33 c0	 xor	 eax, r8d
  00fb1	41 c1 c9 02	 ror	 r9d, 2
  00fb5	41 03 c6	 add	 eax, r14d
  00fb8	d1 c3		 rol	 ebx, 1
  00fba	41 03 c3	 add	 eax, r11d
  00fbd	89 bc 24 a8 00
	00 00		 mov	 DWORD PTR tv5311[rsp], edi
  00fc4	41 8b ca	 mov	 ecx, r10d
  00fc7	89 5c 24 30	 mov	 DWORD PTR tv5310[rsp], ebx
  00fcb	c1 c1 05	 rol	 ecx, 5

; 6683 :   R4(e, a, b, c, d, 66);

  00fce	45 8b ee	 mov	 r13d, r14d
  00fd1	44 33 ac 24 98
	00 00 00	 xor	 r13d, DWORD PTR tv5317[rsp]
  00fd9	44 33 6c 24 2c	 xor	 r13d, DWORD PTR tv5323[rsp]
  00fde	44 33 6c 24 0c	 xor	 r13d, DWORD PTR tv5325[rsp]
  00fe3	44 8d 99 d6 c1
	62 ca		 lea	 r11d, DWORD PTR [rcx-899497514]
  00fea	44 03 d8	 add	 r11d, eax
  00fed	8b c2		 mov	 eax, edx
  00fef	41 33 c1	 xor	 eax, r9d
  00ff2	41 8b cb	 mov	 ecx, r11d
  00ff5	41 33 c2	 xor	 eax, r10d
  00ff8	c1 c1 05	 rol	 ecx, 5
  00ffb	03 c7		 add	 eax, edi
  00ffd	41 c1 ca 02	 ror	 r10d, 2
  01001	41 03 c0	 add	 eax, r8d
  01004	44 8d 81 d6 c1
	62 ca		 lea	 r8d, DWORD PTR [rcx-899497514]
  0100b	44 03 c0	 add	 r8d, eax
  0100e	41 8b c1	 mov	 eax, r9d
  01011	41 33 c2	 xor	 eax, r10d
  01014	41 8b c8	 mov	 ecx, r8d
  01017	41 33 c3	 xor	 eax, r11d
  0101a	c1 c1 05	 rol	 ecx, 5
  0101d	03 c3		 add	 eax, ebx
  0101f	41 c1 cb 02	 ror	 r11d, 2
  01023	03 c2		 add	 eax, edx
  01025	8d 91 d6 c1 62
	ca		 lea	 edx, DWORD PTR [rcx-899497514]
  0102b	03 d0		 add	 edx, eax
  0102d	41 d1 c5	 rol	 r13d, 1
  01030	8b ca		 mov	 ecx, edx

; 6684 :   R4(d, e, a, b, c, 67);

  01032	33 bc 24 a0 00
	00 00		 xor	 edi, DWORD PTR tv5316[rsp]
  01039	41 8b c2	 mov	 eax, r10d
  0103c	33 7c 24 28	 xor	 edi, DWORD PTR tv5322[rsp]
  01040	41 33 c3	 xor	 eax, r11d
  01043	33 7c 24 24	 xor	 edi, DWORD PTR tv5324[rsp]
  01047	41 33 c0	 xor	 eax, r8d
  0104a	41 03 c5	 add	 eax, r13d
  0104d	d1 c7		 rol	 edi, 1
  0104f	41 03 c1	 add	 eax, r9d
  01052	c1 c1 05	 rol	 ecx, 5
  01055	41 c1 c8 02	 ror	 r8d, 2

; 6685 :   R4(c, d, e, a, b, 68);

  01059	8b f3		 mov	 esi, ebx
  0105b	33 f5		 xor	 esi, ebp
  0105d	89 7c 24 24	 mov	 DWORD PTR tv5308[rsp], edi
  01061	33 74 24 1c	 xor	 esi, DWORD PTR tv5321[rsp]

; 6686 :   R4(b, c, d, e, a, 69);

  01065	41 8b ed	 mov	 ebp, r13d
  01068	33 74 24 2c	 xor	 esi, DWORD PTR tv5323[rsp]
  0106c	44 8d 89 d6 c1
	62 ca		 lea	 r9d, DWORD PTR [rcx-899497514]
  01073	44 03 c8	 add	 r9d, eax
  01076	d1 c6		 rol	 esi, 1
  01078	41 33 ec	 xor	 ebp, r12d
  0107b	89 74 24 0c	 mov	 DWORD PTR tv5307[rsp], esi
  0107f	33 6c 24 10	 xor	 ebp, DWORD PTR tv5320[rsp]

; 6687 :   R4(a, b, c, d, e, 70);

  01083	44 8b e7	 mov	 r12d, edi
  01086	33 6c 24 28	 xor	 ebp, DWORD PTR tv5322[rsp]
  0108a	45 33 e7	 xor	 r12d, r15d
  0108d	44 33 64 24 34	 xor	 r12d, DWORD PTR tv5319[rsp]
  01092	8b c2		 mov	 eax, edx
  01094	44 33 64 24 1c	 xor	 r12d, DWORD PTR tv5321[rsp]
  01099	41 33 c3	 xor	 eax, r11d
  0109c	41 33 c0	 xor	 eax, r8d
  0109f	c1 ca 02	 ror	 edx, 2
  010a2	03 c7		 add	 eax, edi
  010a4	d1 c5		 rol	 ebp, 1
  010a6	41 03 c2	 add	 eax, r10d
  010a9	41 d1 c4	 rol	 r12d, 1
  010ac	41 8b c9	 mov	 ecx, r9d
  010af	89 6c 24 28	 mov	 DWORD PTR tv5306[rsp], ebp
  010b3	c1 c1 05	 rol	 ecx, 5

; 6688 :   R4(e, a, b, c, d, 71);

  010b6	44 8b fe	 mov	 r15d, esi
  010b9	45 33 fe	 xor	 r15d, r14d
  010bc	44 33 7c 24 08	 xor	 r15d, DWORD PTR tv5318[rsp]
  010c1	44 33 7c 24 10	 xor	 r15d, DWORD PTR tv5320[rsp]
  010c6	44 8d 91 d6 c1
	62 ca		 lea	 r10d, DWORD PTR [rcx-899497514]
  010cd	41 d1 c7	 rol	 r15d, 1
  010d0	44 03 d0	 add	 r10d, eax
  010d3	8b c2		 mov	 eax, edx
  010d5	41 33 c1	 xor	 eax, r9d
  010d8	41 8b ca	 mov	 ecx, r10d
  010db	41 33 c0	 xor	 eax, r8d
  010de	41 c1 c9 02	 ror	 r9d, 2
  010e2	05 d6 c1 62 ca	 add	 eax, -899497514		; ca62c1d6H
  010e7	c1 c1 05	 rol	 ecx, 5
  010ea	03 c6		 add	 eax, esi
  010ec	44 03 d8	 add	 r11d, eax
  010ef	8b c2		 mov	 eax, edx
  010f1	41 33 c1	 xor	 eax, r9d
  010f4	44 03 d9	 add	 r11d, ecx
  010f7	41 33 c2	 xor	 eax, r10d
  010fa	41 8b db	 mov	 ebx, r11d
  010fd	05 d6 c1 62 ca	 add	 eax, -899497514		; ca62c1d6H
  01102	41 c1 ca 02	 ror	 r10d, 2
  01106	03 c5		 add	 eax, ebp
  01108	c1 c3 05	 rol	 ebx, 5
  0110b	41 03 c0	 add	 eax, r8d
  0110e	03 d8		 add	 ebx, eax
  01110	41 8b c1	 mov	 eax, r9d
  01113	41 33 c2	 xor	 eax, r10d
  01116	8b fb		 mov	 edi, ebx
  01118	41 33 c3	 xor	 eax, r11d
  0111b	c1 c7 05	 rol	 edi, 5
  0111e	05 d6 c1 62 ca	 add	 eax, -899497514		; ca62c1d6H
  01123	41 c1 cb 02	 ror	 r11d, 2
  01127	41 03 c4	 add	 eax, r12d
  0112a	03 c2		 add	 eax, edx
  0112c	03 f8		 add	 edi, eax
  0112e	41 8b c2	 mov	 eax, r10d
  01131	8b f7		 mov	 esi, edi
  01133	41 33 c3	 xor	 eax, r11d
  01136	c1 c6 05	 rol	 esi, 5
  01139	33 c3		 xor	 eax, ebx
  0113b	41 03 c7	 add	 eax, r15d
  0113e	c1 cb 02	 ror	 ebx, 2

; 6689 :   R4(d, e, a, b, c, 72);

  01141	44 8b f5	 mov	 r14d, ebp
  01144	41 81 c1 d6 c1
	62 ca		 add	 r9d, -899497514		; ca62c1d6H
  0114b	44 33 b4 24 a8
	00 00 00	 xor	 r14d, DWORD PTR tv5311[rsp]
  01153	41 03 c1	 add	 eax, r9d
  01156	44 33 b4 24 98
	00 00 00	 xor	 r14d, DWORD PTR tv5317[rsp]
  0115e	03 f0		 add	 esi, eax
  01160	44 33 74 24 34	 xor	 r14d, DWORD PTR tv5319[rsp]
  01165	8b c7		 mov	 eax, edi
  01167	41 33 c3	 xor	 eax, r11d
  0116a	41 d1 c6	 rol	 r14d, 1
  0116d	33 c3		 xor	 eax, ebx
  0116f	c1 cf 02	 ror	 edi, 2
  01172	05 d6 c1 62 ca	 add	 eax, -899497514		; ca62c1d6H

; 6690 :   R4(c, d, e, a, b, 73);

  01177	41 81 c3 d6 c1
	62 ca		 add	 r11d, -899497514	; ca62c1d6H
  0117e	41 03 c6	 add	 eax, r14d
  01181	44 8b ce	 mov	 r9d, esi

; 6691 :   R4(b, c, d, e, a, 74);
; 6692 :   R4(a, b, c, d, e, 75);

  01184	44 33 74 24 24	 xor	 r14d, DWORD PTR tv5308[rsp]
  01189	41 03 c2	 add	 eax, r10d
  0118c	44 33 74 24 18	 xor	 r14d, DWORD PTR tv5314[rsp]
  01191	41 8b ec	 mov	 ebp, r12d
  01194	33 6c 24 30	 xor	 ebp, DWORD PTR tv5310[rsp]
  01198	41 8b d7	 mov	 edx, r15d
  0119b	33 ac 24 a0 00
	00 00		 xor	 ebp, DWORD PTR tv5316[rsp]
  011a2	41 33 d5	 xor	 edx, r13d
  011a5	33 6c 24 08	 xor	 ebp, DWORD PTR tv5318[rsp]
  011a9	33 54 24 04	 xor	 edx, DWORD PTR tv5315[rsp]
  011ad	33 94 24 98 00
	00 00		 xor	 edx, DWORD PTR tv5317[rsp]
  011b4	44 33 b4 24 a0
	00 00 00	 xor	 r14d, DWORD PTR tv5316[rsp]
  011bc	d1 c5		 rol	 ebp, 1
  011be	d1 c2		 rol	 edx, 1
  011c0	41 c1 c1 05	 rol	 r9d, 5
  011c4	44 03 c8	 add	 r9d, eax
  011c7	41 d1 c6	 rol	 r14d, 1
  011ca	45 8b c1	 mov	 r8d, r9d
  011cd	8b c7		 mov	 eax, edi
  011cf	33 c6		 xor	 eax, esi
  011d1	41 c1 c0 05	 rol	 r8d, 5
  011d5	33 c3		 xor	 eax, ebx
  011d7	c1 ce 02	 ror	 esi, 2
  011da	03 c5		 add	 eax, ebp

; 6693 :   R4(e, a, b, c, d, 76);

  011dc	33 6c 24 0c	 xor	 ebp, DWORD PTR tv5307[rsp]
  011e0	33 2c 24	 xor	 ebp, DWORD PTR tv5313[rsp]
  011e3	41 03 c3	 add	 eax, r11d
  011e6	33 6c 24 04	 xor	 ebp, DWORD PTR tv5315[rsp]
  011ea	44 03 c0	 add	 r8d, eax
  011ed	41 8b c8	 mov	 ecx, r8d
  011f0	d1 c5		 rol	 ebp, 1
  011f2	c1 c1 05	 rol	 ecx, 5
  011f5	8b c7		 mov	 eax, edi
  011f7	33 c6		 xor	 eax, esi
  011f9	41 33 c1	 xor	 eax, r9d
  011fc	41 c1 c9 02	 ror	 r9d, 2
  01200	05 d6 c1 62 ca	 add	 eax, -899497514		; ca62c1d6H
  01205	03 c2		 add	 eax, edx

; 6694 :   R4(d, e, a, b, c, 77);

  01207	33 54 24 28	 xor	 edx, DWORD PTR tv5306[rsp]
  0120b	33 54 24 14	 xor	 edx, DWORD PTR tv5312[rsp]
  0120f	03 d8		 add	 ebx, eax
  01211	03 d9		 add	 ebx, ecx
  01213	8b c6		 mov	 eax, esi
  01215	41 33 c1	 xor	 eax, r9d
  01218	44 8b db	 mov	 r11d, ebx
  0121b	41 33 c0	 xor	 eax, r8d
  0121e	41 c1 c3 05	 rol	 r11d, 5
  01222	05 d6 c1 62 ca	 add	 eax, -899497514		; ca62c1d6H
  01227	41 c1 c8 02	 ror	 r8d, 2
  0122b	41 03 c6	 add	 eax, r14d
  0122e	03 c7		 add	 eax, edi
  01230	44 03 d8	 add	 r11d, eax
  01233	41 8b c1	 mov	 eax, r9d
  01236	41 33 c0	 xor	 eax, r8d
  01239	45 8b d3	 mov	 r10d, r11d
  0123c	33 c3		 xor	 eax, ebx
  0123e	41 c1 c2 05	 rol	 r10d, 5
  01242	05 d6 c1 62 ca	 add	 eax, -899497514		; ca62c1d6H
  01247	c1 cb 02	 ror	 ebx, 2
  0124a	03 c5		 add	 eax, ebp
  0124c	03 c6		 add	 eax, esi
  0124e	44 03 d0	 add	 r10d, eax
  01251	33 54 24 18	 xor	 edx, DWORD PTR tv5314[rsp]

; 6695 :   R4(c, d, e, a, b, 78);

  01255	45 33 f4	 xor	 r14d, r12d
  01258	d1 c2		 rol	 edx, 1
  0125a	44 33 b4 24 a8
	00 00 00	 xor	 r14d, DWORD PTR tv5311[rsp]

; 6696 :   R4(b, c, d, e, a, 79);

  01262	41 33 ef	 xor	 ebp, r15d
  01265	44 33 34 24	 xor	 r14d, DWORD PTR tv5313[rsp]
  01269	41 8b c2	 mov	 eax, r10d
  0126c	33 6c 24 30	 xor	 ebp, DWORD PTR tv5310[rsp]
  01270	33 6c 24 14	 xor	 ebp, DWORD PTR tv5312[rsp]
  01274	c1 c0 05	 rol	 eax, 5
  01277	03 d0		 add	 edx, eax
  01279	41 d1 c6	 rol	 r14d, 1
  0127c	41 8b c3	 mov	 eax, r11d
  0127f	d1 c5		 rol	 ebp, 1
  01281	41 33 c0	 xor	 eax, r8d
  01284	41 c1 cb 02	 ror	 r11d, 2
  01288	33 c3		 xor	 eax, ebx
  0128a	41 8b cb	 mov	 ecx, r11d
  0128d	41 03 c1	 add	 eax, r9d
  01290	44 8d 8a d6 c1
	62 ca		 lea	 r9d, DWORD PTR [rdx-899497514]
  01297	44 03 c8	 add	 r9d, eax
  0129a	41 8b c1	 mov	 eax, r9d
  0129d	c1 c0 05	 rol	 eax, 5
  012a0	44 03 f0	 add	 r14d, eax
  012a3	41 8b c3	 mov	 eax, r11d
  012a6	41 33 c2	 xor	 eax, r10d
  012a9	41 c1 ca 02	 ror	 r10d, 2
  012ad	33 c3		 xor	 eax, ebx
  012af	41 33 ca	 xor	 ecx, r10d
  012b2	41 03 c0	 add	 eax, r8d
  012b5	41 33 c9	 xor	 ecx, r9d
  012b8	41 c1 c9 02	 ror	 r9d, 2
  012bc	45 8d 86 d6 c1
	62 ca		 lea	 r8d, DWORD PTR [r14-899497514]
  012c3	44 03 c0	 add	 r8d, eax

; 6697 :   state[0] += a;

  012c6	8d 83 d6 c1 62
	ca		 lea	 eax, DWORD PTR [rbx-899497514]
  012cc	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR state$[rsp]
  012d4	03 c5		 add	 eax, ebp
  012d6	41 8b d0	 mov	 edx, r8d
  012d9	c1 c2 05	 rol	 edx, 5
  012dc	03 c2		 add	 eax, edx
  012de	03 0b		 add	 ecx, DWORD PTR [rbx]

; 6698 :   state[1] += b;

  012e0	44 01 43 04	 add	 DWORD PTR [rbx+4], r8d
  012e4	03 c1		 add	 eax, ecx

; 6699 :   state[2] += c;

  012e6	44 01 4b 08	 add	 DWORD PTR [rbx+8], r9d

; 6700 :   state[3] += d;

  012ea	44 01 53 0c	 add	 DWORD PTR [rbx+12], r10d

; 6701 :   state[4] += e;

  012ee	44 01 5b 10	 add	 DWORD PTR [rbx+16], r11d
  012f2	89 03		 mov	 DWORD PTR [rbx], eax

; 6702 :   /* Erase working structures. The order of operations is important,
; 6703 :    * used to ensure that compiler doesn't optimize those out. */
; 6704 :   memset(block, 0, sizeof(block));
; 6705 :   a = b = c = d = e = 0;
; 6706 :   (void) a;
; 6707 :   (void) b;
; 6708 :   (void) c;
; 6709 :   (void) d;
; 6710 :   (void) e;
; 6711 : }

  012f4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  012f8	41 5f		 pop	 r15
  012fa	41 5e		 pop	 r14
  012fc	41 5d		 pop	 r13
  012fe	41 5c		 pop	 r12
  01300	5f		 pop	 rdi
  01301	5e		 pop	 rsi
  01302	5d		 pop	 rbp
  01303	5b		 pop	 rbx
  01304	c3		 ret	 0
mg_sha1_transform ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_sha1_init
_TEXT	SEGMENT
context$ = 8
mg_sha1_init PROC					; COMDAT

; 6714 :   context->state[0] = 0x67452301;
; 6715 :   context->state[1] = 0xEFCDAB89;
; 6716 :   context->state[2] = 0x98BADCFE;
; 6717 :   context->state[3] = 0x10325476;
; 6718 :   context->state[4] = 0xC3D2E1F0;
; 6719 :   context->count[0] = context->count[1] = 0;

  00000	83 61 18 00	 and	 DWORD PTR [rcx+24], 0
  00004	83 61 14 00	 and	 DWORD PTR [rcx+20], 0
  00008	c7 01 01 23 45
	67		 mov	 DWORD PTR [rcx], 1732584193 ; 67452301H
  0000e	c7 41 04 89 ab
	cd ef		 mov	 DWORD PTR [rcx+4], -271733879 ; efcdab89H
  00015	c7 41 08 fe dc
	ba 98		 mov	 DWORD PTR [rcx+8], -1732584194 ; 98badcfeH
  0001c	c7 41 0c 76 54
	32 10		 mov	 DWORD PTR [rcx+12], 271733878 ; 10325476H
  00023	c7 41 10 f0 e1
	d2 c3		 mov	 DWORD PTR [rcx+16], -1009589776 ; c3d2e1f0H

; 6720 : }

  0002a	c3		 ret	 0
mg_sha1_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_sha1_update
_TEXT	SEGMENT
context$ = 48
data$ = 56
len$ = 64
mg_sha1_update PROC					; COMDAT

; 6723 :                     size_t len) {

$LN17:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 6724 :   size_t i, j;
; 6725 : 
; 6726 :   j = context->count[0];

  00019	44 8b 49 14	 mov	 r9d, DWORD PTR [rcx+20]
  0001d	49 8b f8	 mov	 rdi, r8
  00020	4c 8b f2	 mov	 r14, rdx
  00023	48 8b f1	 mov	 rsi, rcx

; 6727 :   if ((context->count[0] += (uint32_t) len << 3) < j) context->count[1]++;

  00026	43 8d 04 c1	 lea	 eax, DWORD PTR [r9+r8*8]
  0002a	89 41 14	 mov	 DWORD PTR [rcx+20], eax
  0002d	49 3b c1	 cmp	 rax, r9
  00030	73 03		 jae	 SHORT $LN14@mg_sha1_up
  00032	ff 41 18	 inc	 DWORD PTR [rcx+24]
$LN14@mg_sha1_up:

; 6728 :   context->count[1] += (uint32_t) (len >> 29);
; 6729 :   j = (j >> 3) & 63;

  00035	49 c1 e9 03	 shr	 r9, 3
  00039	48 8b c7	 mov	 rax, rdi
  0003c	48 c1 e8 1d	 shr	 rax, 29
  00040	41 83 e1 3f	 and	 r9d, 63			; 0000003fH
  00044	01 41 18	 add	 DWORD PTR [rcx+24], eax

; 6730 :   if ((j + len) > 63) {

  00047	4b 8d 04 01	 lea	 rax, QWORD PTR [r9+r8]
  0004b	48 83 f8 3f	 cmp	 rax, 63			; 0000003fH
  0004f	76 4a		 jbe	 SHORT $LN6@mg_sha1_up

; 6731 :     memcpy(&context->buffer[j], data, (i = 64 - j));

  00051	48 83 c1 1c	 add	 rcx, 28
  00055	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H
  0005a	49 2b d9	 sub	 rbx, r9
  0005d	49 03 c9	 add	 rcx, r9
  00060	4c 8b c3	 mov	 r8, rbx
  00063	e8 00 00 00 00	 call	 memcpy

; 6732 :     mg_sha1_transform(context->state, context->buffer);

  00068	48 8d 56 1c	 lea	 rdx, QWORD PTR [rsi+28]
  0006c	48 8b ce	 mov	 rcx, rsi
  0006f	e8 00 00 00 00	 call	 mg_sha1_transform

; 6733 :     for (; i + 63 < len; i += 64) {

  00074	48 8d 6b 3f	 lea	 rbp, QWORD PTR [rbx+63]
  00078	eb 17		 jmp	 SHORT $LN15@mg_sha1_up
$LL4@mg_sha1_up:

; 6734 :       mg_sha1_transform(context->state, &data[i]);

  0007a	49 8d 56 c1	 lea	 rdx, QWORD PTR [r14-63]
  0007e	48 8b ce	 mov	 rcx, rsi
  00081	48 03 d5	 add	 rdx, rbp
  00084	e8 00 00 00 00	 call	 mg_sha1_transform
  00089	48 83 c3 40	 add	 rbx, 64			; 00000040H
  0008d	48 83 c5 40	 add	 rbp, 64			; 00000040H
$LN15@mg_sha1_up:

; 6733 :     for (; i + 63 < len; i += 64) {

  00091	48 3b ef	 cmp	 rbp, rdi
  00094	72 e4		 jb	 SHORT $LL4@mg_sha1_up

; 6735 :     }
; 6736 :     j = 0;

  00096	45 33 c9	 xor	 r9d, r9d

; 6737 :   } else

  00099	eb 02		 jmp	 SHORT $LN7@mg_sha1_up
$LN6@mg_sha1_up:

; 6738 :     i = 0;

  0009b	33 db		 xor	 ebx, ebx
$LN7@mg_sha1_up:

; 6739 :   memcpy(&context->buffer[j], &data[i], len - i);

  0009d	48 2b fb	 sub	 rdi, rbx
  000a0	48 8d 4e 1c	 lea	 rcx, QWORD PTR [rsi+28]
  000a4	49 03 c9	 add	 rcx, r9
  000a7	4a 8d 14 33	 lea	 rdx, QWORD PTR [rbx+r14]
  000ab	4c 8b c7	 mov	 r8, rdi

; 6740 : }

  000ae	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b3	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000b8	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000bd	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000c2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c6	41 5e		 pop	 r14

; 6739 :   memcpy(&context->buffer[j], &data[i], len - i);

  000c8	e9 00 00 00 00	 jmp	 memcpy
mg_sha1_update ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_sha1_final
_TEXT	SEGMENT
digest$ = 64
c$ = 72
context$ = 72
finalcount$ = 80
mg_sha1_final PROC					; COMDAT

; 6742 : void mg_sha1_final(unsigned char digest[20], mg_sha1_ctx *context) {

$LN26:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 6743 :   unsigned i;
; 6744 :   unsigned char finalcount[8], c;
; 6745 : 
; 6746 :   for (i = 0; i < 8; i++) {

  0000c	33 ff		 xor	 edi, edi
  0000e	4c 8d 4c 24 50	 lea	 r9, QWORD PTR finalcount$[rsp]
  00013	48 8b da	 mov	 rbx, rdx
  00016	48 8b f1	 mov	 rsi, rcx
  00019	44 8b c7	 mov	 r8d, edi
  0001c	8d 6f 01	 lea	 ebp, QWORD PTR [rdi+1]
$LL4@mg_sha1_fi:

; 6747 :     finalcount[i] = (unsigned char) ((context->count[(i >= 4 ? 0 : 1)] >>

  0001f	41 8b c0	 mov	 eax, r8d
  00022	b9 03 00 00 00	 mov	 ecx, 3
  00027	83 e0 03	 and	 eax, 3
  0002a	2b c8		 sub	 ecx, eax
  0002c	c1 e1 03	 shl	 ecx, 3
  0002f	41 83 f8 04	 cmp	 r8d, 4
  00033	48 1b c0	 sbb	 rax, rax
  00036	44 03 c5	 add	 r8d, ebp
  00039	83 e0 04	 and	 eax, 4
  0003c	8b 54 18 14	 mov	 edx, DWORD PTR [rax+rbx+20]
  00040	d3 ea		 shr	 edx, cl
  00042	41 88 11	 mov	 BYTE PTR [r9], dl
  00045	4c 03 cd	 add	 r9, rbp
  00048	41 83 f8 08	 cmp	 r8d, 8
  0004c	72 d1		 jb	 SHORT $LL4@mg_sha1_fi

; 6748 :                                       ((3 - (i & 3)) * 8)) &
; 6749 :                                      255);
; 6750 :   }
; 6751 :   c = 0200;

  0004e	c6 44 24 48 80	 mov	 BYTE PTR c$[rsp], 128	; 00000080H

; 6752 :   mg_sha1_update(context, &c, 1);
; 6753 :   while ((context->count[0] & 504) != 448) {

  00053	eb 05		 jmp	 SHORT $LN24@mg_sha1_fi
$LL5@mg_sha1_fi:

; 6754 :     c = 0000;

  00055	40 88 7c 24 48	 mov	 BYTE PTR c$[rsp], dil
$LN24@mg_sha1_fi:

; 6752 :   mg_sha1_update(context, &c, 1);
; 6753 :   while ((context->count[0] & 504) != 448) {

  0005a	4c 8b c5	 mov	 r8, rbp
  0005d	48 8d 54 24 48	 lea	 rdx, QWORD PTR c$[rsp]
  00062	48 8b cb	 mov	 rcx, rbx
  00065	e8 00 00 00 00	 call	 mg_sha1_update
  0006a	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  0006d	25 f8 01 00 00	 and	 eax, 504		; 000001f8H
  00072	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  00077	75 dc		 jne	 SHORT $LL5@mg_sha1_fi

; 6755 :     mg_sha1_update(context, &c, 1);
; 6756 :   }
; 6757 :   mg_sha1_update(context, finalcount, 8);

  00079	41 b8 08 00 00
	00		 mov	 r8d, 8
  0007f	48 8d 54 24 50	 lea	 rdx, QWORD PTR finalcount$[rsp]
  00084	48 8b cb	 mov	 rcx, rbx
  00087	e8 00 00 00 00	 call	 mg_sha1_update
  0008c	4c 8b c7	 mov	 r8, rdi
$LL9@mg_sha1_fi:

; 6758 :   for (i = 0; i < 20; i++) {
; 6759 :     digest[i] =

  0008f	8b c7		 mov	 eax, edi
  00091	b9 03 00 00 00	 mov	 ecx, 3
  00096	83 e0 03	 and	 eax, 3
  00099	03 fd		 add	 edi, ebp
  0009b	2b c8		 sub	 ecx, eax
  0009d	49 8b c0	 mov	 rax, r8
  000a0	48 c1 e8 02	 shr	 rax, 2
  000a4	4c 03 c5	 add	 r8, rbp
  000a7	c1 e1 03	 shl	 ecx, 3
  000aa	8b 14 83	 mov	 edx, DWORD PTR [rbx+rax*4]
  000ad	d3 ea		 shr	 edx, cl
  000af	88 16		 mov	 BYTE PTR [rsi], dl
  000b1	48 03 f5	 add	 rsi, rbp
  000b4	83 ff 14	 cmp	 edi, 20
  000b7	72 d6		 jb	 SHORT $LL9@mg_sha1_fi

; 6760 :         (unsigned char) ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);
; 6761 :   }
; 6762 :   memset(context, '\0', sizeof(*context));

  000b9	33 d2		 xor	 edx, edx
  000bb	48 8b cb	 mov	 rcx, rbx
  000be	44 8d 42 5c	 lea	 r8d, QWORD PTR [rdx+92]

; 6763 :   memset(&finalcount, '\0', sizeof(finalcount));
; 6764 : }

  000c2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cb	5f		 pop	 rdi
  000cc	5e		 pop	 rsi
  000cd	5d		 pop	 rbp

; 6760 :         (unsigned char) ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);
; 6761 :   }
; 6762 :   memset(context, '\0', sizeof(*context));

  000ce	e9 00 00 00 00	 jmp	 memset
mg_sha1_final ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_sha256_init
_TEXT	SEGMENT
ctx$ = 8
mg_sha256_init PROC					; COMDAT

; 6793 :   ctx->len = 0;

  00000	83 61 28 00	 and	 DWORD PTR [rcx+40], 0

; 6794 :   ctx->bits = 0;

  00004	48 83 61 20 00	 and	 QWORD PTR [rcx+32], 0

; 6795 :   ctx->state[0] = 0x6a09e667;

  00009	c7 01 67 e6 09
	6a		 mov	 DWORD PTR [rcx], 1779033703 ; 6a09e667H

; 6796 :   ctx->state[1] = 0xbb67ae85;

  0000f	c7 41 04 85 ae
	67 bb		 mov	 DWORD PTR [rcx+4], -1150833019 ; bb67ae85H

; 6797 :   ctx->state[2] = 0x3c6ef372;

  00016	c7 41 08 72 f3
	6e 3c		 mov	 DWORD PTR [rcx+8], 1013904242 ; 3c6ef372H

; 6798 :   ctx->state[3] = 0xa54ff53a;

  0001d	c7 41 0c 3a f5
	4f a5		 mov	 DWORD PTR [rcx+12], -1521486534 ; a54ff53aH

; 6799 :   ctx->state[4] = 0x510e527f;

  00024	c7 41 10 7f 52
	0e 51		 mov	 DWORD PTR [rcx+16], 1359893119 ; 510e527fH

; 6800 :   ctx->state[5] = 0x9b05688c;

  0002b	c7 41 14 8c 68
	05 9b		 mov	 DWORD PTR [rcx+20], -1694144372 ; 9b05688cH

; 6801 :   ctx->state[6] = 0x1f83d9ab;

  00032	c7 41 18 ab d9
	83 1f		 mov	 DWORD PTR [rcx+24], 528734635 ; 1f83d9abH

; 6802 :   ctx->state[7] = 0x5be0cd19;

  00039	c7 41 1c 19 cd
	e0 5b		 mov	 DWORD PTR [rcx+28], 1541459225 ; 5be0cd19H

; 6803 : }

  00040	c3		 ret	 0
mg_sha256_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_sha256_chunk
_TEXT	SEGMENT
m$ = 16
ctx$ = 352
d$1$ = 368
mg_sha256_chunk PROC					; COMDAT

; 6805 : static void mg_sha256_chunk(mg_sha256_ctx *ctx) {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00014	33 db		 xor	 ebx, ebx
  00016	4c 8b c9	 mov	 r9, rcx
  00019	44 8b c3	 mov	 r8d, ebx

; 6806 :   int i, j;
; 6807 :   uint32_t a, b, c, d, e, f, g, h;
; 6808 :   uint32_t m[64];
; 6809 :   for (i = 0, j = 0; i < 16; ++i, j += 4)

  0001c	48 83 c1 2d	 add	 rcx, 45			; 0000002dH
$LL4@mg_sha256_:

; 6810 :     m[i] = (uint32_t) ((ctx->buffer[j] << 24) | (ctx->buffer[j + 1] << 16) |

  00020	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00023	0f b6 51 ff	 movzx	 edx, BYTE PTR [rcx-1]
  00027	48 8d 49 04	 lea	 rcx, QWORD PTR [rcx+4]
  0002b	c1 e2 08	 shl	 edx, 8
  0002e	0b d0		 or	 edx, eax
  00030	0f b6 41 fd	 movzx	 eax, BYTE PTR [rcx-3]
  00034	c1 e2 08	 shl	 edx, 8
  00037	0b d0		 or	 edx, eax
  00039	0f b6 41 fe	 movzx	 eax, BYTE PTR [rcx-2]
  0003d	c1 e2 08	 shl	 edx, 8
  00040	0b d0		 or	 edx, eax
  00042	42 89 54 84 10	 mov	 DWORD PTR m$[rsp+r8*4], edx
  00047	49 ff c0	 inc	 r8
  0004a	49 83 f8 10	 cmp	 r8, 16
  0004e	7c d0		 jl	 SHORT $LL4@mg_sha256_

; 6811 :                        (ctx->buffer[j + 2] << 8) | (ctx->buffer[j + 3]));
; 6812 :   for (; i < 64; ++i)

  00050	4c 8d 54 24 48	 lea	 r10, QWORD PTR m$[rsp+56]
  00055	41 bb 30 00 00
	00		 mov	 r11d, 48		; 00000030H
$LL7@mg_sha256_:

; 6813 :     m[i] = sig1(m[i - 2]) + m[i - 7] + sig0(m[i - 15]) + m[i - 16];

  0005b	41 8b 4a cc	 mov	 ecx, DWORD PTR [r10-52]
  0005f	44 8b c1	 mov	 r8d, ecx
  00062	41 8b 12	 mov	 edx, DWORD PTR [r10]
  00065	8b c1		 mov	 eax, ecx
  00067	41 c1 c0 0e	 rol	 r8d, 14
  0006b	4d 8d 52 04	 lea	 r10, QWORD PTR [r10+4]
  0006f	c1 e9 03	 shr	 ecx, 3
  00072	c1 c8 07	 ror	 eax, 7
  00075	44 33 c0	 xor	 r8d, eax
  00078	8b c2		 mov	 eax, edx
  0007a	44 33 c1	 xor	 r8d, ecx
  0007d	c1 c0 0d	 rol	 eax, 13
  00080	8b ca		 mov	 ecx, edx
  00082	c1 ea 0a	 shr	 edx, 10
  00085	c1 c1 0f	 rol	 ecx, 15
  00088	33 c8		 xor	 ecx, eax
  0008a	33 ca		 xor	 ecx, edx
  0008c	44 03 c1	 add	 r8d, ecx
  0008f	45 03 42 c4	 add	 r8d, DWORD PTR [r10-60]
  00093	45 03 42 e8	 add	 r8d, DWORD PTR [r10-24]
  00097	45 89 42 04	 mov	 DWORD PTR [r10+4], r8d
  0009b	49 83 eb 01	 sub	 r11, 1
  0009f	75 ba		 jne	 SHORT $LL7@mg_sha256_

; 6814 : 
; 6815 :   a = ctx->state[0];
; 6816 :   b = ctx->state[1];
; 6817 :   c = ctx->state[2];
; 6818 :   d = ctx->state[3];

  000a1	41 8b 71 0c	 mov	 esi, DWORD PTR [r9+12]

; 6819 :   e = ctx->state[4];
; 6820 :   f = ctx->state[5];
; 6821 :   g = ctx->state[6];
; 6822 :   h = ctx->state[7];

  000a5	41 8b 69 1c	 mov	 ebp, DWORD PTR [r9+28]
  000a9	44 8b e5	 mov	 r12d, ebp
  000ac	45 8b 29	 mov	 r13d, DWORD PTR [r9]
  000af	45 8b 59 04	 mov	 r11d, DWORD PTR [r9+4]
  000b3	41 8b 79 08	 mov	 edi, DWORD PTR [r9+8]
  000b7	45 8b 51 10	 mov	 r10d, DWORD PTR [r9+16]
  000bb	45 8b 71 18	 mov	 r14d, DWORD PTR [r9+24]
  000bf	89 b4 24 70 01
	00 00		 mov	 DWORD PTR d$1$[rsp], esi
  000c6	44 8b bc 24 70
	01 00 00	 mov	 r15d, DWORD PTR d$1$[rsp]
  000ce	41 8b 71 14	 mov	 esi, DWORD PTR [r9+20]
$LL10@mg_sha256_:

; 6823 : 
; 6824 :   for (i = 0; i < 64; ++i) {
; 6825 :     uint32_t t1 = h + ep1(e) + ch(e, f, g) + mg_sha256_k[i] + m[i];

  000d2	41 8b c2	 mov	 eax, r10d
  000d5	45 8b c2	 mov	 r8d, r10d
  000d8	c1 c0 07	 rol	 eax, 7
  000db	41 8b ca	 mov	 ecx, r10d
  000de	41 c1 c8 0b	 ror	 r8d, 11
  000e2	f7 d1		 not	 ecx
  000e4	44 33 c0	 xor	 r8d, eax
  000e7	41 23 ce	 and	 ecx, r14d
  000ea	41 8b c2	 mov	 eax, r10d

; 6826 :     uint32_t t2 = ep0(a) + maj(a, b, c);

  000ed	41 8b d5	 mov	 edx, r13d
  000f0	c1 c8 06	 ror	 eax, 6
  000f3	44 33 c0	 xor	 r8d, eax
  000f6	c1 ca 0d	 ror	 edx, 13
  000f9	8b c6		 mov	 eax, esi
  000fb	41 23 c2	 and	 eax, r10d
  000fe	33 c8		 xor	 ecx, eax
  00100	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:mg_sha256_k
  00107	44 03 c1	 add	 r8d, ecx
  0010a	41 8b cb	 mov	 ecx, r11d
  0010d	44 03 04 03	 add	 r8d, DWORD PTR [rbx+rax]
  00111	41 33 cd	 xor	 ecx, r13d
  00114	44 03 44 1c 10	 add	 r8d, DWORD PTR m$[rsp+rbx]
  00119	23 cf		 and	 ecx, edi
  0011b	45 03 c4	 add	 r8d, r12d
  0011e	41 8b c5	 mov	 eax, r13d
  00121	c1 c0 0a	 rol	 eax, 10

; 6827 :     h = g;

  00124	45 8b e6	 mov	 r12d, r14d
  00127	33 d0		 xor	 edx, eax

; 6828 :     g = f;

  00129	44 8b f6	 mov	 r14d, esi
  0012c	41 8b c5	 mov	 eax, r13d

; 6829 :     f = e;

  0012f	41 8b f2	 mov	 esi, r10d
  00132	c1 c8 02	 ror	 eax, 2

; 6830 :     e = d + t1;

  00135	47 8d 14 38	 lea	 r10d, DWORD PTR [r8+r15]
  00139	33 d0		 xor	 edx, eax

; 6831 :     d = c;

  0013b	44 8b ff	 mov	 r15d, edi
  0013e	41 8b c3	 mov	 eax, r11d
  00141	48 83 c3 04	 add	 rbx, 4
  00145	41 23 c5	 and	 eax, r13d

; 6832 :     c = b;

  00148	41 8b fb	 mov	 edi, r11d
  0014b	33 c8		 xor	 ecx, eax

; 6833 :     b = a;

  0014d	45 8b dd	 mov	 r11d, r13d
  00150	03 d1		 add	 edx, ecx

; 6834 :     a = t1 + t2;

  00152	46 8d 2c 02	 lea	 r13d, DWORD PTR [rdx+r8]
  00156	48 81 fb 00 01
	00 00		 cmp	 rbx, 256		; 00000100H
  0015d	0f 8c 6f ff ff
	ff		 jl	 $LL10@mg_sha256_

; 6835 :   }
; 6836 : 
; 6837 :   ctx->state[0] += a;

  00163	45 01 29	 add	 DWORD PTR [r9], r13d

; 6838 :   ctx->state[1] += b;
; 6839 :   ctx->state[2] += c;
; 6840 :   ctx->state[3] += d;
; 6841 :   ctx->state[4] += e;
; 6842 :   ctx->state[5] += f;
; 6843 :   ctx->state[6] += g;
; 6844 :   ctx->state[7] += h;

  00166	41 8d 04 2c	 lea	 eax, DWORD PTR [r12+rbp]
  0016a	45 01 59 04	 add	 DWORD PTR [r9+4], r11d
  0016e	41 01 79 08	 add	 DWORD PTR [r9+8], edi
  00172	45 01 79 0c	 add	 DWORD PTR [r9+12], r15d
  00176	45 01 51 10	 add	 DWORD PTR [r9+16], r10d
  0017a	41 01 71 14	 add	 DWORD PTR [r9+20], esi
  0017e	45 01 71 18	 add	 DWORD PTR [r9+24], r14d
  00182	41 89 41 1c	 mov	 DWORD PTR [r9+28], eax

; 6845 : }

  00186	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  0018d	41 5f		 pop	 r15
  0018f	41 5e		 pop	 r14
  00191	41 5d		 pop	 r13
  00193	41 5c		 pop	 r12
  00195	5f		 pop	 rdi
  00196	5e		 pop	 rsi
  00197	5d		 pop	 rbp
  00198	5b		 pop	 rbx
  00199	c3		 ret	 0
mg_sha256_chunk ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_sha256_update
_TEXT	SEGMENT
ctx$ = 48
data$ = 56
len$ = 64
mg_sha256_update PROC					; COMDAT

; 6848 :                       size_t len) {

$LN13:

; 6849 :   size_t i;
; 6850 :   for (i = 0; i < len; i++) {

  00000	4d 85 c0	 test	 r8, r8
  00003	74 64		 je	 SHORT $LN11@mg_sha256_
  00005	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  0000a	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000f	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 6848 :                       size_t len) {

  00019	49 8b f0	 mov	 rsi, r8
  0001c	48 8b ea	 mov	 rbp, rdx
  0001f	48 8b d9	 mov	 rbx, rcx

; 6849 :   size_t i;
; 6850 :   for (i = 0; i < len; i++) {

  00022	33 ff		 xor	 edi, edi
$LL4@mg_sha256_:

; 6851 :     ctx->buffer[ctx->len] = data[i];

  00024	44 8b 4b 28	 mov	 r9d, DWORD PTR [rbx+40]
  00028	8a 04 2f	 mov	 al, BYTE PTR [rdi+rbp]
  0002b	41 88 44 19 2c	 mov	 BYTE PTR [r9+rbx+44], al

; 6852 :     if ((++ctx->len) == 64) {

  00030	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00033	83 7b 28 40	 cmp	 DWORD PTR [rbx+40], 64	; 00000040H
  00037	75 14		 jne	 SHORT $LN2@mg_sha256_

; 6853 :       mg_sha256_chunk(ctx);

  00039	48 8b cb	 mov	 rcx, rbx
  0003c	e8 00 00 00 00	 call	 mg_sha256_chunk

; 6854 :       ctx->bits += 512;

  00041	48 81 43 20 00
	02 00 00	 add	 QWORD PTR [rbx+32], 512	; 00000200H

; 6855 :       ctx->len = 0;

  00049	83 63 28 00	 and	 DWORD PTR [rbx+40], 0
$LN2@mg_sha256_:

; 6849 :   size_t i;
; 6850 :   for (i = 0; i < len; i++) {

  0004d	48 ff c7	 inc	 rdi
  00050	48 3b fe	 cmp	 rdi, rsi
  00053	72 cf		 jb	 SHORT $LL4@mg_sha256_

; 6856 :     }
; 6857 :   }
; 6858 : }

  00055	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005a	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0005f	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00064	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00068	5f		 pop	 rdi
$LN11@mg_sha256_:
  00069	c3		 ret	 0
mg_sha256_update ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_sha256_final
_TEXT	SEGMENT
digest$ = 48
ctx$ = 56
mg_sha256_final PROC					; COMDAT

; 6861 : void mg_sha256_final(unsigned char digest[32], mg_sha256_ctx *ctx) {

$LN25:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 6862 :   uint32_t i = ctx->len;

  0000a	44 8b 42 28	 mov	 r8d, DWORD PTR [rdx+40]
  0000e	48 8b da	 mov	 rbx, rdx

; 6863 :   if (i < 56) {

  00011	41 b9 38 00 00
	00		 mov	 r9d, 56			; 00000038H
  00017	48 8b f9	 mov	 rdi, rcx
  0001a	41 c6 44 18 2c
	80		 mov	 BYTE PTR [r8+rbx+44], 128 ; 00000080H
  00020	41 8d 50 01	 lea	 edx, DWORD PTR [r8+1]
  00024	45 3b c1	 cmp	 r8d, r9d
  00027	73 1d		 jae	 SHORT $LN9@mg_sha256_

; 6864 :     ctx->buffer[i++] = 0x80;
; 6865 :     while (i < 56) {

  00029	41 3b d1	 cmp	 edx, r9d
  0002c	73 53		 jae	 SHORT $LN10@mg_sha256_

; 6866 :       ctx->buffer[i++] = 0x00;
; 6867 :     }
; 6868 :   } else {

  0002e	8b ca		 mov	 ecx, edx
  00030	44 2b ca	 sub	 r9d, edx
  00033	48 83 c1 2c	 add	 rcx, 44			; 0000002cH
  00037	45 8b c1	 mov	 r8d, r9d
  0003a	48 03 cb	 add	 rcx, rbx
  0003d	33 d2		 xor	 edx, edx
  0003f	e8 00 00 00 00	 call	 memset
  00044	eb 3b		 jmp	 SHORT $LN10@mg_sha256_
$LN9@mg_sha256_:

; 6869 :     ctx->buffer[i++] = 0x80;
; 6870 :     while (i < 64) {

  00046	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0004c	41 3b d0	 cmp	 edx, r8d
  0004f	73 13		 jae	 SHORT $LN4@mg_sha256_
  00051	8b ca		 mov	 ecx, edx
  00053	44 2b c2	 sub	 r8d, edx
  00056	48 83 c1 2c	 add	 rcx, 44			; 0000002cH
  0005a	33 d2		 xor	 edx, edx
  0005c	48 03 cb	 add	 rcx, rbx
  0005f	e8 00 00 00 00	 call	 memset
$LN4@mg_sha256_:

; 6871 :       ctx->buffer[i++] = 0x00;
; 6872 :     }
; 6873 :     mg_sha256_chunk(ctx);

  00064	48 8b cb	 mov	 rcx, rbx
  00067	e8 00 00 00 00	 call	 mg_sha256_chunk
  0006c	0f 57 c0	 xorps	 xmm0, xmm0

; 6874 :     memset(ctx->buffer, 0, 56);

  0006f	33 c0		 xor	 eax, eax
  00071	0f 11 43 2c	 movups	 XMMWORD PTR [rbx+44], xmm0
  00075	0f 11 43 3c	 movups	 XMMWORD PTR [rbx+60], xmm0
  00079	0f 11 43 4c	 movups	 XMMWORD PTR [rbx+76], xmm0
  0007d	48 89 43 5c	 mov	 QWORD PTR [rbx+92], rax
$LN10@mg_sha256_:

; 6875 :   }
; 6876 : 
; 6877 :   ctx->bits += ctx->len * 8;

  00081	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  00084	c1 e1 03	 shl	 ecx, 3
  00087	48 03 4b 20	 add	 rcx, QWORD PTR [rbx+32]
  0008b	48 89 4b 20	 mov	 QWORD PTR [rbx+32], rcx

; 6878 :   ctx->buffer[63] = (uint8_t) ((ctx->bits) & 0xff);
; 6879 :   ctx->buffer[62] = (uint8_t) ((ctx->bits >> 8) & 0xff);

  0008f	8a 43 21	 mov	 al, BYTE PTR [rbx+33]
  00092	88 43 6a	 mov	 BYTE PTR [rbx+106], al

; 6880 :   ctx->buffer[61] = (uint8_t) ((ctx->bits >> 16) & 0xff);

  00095	8a 43 22	 mov	 al, BYTE PTR [rbx+34]
  00098	88 43 69	 mov	 BYTE PTR [rbx+105], al

; 6881 :   ctx->buffer[60] = (uint8_t) ((ctx->bits >> 24) & 0xff);

  0009b	8a 43 23	 mov	 al, BYTE PTR [rbx+35]
  0009e	88 43 68	 mov	 BYTE PTR [rbx+104], al

; 6882 :   ctx->buffer[59] = (uint8_t) ((ctx->bits >> 32) & 0xff);

  000a1	8a 43 24	 mov	 al, BYTE PTR [rbx+36]
  000a4	88 43 67	 mov	 BYTE PTR [rbx+103], al

; 6883 :   ctx->buffer[58] = (uint8_t) ((ctx->bits >> 40) & 0xff);

  000a7	8a 43 25	 mov	 al, BYTE PTR [rbx+37]
  000aa	88 43 66	 mov	 BYTE PTR [rbx+102], al

; 6884 :   ctx->buffer[57] = (uint8_t) ((ctx->bits >> 48) & 0xff);

  000ad	8a 43 26	 mov	 al, BYTE PTR [rbx+38]
  000b0	88 43 65	 mov	 BYTE PTR [rbx+101], al

; 6885 :   ctx->buffer[56] = (uint8_t) ((ctx->bits >> 56) & 0xff);

  000b3	8a 43 27	 mov	 al, BYTE PTR [rbx+39]
  000b6	88 4b 6b	 mov	 BYTE PTR [rbx+107], cl

; 6886 :   mg_sha256_chunk(ctx);

  000b9	48 8b cb	 mov	 rcx, rbx
  000bc	88 43 64	 mov	 BYTE PTR [rbx+100], al
  000bf	e8 00 00 00 00	 call	 mg_sha256_chunk
  000c4	45 33 c0	 xor	 r8d, r8d
  000c7	48 8d 57 08	 lea	 rdx, QWORD PTR [rdi+8]
$LL8@mg_sha256_:

; 6887 : 
; 6888 :   for (i = 0; i < 4; ++i) {
; 6889 :     digest[i] = (ctx->state[0] >> (24 - i * 8)) & 0xff;

  000cb	8b 03		 mov	 eax, DWORD PTR [rbx]
  000cd	b9 18 00 00 00	 mov	 ecx, 24
  000d2	41 2b c8	 sub	 ecx, r8d
  000d5	41 83 c0 08	 add	 r8d, 8
  000d9	d3 e8		 shr	 eax, cl
  000db	88 07		 mov	 BYTE PTR [rdi], al
  000dd	48 ff c7	 inc	 rdi

; 6890 :     digest[i + 4] = (ctx->state[1] >> (24 - i * 8)) & 0xff;

  000e0	8b 43 04	 mov	 eax, DWORD PTR [rbx+4]
  000e3	d3 e8		 shr	 eax, cl
  000e5	88 42 fc	 mov	 BYTE PTR [rdx-4], al

; 6891 :     digest[i + 8] = (ctx->state[2] >> (24 - i * 8)) & 0xff;

  000e8	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  000eb	d3 e8		 shr	 eax, cl
  000ed	88 02		 mov	 BYTE PTR [rdx], al

; 6892 :     digest[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0xff;

  000ef	8b 43 0c	 mov	 eax, DWORD PTR [rbx+12]
  000f2	d3 e8		 shr	 eax, cl
  000f4	88 42 04	 mov	 BYTE PTR [rdx+4], al

; 6893 :     digest[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0xff;

  000f7	8b 43 10	 mov	 eax, DWORD PTR [rbx+16]
  000fa	d3 e8		 shr	 eax, cl
  000fc	88 42 08	 mov	 BYTE PTR [rdx+8], al

; 6894 :     digest[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0xff;

  000ff	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  00102	d3 e8		 shr	 eax, cl
  00104	88 42 0c	 mov	 BYTE PTR [rdx+12], al

; 6895 :     digest[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0xff;

  00107	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  0010a	d3 e8		 shr	 eax, cl
  0010c	88 42 10	 mov	 BYTE PTR [rdx+16], al

; 6896 :     digest[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0xff;

  0010f	8b 43 1c	 mov	 eax, DWORD PTR [rbx+28]
  00112	d3 e8		 shr	 eax, cl
  00114	88 42 14	 mov	 BYTE PTR [rdx+20], al
  00117	48 ff c2	 inc	 rdx
  0011a	41 83 f8 20	 cmp	 r8d, 32			; 00000020H
  0011e	72 ab		 jb	 SHORT $LL8@mg_sha256_

; 6897 :   }
; 6898 : }

  00120	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00125	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00129	5f		 pop	 rdi
  0012a	c3		 ret	 0
mg_sha256_final ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_hmac_sha256
_TEXT	SEGMENT
ctx$ = 32
k$ = 144
i_pad$ = 208
o_pad$ = 272
dst$ = 368
key$ = 376
keysz$ = 384
data$ = 392
datasz$ = 400
mg_hmac_sha256 PROC					; COMDAT

; 6901 :                     size_t datasz) {

$LN23:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000f	55		 push	 rbp
  00010	41 54		 push	 r12
  00012	41 56		 push	 r14
  00014	48 8d 68 98	 lea	 rbp, QWORD PTR [rax-104]
  00018	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H
  0001f	49 8b d8	 mov	 rbx, r8
  00022	48 8b fa	 mov	 rdi, rdx
  00025	48 8b f1	 mov	 rsi, rcx

; 6902 :   mg_sha256_ctx ctx;
; 6903 :   uint8_t k[64] = {0};

  00028	41 bc 40 00 00
	00		 mov	 r12d, 64		; 00000040H
  0002e	45 8b c4	 mov	 r8d, r12d
  00031	48 8d 4d 90	 lea	 rcx, QWORD PTR k$[rbp-256]
  00035	33 d2		 xor	 edx, edx
  00037	4d 8b f1	 mov	 r14, r9
  0003a	e8 00 00 00 00	 call	 memset

; 6904 :   uint8_t o_pad[64], i_pad[64];
; 6905 :   unsigned int i;
; 6906 :   memset(i_pad, 0x36, sizeof(i_pad));

  0003f	45 8b c4	 mov	 r8d, r12d
  00042	41 8d 54 24 f6	 lea	 edx, QWORD PTR [r12-10]
  00047	48 8d 4d d0	 lea	 rcx, QWORD PTR i_pad$[rbp-256]
  0004b	e8 00 00 00 00	 call	 memset

; 6907 :   memset(o_pad, 0x5c, sizeof(o_pad));

  00050	45 8b c4	 mov	 r8d, r12d
  00053	41 8d 54 24 1c	 lea	 edx, QWORD PTR [r12+28]
  00058	48 8d 4d 10	 lea	 rcx, QWORD PTR o_pad$[rbp-256]
  0005c	e8 00 00 00 00	 call	 memset

; 6908 :   if (keysz < 64) {

  00061	4c 8b c3	 mov	 r8, rbx
  00064	48 8b d7	 mov	 rdx, rdi
  00067	49 3b dc	 cmp	 rbx, r12
  0006a	73 0b		 jae	 SHORT $LN5@mg_hmac_sh

; 6909 :     memmove(k, key, keysz);

  0006c	48 8d 4d 90	 lea	 rcx, QWORD PTR k$[rbp-256]
  00070	e8 00 00 00 00	 call	 memcpy

; 6910 :   } else {

  00075	eb 63		 jmp	 SHORT $LN6@mg_hmac_sh
$LN5@mg_hmac_sh:

; 6793 :   ctx->len = 0;

  00077	83 64 24 48 00	 and	 DWORD PTR ctx$[rsp+40], 0

; 6911 :     mg_sha256_init(&ctx);
; 6912 :     mg_sha256_update(&ctx, key, keysz);

  0007c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]

; 6794 :   ctx->bits = 0;

  00081	48 83 64 24 40
	00		 and	 QWORD PTR ctx$[rsp+32], 0

; 6795 :   ctx->state[0] = 0x6a09e667;

  00087	c7 44 24 20 67
	e6 09 6a	 mov	 DWORD PTR ctx$[rsp], 1779033703 ; 6a09e667H

; 6796 :   ctx->state[1] = 0xbb67ae85;

  0008f	c7 44 24 24 85
	ae 67 bb	 mov	 DWORD PTR ctx$[rsp+4], -1150833019 ; bb67ae85H

; 6797 :   ctx->state[2] = 0x3c6ef372;

  00097	c7 44 24 28 72
	f3 6e 3c	 mov	 DWORD PTR ctx$[rsp+8], 1013904242 ; 3c6ef372H

; 6798 :   ctx->state[3] = 0xa54ff53a;

  0009f	c7 44 24 2c 3a
	f5 4f a5	 mov	 DWORD PTR ctx$[rsp+12], -1521486534 ; a54ff53aH

; 6799 :   ctx->state[4] = 0x510e527f;

  000a7	c7 44 24 30 7f
	52 0e 51	 mov	 DWORD PTR ctx$[rsp+16], 1359893119 ; 510e527fH

; 6800 :   ctx->state[5] = 0x9b05688c;

  000af	c7 44 24 34 8c
	68 05 9b	 mov	 DWORD PTR ctx$[rsp+20], -1694144372 ; 9b05688cH

; 6801 :   ctx->state[6] = 0x1f83d9ab;

  000b7	c7 44 24 38 ab
	d9 83 1f	 mov	 DWORD PTR ctx$[rsp+24], 528734635 ; 1f83d9abH

; 6802 :   ctx->state[7] = 0x5be0cd19;

  000bf	c7 44 24 3c 19
	cd e0 5b	 mov	 DWORD PTR ctx$[rsp+28], 1541459225 ; 5be0cd19H

; 6911 :     mg_sha256_init(&ctx);
; 6912 :     mg_sha256_update(&ctx, key, keysz);

  000c7	e8 00 00 00 00	 call	 mg_sha256_update

; 6913 :     mg_sha256_final(k, &ctx);

  000cc	48 8d 54 24 20	 lea	 rdx, QWORD PTR ctx$[rsp]
  000d1	48 8d 4d 90	 lea	 rcx, QWORD PTR k$[rbp-256]
  000d5	e8 00 00 00 00	 call	 mg_sha256_final
$LN6@mg_hmac_sh:

; 6914 :   }
; 6915 :   for (i = 0; i < sizeof(k); i++) {

  000da	33 c0		 xor	 eax, eax
  000dc	8d 48 04	 lea	 ecx, QWORD PTR [rax+4]
$LL4@mg_hmac_sh:

; 6916 :     i_pad[i] ^= k[i];

  000df	f3 0f 6f 4c 05
	90		 movdqu	 xmm1, XMMWORD PTR k$[rbp+rax-256]
  000e5	f3 0f 6f 44 05
	d0		 movdqu	 xmm0, XMMWORD PTR i_pad$[rbp+rax-256]
  000eb	48 8d 40 10	 lea	 rax, QWORD PTR [rax+16]
  000ef	66 0f ef c1	 pxor	 xmm0, xmm1
  000f3	f3 0f 7f 44 05
	c0		 movdqu	 XMMWORD PTR i_pad$[rbp+rax-272], xmm0

; 6917 :     o_pad[i] ^= k[i];

  000f9	f3 0f 6f 44 05
	00		 movdqu	 xmm0, XMMWORD PTR o_pad$[rbp+rax-272]
  000ff	66 0f ef c1	 pxor	 xmm0, xmm1
  00103	f3 0f 7f 44 05
	00		 movdqu	 XMMWORD PTR o_pad$[rbp+rax-272], xmm0
  00109	48 83 e9 01	 sub	 rcx, 1
  0010d	75 d0		 jne	 SHORT $LL4@mg_hmac_sh

; 6793 :   ctx->len = 0;

  0010f	21 4c 24 48	 and	 DWORD PTR ctx$[rsp+40], ecx

; 6918 :   }
; 6919 :   mg_sha256_init(&ctx);
; 6920 :   mg_sha256_update(&ctx, i_pad, sizeof(i_pad));

  00113	48 8d 55 d0	 lea	 rdx, QWORD PTR i_pad$[rbp-256]

; 6794 :   ctx->bits = 0;

  00117	48 21 4c 24 40	 and	 QWORD PTR ctx$[rsp+32], rcx

; 6796 :   ctx->state[1] = 0xbb67ae85;

  0011c	bb 85 ae 67 bb	 mov	 ebx, -1150833019	; bb67ae85H

; 6797 :   ctx->state[2] = 0x3c6ef372;

  00121	bf 72 f3 6e 3c	 mov	 edi, 1013904242		; 3c6ef372H
  00126	89 5c 24 24	 mov	 DWORD PTR ctx$[rsp+4], ebx

; 6918 :   }
; 6919 :   mg_sha256_init(&ctx);
; 6920 :   mg_sha256_update(&ctx, i_pad, sizeof(i_pad));

  0012a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]

; 6797 :   ctx->state[2] = 0x3c6ef372;

  0012f	89 7c 24 28	 mov	 DWORD PTR ctx$[rsp+8], edi

; 6918 :   }
; 6919 :   mg_sha256_init(&ctx);
; 6920 :   mg_sha256_update(&ctx, i_pad, sizeof(i_pad));

  00133	4d 8b c4	 mov	 r8, r12

; 6795 :   ctx->state[0] = 0x6a09e667;

  00136	c7 44 24 20 67
	e6 09 6a	 mov	 DWORD PTR ctx$[rsp], 1779033703 ; 6a09e667H

; 6798 :   ctx->state[3] = 0xa54ff53a;

  0013e	c7 44 24 2c 3a
	f5 4f a5	 mov	 DWORD PTR ctx$[rsp+12], -1521486534 ; a54ff53aH

; 6799 :   ctx->state[4] = 0x510e527f;

  00146	c7 44 24 30 7f
	52 0e 51	 mov	 DWORD PTR ctx$[rsp+16], 1359893119 ; 510e527fH

; 6800 :   ctx->state[5] = 0x9b05688c;

  0014e	c7 44 24 34 8c
	68 05 9b	 mov	 DWORD PTR ctx$[rsp+20], -1694144372 ; 9b05688cH

; 6801 :   ctx->state[6] = 0x1f83d9ab;

  00156	c7 44 24 38 ab
	d9 83 1f	 mov	 DWORD PTR ctx$[rsp+24], 528734635 ; 1f83d9abH

; 6802 :   ctx->state[7] = 0x5be0cd19;

  0015e	c7 44 24 3c 19
	cd e0 5b	 mov	 DWORD PTR ctx$[rsp+28], 1541459225 ; 5be0cd19H

; 6918 :   }
; 6919 :   mg_sha256_init(&ctx);
; 6920 :   mg_sha256_update(&ctx, i_pad, sizeof(i_pad));

  00166	e8 00 00 00 00	 call	 mg_sha256_update

; 6921 :   mg_sha256_update(&ctx, data, datasz);

  0016b	4c 8b 85 90 00
	00 00		 mov	 r8, QWORD PTR datasz$[rbp-256]
  00172	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  00177	49 8b d6	 mov	 rdx, r14
  0017a	e8 00 00 00 00	 call	 mg_sha256_update

; 6922 :   mg_sha256_final(dst, &ctx);

  0017f	48 8d 54 24 20	 lea	 rdx, QWORD PTR ctx$[rsp]
  00184	48 8b ce	 mov	 rcx, rsi
  00187	e8 00 00 00 00	 call	 mg_sha256_final

; 6793 :   ctx->len = 0;

  0018c	83 64 24 48 00	 and	 DWORD PTR ctx$[rsp+40], 0

; 6923 :   mg_sha256_init(&ctx);
; 6924 :   mg_sha256_update(&ctx, o_pad, sizeof(o_pad));

  00191	48 8d 55 10	 lea	 rdx, QWORD PTR o_pad$[rbp-256]

; 6794 :   ctx->bits = 0;

  00195	48 83 64 24 40
	00		 and	 QWORD PTR ctx$[rsp+32], 0

; 6923 :   mg_sha256_init(&ctx);
; 6924 :   mg_sha256_update(&ctx, o_pad, sizeof(o_pad));

  0019b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  001a0	4d 8b c4	 mov	 r8, r12

; 6795 :   ctx->state[0] = 0x6a09e667;

  001a3	c7 44 24 20 67
	e6 09 6a	 mov	 DWORD PTR ctx$[rsp], 1779033703 ; 6a09e667H

; 6796 :   ctx->state[1] = 0xbb67ae85;

  001ab	89 5c 24 24	 mov	 DWORD PTR ctx$[rsp+4], ebx

; 6797 :   ctx->state[2] = 0x3c6ef372;

  001af	89 7c 24 28	 mov	 DWORD PTR ctx$[rsp+8], edi

; 6798 :   ctx->state[3] = 0xa54ff53a;

  001b3	c7 44 24 2c 3a
	f5 4f a5	 mov	 DWORD PTR ctx$[rsp+12], -1521486534 ; a54ff53aH

; 6799 :   ctx->state[4] = 0x510e527f;

  001bb	c7 44 24 30 7f
	52 0e 51	 mov	 DWORD PTR ctx$[rsp+16], 1359893119 ; 510e527fH

; 6800 :   ctx->state[5] = 0x9b05688c;

  001c3	c7 44 24 34 8c
	68 05 9b	 mov	 DWORD PTR ctx$[rsp+20], -1694144372 ; 9b05688cH

; 6801 :   ctx->state[6] = 0x1f83d9ab;

  001cb	c7 44 24 38 ab
	d9 83 1f	 mov	 DWORD PTR ctx$[rsp+24], 528734635 ; 1f83d9abH

; 6802 :   ctx->state[7] = 0x5be0cd19;

  001d3	c7 44 24 3c 19
	cd e0 5b	 mov	 DWORD PTR ctx$[rsp+28], 1541459225 ; 5be0cd19H

; 6923 :   mg_sha256_init(&ctx);
; 6924 :   mg_sha256_update(&ctx, o_pad, sizeof(o_pad));

  001db	e8 00 00 00 00	 call	 mg_sha256_update

; 6925 :   mg_sha256_update(&ctx, dst, 32);

  001e0	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  001e6	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ctx$[rsp]
  001eb	48 8b d6	 mov	 rdx, rsi
  001ee	e8 00 00 00 00	 call	 mg_sha256_update

; 6926 :   mg_sha256_final(dst, &ctx);

  001f3	48 8d 54 24 20	 lea	 rdx, QWORD PTR ctx$[rsp]
  001f8	48 8b ce	 mov	 rcx, rsi
  001fb	e8 00 00 00 00	 call	 mg_sha256_final

; 6927 : }

  00200	4c 8d 9c 24 50
	01 00 00	 lea	 r11, QWORD PTR [rsp+336]
  00208	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  0020c	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  00210	49 8b 7b 30	 mov	 rdi, QWORD PTR [r11+48]
  00214	49 8b e3	 mov	 rsp, r11
  00217	41 5e		 pop	 r14
  00219	41 5c		 pop	 r12
  0021b	5d		 pop	 rbp
  0021c	c3		 ret	 0
mg_hmac_sha256 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT gettimestamp
_TEXT	SEGMENT
data$ = 8
gettimestamp PROC					; COMDAT

; 13799:   memcpy(&data, &net, sizeof(data));

  00000	8b 01		 mov	 eax, DWORD PTR [rcx]

; 6942 : static int64_t gettimestamp(const uint32_t *data) {

  00002	4c 8b c1	 mov	 r8, rcx

; 13800:   return (((uint32_t) data[3]) << 0) | (((uint32_t) data[2]) << 8) |

  00005	8b d0		 mov	 edx, eax
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	c1 ea 08	 shr	 edx, 8
  0000d	44 0f b6 ca	 movzx	 r9d, dl
  00011	0f b6 d0	 movzx	 edx, al
  00014	c1 e2 08	 shl	 edx, 8
  00017	44 0b ca	 or	 r9d, edx
  0001a	8b d0		 mov	 edx, eax
  0001c	c1 e8 18	 shr	 eax, 24
  0001f	41 c1 e1 08	 shl	 r9d, 8
  00023	c1 ea 10	 shr	 edx, 16
  00026	0f b6 ca	 movzx	 ecx, dl
  00029	44 0b c9	 or	 r9d, ecx
  0002c	41 c1 e1 08	 shl	 r9d, 8
  00030	44 0b c8	 or	 r9d, eax

; 13799:   memcpy(&data, &net, sizeof(data));

  00033	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  00037	8b c8		 mov	 ecx, eax
  00039	c1 e9 08	 shr	 ecx, 8

; 13800:   return (((uint32_t) data[3]) << 0) | (((uint32_t) data[2]) << 8) |

  0003c	44 0f b6 c1	 movzx	 r8d, cl
  00040	0f b6 c8	 movzx	 ecx, al

; 6943 :   uint32_t sec = mg_ntohl(data[0]), frac = mg_ntohl(data[1]);

  00043	c1 e1 08	 shl	 ecx, 8

; 13800:   return (((uint32_t) data[3]) << 0) | (((uint32_t) data[2]) << 8) |

  00046	44 0b c1	 or	 r8d, ecx
  00049	8b c8		 mov	 ecx, eax
  0004b	c1 e8 18	 shr	 eax, 24
  0004e	c1 e9 10	 shr	 ecx, 16
  00051	41 c1 e0 08	 shl	 r8d, 8
  00055	0f b6 d1	 movzx	 edx, cl
  00058	44 0b c2	 or	 r8d, edx
  0005b	41 c1 e0 08	 shl	 r8d, 8
  0005f	41 0b c0	 or	 eax, r8d

; 6944 :   if (sec) sec -= SNTP_TIME_OFFSET;
; 6945 :   return ((int64_t) sec) * 1000 + (int64_t) (frac / SNTP_MAX_FRAC * 1000.0);

  00062	45 85 c9	 test	 r9d, r9d
  00065	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0006a	41 8d 81 80 81
	55 7c		 lea	 eax, DWORD PTR [r9+2085978496]
  00071	41 0f 44 c1	 cmove	 eax, r9d
  00075	48 69 c0 e8 03
	00 00		 imul	 rax, rax, 1000		; 000003e8H
  0007c	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@c1efffffffe00000
  00084	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@408f400000000000
  0008c	f2 48 0f 2c c8	 cvttsd2si rcx, xmm0
  00091	48 2b c1	 sub	 rax, rcx

; 6946 : }

  00094	c3		 ret	 0
gettimestamp ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_sntp_parse
_TEXT	SEGMENT
buf$ = 64
len$ = 72
mg_sntp_parse PROC					; COMDAT

; 6948 : int64_t mg_sntp_parse(const unsigned char *buf, size_t len) {

$LN44:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 6949 :   int64_t res = -1;

  00019	48 83 cf ff	 or	 rdi, -1
  0001d	4c 8b d1	 mov	 r10, rcx

; 6950 :   int mode = len > 0 ? buf[0] & 7 : 0;

  00020	48 85 d2	 test	 rdx, rdx
  00023	0f 84 3d 01 00
	00		 je	 $LN38@mg_sntp_pa

; 6951 :   int version = len > 0 ? (buf[0] >> 3) & 7 : 0;

  00029	0f b6 19	 movzx	 ebx, BYTE PTR [rcx]
  0002c	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  0002f	c1 eb 03	 shr	 ebx, 3
  00032	83 e0 07	 and	 eax, 7
  00035	83 e3 07	 and	 ebx, 7

; 6952 :   if (len < 48) {

  00038	48 83 fa 30	 cmp	 rdx, 48			; 00000030H
  0003c	0f 82 24 01 00
	00		 jb	 $LN38@mg_sntp_pa

; 6954 :   } else if (mode != 4 && mode != 5) {

  00042	83 c0 fc	 add	 eax, -4			; fffffffcH
  00045	8d 4f 02	 lea	 ecx, QWORD PTR [rdi+2]
  00048	3b c1		 cmp	 eax, ecx
  0004a	76 2a		 jbe	 SHORT $LN20@mg_sntp_pa

; 6955 :     MG_ERROR(("%s", "not a server reply"));

  0004c	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  00052	0f 8c 40 01 00
	00		 jl	 $LN15@mg_sntp_pa
  00058	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0O@HEBLIINH@mg_sntp_parse@
  0005f	41 b8 2b 1b 00
	00		 mov	 r8d, 6955		; 00001b2bH
  00065	e8 00 00 00 00	 call	 mg_log_prefix
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@ODENNIKF@not?5a?5server?5reply@

; 6956 :   } else if (buf[1] == 0) {

  00071	e9 16 01 00 00	 jmp	 $LN42@mg_sntp_pa
$LN20@mg_sntp_pa:
  00076	41 80 7a 01 00	 cmp	 BYTE PTR [r10+1], 0
  0007b	75 2a		 jne	 SHORT $LN23@mg_sntp_pa

; 6957 :     MG_ERROR(("%s", "server sent a kiss of death"));

  0007d	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  00083	0f 8c 0f 01 00
	00		 jl	 $LN15@mg_sntp_pa
  00089	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0O@HEBLIINH@mg_sntp_parse@
  00090	41 b8 2d 1b 00
	00		 mov	 r8d, 6957		; 00001b2dH
  00096	e8 00 00 00 00	 call	 mg_log_prefix
  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@DMBHJOKM@server?5sent?5a?5kiss?5of?5death@

; 6958 :   } else if (version == 4 || version == 3) {

  000a2	e9 e5 00 00 00	 jmp	 $LN42@mg_sntp_pa
$LN23@mg_sntp_pa:
  000a7	8d 43 fd	 lea	 eax, DWORD PTR [rbx-3]
  000aa	3b c1		 cmp	 eax, ecx
  000ac	76 31		 jbe	 SHORT $LN28@mg_sntp_pa

; 6967 :   } else {
; 6968 :     MG_ERROR(("unexpected version: %d", version));

  000ae	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  000b4	0f 8c de 00 00
	00		 jl	 $LN15@mg_sntp_pa
  000ba	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0O@HEBLIINH@mg_sntp_parse@
  000c1	41 b8 38 1b 00
	00		 mov	 r8d, 6968		; 00001b38H
  000c7	e8 00 00 00 00	 call	 mg_log_prefix
  000cc	8b d3		 mov	 edx, ebx
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@HEKJPPM@unexpected?5version?3?5?$CFd@
  000d5	e8 00 00 00 00	 call	 mg_log
  000da	e9 b9 00 00 00	 jmp	 $LN15@mg_sntp_pa
$LN28@mg_sntp_pa:

; 6959 :     // int64_t ref = gettimestamp((uint32_t *) &buf[16]);
; 6960 :     int64_t t0 = gettimestamp((uint32_t *) &buf[24]);

  000df	49 8d 4a 18	 lea	 rcx, QWORD PTR [r10+24]
  000e3	e8 00 00 00 00	 call	 gettimestamp

; 6961 :     int64_t t1 = gettimestamp((uint32_t *) &buf[32]);

  000e8	49 8d 4a 20	 lea	 rcx, QWORD PTR [r10+32]
  000ec	48 8b f8	 mov	 rdi, rax
  000ef	e8 00 00 00 00	 call	 gettimestamp

; 6962 :     int64_t t2 = gettimestamp((uint32_t *) &buf[40]);

  000f4	49 8d 4a 28	 lea	 rcx, QWORD PTR [r10+40]
  000f8	48 8b e8	 mov	 rbp, rax
  000fb	e8 00 00 00 00	 call	 gettimestamp
  00100	48 8b f0	 mov	 rsi, rax

; 13865:   return GetTickCount();

  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount

; 6963 :     int64_t t3 = (int64_t) mg_millis();
; 6964 :     int64_t delta = (t3 - t0) - (t2 - t1);

  00109	8b d8		 mov	 ebx, eax

; 6965 :     MG_VERBOSE(("%lld %lld %lld %lld delta:%lld", t0, t1, t2, t3, delta));

  0010b	b9 04 00 00 00	 mov	 ecx, 4
  00110	48 2b de	 sub	 rbx, rsi

; 13865:   return GetTickCount();

  00113	44 8b f0	 mov	 r14d, eax

; 6963 :     int64_t t3 = (int64_t) mg_millis();
; 6964 :     int64_t delta = (t3 - t0) - (t2 - t1);

  00116	48 2b df	 sub	 rbx, rdi
  00119	48 03 dd	 add	 rbx, rbp

; 6965 :     MG_VERBOSE(("%lld %lld %lld %lld delta:%lld", t0, t1, t2, t3, delta));

  0011c	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  00122	7c 31		 jl	 SHORT $LN11@mg_sntp_pa
  00124	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0O@HEBLIINH@mg_sntp_parse@
  0012b	41 b8 35 1b 00
	00		 mov	 r8d, 6965		; 00001b35H
  00131	e8 00 00 00 00	 call	 mg_log_prefix
  00136	4c 8b ce	 mov	 r9, rsi
  00139	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx
  0013e	4c 8b c5	 mov	 r8, rbp
  00141	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00146	48 8b d7	 mov	 rdx, rdi
  00149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@BOHGPAAD@?$CFlld?5?$CFlld?5?$CFlld?5?$CFlld?5delta?3?$CFlld@
  00150	e8 00 00 00 00	 call	 mg_log
$LN11@mg_sntp_pa:

; 6966 :     res = t2 + delta / 2;

  00155	48 8b c3	 mov	 rax, rbx
  00158	48 99		 cdq
  0015a	48 2b c2	 sub	 rax, rdx
  0015d	48 d1 f8	 sar	 rax, 1
  00160	48 8d 3c 06	 lea	 rdi, QWORD PTR [rsi+rax]
  00164	eb 32		 jmp	 SHORT $LN15@mg_sntp_pa
$LN38@mg_sntp_pa:

; 6953 :     MG_ERROR(("%s", "corrupt packet"));

  00166	b9 01 00 00 00	 mov	 ecx, 1
  0016b	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  00171	7c 25		 jl	 SHORT $LN15@mg_sntp_pa
  00173	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0O@HEBLIINH@mg_sntp_parse@
  0017a	41 b8 29 1b 00
	00		 mov	 r8d, 6953		; 00001b29H
  00180	e8 00 00 00 00	 call	 mg_log_prefix
  00185	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@IGMAHBCN@corrupt?5packet@
$LN42@mg_sntp_pa:

; 6969 :   }
; 6970 :   return res;

  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00193	e8 00 00 00 00	 call	 mg_log
$LN15@mg_sntp_pa:

; 6971 : }

  00198	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0019d	48 8b c7	 mov	 rax, rdi
  001a0	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  001a5	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001aa	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001af	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001b3	41 5e		 pop	 r14
  001b5	c3		 ret	 0
mg_sntp_parse ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT sntp_cb
_TEXT	SEGMENT
c$ = 48
ev$ = 56
ev_data$ = 64
milliseconds$1 = 72
sntp_cb	PROC						; COMDAT

; 6973 : static void sntp_cb(struct mg_connection *c, int ev, void *ev_data) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 6974 :   if (ev == MG_EV_READ) {

  0000d	83 fa 07	 cmp	 edx, 7
  00010	0f 85 c6 00 00
	00		 jne	 $LN8@sntp_cb

; 6975 :     int64_t milliseconds = mg_sntp_parse(c->recv.buf, c->recv.len);

  00016	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  0001a	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  0001e	e8 00 00 00 00	 call	 mg_sntp_parse
  00023	48 89 44 24 48	 mov	 QWORD PTR milliseconds$1[rsp], rax

; 6976 :     if (milliseconds > 0) {

  00028	48 85 c0	 test	 rax, rax
  0002b	0f 8e 9a 00 00
	00		 jle	 $LN6@sntp_cb

; 6977 :       MG_INFO(("%lu got time: %lld ms from epoch", c->id, milliseconds));

  00031	b9 02 00 00 00	 mov	 ecx, 2
  00036	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  0003c	7c 26		 jl	 SHORT $LN2@sntp_cb
  0003e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_07IENOENON@sntp_cb@
  00045	41 b8 41 1b 00
	00		 mov	 r8d, 6977		; 00001b41H
  0004b	e8 00 00 00 00	 call	 mg_log_prefix
  00050	4c 8b 44 24 48	 mov	 r8, QWORD PTR milliseconds$1[rsp]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@NMDLDFPE@?$CFlu?5got?5time?3?5?$CFlld?5ms?5from?5epoc@
  0005c	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  0005f	e8 00 00 00 00	 call	 mg_log
$LN2@sntp_cb:

; 6978 :       mg_call(c, MG_EV_SNTP_TIME, (uint64_t *) &milliseconds);

  00064	4c 8d 44 24 48	 lea	 r8, QWORD PTR milliseconds$1[rsp]
  00069	ba 11 00 00 00	 mov	 edx, 17
  0006e	48 8b cb	 mov	 rcx, rbx
  00071	e8 00 00 00 00	 call	 mg_call

; 6979 :       MG_VERBOSE(("%u.%u", (unsigned) (milliseconds / 1000),

  00076	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR mg_log_level, 4
  0007d	7c 4c		 jl	 SHORT $LN6@sntp_cb
  0007f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_07IENOENON@sntp_cb@
  00086	b9 04 00 00 00	 mov	 ecx, 4
  0008b	41 b8 44 1b 00
	00		 mov	 r8d, 6980		; 00001b44H
  00091	e8 00 00 00 00	 call	 mg_log_prefix
  00096	4c 8b 44 24 48	 mov	 r8, QWORD PTR milliseconds$1[rsp]
  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05EENHEND@?$CFu?4?$CFu@
  000a2	48 b8 cf f7 53
	e3 a5 9b c4 20	 mov	 rax, 2361183241434822607 ; 20c49ba5e353f7cfH
  000ac	49 f7 e8	 imul	 r8
  000af	48 c1 fa 07	 sar	 rdx, 7
  000b3	48 8b c2	 mov	 rax, rdx
  000b6	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  000ba	48 03 d0	 add	 rdx, rax
  000bd	69 c2 e8 03 00
	00		 imul	 eax, edx, 1000		; 000003e8H
  000c3	44 2b c0	 sub	 r8d, eax
  000c6	e8 00 00 00 00	 call	 mg_log
$LN6@sntp_cb:

; 6980 :                   (unsigned) (milliseconds % 1000)));
; 6981 :     }
; 6982 :     mg_iobuf_del(&c->recv, 0, c->recv.len);  // Free receive buffer

  000cb	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  000cf	48 8d 4b 48	 lea	 rcx, QWORD PTR [rbx+72]
  000d3	33 d2		 xor	 edx, edx
  000d5	e8 00 00 00 00	 call	 mg_iobuf_del
  000da	eb 0a		 jmp	 SHORT $LN13@sntp_cb
$LN8@sntp_cb:

; 6983 :   } else if (ev == MG_EV_CONNECT) {

  000dc	83 fa 04	 cmp	 edx, 4
  000df	75 05		 jne	 SHORT $LN13@sntp_cb

; 6984 :     mg_sntp_request(c);

  000e1	e8 00 00 00 00	 call	 mg_sntp_request
$LN13@sntp_cb:

; 6985 :   } else if (ev == MG_EV_CLOSE) {
; 6986 :   }
; 6987 :   (void) ev_data;
; 6988 : }

  000e6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000eb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ef	5f		 pop	 rdi
  000f0	c3		 ret	 0
sntp_cb	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_sntp_request
_TEXT	SEGMENT
buf$1 = 32
c$ = 96
mg_sntp_request PROC					; COMDAT

; 6990 : void mg_sntp_request(struct mg_connection *c) {

$LN16:
  00000	40 53		 push	 rbx
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 6991 :   if (c->is_resolving) {

  00006	f6 81 10 01 00
	00 08		 test	 BYTE PTR [rcx+272], 8
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	74 37		 je	 SHORT $LN5@mg_sntp_re

; 6992 :     MG_ERROR(("%lu wait until resolved", c->id));

  00012	b9 01 00 00 00	 mov	 ecx, 1
  00017	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  0001d	0f 8c 02 01 00
	00		 jl	 $LN6@mg_sntp_re
  00023	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BA@IPEAOCEK@mg_sntp_request@
  0002a	41 b8 50 1b 00
	00		 mov	 r8d, 6992		; 00001b50H
  00030	e8 00 00 00 00	 call	 mg_log_prefix
  00035	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@GABKECNF@?$CFlu?5wait?5until?5resolved@

; 7002 :   }
; 7003 : }

  0003f	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00043	5b		 pop	 rbx

; 6992 :     MG_ERROR(("%lu wait until resolved", c->id));

  00044	e9 00 00 00 00	 jmp	 mg_log
$LN5@mg_sntp_re:

; 13865:   return GetTickCount();

  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  0004f	44 8b d0	 mov	 r10d, eax
  00052	0f 57 c0	 xorps	 xmm0, xmm0

; 6993 :   } else {
; 6994 :     int64_t now = (int64_t) mg_millis();  // Use int64_t, for vc98
; 6995 :     uint8_t buf[48] = {0};

  00055	0f 11 44 24 40	 movups	 XMMWORD PTR buf$1[rsp+32], xmm0

; 6998 :     buf[0] = (0 << 6) | (4 << 3) | 3;
; 6999 :     t[0] = mg_htonl((uint32_t) (now / 1000) + SNTP_TIME_OFFSET);

  0005a	45 8b ca	 mov	 r9d, r10d
  0005d	48 b8 77 be 9f
	1a 2f dd 24 06	 mov	 rax, 442721857769029239	; 0624dd2f1a9fbe77H
  00067	49 f7 e2	 mul	 r10
  0006a	0f 11 44 24 20	 movups	 XMMWORD PTR buf$1[rsp], xmm0
  0006f	0f 11 44 24 30	 movups	 XMMWORD PTR buf$1[rsp+16], xmm0
  00074	0f 57 c0	 xorps	 xmm0, xmm0
  00077	c6 44 24 20 23	 mov	 BYTE PTR buf$1[rsp], 35	; 00000023H
  0007c	4c 2b ca	 sub	 r9, rdx
  0007f	49 d1 e9	 shr	 r9, 1
  00082	4c 03 ca	 add	 r9, rdx
  00085	49 c1 e9 09	 shr	 r9, 9
  00089	41 8d 81 80 7e
	aa 83		 lea	 eax, DWORD PTR [r9-2085978496]

; 13800:   return (((uint32_t) data[3]) << 0) | (((uint32_t) data[2]) << 8) |

  00090	8b c8		 mov	 ecx, eax
  00092	c1 e9 08	 shr	 ecx, 8
  00095	44 0f b6 c1	 movzx	 r8d, cl
  00099	0f b6 c8	 movzx	 ecx, al
  0009c	c1 e1 08	 shl	 ecx, 8
  0009f	44 0b c1	 or	 r8d, ecx
  000a2	8b c8		 mov	 ecx, eax
  000a4	c1 e8 18	 shr	 eax, 24
  000a7	41 c1 e0 08	 shl	 r8d, 8
  000ab	c1 e9 10	 shr	 ecx, 16
  000ae	0f b6 d1	 movzx	 edx, cl
  000b1	44 0b c2	 or	 r8d, edx
  000b4	41 c1 e0 08	 shl	 r8d, 8
  000b8	44 0b c0	 or	 r8d, eax

; 6996 :     uint32_t *t = (uint32_t *) &buf[40];
; 6997 :     double frac = ((double) (now % 1000)) / 1000.0 * SNTP_MAX_FRAC;

  000bb	49 69 c1 e8 03
	00 00		 imul	 rax, r9, 1000		; 000003e8H

; 6998 :     buf[0] = (0 << 6) | (4 << 3) | 3;
; 6999 :     t[0] = mg_htonl((uint32_t) (now / 1000) + SNTP_TIME_OFFSET);

  000c2	44 89 44 24 48	 mov	 DWORD PTR buf$1[rsp+40], r8d
  000c7	4c 2b d0	 sub	 r10, rax
  000ca	f2 49 0f 2a c2	 cvtsi2sd xmm0, r10
  000cf	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@408f400000000000
  000d7	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@41efffffffe00000

; 7000 :     t[1] = mg_htonl((uint32_t) frac);

  000df	f2 4c 0f 2c c0	 cvttsd2si r8, xmm0

; 13800:   return (((uint32_t) data[3]) << 0) | (((uint32_t) data[2]) << 8) |

  000e4	41 8b c0	 mov	 eax, r8d
  000e7	c1 e8 08	 shr	 eax, 8
  000ea	0f b6 d0	 movzx	 edx, al
  000ed	41 0f b6 c0	 movzx	 eax, r8b
  000f1	c1 e0 08	 shl	 eax, 8
  000f4	0b d0		 or	 edx, eax
  000f6	41 8b c0	 mov	 eax, r8d
  000f9	c1 e2 08	 shl	 edx, 8
  000fc	41 c1 e8 18	 shr	 r8d, 24
  00100	c1 e8 10	 shr	 eax, 16
  00103	0f b6 c8	 movzx	 ecx, al
  00106	0b d1		 or	 edx, ecx

; 7001 :     mg_send(c, buf, sizeof(buf));

  00108	48 8b cb	 mov	 rcx, rbx

; 13800:   return (((uint32_t) data[3]) << 0) | (((uint32_t) data[2]) << 8) |

  0010b	c1 e2 08	 shl	 edx, 8
  0010e	41 0b d0	 or	 edx, r8d

; 7001 :     mg_send(c, buf, sizeof(buf));

  00111	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  00117	89 54 24 4c	 mov	 DWORD PTR buf$1[rsp+44], edx
  0011b	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$1[rsp]
  00120	e8 00 00 00 00	 call	 mg_send
$LN6@mg_sntp_re:

; 7002 :   }
; 7003 : }

  00125	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00129	5b		 pop	 rbx
  0012a	c3		 ret	 0
mg_sntp_request ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_sntp_connect
_TEXT	SEGMENT
mgr$ = 48
url$ = 56
fn$ = 64
fnd$ = 72
mg_sntp_connect PROC					; COMDAT

; 7006 :                                       mg_event_handler_t fn, void *fnd) {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b c2	 mov	 rax, rdx

; 7007 :   struct mg_connection *c = NULL;
; 7008 :   if (url == NULL) url = "udp://time.google.com:123";
; 7009 :   if ((c = mg_connect(mgr, url, fn, fnd)) != NULL) c->pfn = sntp_cb;

  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GMHACAIO@udp?3?1?1time?4google?4com?3123@
  0000e	48 85 c0	 test	 rax, rax
  00011	48 0f 45 d0	 cmovne	 rdx, rax
  00015	e8 00 00 00 00	 call	 mg_connect
  0001a	48 85 c0	 test	 rax, rax
  0001d	74 0e		 je	 SHORT $LN3@mg_sntp_co
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sntp_cb
  00026	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx
$LN3@mg_sntp_co:

; 7010 :   return c;
; 7011 : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
mg_sntp_connect ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT tousa
_TEXT	SEGMENT
a$ = 8
usa$ = 16
tousa	PROC						; COMDAT

; 7071 :   socklen_t len = sizeof(usa->sin);
; 7072 :   memset(usa, 0, sizeof(*usa));
; 7073 :   usa->sin.sin_family = AF_INET;

  00000	b8 02 00 00 00	 mov	 eax, 2
  00005	0f 57 c0	 xorps	 xmm0, xmm0
  00008	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  0000b	66 89 02	 mov	 WORD PTR [rdx], ax

; 7074 :   usa->sin.sin_port = a->port;

  0000e	0f b7 41 10	 movzx	 eax, WORD PTR [rcx+16]
  00012	66 89 42 02	 mov	 WORD PTR [rdx+2], ax

; 7075 :   memcpy(&usa->sin.sin_addr, a->ip, sizeof(uint32_t));

  00016	8b 01		 mov	 eax, DWORD PTR [rcx]
  00018	89 42 04	 mov	 DWORD PTR [rdx+4], eax

; 7076 : #if MG_ENABLE_IPV6
; 7077 :   if (a->is_ip6) {
; 7078 :     usa->sin.sin_family = AF_INET6;
; 7079 :     usa->sin6.sin6_port = a->port;
; 7080 :     usa->sin6.sin6_scope_id = a->scope_id;
; 7081 :     memcpy(&usa->sin6.sin6_addr, a->ip, sizeof(a->ip));
; 7082 :     len = sizeof(usa->sin6);
; 7083 :   }
; 7084 : #endif
; 7085 :   return len;

  0001b	b8 10 00 00 00	 mov	 eax, 16

; 7086 : }

  00020	c3		 ret	 0
tousa	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT tomgaddr
_TEXT	SEGMENT
usa$ = 8
a$ = 16
is_ip6$ = 24
tomgaddr PROC						; COMDAT

; 7089 :   a->is_ip6 = is_ip6;

  00000	44 88 42 13	 mov	 BYTE PTR [rdx+19], r8b

; 7090 :   a->port = usa->sin.sin_port;

  00004	0f b7 41 02	 movzx	 eax, WORD PTR [rcx+2]
  00008	66 89 42 10	 mov	 WORD PTR [rdx+16], ax

; 7091 :   memcpy(&a->ip, &usa->sin.sin_addr, sizeof(uint32_t));

  0000c	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]
  0000f	89 02		 mov	 DWORD PTR [rdx], eax

; 7092 : #if MG_ENABLE_IPV6
; 7093 :   if (is_ip6) {
; 7094 :     memcpy(a->ip, &usa->sin6.sin6_addr, sizeof(a->ip));
; 7095 :     a->port = usa->sin6.sin6_port;
; 7096 :     a->scope_id = (uint8_t) usa->sin6.sin6_scope_id;
; 7097 :   }
; 7098 : #endif
; 7099 : }

  00011	c3		 ret	 0
tomgaddr ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT setlocaddr
_TEXT	SEGMENT
usa$ = 32
fd$ = 64
addr$ = 72
n$ = 80
setlocaddr PROC						; COMDAT

; 7101 : static void setlocaddr(MG_SOCKET_TYPE fd, struct mg_addr *addr) {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b da	 mov	 rbx, rdx

; 7102 :   union usa usa;
; 7103 :   socklen_t n = sizeof(usa);

  00009	c7 44 24 50 10
	00 00 00	 mov	 DWORD PTR n$[rsp], 16

; 7104 :   if (getsockname(fd, &usa.sa, &n) == 0) {

  00011	48 8d 54 24 20	 lea	 rdx, QWORD PTR usa$[rsp]
  00016	4c 8d 44 24 50	 lea	 r8, QWORD PTR n$[rsp]
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getsockname
  00021	85 c0		 test	 eax, eax
  00023	75 1a		 jne	 SHORT $LN4@setlocaddr

; 7105 :     tomgaddr(&usa, addr, n != sizeof(usa.sin));

  00025	83 7c 24 50 10	 cmp	 DWORD PTR n$[rsp], 16
  0002a	0f 95 c0	 setne	 al

; 7089 :   a->is_ip6 = is_ip6;

  0002d	88 43 13	 mov	 BYTE PTR [rbx+19], al

; 7090 :   a->port = usa->sin.sin_port;

  00030	0f b7 44 24 22	 movzx	 eax, WORD PTR usa$[rsp+2]
  00035	66 89 43 10	 mov	 WORD PTR [rbx+16], ax

; 7091 :   memcpy(&a->ip, &usa->sin.sin_addr, sizeof(uint32_t));

  00039	8b 44 24 24	 mov	 eax, DWORD PTR usa$[rsp+4]
  0003d	89 03		 mov	 DWORD PTR [rbx], eax
$LN4@setlocaddr:

; 7106 :   }
; 7107 : }

  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	5b		 pop	 rbx
  00044	c3		 ret	 0
setlocaddr ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT iolog
_TEXT	SEGMENT
slen$1 = 64
usa$2 = 72
c$ = 112
buf$ = 120
n$ = 128
r$ = 136
iolog	PROC						; COMDAT

; 7110 :   if (n == MG_IO_WAIT) {

  00000	41 83 f8 fe	 cmp	 r8d, -2
  00004	0f 84 24 01 00
	00		 je	 $LN18@iolog

; 7109 : static void iolog(struct mg_connection *c, char *buf, long n, bool r) {

  0000a	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  0000f	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00014	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00019	57		 push	 rdi
  0001a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0001e	41 8a f9	 mov	 dil, r9b
  00021	48 8b f2	 mov	 rsi, rdx
  00024	48 8b d9	 mov	 rbx, rcx

; 7111 :     // Do nothing
; 7112 :   } else if (n <= 0) {

  00027	45 85 c0	 test	 r8d, r8d
  0002a	7f 0d		 jg	 SHORT $LN17@iolog

; 7113 :     c->is_closing = 1;  // Termination. Don't call mg_error(): #1529

  0002c	0f ba a9 10 01
	00 00 0d	 bts	 DWORD PTR [rcx+272], 13
  00034	e9 e6 00 00 00	 jmp	 $LN14@iolog
$LN17@iolog:

; 7114 :   } else if (n > 0) {
; 7115 :     if (c->is_hexdumping) {

  00039	f7 81 10 01 00
	00 00 08 00 00	 test	 DWORD PTR [rcx+272], 2048 ; 00000800H
  00043	0f 84 a0 00 00
	00		 je	 $LN10@iolog

; 7116 :       union usa usa;
; 7117 :       socklen_t slen = sizeof(usa.sin);
; 7118 :       if (getsockname(FD(c), &usa.sa, &slen) < 0) (void) 0;  // Ignore result

  00049	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0004d	4c 8d 44 24 40	 lea	 r8, QWORD PTR slen$1[rsp]
  00052	48 8d 54 24 48	 lea	 rdx, QWORD PTR usa$2[rsp]
  00057	c7 44 24 40 10
	00 00 00	 mov	 DWORD PTR slen$1[rsp], 16
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getsockname

; 7119 :       MG_INFO(("\n-- %lu %M %s %M %ld", c->id, mg_print_ip_port, &c->loc,

  00065	b9 02 00 00 00	 mov	 ecx, 2
  0006a	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  00070	7c 5f		 jl	 SHORT $LN2@iolog
  00072	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_05GCGDNJJE@iolog@
  00079	41 b8 d0 1b 00
	00		 mov	 r8d, 7120		; 00001bd0H
  0007f	e8 00 00 00 00	 call	 mg_log_prefix
  00084	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02NOFGAPG@?$DM?9@
  0008b	40 84 ff	 test	 dil, dil
  0008e	48 8d 4b 24	 lea	 rcx, QWORD PTR [rbx+36]
  00092	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:mg_print_ip_port
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02HBOOOICD@?9?$DO@
  000a0	48 0f 45 d0	 cmovne	 rdx, rax
  000a4	4c 8d 4b 10	 lea	 r9, QWORD PTR [rbx+16]
  000a8	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  000af	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  000b3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@EEHNBJP@?6?9?9?5?$CFlu?5?$CFM?5?$CFs?5?$CFM?5?$CFld@
  000bf	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  000c4	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000c9	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  000cc	e8 00 00 00 00	 call	 mg_log
$LN2@iolog:

; 7120 :                r ? "<-" : "->", mg_print_ip_port, &c->rem, n));
; 7121 : 
; 7122 :       mg_hexdump(buf, (size_t) n);

  000d1	48 63 94 24 80
	00 00 00	 movsxd	 rdx, DWORD PTR n$[rsp]
  000d9	48 8b ce	 mov	 rcx, rsi
  000dc	e8 00 00 00 00	 call	 mg_hexdump
  000e1	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR n$[rsp]
$LN10@iolog:

; 7123 :     }
; 7124 :     if (r) {

  000e9	40 84 ff	 test	 dil, dil
  000ec	74 0e		 je	 SHORT $LN13@iolog

; 7125 :       c->recv.len += (size_t) n;

  000ee	49 63 c0	 movsxd	 rax, r8d

; 7126 :       mg_call(c, MG_EV_READ, &n);

  000f1	ba 07 00 00 00	 mov	 edx, 7
  000f6	48 01 43 58	 add	 QWORD PTR [rbx+88], rax

; 7127 :     } else {

  000fa	eb 13		 jmp	 SHORT $LN19@iolog
$LN13@iolog:

; 7128 :       mg_iobuf_del(&c->send, 0, (size_t) n);

  000fc	4d 63 c0	 movsxd	 r8, r8d
  000ff	48 8d 4b 68	 lea	 rcx, QWORD PTR [rbx+104]
  00103	33 d2		 xor	 edx, edx
  00105	e8 00 00 00 00	 call	 mg_iobuf_del

; 7129 :       // if (c->send.len == 0) mg_iobuf_resize(&c->send, 0);
; 7130 :       if (c->send.len == 0) {
; 7131 :         MG_EPOLL_MOD(c, 0);
; 7132 :       }
; 7133 :       mg_call(c, MG_EV_WRITE, &n);

  0010a	ba 08 00 00 00	 mov	 edx, 8
$LN19@iolog:

; 7134 :     }
; 7135 :   }
; 7136 : }

  0010f	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR n$[rsp]
  00117	48 8b cb	 mov	 rcx, rbx
  0011a	e8 00 00 00 00	 call	 mg_call
$LN14@iolog:
  0011f	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00124	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  00129	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0012d	5f		 pop	 rdi
$LN18@iolog:
  0012e	c3		 ret	 0
iolog	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_io_send
_TEXT	SEGMENT
usa$1 = 48
c$ = 80
buf$ = 88
len$ = 96
mg_io_send PROC						; COMDAT

; 7138 : long mg_io_send(struct mg_connection *c, const void *buf, size_t len) {

$LN14:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  00007	57		 push	 rdi
  00008	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 7139 :   long n;
; 7140 :   if (c->is_udp) {

  0000c	45 33 c9	 xor	 r9d, r9d
  0000f	48 8b f9	 mov	 rdi, rcx
  00012	f7 81 10 01 00
	00 00 01 00 00	 test	 DWORD PTR [rcx+272], 256 ; 00000100H
  0001c	74 5f		 je	 SHORT $LN2@mg_io_send

; 7072 :   memset(usa, 0, sizeof(*usa));

  0001e	4d 21 4b f0	 and	 QWORD PTR [r11-16], r9

; 7073 :   usa->sin.sin_family = AF_INET;

  00022	41 8d 41 02	 lea	 eax, QWORD PTR [r9+2]
  00026	66 89 44 24 30	 mov	 WORD PTR usa$1[rsp], ax

; 7074 :   usa->sin.sin_port = a->port;

  0002b	0f b7 41 34	 movzx	 eax, WORD PTR [rcx+52]
  0002f	66 89 44 24 32	 mov	 WORD PTR usa$1[rsp+2], ax

; 7075 :   memcpy(&usa->sin.sin_addr, a->ip, sizeof(uint32_t));

  00034	8b 41 24	 mov	 eax, DWORD PTR [rcx+36]

; 7141 :     union usa usa;
; 7142 :     socklen_t slen = tousa(&c->rem, &usa);
; 7143 :     n = sendto(FD(c), (char *) buf, len, 0, &usa.sa, slen);

  00037	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]

; 7075 :   memcpy(&usa->sin.sin_addr, a->ip, sizeof(uint32_t));

  0003b	89 44 24 34	 mov	 DWORD PTR usa$1[rsp+4], eax

; 7141 :     union usa usa;
; 7142 :     socklen_t slen = tousa(&c->rem, &usa);
; 7143 :     n = sendto(FD(c), (char *) buf, len, 0, &usa.sa, slen);

  0003f	49 8d 43 e8	 lea	 rax, QWORD PTR [r11-24]
  00043	c7 44 24 28 10
	00 00 00	 mov	 DWORD PTR [rsp+40], 16
  0004b	49 89 43 d8	 mov	 QWORD PTR [r11-40], rax
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sendto
  00055	8b d8		 mov	 ebx, eax

; 7144 :     if (n > 0) setlocaddr(FD(c), &c->loc);

  00057	85 c0		 test	 eax, eax
  00059	7e 2e		 jle	 SHORT $LN3@mg_io_send
  0005b	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  0005f	48 8d 57 10	 lea	 rdx, QWORD PTR [rdi+16]
  00063	e8 00 00 00 00	 call	 setlocaddr
$LN7@mg_io_send:

; 7150 :   if (n <= 0) return MG_IO_ERR;

  00068	83 c9 ff	 or	 ecx, -1
  0006b	85 db		 test	 ebx, ebx
  0006d	0f 4e d9	 cmovle	 ebx, ecx
  00070	8b c3		 mov	 eax, ebx
$LN1@mg_io_send:

; 7151 :   return n;
; 7152 : }

  00072	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00077	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
$LN2@mg_io_send:

; 7145 :   } else {
; 7146 :     n = send(FD(c), (char *) buf, len, MSG_NONBLOCKING);

  0007d	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  00087	8b d8		 mov	 ebx, eax
$LN3@mg_io_send:

; 7147 :   }
; 7148 :   if (MG_SOCK_PENDING(n)) return MG_IO_WAIT;

  00089	85 db		 test	 ebx, ebx
  0008b	79 db		 jns	 SHORT $LN7@mg_io_send
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00093	3d 14 27 00 00	 cmp	 eax, 10004		; 00002714H
  00098	74 32		 je	 SHORT $LN6@mg_io_send
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000a0	3d 34 27 00 00	 cmp	 eax, 10036		; 00002734H
  000a5	74 25		 je	 SHORT $LN6@mg_io_send
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000ad	3d 33 27 00 00	 cmp	 eax, 10035		; 00002733H
  000b2	74 18		 je	 SHORT $LN6@mg_io_send

; 7149 :   if (MG_SOCK_RESET(n)) return MG_IO_RESET;

  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000ba	83 c9 ff	 or	 ecx, -1
  000bd	3d 46 27 00 00	 cmp	 eax, 10054		; 00002746H
  000c2	8d 51 fe	 lea	 edx, QWORD PTR [rcx-2]
  000c5	0f 44 ca	 cmove	 ecx, edx
  000c8	8b c1		 mov	 eax, ecx
  000ca	eb a6		 jmp	 SHORT $LN1@mg_io_send
$LN6@mg_io_send:

; 7147 :   }
; 7148 :   if (MG_SOCK_PENDING(n)) return MG_IO_WAIT;

  000cc	b8 fe ff ff ff	 mov	 eax, -2
  000d1	eb 9f		 jmp	 SHORT $LN1@mg_io_send
mg_io_send ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_send
_TEXT	SEGMENT
c$ = 80
buf$ = 88
len$ = 96
mg_send	PROC						; COMDAT

; 7154 : bool mg_send(struct mg_connection *c, const void *buf, size_t len) {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 7155 :   if (c->is_udp) {

  0000f	f7 81 10 01 00
	00 00 01 00 00	 test	 DWORD PTR [rcx+272], 256 ; 00000100H
  00019	48 8b f2	 mov	 rsi, rdx
  0001c	48 8b d9	 mov	 rbx, rcx
  0001f	74 72		 je	 SHORT $LN5@mg_send

; 7156 :     long n = mg_io_send(c, buf, len);

  00021	e8 00 00 00 00	 call	 mg_io_send

; 7157 :     MG_DEBUG(("%lu %ld %d:%d %ld err %d", c->id, c->fd, (int) c->send.len,

  00026	b9 03 00 00 00	 mov	 ecx, 3
  0002b	8b f8		 mov	 edi, eax
  0002d	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  00033	7c 46		 jl	 SHORT $LN2@mg_send
  00035	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_07JDKIIIBC@mg_send@
  0003c	41 b8 f6 1b 00
	00		 mov	 r8d, 7158		; 00001bf6H
  00042	e8 00 00 00 00	 call	 mg_log_prefix
  00047	85 ff		 test	 edi, edi
  00049	79 08		 jns	 SHORT $LN9@mg_send
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00051	eb 02		 jmp	 SHORT $LN10@mg_send
$LN9@mg_send:
  00053	33 c0		 xor	 eax, eax
$LN10@mg_send:
  00055	44 8b 4b 78	 mov	 r9d, DWORD PTR [rbx+120]
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@PDGMPLOC@?$CFlu?5?$CFld?5?$CFd?3?$CFd?5?$CFld?5err?5?$CFd@
  00060	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  00064	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  00067	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0006b	8b 43 58	 mov	 eax, DWORD PTR [rbx+88]
  0006e	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  00072	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00076	e8 00 00 00 00	 call	 mg_log
$LN2@mg_send:

; 7158 :               (int) c->recv.len, n, MG_SOCK_ERR(n)));
; 7159 :     iolog(c, (char *) buf, n, false);

  0007b	45 33 c9	 xor	 r9d, r9d
  0007e	44 8b c7	 mov	 r8d, edi
  00081	48 8b d6	 mov	 rdx, rsi
  00084	48 8b cb	 mov	 rcx, rbx
  00087	e8 00 00 00 00	 call	 iolog

; 7160 :     return n > 0;

  0008c	85 ff		 test	 edi, edi
  0008e	0f 9f c0	 setg	 al
  00091	eb 19		 jmp	 SHORT $LN6@mg_send
$LN5@mg_send:

; 7161 :   } else {
; 7162 :     return mg_iobuf_add(&c->send, c->send.len, buf, len);

  00093	48 8b 53 78	 mov	 rdx, QWORD PTR [rbx+120]
  00097	4d 8b c8	 mov	 r9, r8
  0009a	4c 8b c6	 mov	 r8, rsi
  0009d	48 83 c1 68	 add	 rcx, 104		; 00000068H
  000a1	e8 00 00 00 00	 call	 mg_iobuf_add
  000a6	48 85 c0	 test	 rax, rax
  000a9	0f 95 c0	 setne	 al
$LN6@mg_send:

; 7163 :   }
; 7164 : }

  000ac	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000b1	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  000b6	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
mg_send	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_set_non_blocking_mode
_TEXT	SEGMENT
fd$ = 48
on$ = 56
mg_set_non_blocking_mode PROC				; COMDAT

; 7166 : static void mg_set_non_blocking_mode(MG_SOCKET_TYPE fd) {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 7167 : #if defined(MG_CUSTOM_NONBLOCK)
; 7168 :   MG_CUSTOM_NONBLOCK(fd);
; 7169 : #elif MG_ARCH == MG_ARCH_WIN32 && MG_ENABLE_WINSOCK
; 7170 :   unsigned long on = 1;
; 7171 :   ioctlsocket(fd, FIONBIO, &on);

  00004	4c 8d 44 24 38	 lea	 r8, QWORD PTR on$[rsp]
  00009	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR on$[rsp], 1
  00011	ba 7e 66 04 80	 mov	 edx, -2147195266	; ffffffff8004667eH
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ioctlsocket

; 7172 : #elif MG_ENABLE_RL
; 7173 :   unsigned long on = 1;
; 7174 :   ioctlsocket(fd, FIONBIO, &on);
; 7175 : #elif MG_ENABLE_FREERTOS_TCP
; 7176 :   const BaseType_t off = 0;
; 7177 :   if (setsockopt(fd, 0, FREERTOS_SO_RCVTIMEO, &off, sizeof(off)) != 0) (void) 0;
; 7178 :   if (setsockopt(fd, 0, FREERTOS_SO_SNDTIMEO, &off, sizeof(off)) != 0) (void) 0;
; 7179 : #elif MG_ENABLE_LWIP
; 7180 :   lwip_fcntl(fd, F_SETFL, O_NONBLOCK);
; 7181 : #elif MG_ARCH == MG_ARCH_AZURERTOS
; 7182 :   fcntl(fd, F_SETFL, O_NONBLOCK);
; 7183 : #elif MG_ARCH == MG_ARCH_TIRTOS
; 7184 :   int val = 0;
; 7185 :   setsockopt(fd, SOL_SOCKET, SO_BLOCKING, &val, sizeof(val));
; 7186 :   // SPRU524J section 3.3.3 page 63, SO_SNDLOWAT
; 7187 :   int sz = sizeof(val);
; 7188 :   getsockopt(fd, SOL_SOCKET, SO_SNDBUF, &val, &sz);
; 7189 :   val /= 2;  // set send low-water mark at half send buffer size
; 7190 :   setsockopt(fd, SOL_SOCKET, SO_SNDLOWAT, &val, sizeof(val));
; 7191 : #else
; 7192 :   fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);  // Non-blocking mode
; 7193 :   fcntl(fd, F_SETFD, FD_CLOEXEC);                          // Set close-on-exec
; 7194 : #endif
; 7195 : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
mg_set_non_blocking_mode ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_open_listener
_TEXT	SEGMENT
$T1 = 48
usa$2 = 48
$T3 = 64
on$4 = 128
c$ = 128
url$ = 136
mg_open_listener PROC					; COMDAT

; 7197 : bool mg_open_listener(struct mg_connection *c, const char *url) {

$LN47:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0001c	4c 8b f1	 mov	 r14, rcx
  0001f	48 8b ea	 mov	 rbp, rdx

; 7198 :   MG_SOCKET_TYPE fd = MG_INVALID_SOCKET;
; 7199 :   bool success = false;
; 7200 :   c->loc.port = mg_htons(mg_url_port(url));

  00022	48 8b ca	 mov	 rcx, rdx
  00025	33 f6		 xor	 esi, esi
  00027	e8 00 00 00 00	 call	 mg_url_port

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  0002c	44 0f b6 c0	 movzx	 r8d, al

; 7201 :   if (!mg_aton(mg_url_host(url), &c->loc)) {

  00030	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T3[rsp]

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00035	66 41 c1 e0 08	 shl	 r8w, 8

; 7201 :   if (!mg_aton(mg_url_host(url), &c->loc)) {

  0003a	48 8b d5	 mov	 rdx, rbp

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  0003d	66 c1 e8 08	 shr	 ax, 8
  00041	66 44 0b c0	 or	 r8w, ax

; 7198 :   MG_SOCKET_TYPE fd = MG_INVALID_SOCKET;
; 7199 :   bool success = false;
; 7200 :   c->loc.port = mg_htons(mg_url_port(url));

  00045	66 45 89 46 20	 mov	 WORD PTR [r14+32], r8w

; 7201 :   if (!mg_aton(mg_url_host(url), &c->loc)) {

  0004a	e8 00 00 00 00	 call	 mg_url_host
  0004f	4d 8d 7e 10	 lea	 r15, QWORD PTR [r14+16]
  00053	49 8b d7	 mov	 rdx, r15
  00056	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  0005b	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0005e	f3 0f 7f 44 24
	30		 movdqu	 XMMWORD PTR $T1[rsp], xmm0
  00064	e8 00 00 00 00	 call	 mg_aton
  00069	8d 7e 01	 lea	 edi, QWORD PTR [rsi+1]
  0006c	84 c0		 test	 al, al
  0006e	75 34		 jne	 SHORT $LN17@mg_open_li

; 7202 :     MG_ERROR(("invalid listening URL: %s", url));

  00070	39 3d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, edi
  00076	0f 8c 0d 02 00
	00		 jl	 $LN32@mg_open_li
  0007c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BB@DCONLCEI@mg_open_listener@
  00083	41 b8 22 1c 00
	00		 mov	 r8d, 7202		; 00001c22H
  00089	8b cf		 mov	 ecx, edi
  0008b	e8 00 00 00 00	 call	 mg_log_prefix
  00090	48 8b d5	 mov	 rdx, rbp
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@JOJCJPAN@invalid?5listening?5URL?3?5?$CFs@
  0009a	e8 00 00 00 00	 call	 mg_log

; 7203 :   } else {

  0009f	e9 e5 01 00 00	 jmp	 $LN32@mg_open_li
$LN17@mg_open_li:

; 7074 :   usa->sin.sin_port = a->port;

  000a4	41 0f b7 47 10	 movzx	 eax, WORD PTR [r15+16]

; 7207 :     int type = strncmp(url, "udp:", 4) == 0 ? SOCK_DGRAM : SOCK_STREAM;

  000a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04MNPDLBCA@udp?3@

; 7074 :   usa->sin.sin_port = a->port;

  000b0	66 89 44 24 32	 mov	 WORD PTR usa$2[rsp+2], ax
  000b5	41 bd 02 00 00
	00		 mov	 r13d, 2

; 7075 :   memcpy(&usa->sin.sin_addr, a->ip, sizeof(uint32_t));

  000bb	41 8b 07	 mov	 eax, DWORD PTR [r15]

; 7207 :     int type = strncmp(url, "udp:", 4) == 0 ? SOCK_DGRAM : SOCK_STREAM;

  000be	48 8b cd	 mov	 rcx, rbp

; 7075 :   memcpy(&usa->sin.sin_addr, a->ip, sizeof(uint32_t));

  000c1	89 44 24 34	 mov	 DWORD PTR usa$2[rsp+4], eax

; 7204 :     union usa usa;
; 7205 :     socklen_t slen = tousa(&c->loc, &usa);
; 7206 :     int rc, on = 1, af = c->loc.is_ip6 ? AF_INET6 : AF_INET;

  000c5	41 8a 46 23	 mov	 al, BYTE PTR [r14+35]
  000c9	f6 d8		 neg	 al

; 7072 :   memset(usa, 0, sizeof(*usa));

  000cb	48 89 74 24 38	 mov	 QWORD PTR usa$2[rsp+8], rsi

; 7207 :     int type = strncmp(url, "udp:", 4) == 0 ? SOCK_DGRAM : SOCK_STREAM;

  000d0	45 8d 45 02	 lea	 r8d, QWORD PTR [r13+2]

; 7073 :   usa->sin.sin_family = AF_INET;

  000d4	66 44 89 6c 24
	30		 mov	 WORD PTR usa$2[rsp], r13w

; 7204 :     union usa usa;
; 7205 :     socklen_t slen = tousa(&c->loc, &usa);
; 7206 :     int rc, on = 1, af = c->loc.is_ip6 ? AF_INET6 : AF_INET;

  000da	1b db		 sbb	 ebx, ebx
  000dc	89 bc 24 80 00
	00 00		 mov	 DWORD PTR on$4[rsp], edi
  000e3	83 e3 15	 and	 ebx, 21
  000e6	41 03 dd	 add	 ebx, r13d

; 7207 :     int type = strncmp(url, "udp:", 4) == 0 ? SOCK_DGRAM : SOCK_STREAM;

  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  000ef	8b d0		 mov	 edx, eax

; 7208 :     int proto = type == SOCK_DGRAM ? IPPROTO_UDP : IPPROTO_TCP;
; 7209 :     (void) on;
; 7210 : 
; 7211 :     if ((fd = socket(af, type, proto)) == MG_INVALID_SOCKET) {

  000f1	8b cb		 mov	 ecx, ebx
  000f3	f7 da		 neg	 edx
  000f5	45 1b e4	 sbb	 r12d, r12d
  000f8	45 03 e5	 add	 r12d, r13d
  000fb	f7 d8		 neg	 eax
  000fd	41 8b d4	 mov	 edx, r12d
  00100	45 1b c0	 sbb	 r8d, r8d
  00103	41 83 e0 f5	 and	 r8d, -11
  00107	41 83 c0 11	 add	 r8d, 17
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket
  00111	48 8b d8	 mov	 rbx, rax
  00114	48 83 f8 ff	 cmp	 rax, -1
  00118	75 39		 jne	 SHORT $LN20@mg_open_li

; 7212 :       MG_ERROR(("socket: %d", MG_SOCK_ERR(-1)));

  0011a	39 3d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, edi
  00120	0f 8c 63 01 00
	00		 jl	 $LN32@mg_open_li
  00126	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BB@DCONLCEI@mg_open_listener@
  0012d	41 b8 2c 1c 00
	00		 mov	 r8d, 7212		; 00001c2cH
  00133	8b cf		 mov	 ecx, edi
  00135	e8 00 00 00 00	 call	 mg_log_prefix
  0013a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00140	8b d0		 mov	 edx, eax
  00142	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@GLCCNLE@socket?3?5?$CFd@
  00149	e8 00 00 00 00	 call	 mg_log

; 7213 : #if defined(SO_EXCLUSIVEADDRUSE)
; 7214 :     } else if ((rc = setsockopt(fd, SOL_SOCKET, SO_EXCLUSIVEADDRUSE,

  0014e	e9 36 01 00 00	 jmp	 $LN32@mg_open_li
$LN20@mg_open_li:

; 7215 :                                 (char *) &on, sizeof(on))) != 0) {

  00153	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR on$4[rsp]
  0015b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00163	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00168	41 b8 fb ff ff
	ff		 mov	 r8d, -5
  0016e	48 8b cb	 mov	 rcx, rbx
  00171	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt
  00177	8b e8		 mov	 ebp, eax
  00179	85 c0		 test	 eax, eax
  0017b	74 49		 je	 SHORT $LN23@mg_open_li

; 7216 :       // "Using SO_REUSEADDR and SO_EXCLUSIVEADDRUSE"
; 7217 :       MG_ERROR(("setsockopt(SO_EXCLUSIVEADDRUSE): %d %d", on, MG_SOCK_ERR(rc)));

  0017d	39 3d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, edi
  00183	0f 8c db 00 00
	00		 jl	 $LN44@mg_open_li
  00189	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BB@DCONLCEI@mg_open_listener@
  00190	41 b8 31 1c 00
	00		 mov	 r8d, 7217		; 00001c31H
  00196	8b cf		 mov	 ecx, edi
  00198	e8 00 00 00 00	 call	 mg_log_prefix
  0019d	85 ed		 test	 ebp, ebp
  0019f	79 08		 jns	 SHORT $LN34@mg_open_li
  001a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  001a7	eb 02		 jmp	 SHORT $LN35@mg_open_li
$LN34@mg_open_li:
  001a9	8b c6		 mov	 eax, esi
$LN35@mg_open_li:
  001ab	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR on$4[rsp]
  001b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@MDOFAPIK@setsockopt?$CISO_EXCLUSIVEADDRUSE?$CJ@
  001b9	44 8b c0	 mov	 r8d, eax
  001bc	e8 00 00 00 00	 call	 mg_log

; 7218 : #elif defined(SO_REUSEADDR) && (!defined(LWIP_SOCKET) || SO_REUSE)
; 7219 :     } else if ((rc = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *) &on,
; 7220 :                                 sizeof(on))) != 0) {
; 7221 :       // 1. SO_REUSEADDR semantics on UNIX and Windows is different.  On
; 7222 :       // Windows, SO_REUSEADDR allows to bind a socket to a port without error
; 7223 :       // even if the port is already open by another program. This is not the
; 7224 :       // behavior SO_REUSEADDR was designed for, and leads to hard-to-track
; 7225 :       // failure scenarios.
; 7226 :       //
; 7227 :       // 2. For LWIP, SO_REUSEADDR should be explicitly enabled by defining
; 7228 :       // SO_REUSE = 1 in lwipopts.h, otherwise the code below will compile but
; 7229 :       // won't work! (setsockopt will return EINVAL)
; 7230 :       MG_ERROR(("setsockopt(SO_REUSEADDR): %d", MG_SOCK_ERR(rc)));
; 7231 : #endif
; 7232 : #if MG_IPV6_V6ONLY
; 7233 :       // Bind only to the V6 address, not V4 address on this port
; 7234 :     } else if (c->loc.is_ip6 &&
; 7235 :                (rc = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &on,
; 7236 :                                 sizeof(on))) != 0) {
; 7237 :       // See #2089. Allow to bind v4 and v6 sockets on the same port
; 7238 :       MG_ERROR(("setsockopt(IPV6_V6ONLY): %d", MG_SOCK_ERR(rc)));
; 7239 : #endif
; 7240 :     } else if ((rc = bind(fd, &usa.sa, slen)) != 0) {

  001c1	e9 9e 00 00 00	 jmp	 $LN44@mg_open_li
$LN23@mg_open_li:
  001c6	41 b8 10 00 00
	00		 mov	 r8d, 16
  001cc	48 8d 54 24 30	 lea	 rdx, QWORD PTR usa$2[rsp]
  001d1	48 8b cb	 mov	 rcx, rbx
  001d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_bind
  001da	8b e8		 mov	 ebp, eax
  001dc	85 c0		 test	 eax, eax
  001de	74 33		 je	 SHORT $LN26@mg_open_li

; 7241 :       MG_ERROR(("bind: %d", MG_SOCK_ERR(rc)));

  001e0	39 3d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, edi
  001e6	7c 7c		 jl	 SHORT $LN44@mg_open_li
  001e8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BB@DCONLCEI@mg_open_listener@
  001ef	41 b8 49 1c 00
	00		 mov	 r8d, 7241		; 00001c49H
  001f5	8b cf		 mov	 ecx, edi
  001f7	e8 00 00 00 00	 call	 mg_log_prefix
  001fc	85 ed		 test	 ebp, ebp
  001fe	79 08		 jns	 SHORT $LN36@mg_open_li
  00200	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00206	eb 02		 jmp	 SHORT $LN37@mg_open_li
$LN36@mg_open_li:
  00208	8b c6		 mov	 eax, esi
$LN37@mg_open_li:
  0020a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08JIJPKGKG@bind?3?5?$CFd@

; 7242 :     } else if ((type == SOCK_STREAM &&

  00211	eb 4a		 jmp	 SHORT $LN45@mg_open_li
$LN26@mg_open_li:
  00213	44 3b e7	 cmp	 r12d, edi
  00216	75 57		 jne	 SHORT $LN29@mg_open_li
  00218	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0021d	48 8b cb	 mov	 rcx, rbx
  00220	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_listen
  00226	8b e8		 mov	 ebp, eax
  00228	85 c0		 test	 eax, eax
  0022a	74 43		 je	 SHORT $LN29@mg_open_li

; 7243 :                 (rc = listen(fd, MG_SOCK_LISTEN_BACKLOG_SIZE)) != 0)) {
; 7244 :       // NOTE(lsm): FreeRTOS uses backlog value as a connection limit
; 7245 :       // In case port was set to 0, get the real port number
; 7246 :       MG_ERROR(("listen: %d", MG_SOCK_ERR(rc)));

  0022c	39 3d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, edi
  00232	7c 30		 jl	 SHORT $LN44@mg_open_li
  00234	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BB@DCONLCEI@mg_open_listener@
  0023b	41 b8 4e 1c 00
	00		 mov	 r8d, 7246		; 00001c4eH
  00241	8b cf		 mov	 ecx, edi
  00243	e8 00 00 00 00	 call	 mg_log_prefix
  00248	85 ed		 test	 ebp, ebp
  0024a	79 08		 jns	 SHORT $LN38@mg_open_li
  0024c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00252	eb 02		 jmp	 SHORT $LN39@mg_open_li
$LN38@mg_open_li:
  00254	8b c6		 mov	 eax, esi
$LN39@mg_open_li:
  00256	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@JNLECNPF@listen?3?5?$CFd@
$LN45@mg_open_li:

; 7253 :     }
; 7254 :   }
; 7255 :   if (success == false && fd != MG_INVALID_SOCKET) closesocket(fd);

  0025d	8b d0		 mov	 edx, eax
  0025f	e8 00 00 00 00	 call	 mg_log
$LN44@mg_open_li:
  00264	48 8b cb	 mov	 rcx, rbx
  00267	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
  0026d	eb 1a		 jmp	 SHORT $LN32@mg_open_li
$LN29@mg_open_li:

; 7247 :     } else {
; 7248 :       setlocaddr(fd, &c->loc);

  0026f	49 8b d7	 mov	 rdx, r15
  00272	48 8b cb	 mov	 rcx, rbx
  00275	e8 00 00 00 00	 call	 setlocaddr

; 7249 :       mg_set_non_blocking_mode(fd);

  0027a	48 8b cb	 mov	 rcx, rbx
  0027d	e8 00 00 00 00	 call	 mg_set_non_blocking_mode

; 7250 :       c->fd = S2PTR(fd);

  00282	49 89 5e 38	 mov	 QWORD PTR [r14+56], rbx

; 7251 :       MG_EPOLL_ADD(c);
; 7252 :       success = true;

  00286	40 8a f7	 mov	 sil, dil
$LN32@mg_open_li:

; 7256 :   return success;
; 7257 : }

  00289	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  0028e	40 8a c6	 mov	 al, sil
  00291	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  00295	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  00299	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  0029d	49 8b e3	 mov	 rsp, r11
  002a0	41 5f		 pop	 r15
  002a2	41 5e		 pop	 r14
  002a4	41 5d		 pop	 r13
  002a6	41 5c		 pop	 r12
  002a8	5f		 pop	 rdi
  002a9	c3		 ret	 0
mg_open_listener ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT recv_raw
_TEXT	SEGMENT
usa$1 = 48
slen$2 = 80
c$ = 80
buf$ = 88
len$ = 96
recv_raw PROC						; COMDAT

; 7259 : static long recv_raw(struct mg_connection *c, void *buf, size_t len) {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 7260 :   long n = 0;
; 7261 :   if (c->is_udp) {

  00008	45 33 c9	 xor	 r9d, r9d
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	f7 81 10 01 00
	00 00 01 00 00	 test	 DWORD PTR [rcx+272], 256 ; 00000100H
  00018	74 6c		 je	 SHORT $LN2@recv_raw

; 7072 :   memset(usa, 0, sizeof(*usa));

  0001a	4d 21 4b f0	 and	 QWORD PTR [r11-16], r9

; 7073 :   usa->sin.sin_family = AF_INET;

  0001e	41 8d 41 02	 lea	 eax, QWORD PTR [r9+2]
  00022	66 89 44 24 30	 mov	 WORD PTR usa$1[rsp], ax

; 7074 :   usa->sin.sin_port = a->port;

  00027	0f b7 41 34	 movzx	 eax, WORD PTR [rcx+52]
  0002b	66 89 44 24 32	 mov	 WORD PTR usa$1[rsp+2], ax

; 7075 :   memcpy(&usa->sin.sin_addr, a->ip, sizeof(uint32_t));

  00030	8b 41 24	 mov	 eax, DWORD PTR [rcx+36]

; 7262 :     union usa usa;
; 7263 :     socklen_t slen = tousa(&c->rem, &usa);
; 7264 :     n = recvfrom(FD(c), (char *) buf, len, 0, &usa.sa, &slen);

  00033	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]

; 7075 :   memcpy(&usa->sin.sin_addr, a->ip, sizeof(uint32_t));

  00037	89 44 24 34	 mov	 DWORD PTR usa$1[rsp+4], eax

; 7262 :     union usa usa;
; 7263 :     socklen_t slen = tousa(&c->rem, &usa);
; 7264 :     n = recvfrom(FD(c), (char *) buf, len, 0, &usa.sa, &slen);

  0003b	49 8d 43 08	 lea	 rax, QWORD PTR [r11+8]
  0003f	49 89 43 e0	 mov	 QWORD PTR [r11-32], rax
  00043	49 8d 43 e8	 lea	 rax, QWORD PTR [r11-24]
  00047	49 89 43 d8	 mov	 QWORD PTR [r11-40], rax
  0004b	c7 44 24 50 10
	00 00 00	 mov	 DWORD PTR slen$2[rsp], 16
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recvfrom

; 7265 :     if (n > 0) tomgaddr(&usa, &c->rem, slen != sizeof(usa.sin));

  00059	85 c0		 test	 eax, eax
  0005b	7e 35		 jle	 SHORT $LN15@recv_raw
  0005d	83 7c 24 50 10	 cmp	 DWORD PTR slen$2[rsp], 16
  00062	0f 95 c1	 setne	 cl

; 7089 :   a->is_ip6 = is_ip6;

  00065	88 4b 37	 mov	 BYTE PTR [rbx+55], cl

; 7090 :   a->port = usa->sin.sin_port;

  00068	0f b7 4c 24 32	 movzx	 ecx, WORD PTR usa$1[rsp+2]
  0006d	66 89 4b 34	 mov	 WORD PTR [rbx+52], cx

; 7091 :   memcpy(&a->ip, &usa->sin.sin_addr, sizeof(uint32_t));

  00071	8b 4c 24 34	 mov	 ecx, DWORD PTR usa$1[rsp+4]
  00075	89 4b 24	 mov	 DWORD PTR [rbx+36], ecx
$LN7@recv_raw:

; 7271 :   if (n <= 0) return MG_IO_ERR;

  00078	83 c9 ff	 or	 ecx, -1
  0007b	85 c0		 test	 eax, eax
  0007d	0f 4e c1	 cmovle	 eax, ecx
$LN1@recv_raw:

; 7272 :   return n;
; 7273 : }

  00080	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00084	5b		 pop	 rbx
  00085	c3		 ret	 0
$LN2@recv_raw:

; 7266 :   } else {
; 7267 :     n = recv(FD(c), (char *) buf, len, MSG_NONBLOCKING);

  00086	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv

; 7268 :   }
; 7269 :   if (MG_SOCK_PENDING(n)) return MG_IO_WAIT;

  00090	85 c0		 test	 eax, eax
$LN15@recv_raw:
  00092	79 e4		 jns	 SHORT $LN7@recv_raw
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0009a	3d 14 27 00 00	 cmp	 eax, 10004		; 00002714H
  0009f	74 32		 je	 SHORT $LN6@recv_raw
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000a7	3d 34 27 00 00	 cmp	 eax, 10036		; 00002734H
  000ac	74 25		 je	 SHORT $LN6@recv_raw
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000b4	3d 33 27 00 00	 cmp	 eax, 10035		; 00002733H
  000b9	74 18		 je	 SHORT $LN6@recv_raw

; 7270 :   if (MG_SOCK_RESET(n)) return MG_IO_RESET;

  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000c1	83 c9 ff	 or	 ecx, -1
  000c4	3d 46 27 00 00	 cmp	 eax, 10054		; 00002746H
  000c9	8d 51 fe	 lea	 edx, QWORD PTR [rcx-2]
  000cc	0f 44 ca	 cmove	 ecx, edx
  000cf	8b c1		 mov	 eax, ecx
  000d1	eb ad		 jmp	 SHORT $LN1@recv_raw
$LN6@recv_raw:

; 7268 :   }
; 7269 :   if (MG_SOCK_PENDING(n)) return MG_IO_WAIT;

  000d3	b8 fe ff ff ff	 mov	 eax, -2
  000d8	eb a6		 jmp	 SHORT $LN1@recv_raw
recv_raw ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT ioalloc
_TEXT	SEGMENT
c$ = 48
io$ = 56
ioalloc	PROC						; COMDAT

; 7275 : static bool ioalloc(struct mg_connection *c, struct mg_iobuf *io) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 7276 :   bool res = false;

  0000a	33 db		 xor	 ebx, ebx
  0000c	48 8b c2	 mov	 rax, rdx

; 7277 :   if (io->len >= MG_MAX_RECV_SIZE) {

  0000f	48 81 7a 10 00
	00 30 00	 cmp	 QWORD PTR [rdx+16], 3145728 ; 00300000H
  00017	48 8b f9	 mov	 rdi, rcx
  0001a	72 09		 jb	 SHORT $LN2@ioalloc

; 7278 :     mg_error(c, "MG_MAX_RECV_SIZE");

  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@HBLGCKAG@MG_MAX_RECV_SIZE@
  00023	eb 27		 jmp	 SHORT $LN7@ioalloc
$LN2@ioalloc:

; 7279 :   } else if (io->size <= io->len &&

  00025	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00029	48 3b 50 10	 cmp	 rdx, QWORD PTR [rax+16]
  0002d	77 24		 ja	 SHORT $LN4@ioalloc
  0002f	48 81 c2 00 08
	00 00		 add	 rdx, 2048		; 00000800H
  00036	48 8b c8	 mov	 rcx, rax
  00039	e8 00 00 00 00	 call	 mg_iobuf_resize
  0003e	85 c0		 test	 eax, eax
  00040	75 11		 jne	 SHORT $LN4@ioalloc

; 7280 :              !mg_iobuf_resize(io, io->size + MG_IO_SIZE)) {
; 7281 :     mg_error(c, "OOM");

  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03CDNNJDDN@OOM@
  00049	48 8b cf	 mov	 rcx, rdi
$LN7@ioalloc:

; 7284 :   }
; 7285 :   return res;

  0004c	e8 00 00 00 00	 call	 mg_error
  00051	eb 02		 jmp	 SHORT $LN5@ioalloc
$LN4@ioalloc:

; 7282 :   } else {
; 7283 :     res = true;

  00053	b3 01		 mov	 bl, 1
$LN5@ioalloc:

; 7284 :   }
; 7285 :   return res;

  00055	8a c3		 mov	 al, bl

; 7286 : }

  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5f		 pop	 rdi
  00061	c3		 ret	 0
ioalloc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT read_conn
_TEXT	SEGMENT
c$ = 96
read_conn PROC						; COMDAT

; 7290 : static void read_conn(struct mg_connection *c) {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 7291 :   if (ioalloc(c, &c->recv)) {

  00019	48 8d 51 48	 lea	 rdx, QWORD PTR [rcx+72]
  0001d	48 8b d9	 mov	 rbx, rcx
  00020	e8 00 00 00 00	 call	 ioalloc
  00025	33 ff		 xor	 edi, edi
  00027	84 c0		 test	 al, al
  00029	0f 84 15 01 00
	00		 je	 $LN5@read_conn

; 7292 :     char *buf = (char *) &c->recv.buf[c->recv.len];

  0002f	4c 8b 73 48	 mov	 r14, QWORD PTR [rbx+72]

; 7293 :     size_t len = c->recv.size - c->recv.len;
; 7294 :     long n = -1;
; 7295 :     if (c->is_tls) {

  00033	48 8b cb	 mov	 rcx, rbx
  00036	48 8b 6b 50	 mov	 rbp, QWORD PTR [rbx+80]
  0003a	4c 03 73 58	 add	 r14, QWORD PTR [rbx+88]
  0003e	48 2b 6b 58	 sub	 rbp, QWORD PTR [rbx+88]
  00042	f6 83 10 01 00
	00 40		 test	 BYTE PTR [rbx+272], 64	; 00000040H
  00049	74 7c		 je	 SHORT $LN6@read_conn

; 7296 :       if (!ioalloc(c, &c->rtls)) return;

  0004b	48 8d b3 a8 00
	00 00		 lea	 rsi, QWORD PTR [rbx+168]
  00052	48 8b d6	 mov	 rdx, rsi
  00055	e8 00 00 00 00	 call	 ioalloc
  0005a	84 c0		 test	 al, al
  0005c	0f 84 e2 00 00
	00		 je	 $LN5@read_conn

; 7297 :       n = recv_raw(c, (char *) &c->rtls.buf[c->rtls.len],

  00062	48 8b 8b b8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+184]
  00069	4c 8b 83 b0 00
	00 00		 mov	 r8, QWORD PTR [rbx+176]
  00070	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  00073	4c 2b c1	 sub	 r8, rcx
  00076	48 03 d1	 add	 rdx, rcx
  00079	48 8b cb	 mov	 rcx, rbx
  0007c	e8 00 00 00 00	 call	 recv_raw
  00081	48 63 f0	 movsxd	 rsi, eax

; 7298 :                    c->rtls.size - c->rtls.len);
; 7299 :       // MG_DEBUG(("%lu %ld", c->id, n));
; 7300 :       if (n == MG_IO_ERR && mg_tls_pending(c) == 0 && c->rtls.len == 0) {

  00084	83 fe ff	 cmp	 esi, -1
  00087	75 13		 jne	 SHORT $LN22@read_conn
  00089	48 39 bb b8 00
	00 00		 cmp	 QWORD PTR [rbx+184], rdi
  00090	75 15		 jne	 SHORT $LN11@read_conn

; 7301 :         c->is_closing = 1;

  00092	0f ba ab 10 01
	00 00 0d	 bts	 DWORD PTR [rbx+272], 13

; 7302 :       } else {

  0009a	eb 38		 jmp	 SHORT $LN4@read_conn
$LN22@read_conn:

; 7303 :         if (n > 0) c->rtls.len += (size_t) n;

  0009c	85 c0		 test	 eax, eax
  0009e	7e 07		 jle	 SHORT $LN11@read_conn
  000a0	48 01 b3 b8 00
	00 00		 add	 QWORD PTR [rbx+184], rsi
$LN11@read_conn:

; 7304 :         if (c->is_tls_hs) mg_tls_handshake(c);
; 7305 :         if (c->is_tls_hs) return;

  000a7	f6 83 10 01 00
	00 80		 test	 BYTE PTR [rbx+272], 128	; 00000080H
  000ae	0f 85 90 00 00
	00		 jne	 $LN5@read_conn

; 9992 :   return c == NULL || buf == NULL || len == 0 ? 0 : -1;

  000b4	4d 85 f6	 test	 r14, r14
  000b7	74 0a		 je	 SHORT $LN20@read_conn
  000b9	48 85 ed	 test	 rbp, rbp
  000bc	74 05		 je	 SHORT $LN20@read_conn
  000be	83 ce ff	 or	 esi, -1
  000c1	eb 11		 jmp	 SHORT $LN4@read_conn
$LN20@read_conn:
  000c3	8b f7		 mov	 esi, edi

; 7306 :         n = mg_tls_recv(c, buf, len);
; 7307 :       }
; 7308 :     } else {

  000c5	eb 0d		 jmp	 SHORT $LN4@read_conn
$LN6@read_conn:

; 7309 :       n = recv_raw(c, buf, len);

  000c7	4c 8b c5	 mov	 r8, rbp
  000ca	49 8b d6	 mov	 rdx, r14
  000cd	e8 00 00 00 00	 call	 recv_raw
  000d2	8b f0		 mov	 esi, eax
$LN4@read_conn:

; 7310 :     }
; 7311 :     MG_DEBUG(("%lu %p snd %ld/%ld rcv %ld/%ld n=%ld err=%d", c->id, c->fd,

  000d4	b9 03 00 00 00	 mov	 ecx, 3
  000d9	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  000df	7c 52		 jl	 SHORT $LN2@read_conn
  000e1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_09GCLNDOPN@read_conn@
  000e8	41 b8 91 1c 00
	00		 mov	 r8d, 7313		; 00001c91H
  000ee	e8 00 00 00 00	 call	 mg_log_prefix
  000f3	85 f6		 test	 esi, esi
  000f5	79 08		 jns	 SHORT $LN17@read_conn
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000fd	8b f8		 mov	 edi, eax
$LN17@read_conn:
  000ff	8b 43 50	 mov	 eax, DWORD PTR [rbx+80]
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CM@HEALIOMK@?$CFlu?5?$CFp?5snd?5?$CFld?1?$CFld?5rcv?5?$CFld?1?$CFld?5@
  00109	44 8b 4b 78	 mov	 r9d, DWORD PTR [rbx+120]
  0010d	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  00111	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  00114	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  00118	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  0011c	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00120	8b 43 58	 mov	 eax, DWORD PTR [rbx+88]
  00123	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00127	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0012a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0012e	e8 00 00 00 00	 call	 mg_log
$LN2@read_conn:

; 7312 :               (long) c->send.len, (long) c->send.size, (long) c->recv.len,
; 7313 :               (long) c->recv.size, n, MG_SOCK_ERR(n)));
; 7314 :     iolog(c, buf, n, true);

  00133	41 b1 01	 mov	 r9b, 1
  00136	44 8b c6	 mov	 r8d, esi
  00139	49 8b d6	 mov	 rdx, r14
  0013c	48 8b cb	 mov	 rcx, rbx
  0013f	e8 00 00 00 00	 call	 iolog
$LN5@read_conn:

; 7315 :   }
; 7316 : }

  00144	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00149	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  0014e	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  00153	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]
  00158	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0015c	41 5e		 pop	 r14
  0015e	c3		 ret	 0
read_conn ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT write_conn
_TEXT	SEGMENT
c$ = 96
write_conn PROC						; COMDAT

; 7318 : static void write_conn(struct mg_connection *c) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 7319 :   char *buf = (char *) c->send.buf;

  00014	48 8b 69 68	 mov	 rbp, QWORD PTR [rcx+104]

; 7320 :   size_t len = c->send.len;
; 7321 :   long n = c->is_tls ? mg_tls_send(c, buf, len) : mg_io_send(c, buf, len);

  00018	33 ff		 xor	 edi, edi
  0001a	f6 81 10 01 00
	00 40		 test	 BYTE PTR [rcx+272], 64	; 00000040H
  00021	48 8b d9	 mov	 rbx, rcx
  00024	4c 8b 41 78	 mov	 r8, QWORD PTR [rcx+120]
  00028	74 13		 je	 SHORT $LN7@write_conn

; 9995 :   return c == NULL || buf == NULL || len == 0 ? 0 : -1;

  0002a	48 85 ed	 test	 rbp, rbp
  0002d	74 0a		 je	 SHORT $LN13@write_conn
  0002f	4d 85 c0	 test	 r8, r8
  00032	74 05		 je	 SHORT $LN13@write_conn
  00034	83 ce ff	 or	 esi, -1
  00037	eb 0e		 jmp	 SHORT $LN8@write_conn
$LN13@write_conn:
  00039	8b f7		 mov	 esi, edi

; 7320 :   size_t len = c->send.len;
; 7321 :   long n = c->is_tls ? mg_tls_send(c, buf, len) : mg_io_send(c, buf, len);

  0003b	eb 0a		 jmp	 SHORT $LN8@write_conn
$LN7@write_conn:
  0003d	48 8b d5	 mov	 rdx, rbp
  00040	e8 00 00 00 00	 call	 mg_io_send
  00045	8b f0		 mov	 esi, eax
$LN8@write_conn:

; 7322 :   MG_DEBUG(("%lu %ld snd %ld/%ld rcv %ld/%ld n=%ld err=%d", c->id, c->fd,

  00047	b9 03 00 00 00	 mov	 ecx, 3
  0004c	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  00052	7c 52		 jl	 SHORT $LN2@write_conn
  00054	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0L@EJLBGHPI@write_conn@
  0005b	41 b8 9c 1c 00
	00		 mov	 r8d, 7324		; 00001c9cH
  00061	e8 00 00 00 00	 call	 mg_log_prefix
  00066	85 f6		 test	 esi, esi
  00068	79 08		 jns	 SHORT $LN10@write_conn
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00070	8b f8		 mov	 edi, eax
$LN10@write_conn:
  00072	8b 43 50	 mov	 eax, DWORD PTR [rbx+80]
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CN@BLHHFBGP@?$CFlu?5?$CFld?5snd?5?$CFld?1?$CFld?5rcv?5?$CFld?1?$CFld@
  0007c	44 8b 4b 78	 mov	 r9d, DWORD PTR [rbx+120]
  00080	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  00084	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  00087	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  0008b	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  0008f	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00093	8b 43 58	 mov	 eax, DWORD PTR [rbx+88]
  00096	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0009a	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0009d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000a1	e8 00 00 00 00	 call	 mg_log
$LN2@write_conn:

; 7323 :             (long) c->send.len, (long) c->send.size, (long) c->recv.len,
; 7324 :             (long) c->recv.size, n, MG_SOCK_ERR(n)));
; 7325 :   iolog(c, buf, n, false);

  000a6	45 33 c9	 xor	 r9d, r9d
  000a9	44 8b c6	 mov	 r8d, esi
  000ac	48 8b d5	 mov	 rdx, rbp
  000af	48 8b cb	 mov	 rcx, rbx

; 7326 : }

  000b2	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000b7	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  000bc	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  000c1	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000c5	5f		 pop	 rdi

; 7323 :             (long) c->send.len, (long) c->send.size, (long) c->recv.len,
; 7324 :             (long) c->recv.size, n, MG_SOCK_ERR(n)));
; 7325 :   iolog(c, buf, n, false);

  000c6	e9 00 00 00 00	 jmp	 iolog
write_conn ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT close_conn
_TEXT	SEGMENT
c$ = 48
close_conn PROC						; COMDAT

; 7328 : static void close_conn(struct mg_connection *c) {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 7329 :   if (FD(c) != MG_INVALID_SOCKET) {

  00009	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0000d	48 83 f9 ff	 cmp	 rcx, -1
  00011	74 06		 je	 SHORT $LN2@close_conn

; 7330 : #if MG_ENABLE_EPOLL
; 7331 :     epoll_ctl(c->mgr->epoll_fd, EPOLL_CTL_DEL, FD(c), NULL);
; 7332 : #endif
; 7333 :     closesocket(FD(c));

  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
$LN2@close_conn:

; 7334 : #if MG_ENABLE_FREERTOS_TCP
; 7335 :     FreeRTOS_FD_CLR(c->fd, c->mgr->ss, eSELECT_ALL);
; 7336 : #endif
; 7337 :   }
; 7338 :   mg_close_conn(c);

  00019	48 8b cb	 mov	 rcx, rbx

; 7339 : }

  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5b		 pop	 rbx

; 7334 : #if MG_ENABLE_FREERTOS_TCP
; 7335 :     FreeRTOS_FD_CLR(c->fd, c->mgr->ss, eSELECT_ALL);
; 7336 : #endif
; 7337 :   }
; 7338 :   mg_close_conn(c);

  00021	e9 00 00 00 00	 jmp	 mg_close_conn
close_conn ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT connect_conn
_TEXT	SEGMENT
usa$ = 32
n$ = 64
c$ = 64
connect_conn PROC					; COMDAT

; 7341 : static void connect_conn(struct mg_connection *c) {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 7342 :   union usa usa;
; 7343 :   socklen_t n = sizeof(usa);

  00009	c7 44 24 40 10
	00 00 00	 mov	 DWORD PTR n$[rsp], 16

; 7344 :   // Use getpeername() to test whether we have connected
; 7345 :   if (getpeername(FD(c), &usa.sa, &n) == 0) {

  00011	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00015	4c 8d 44 24 40	 lea	 r8, QWORD PTR n$[rsp]
  0001a	48 8d 54 24 20	 lea	 rdx, QWORD PTR usa$[rsp]
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpeername
  00025	48 8b cb	 mov	 rcx, rbx
  00028	85 c0		 test	 eax, eax
  0002a	75 14		 jne	 SHORT $LN2@connect_co

; 7346 :     c->is_connecting = 0;

  0002c	83 a3 10 01 00
	00 df		 and	 DWORD PTR [rbx+272], -33 ; ffffffdfH

; 7347 :     mg_call(c, MG_EV_CONNECT, NULL);

  00033	8d 50 04	 lea	 edx, QWORD PTR [rax+4]
  00036	45 33 c0	 xor	 r8d, r8d
  00039	e8 00 00 00 00	 call	 mg_call

; 7348 :     MG_EPOLL_MOD(c, 0);
; 7349 :     if (c->is_tls_hs) mg_tls_handshake(c);
; 7350 :   } else {

  0003e	eb 0c		 jmp	 SHORT $LN3@connect_co
$LN2@connect_co:

; 7351 :     mg_error(c, "socket error");

  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@PIIOOFNF@socket?5error@
  00047	e8 00 00 00 00	 call	 mg_error
$LN3@connect_co:

; 7352 :   }
; 7353 : }

  0004c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00050	5b		 pop	 rbx
  00051	c3		 ret	 0
connect_conn ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT setsockopts
_TEXT	SEGMENT
on$ = 64
c$ = 64
setsockopts PROC					; COMDAT

; 7355 : static void setsockopts(struct mg_connection *c) {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 7356 : #if MG_ENABLE_FREERTOS_TCP || MG_ARCH == MG_ARCH_AZURERTOS || \
; 7357 :     MG_ARCH == MG_ARCH_TIRTOS
; 7358 :   (void) c;
; 7359 : #else
; 7360 :   int on = 1;

  00006	41 b8 01 00 00
	00		 mov	 r8d, 1

; 7361 : #if !defined(SOL_TCP)
; 7362 : #define SOL_TCP IPPROTO_TCP
; 7363 : #endif
; 7364 :   if (setsockopt(FD(c), SOL_TCP, TCP_NODELAY, (char *) &on, sizeof(on)) != 0)

  0000c	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00014	48 8b d9	 mov	 rbx, rcx
  00017	44 89 44 24 40	 mov	 DWORD PTR on$[rsp], r8d
  0001c	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00020	4c 8d 4c 24 40	 lea	 r9, QWORD PTR on$[rsp]
  00025	41 8d 50 05	 lea	 edx, QWORD PTR [r8+5]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt

; 7365 :     (void) 0;
; 7366 :   if (setsockopt(FD(c), SOL_SOCKET, SO_KEEPALIVE, (char *) &on, sizeof(on)) !=

  0002f	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00033	4c 8d 4c 24 40	 lea	 r9, QWORD PTR on$[rsp]
  00038	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  0003d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00045	41 b8 08 00 00
	00		 mov	 r8d, 8
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt

; 7367 :       0)
; 7368 :     (void) 0;
; 7369 : #endif
; 7370 : }

  00051	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00055	5b		 pop	 rbx
  00056	c3		 ret	 0
setsockopts ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_connect_resolved
_TEXT	SEGMENT
usa$1 = 48
c$ = 80
mg_connect_resolved PROC				; COMDAT

; 7372 : void mg_connect_resolved(struct mg_connection *c) {

$LN24:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 7373 :   int type = c->is_udp ? SOCK_DGRAM : SOCK_STREAM;

  00014	8b 81 10 01 00
	00		 mov	 eax, DWORD PTR [rcx+272]
  0001a	48 8b d9	 mov	 rbx, rcx
  0001d	bf 00 01 00 00	 mov	 edi, 256		; 00000100H

; 7374 :   int rc, af = c->rem.is_ip6 ? AF_INET6 : AF_INET;  // c->rem has resolved IP

  00022	bd 02 00 00 00	 mov	 ebp, 2
  00027	23 c7		 and	 eax, edi
  00029	f7 d8		 neg	 eax
  0002b	8a 41 37	 mov	 al, BYTE PTR [rcx+55]
  0002e	1b d2		 sbb	 edx, edx
  00030	f7 da		 neg	 edx
  00032	ff c2		 inc	 edx
  00034	f6 d8		 neg	 al
  00036	1b c9		 sbb	 ecx, ecx

; 7375 :   c->fd = S2PTR(socket(af, type, 0));               // Create outbound socket

  00038	45 33 c0	 xor	 r8d, r8d
  0003b	83 e1 15	 and	 ecx, 21
  0003e	03 cd		 add	 ecx, ebp
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket

; 7376 :   c->is_resolving = 0;                              // Clear resolving flag

  00046	8b 8b 10 01 00
	00		 mov	 ecx, DWORD PTR [rbx+272]
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	83 e1 f7	 and	 ecx, -9			; fffffff7H
  00052	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
  00056	89 8b 10 01 00
	00		 mov	 DWORD PTR [rbx+272], ecx

; 7377 :   if (FD(c) == MG_INVALID_SOCKET) {

  0005c	48 83 f8 ff	 cmp	 rax, -1
  00060	75 15		 jne	 SHORT $LN5@mg_connect

; 7378 :     mg_error(c, "socket(): %d", MG_SOCK_ERR(-1));

  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00068	44 8b c0	 mov	 r8d, eax
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@NLOJAIMF@socket?$CI?$CJ?3?5?$CFd@
  00072	e9 b5 00 00 00	 jmp	 $LN20@mg_connect
$LN5@mg_connect:

; 7379 :   } else if (c->is_udp) {

  00077	85 cf		 test	 ecx, edi
  00079	74 11		 je	 SHORT $LN7@mg_connect

; 7380 :     MG_EPOLL_ADD(c);
; 7381 : #if MG_ARCH == MG_ARCH_TIRTOS
; 7382 :     union usa usa;  // TI-RTOS NDK requires binding to receive on UDP sockets
; 7383 :     socklen_t slen = tousa(&c->loc, &usa);
; 7384 :     if ((rc = bind(c->fd, &usa.sa, slen)) != 0)
; 7385 :       MG_ERROR(("bind: %d", MG_SOCK_ERR(rc)));
; 7386 : #endif
; 7387 :     mg_call(c, MG_EV_RESOLVE, NULL);

  0007b	45 33 c0	 xor	 r8d, r8d
  0007e	48 8b cb	 mov	 rcx, rbx
  00081	41 8d 50 03	 lea	 edx, QWORD PTR [r8+3]
  00085	e8 00 00 00 00	 call	 mg_call

; 7388 :     mg_call(c, MG_EV_CONNECT, NULL);
; 7389 :   } else {

  0008a	eb 54		 jmp	 SHORT $LN22@mg_connect
$LN7@mg_connect:

; 7390 :     union usa usa;
; 7391 :     socklen_t slen = tousa(&c->rem, &usa);

  0008c	48 8d 73 24	 lea	 rsi, QWORD PTR [rbx+36]

; 7073 :   usa->sin.sin_family = AF_INET;

  00090	66 89 6c 24 30	 mov	 WORD PTR usa$1[rsp], bp

; 7074 :   usa->sin.sin_port = a->port;

  00095	0f b7 46 10	 movzx	 eax, WORD PTR [rsi+16]
  00099	33 ff		 xor	 edi, edi
  0009b	66 89 44 24 32	 mov	 WORD PTR usa$1[rsp+2], ax

; 7392 :     mg_set_non_blocking_mode(FD(c));

  000a0	48 8b ca	 mov	 rcx, rdx

; 7075 :   memcpy(&usa->sin.sin_addr, a->ip, sizeof(uint32_t));

  000a3	8b 06		 mov	 eax, DWORD PTR [rsi]
  000a5	89 44 24 34	 mov	 DWORD PTR usa$1[rsp+4], eax
  000a9	48 89 7c 24 38	 mov	 QWORD PTR usa$1[rsp+8], rdi

; 7392 :     mg_set_non_blocking_mode(FD(c));

  000ae	e8 00 00 00 00	 call	 mg_set_non_blocking_mode

; 7393 :     setsockopts(c);

  000b3	48 8b cb	 mov	 rcx, rbx
  000b6	e8 00 00 00 00	 call	 setsockopts

; 7394 :     MG_EPOLL_ADD(c);
; 7395 :     mg_call(c, MG_EV_RESOLVE, NULL);

  000bb	45 33 c0	 xor	 r8d, r8d
  000be	8d 57 03	 lea	 edx, QWORD PTR [rdi+3]
  000c1	48 8b cb	 mov	 rcx, rbx
  000c4	e8 00 00 00 00	 call	 mg_call

; 7396 :     rc = connect(FD(c), &usa.sa, slen);  // Attempt to connect

  000c9	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  000cd	44 8d 47 10	 lea	 r8d, QWORD PTR [rdi+16]
  000d1	48 8d 54 24 30	 lea	 rdx, QWORD PTR usa$1[rsp]
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_connect

; 7397 :     if (rc == 0) {                       // Success

  000dc	85 c0		 test	 eax, eax
  000de	75 11		 jne	 SHORT $LN21@mg_connect
$LN22@mg_connect:

; 7404 :     }
; 7405 :   }
; 7406 : }

  000e0	45 33 c0	 xor	 r8d, r8d
  000e3	48 8b cb	 mov	 rcx, rbx
  000e6	41 8d 50 04	 lea	 edx, QWORD PTR [r8+4]
  000ea	e8 00 00 00 00	 call	 mg_call
  000ef	eb 43		 jmp	 SHORT $LN12@mg_connect
$LN21@mg_connect:

; 7398 :       mg_call(c, MG_EV_CONNECT, NULL);   // Send MG_EV_CONNECT to the user
; 7399 :     } else if (MG_SOCK_PENDING(rc)) {    // Need to wait for TCP handshake

  000f1	79 2f		 jns	 SHORT $LN17@mg_connect
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000f9	3d 14 27 00 00	 cmp	 eax, 10004		; 00002714H
  000fe	74 49		 je	 SHORT $LN4@mg_connect
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00106	3d 34 27 00 00	 cmp	 eax, 10036		; 00002734H
  0010b	74 3c		 je	 SHORT $LN4@mg_connect
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00113	3d 33 27 00 00	 cmp	 eax, 10035		; 00002733H
  00118	74 2f		 je	 SHORT $LN4@mg_connect

; 7403 :       mg_error(c, "connect: %d", MG_SOCK_ERR(rc));

  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00120	8b f8		 mov	 edi, eax
$LN17@mg_connect:
  00122	44 8b c7	 mov	 r8d, edi
  00125	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@IFBHBJKC@connect?3?5?$CFd@
$LN20@mg_connect:

; 7404 :     }
; 7405 :   }
; 7406 : }

  0012c	48 8b cb	 mov	 rcx, rbx
  0012f	e8 00 00 00 00	 call	 mg_error
$LN12@mg_connect:
  00134	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00139	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  0013e	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00143	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00147	5f		 pop	 rdi
  00148	c3		 ret	 0
$LN4@mg_connect:

; 7400 :       MG_DEBUG(("%lu %ld -> %M pend", c->id, c->fd, mg_print_ip_port, &c->rem));

  00149	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR mg_log_level, 3
  00150	7c 36		 jl	 SHORT $LN2@mg_connect
  00152	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BE@CANALBHN@mg_connect_resolved@
  00159	b9 03 00 00 00	 mov	 ecx, 3
  0015e	41 b8 e8 1c 00
	00		 mov	 r8d, 7400		; 00001ce8H
  00164	e8 00 00 00 00	 call	 mg_log_prefix
  00169	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  0016d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:mg_print_ip_port
  00174	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  00177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@BGCIPAPF@?$CFlu?5?$CFld?5?9?$DO?5?$CFM?5pend@
  0017e	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00183	e8 00 00 00 00	 call	 mg_log
$LN2@mg_connect:

; 7401 :       c->is_connecting = 1;

  00188	83 8b 10 01 00
	00 20		 or	 DWORD PTR [rbx+272], 32	; 00000020H

; 7402 :     } else {

  0018f	eb a3		 jmp	 SHORT $LN12@mg_connect
mg_connect_resolved ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT raccept
_TEXT	SEGMENT
sock$ = 48
usa$ = 56
len$ = 64
raccept	PROC						; COMDAT

; 7409 :                               socklen_t *len) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	49 8b f0	 mov	 rsi, r8
  00017	48 8b fa	 mov	 rdi, rdx
  0001a	48 8b e9	 mov	 rbp, rcx
$LL4@raccept:

; 7410 :   MG_SOCKET_TYPE fd = MG_INVALID_SOCKET;
; 7411 :   do {
; 7412 :     memset(usa, 0, sizeof(*usa));
; 7413 :     fd = accept(sock, &usa->sa, len);

  0001d	0f 57 c0	 xorps	 xmm0, xmm0
  00020	4c 8b c6	 mov	 r8, rsi
  00023	48 8b d7	 mov	 rdx, rdi
  00026	48 8b cd	 mov	 rcx, rbp
  00029	0f 11 07	 movups	 XMMWORD PTR [rdi], xmm0
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_accept
  00032	48 8b d8	 mov	 rbx, rax

; 7414 :   } while (MG_SOCK_INTR(fd));

  00035	48 83 f8 ff	 cmp	 rax, -1
  00039	75 0b		 jne	 SHORT $LN5@raccept
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00041	83 f8 04	 cmp	 eax, 4
  00044	74 d7		 je	 SHORT $LL4@raccept
$LN5@raccept:

; 7415 :   return fd;
; 7416 : }

  00046	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0004b	48 8b c3	 mov	 rax, rbx
  0004e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00053	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
raccept	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT accept_conn
_TEXT	SEGMENT
usa$ = 64
mgr$ = 112
sa_len$ = 120
lsn$ = 120
accept_conn PROC					; COMDAT

; 7418 : static void accept_conn(struct mg_mgr *mgr, struct mg_connection *lsn) {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000b	57		 push	 rdi
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00014	48 8b fa	 mov	 rdi, rdx

; 7419 :   struct mg_connection *c = NULL;
; 7420 :   union usa usa;
; 7421 :   socklen_t sa_len = sizeof(usa);

  00017	c7 40 10 10 00
	00 00		 mov	 DWORD PTR [rax+16], 16
  0001e	4c 8b f1	 mov	 r14, rcx

; 7422 :   MG_SOCKET_TYPE fd = raccept(FD(lsn), &usa, &sa_len);

  00021	4c 8d 40 10	 lea	 r8, QWORD PTR [rax+16]
  00025	48 8d 50 d8	 lea	 rdx, QWORD PTR [rax-40]
  00029	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  0002d	e8 00 00 00 00	 call	 raccept
  00032	48 8b f0	 mov	 rsi, rax

; 7423 :   if (fd == MG_INVALID_SOCKET) {

  00035	48 83 f8 ff	 cmp	 rax, -1
  00039	75 3f		 jne	 SHORT $LN14@accept_con

; 7424 : #if MG_ARCH == MG_ARCH_AZURERTOS || defined(__ECOS)
; 7425 :     // AzureRTOS, in non-block socket mode can mark listening socket readable
; 7426 :     // even it is not. See comment for 'select' func implementation in
; 7427 :     // nx_bsd.c That's not an error, just should try later
; 7428 :     if (errno != EAGAIN)
; 7429 : #endif
; 7430 :       MG_ERROR(("%lu accept failed, errno %d", lsn->id, MG_SOCK_ERR(-1)));

  0003b	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR mg_log_level, 1
  00042	0f 8c 8e 01 00
	00		 jl	 $LN18@accept_con
  00048	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0M@JPIAAHBH@accept_conn@
  0004f	41 b8 06 1d 00
	00		 mov	 r8d, 7430		; 00001d06H
  00055	8d 48 02	 lea	 ecx, QWORD PTR [rax+2]
  00058	e8 00 00 00 00	 call	 mg_log_prefix
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00063	8b 57 40	 mov	 edx, DWORD PTR [rdi+64]
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@MOEFGJHP@?$CFlu?5accept?5failed?0?5errno?5?$CFd@
  0006d	44 8b c0	 mov	 r8d, eax
  00070	e8 00 00 00 00	 call	 mg_log

; 7431 : #if (MG_ARCH != MG_ARCH_WIN32) && !MG_ENABLE_FREERTOS_TCP && \
; 7432 :     (MG_ARCH != MG_ARCH_TIRTOS) && !MG_ENABLE_POLL && !MG_ENABLE_EPOLL
; 7433 :   } else if ((long) fd >= FD_SETSIZE) {
; 7434 :     MG_ERROR(("%ld > %ld", (long) fd, (long) FD_SETSIZE));
; 7435 :     closesocket(fd);
; 7436 : #endif
; 7437 :   } else if ((c = mg_alloc_conn(mgr)) == NULL) {

  00075	e9 5c 01 00 00	 jmp	 $LN18@accept_con
$LN14@accept_con:
  0007a	49 8b ce	 mov	 rcx, r14
  0007d	e8 00 00 00 00	 call	 mg_alloc_conn
  00082	48 8b d8	 mov	 rbx, rax
  00085	48 85 c0	 test	 rax, rax
  00088	75 3b		 jne	 SHORT $LN17@accept_con

; 7438 :     MG_ERROR(("%lu OOM", lsn->id));

  0008a	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR mg_log_level, 1
  00091	7c 24		 jl	 SHORT $LN5@accept_con
  00093	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0M@JPIAAHBH@accept_conn@
  0009a	41 b8 0e 1d 00
	00		 mov	 r8d, 7438		; 00001d0eH
  000a0	8d 48 01	 lea	 ecx, QWORD PTR [rax+1]
  000a3	e8 00 00 00 00	 call	 mg_log_prefix
  000a8	8b 57 40	 mov	 edx, DWORD PTR [rdi+64]
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07BFGKJN@?$CFlu?5OOM@
  000b2	e8 00 00 00 00	 call	 mg_log
$LN5@accept_con:

; 7439 :     closesocket(fd);

  000b7	48 8b ce	 mov	 rcx, rsi
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket

; 7440 :   } else {

  000c0	e9 11 01 00 00	 jmp	 $LN18@accept_con
$LN17@accept_con:

; 7441 :     tomgaddr(&usa, &c->rem, sa_len != sizeof(usa.sin));

  000c5	83 7c 24 78 10	 cmp	 DWORD PTR sa_len$[rsp], 16
  000ca	4c 8d 78 24	 lea	 r15, QWORD PTR [rax+36]

; 7444 :     MG_EPOLL_ADD(c);
; 7445 :     mg_set_non_blocking_mode(FD(c));

  000ce	48 8b ce	 mov	 rcx, rsi
  000d1	0f 95 c0	 setne	 al

; 7089 :   a->is_ip6 = is_ip6;

  000d4	41 88 47 13	 mov	 BYTE PTR [r15+19], al

; 7090 :   a->port = usa->sin.sin_port;

  000d8	0f b7 44 24 42	 movzx	 eax, WORD PTR usa$[rsp+2]
  000dd	66 41 89 47 10	 mov	 WORD PTR [r15+16], ax

; 7091 :   memcpy(&a->ip, &usa->sin.sin_addr, sizeof(uint32_t));

  000e2	8b 44 24 44	 mov	 eax, DWORD PTR usa$[rsp+4]
  000e6	41 89 07	 mov	 DWORD PTR [r15], eax

; 7442 :     LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);

  000e9	49 8b 06	 mov	 rax, QWORD PTR [r14]
  000ec	48 89 03	 mov	 QWORD PTR [rbx], rax
  000ef	49 89 1e	 mov	 QWORD PTR [r14], rbx

; 7443 :     c->fd = S2PTR(fd);

  000f2	48 89 73 38	 mov	 QWORD PTR [rbx+56], rsi

; 7444 :     MG_EPOLL_ADD(c);
; 7445 :     mg_set_non_blocking_mode(FD(c));

  000f6	e8 00 00 00 00	 call	 mg_set_non_blocking_mode

; 7446 :     setsockopts(c);

  000fb	48 8b cb	 mov	 rcx, rbx
  000fe	e8 00 00 00 00	 call	 setsockopts

; 7447 :     c->is_accepted = 1;

  00103	8b 8b 10 01 00
	00		 mov	 ecx, DWORD PTR [rbx+272]

; 7448 :     c->is_hexdumping = lsn->is_hexdumping;
; 7449 :     c->loc = lsn->loc;

  00109	48 8d 73 10	 lea	 rsi, QWORD PTR [rbx+16]
  0010d	83 c9 04	 or	 ecx, 4
  00110	89 8b 10 01 00
	00		 mov	 DWORD PTR [rbx+272], ecx
  00116	8b c1		 mov	 eax, ecx
  00118	33 87 10 01 00
	00		 xor	 eax, DWORD PTR [rdi+272]
  0011e	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00123	33 c1		 xor	 eax, ecx

; 7450 :     c->pfn = lsn->pfn;
; 7451 :     c->pfn_data = lsn->pfn_data;
; 7452 :     c->fn = lsn->fn;
; 7453 :     c->fn_data = lsn->fn_data;
; 7454 :     MG_DEBUG(("%lu %ld accepted %M -> %M", c->id, c->fd, mg_print_ip_port,

  00125	b9 03 00 00 00	 mov	 ecx, 3
  0012a	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  00130	89 83 10 01 00
	00		 mov	 DWORD PTR [rbx+272], eax
  00136	0f 10 47 10	 movups	 xmm0, XMMWORD PTR [rdi+16]
  0013a	0f 11 06	 movups	 XMMWORD PTR [rsi], xmm0
  0013d	8b 47 20	 mov	 eax, DWORD PTR [rdi+32]
  00140	89 46 10	 mov	 DWORD PTR [rsi+16], eax
  00143	48 8b 87 d8 00
	00 00		 mov	 rax, QWORD PTR [rdi+216]
  0014a	48 89 83 d8 00
	00 00		 mov	 QWORD PTR [rbx+216], rax
  00151	48 8b 87 e0 00
	00 00		 mov	 rax, QWORD PTR [rdi+224]
  00158	48 89 83 e0 00
	00 00		 mov	 QWORD PTR [rbx+224], rax
  0015f	48 8b 87 c8 00
	00 00		 mov	 rax, QWORD PTR [rdi+200]
  00166	48 89 83 c8 00
	00 00		 mov	 QWORD PTR [rbx+200], rax
  0016d	48 8b 87 d0 00
	00 00		 mov	 rax, QWORD PTR [rdi+208]
  00174	48 89 83 d0 00
	00 00		 mov	 QWORD PTR [rbx+208], rax
  0017b	7c 3b		 jl	 SHORT $LN11@accept_con
  0017d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0M@JPIAAHBH@accept_conn@
  00184	41 b8 1f 1d 00
	00		 mov	 r8d, 7455		; 00001d1fH
  0018a	e8 00 00 00 00	 call	 mg_log_prefix
  0018f	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  00193	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:mg_print_ip_port
  0019a	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  0019d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@FOFCOHME@?$CFlu?5?$CFld?5accepted?5?$CFM?5?9?$DO?5?$CFM@
  001a4	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  001a9	4c 89 4c 24 28	 mov	 QWORD PTR [rsp+40], r9
  001ae	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  001b3	e8 00 00 00 00	 call	 mg_log
$LN11@accept_con:

; 7455 :               &c->rem, mg_print_ip_port, &c->loc));
; 7456 :     mg_call(c, MG_EV_OPEN, NULL);

  001b8	45 33 c0	 xor	 r8d, r8d
  001bb	48 8b cb	 mov	 rcx, rbx
  001be	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  001c2	e8 00 00 00 00	 call	 mg_call

; 7457 :     mg_call(c, MG_EV_ACCEPT, NULL);

  001c7	45 33 c0	 xor	 r8d, r8d
  001ca	48 8b cb	 mov	 rcx, rbx
  001cd	41 8d 50 05	 lea	 edx, QWORD PTR [r8+5]
  001d1	e8 00 00 00 00	 call	 mg_call
$LN18@accept_con:

; 7458 :   }
; 7459 : }

  001d6	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  001db	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  001df	49 8b 73 30	 mov	 rsi, QWORD PTR [r11+48]
  001e3	49 8b e3	 mov	 rsp, r11
  001e6	41 5f		 pop	 r15
  001e8	41 5e		 pop	 r14
  001ea	5f		 pop	 rdi
  001eb	c3		 ret	 0
accept_conn ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT can_read
_TEXT	SEGMENT
c$ = 8
can_read PROC						; COMDAT

; 7462 :   return c->is_full == false;

  00000	8b 81 10 01 00
	00		 mov	 eax, DWORD PTR [rcx+272]
  00006	c1 e8 0e	 shr	 eax, 14
  00009	f6 d0		 not	 al
  0000b	24 01		 and	 al, 1

; 7463 : }

  0000d	c3		 ret	 0
can_read ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT can_write
_TEXT	SEGMENT
c$ = 8
can_write PROC						; COMDAT

; 7466 :   return c->is_connecting || (c->send.len > 0 && c->is_tls_hs == 0);

  00000	8b 91 10 01 00
	00		 mov	 edx, DWORD PTR [rcx+272]
  00006	f6 c2 20	 test	 dl, 32			; 00000020H
  00009	75 0c		 jne	 SHORT $LN4@can_write
  0000b	33 c0		 xor	 eax, eax
  0000d	48 39 41 78	 cmp	 QWORD PTR [rcx+120], rax
  00011	76 06		 jbe	 SHORT $LN5@can_write
  00013	84 d2		 test	 dl, dl
  00015	78 02		 js	 SHORT $LN5@can_write
$LN4@can_write:
  00017	b0 01		 mov	 al, 1
$LN5@can_write:

; 7467 : }

  00019	c3		 ret	 0
can_write ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT skip_iotest
_TEXT	SEGMENT
c$ = 8
skip_iotest PROC					; COMDAT

; 7470 :   return (c->is_closing || c->is_resolving || FD(c) == MG_INVALID_SOCKET) ||

  00000	8b 91 10 01 00
	00		 mov	 edx, DWORD PTR [rcx+272]
  00006	4c 8b c1	 mov	 r8, rcx
  00009	f7 c2 08 20 00
	00		 test	 edx, 8200		; 00002008H
  0000f	75 23		 jne	 SHORT $LN3@skip_iotes
  00011	48 83 79 38 ff	 cmp	 QWORD PTR [rcx+56], -1
  00016	74 1c		 je	 SHORT $LN3@skip_iotes

; 7462 :   return c->is_full == false;

  00018	8b c2		 mov	 eax, edx
  0001a	33 c9		 xor	 ecx, ecx
  0001c	c1 e8 0e	 shr	 eax, 14
  0001f	f6 d0		 not	 al
  00021	a8 01		 test	 al, 1

; 7470 :   return (c->is_closing || c->is_resolving || FD(c) == MG_INVALID_SOCKET) ||

  00023	75 11		 jne	 SHORT $LN5@skip_iotes

; 7466 :   return c->is_connecting || (c->send.len > 0 && c->is_tls_hs == 0);

  00025	f6 c2 20	 test	 dl, 32			; 00000020H
  00028	75 0c		 jne	 SHORT $LN5@skip_iotes
  0002a	49 39 48 78	 cmp	 QWORD PTR [r8+120], rcx
  0002e	76 04		 jbe	 SHORT $LN3@skip_iotes
  00030	84 d2		 test	 dl, dl
  00032	79 02		 jns	 SHORT $LN5@skip_iotes
$LN3@skip_iotes:

; 7470 :   return (c->is_closing || c->is_resolving || FD(c) == MG_INVALID_SOCKET) ||

  00034	b1 01		 mov	 cl, 1
$LN5@skip_iotes:
  00036	8a c1		 mov	 al, cl

; 7471 :          (can_read(c) == false && can_write(c) == false);
; 7472 : }

  00038	c3		 ret	 0
skip_iotest ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_iotest
_TEXT	SEGMENT
eset$ = 48
rset$ = 576
wset$ = 1104
tv$ = 1664
mgr$ = 1664
ms$ = 1672
mg_iotest PROC						; COMDAT

; 7474 : static void mg_iotest(struct mg_mgr *mgr, int ms) {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	41 56		 push	 r14
  0000e	48 8d ac 24 a0
	fa ff ff	 lea	 rbp, QWORD PTR [rsp-1376]
  00016	48 81 ec 60 06
	00 00		 sub	 rsp, 1632		; 00000660H

; 7475 : #if MG_ENABLE_FREERTOS_TCP
; 7476 :   struct mg_connection *c;
; 7477 :   for (c = mgr->conns; c != NULL; c = c->next) {
; 7478 :     c->is_readable = c->is_writable = 0;
; 7479 :     if (skip_iotest(c)) continue;
; 7480 :     if (can_read(c))
; 7481 :       FreeRTOS_FD_SET(c->fd, mgr->ss, eSELECT_READ | eSELECT_EXCEPT);
; 7482 :     if (can_write(c)) FreeRTOS_FD_SET(c->fd, mgr->ss, eSELECT_WRITE);
; 7483 :     if (c->is_closing) ms = 1;
; 7484 :   }
; 7485 :   FreeRTOS_select(mgr->ss, pdMS_TO_TICKS(ms));
; 7486 :   for (c = mgr->conns; c != NULL; c = c->next) {
; 7487 :     EventBits_t bits = FreeRTOS_FD_ISSET(c->fd, mgr->ss);
; 7488 :     c->is_readable = bits & (eSELECT_READ | eSELECT_EXCEPT) ? 1U : 0;
; 7489 :     c->is_writable = bits & eSELECT_WRITE ? 1U : 0;
; 7490 :     if (c->fd != MG_INVALID_SOCKET)
; 7491 :       FreeRTOS_FD_CLR(c->fd, mgr->ss,
; 7492 :                       eSELECT_READ | eSELECT_EXCEPT | eSELECT_WRITE);
; 7493 :   }
; 7494 : #elif MG_ENABLE_EPOLL
; 7495 :   size_t max = 1;
; 7496 :   for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) {
; 7497 :     c->is_readable = c->is_writable = 0;
; 7498 :     if (mg_tls_pending(c) > 0) ms = 1, c->is_readable = 1;
; 7499 :     if (can_write(c)) MG_EPOLL_MOD(c, 1);
; 7500 :     if (c->is_closing) ms = 1;
; 7501 :     max++;
; 7502 :   }
; 7503 :   struct epoll_event *evs = (struct epoll_event *) alloca(max * sizeof(evs[0]));
; 7504 :   int n = epoll_wait(mgr->epoll_fd, evs, (int) max, ms);
; 7505 :   for (int i = 0; i < n; i++) {
; 7506 :     struct mg_connection *c = (struct mg_connection *) evs[i].data.ptr;
; 7507 :     if (evs[i].events & EPOLLERR) {
; 7508 :       mg_error(c, "socket error");
; 7509 :     } else if (c->is_readable == 0) {
; 7510 :       bool rd = evs[i].events & (EPOLLIN | EPOLLHUP);
; 7511 :       bool wr = evs[i].events & EPOLLOUT;
; 7512 :       c->is_readable = can_read(c) && rd ? 1U : 0;
; 7513 :       c->is_writable = can_write(c) && wr ? 1U : 0;
; 7514 :     }
; 7515 :   }
; 7516 :   (void) skip_iotest;
; 7517 : #elif MG_ENABLE_POLL
; 7518 :   nfds_t n = 0;
; 7519 :   for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) n++;
; 7520 :   struct pollfd *fds = (struct pollfd *) alloca(n * sizeof(fds[0]));
; 7521 :   memset(fds, 0, n * sizeof(fds[0]));
; 7522 :   n = 0;
; 7523 :   for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) {
; 7524 :     c->is_readable = c->is_writable = 0;
; 7525 :     if (skip_iotest(c)) {
; 7526 :       // Socket not valid, ignore
; 7527 :     } else if (mg_tls_pending(c) > 0) {
; 7528 :       ms = 1;  // Don't wait if TLS is ready
; 7529 :     } else {
; 7530 :       fds[n].fd = FD(c);
; 7531 :       if (can_read(c)) fds[n].events |= POLLIN;
; 7532 :       if (can_write(c)) fds[n].events |= POLLOUT;
; 7533 :       if (c->is_closing) ms = 1;
; 7534 :       n++;
; 7535 :     }
; 7536 :   }
; 7537 : 
; 7538 :   // MG_INFO(("poll n=%d ms=%d", (int) n, ms));
; 7539 :   if (poll(fds, n, ms) < 0) {
; 7540 : #if MG_ARCH == MG_ARCH_WIN32
; 7541 :     if (n == 0) Sleep(ms);  // On Windows, poll fails if no sockets
; 7542 : #endif
; 7543 :     memset(fds, 0, n * sizeof(fds[0]));
; 7544 :   }
; 7545 :   n = 0;
; 7546 :   for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) {
; 7547 :     if (skip_iotest(c)) {
; 7548 :       // Socket not valid, ignore
; 7549 :     } else if (mg_tls_pending(c) > 0) {
; 7550 :       c->is_readable = 1;
; 7551 :     } else {
; 7552 :       if (fds[n].revents & POLLERR) {
; 7553 :         mg_error(c, "socket error");
; 7554 :       } else {
; 7555 :         c->is_readable =
; 7556 :             (unsigned) (fds[n].revents & (POLLIN | POLLHUP) ? 1 : 0);
; 7557 :         c->is_writable = (unsigned) (fds[n].revents & POLLOUT ? 1 : 0);
; 7558 :       }
; 7559 :       n++;
; 7560 :     }
; 7561 :   }
; 7562 : #else
; 7563 :   struct timeval tv = {ms / 1000, (ms % 1000) * 1000}, tv_zero = {0, 0}, *tvp;
; 7564 :   struct mg_connection *c;
; 7565 :   fd_set rset, wset, eset;
; 7566 :   MG_SOCKET_TYPE maxfd = 0;

  0001d	45 33 f6	 xor	 r14d, r14d

; 7567 :   int rc;
; 7568 : 
; 7569 :   FD_ZERO(&rset);
; 7570 :   FD_ZERO(&wset);
; 7571 :   FD_ZERO(&eset);
; 7572 :   tvp = ms < 0 ? NULL : &tv;

  00020	4c 8d 95 80 05
	00 00		 lea	 r10, QWORD PTR tv$[rbp-256]
  00027	8b fa		 mov	 edi, edx
  00029	44 89 b5 40 01
	00 00		 mov	 DWORD PTR rset$[rbp-256], r14d
  00030	48 8b f1	 mov	 rsi, rcx
  00033	44 89 b5 50 03
	00 00		 mov	 DWORD PTR wset$[rbp-256], r14d
  0003a	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  0003f	44 89 74 24 30	 mov	 DWORD PTR eset$[rsp], r14d
  00044	f7 ea		 imul	 edx

; 7573 :   for (c = mgr->conns; c != NULL; c = c->next) {

  00046	4c 8b 0e	 mov	 r9, QWORD PTR [rsi]
  00049	8b cf		 mov	 ecx, edi
  0004b	c1 fa 06	 sar	 edx, 6
  0004e	41 8b de	 mov	 ebx, r14d
  00051	8b c2		 mov	 eax, edx
  00053	c1 e8 1f	 shr	 eax, 31
  00056	03 d0		 add	 edx, eax
  00058	69 c2 e8 03 00
	00		 imul	 eax, edx, 1000		; 000003e8H
  0005e	89 95 80 05 00
	00		 mov	 DWORD PTR tv$[rbp-256], edx
  00064	2b c8		 sub	 ecx, eax
  00066	69 c1 e8 03 00
	00		 imul	 eax, ecx, 1000		; 000003e8H
  0006c	85 ff		 test	 edi, edi
  0006e	4d 0f 48 d6	 cmovs	 r10, r14
  00072	89 85 84 05 00
	00		 mov	 DWORD PTR tv$[rbp-252], eax
  00078	4d 85 c9	 test	 r9, r9
  0007b	0f 84 1f 01 00
	00		 je	 $LN3@mg_iotest
  00081	45 8d 5e 01	 lea	 r11d, QWORD PTR [r14+1]
$LL4@mg_iotest:

; 7574 :     c->is_readable = c->is_writable = 0;

  00085	41 81 a1 10 01
	00 00 ff ff fc
	ff		 and	 DWORD PTR [r9+272], -196609 ; fffcffffH

; 7575 :     if (skip_iotest(c)) continue;

  00090	49 8b c9	 mov	 rcx, r9
  00093	e8 00 00 00 00	 call	 skip_iotest
  00098	84 c0		 test	 al, al
  0009a	0f 85 f4 00 00
	00		 jne	 $LN2@mg_iotest

; 7576 :     FD_SET(FD(c), &eset);

  000a0	8b 54 24 30	 mov	 edx, DWORD PTR eset$[rsp]
  000a4	41 8b ce	 mov	 ecx, r14d
  000a7	85 d2		 test	 edx, edx
  000a9	74 12		 je	 SHORT $LN63@mg_iotest
  000ab	4d 8b 41 38	 mov	 r8, QWORD PTR [r9+56]
$LL10@mg_iotest:
  000af	4c 39 44 cc 38	 cmp	 QWORD PTR eset$[rsp+rcx*8+8], r8
  000b4	74 07		 je	 SHORT $LN63@mg_iotest
  000b6	41 03 cb	 add	 ecx, r11d
  000b9	3b ca		 cmp	 ecx, edx
  000bb	72 f2		 jb	 SHORT $LL10@mg_iotest
$LN63@mg_iotest:
  000bd	3b ca		 cmp	 ecx, edx
  000bf	75 13		 jne	 SHORT $LN5@mg_iotest
  000c1	83 fa 40	 cmp	 edx, 64			; 00000040H
  000c4	73 0e		 jae	 SHORT $LN5@mg_iotest
  000c6	49 8b 41 38	 mov	 rax, QWORD PTR [r9+56]
  000ca	48 89 44 cc 38	 mov	 QWORD PTR eset$[rsp+rcx*8+8], rax
  000cf	44 01 5c 24 30	 add	 DWORD PTR eset$[rsp], r11d
$LN5@mg_iotest:

; 7462 :   return c->is_full == false;

  000d4	41 8b 81 10 01
	00 00		 mov	 eax, DWORD PTR [r9+272]
  000db	c1 e8 0e	 shr	 eax, 14
  000de	f6 d0		 not	 al
  000e0	41 84 c3	 test	 al, r11b

; 7577 :     if (can_read(c)) FD_SET(FD(c), &rset);

  000e3	74 3e		 je	 SHORT $LN12@mg_iotest
  000e5	8b 95 40 01 00
	00		 mov	 edx, DWORD PTR rset$[rbp-256]
  000eb	41 8b ce	 mov	 ecx, r14d
  000ee	85 d2		 test	 edx, edx
  000f0	74 15		 je	 SHORT $LN64@mg_iotest
  000f2	4d 8b 41 38	 mov	 r8, QWORD PTR [r9+56]
$LL16@mg_iotest:
  000f6	4c 39 84 cd 48
	01 00 00	 cmp	 QWORD PTR rset$[rbp+rcx*8-248], r8
  000fe	74 07		 je	 SHORT $LN64@mg_iotest
  00100	41 03 cb	 add	 ecx, r11d
  00103	3b ca		 cmp	 ecx, edx
  00105	72 ef		 jb	 SHORT $LL16@mg_iotest
$LN64@mg_iotest:
  00107	3b ca		 cmp	 ecx, edx
  00109	75 18		 jne	 SHORT $LN12@mg_iotest
  0010b	83 fa 40	 cmp	 edx, 64			; 00000040H
  0010e	73 13		 jae	 SHORT $LN12@mg_iotest
  00110	49 8b 41 38	 mov	 rax, QWORD PTR [r9+56]
  00114	48 89 84 cd 48
	01 00 00	 mov	 QWORD PTR rset$[rbp+rcx*8-248], rax
  0011c	44 01 9d 40 01
	00 00		 add	 DWORD PTR rset$[rbp-256], r11d
$LN12@mg_iotest:

; 7466 :   return c->is_connecting || (c->send.len > 0 && c->is_tls_hs == 0);

  00123	41 8b 81 10 01
	00 00		 mov	 eax, DWORD PTR [r9+272]
  0012a	a8 20		 test	 al, 32			; 00000020H
  0012c	75 0a		 jne	 SHORT $LN88@mg_iotest
  0012e	4d 39 71 78	 cmp	 QWORD PTR [r9+120], r14
  00132	76 42		 jbe	 SHORT $LN18@mg_iotest
  00134	84 c0		 test	 al, al
  00136	78 3e		 js	 SHORT $LN18@mg_iotest
$LN88@mg_iotest:

; 7578 :     if (can_write(c)) FD_SET(FD(c), &wset);

  00138	8b 95 50 03 00
	00		 mov	 edx, DWORD PTR wset$[rbp-256]
  0013e	41 8b ce	 mov	 ecx, r14d
  00141	85 d2		 test	 edx, edx
  00143	74 15		 je	 SHORT $LN65@mg_iotest
  00145	4d 8b 41 38	 mov	 r8, QWORD PTR [r9+56]
$LL22@mg_iotest:
  00149	4c 39 84 cd 58
	03 00 00	 cmp	 QWORD PTR wset$[rbp+rcx*8-248], r8
  00151	74 07		 je	 SHORT $LN65@mg_iotest
  00153	41 03 cb	 add	 ecx, r11d
  00156	3b ca		 cmp	 ecx, edx
  00158	72 ef		 jb	 SHORT $LL22@mg_iotest
$LN65@mg_iotest:
  0015a	3b ca		 cmp	 ecx, edx
  0015c	75 18		 jne	 SHORT $LN18@mg_iotest
  0015e	83 fa 40	 cmp	 edx, 64			; 00000040H
  00161	73 13		 jae	 SHORT $LN18@mg_iotest
  00163	49 8b 41 38	 mov	 rax, QWORD PTR [r9+56]
  00167	48 89 84 cd 58
	03 00 00	 mov	 QWORD PTR wset$[rbp+rcx*8-248], rax
  0016f	44 01 9d 50 03
	00 00		 add	 DWORD PTR wset$[rbp-256], r11d
$LN18@mg_iotest:

; 7579 :     if (mg_tls_pending(c) > 0) tvp = &tv_zero;
; 7580 :     if (FD(c) > maxfd) maxfd = FD(c);

  00176	49 8b 41 38	 mov	 rax, QWORD PTR [r9+56]

; 7581 :     if (c->is_closing) ms = 1;

  0017a	48 3b c3	 cmp	 rax, rbx
  0017d	48 0f 46 c3	 cmovbe	 rax, rbx
  00181	41 f7 81 10 01
	00 00 00 20 00
	00		 test	 DWORD PTR [r9+272], 8192 ; 00002000H
  0018c	48 8b d8	 mov	 rbx, rax
  0018f	74 03		 je	 SHORT $LN2@mg_iotest
  00191	41 8b fb	 mov	 edi, r11d
$LN2@mg_iotest:

; 7573 :   for (c = mgr->conns; c != NULL; c = c->next) {

  00194	4d 8b 09	 mov	 r9, QWORD PTR [r9]
  00197	4d 85 c9	 test	 r9, r9
  0019a	0f 85 e5 fe ff
	ff		 jne	 $LL4@mg_iotest
$LN3@mg_iotest:

; 7582 :   }
; 7583 : 
; 7584 :   if ((rc = select((int) maxfd + 1, &rset, &wset, &eset, tvp)) < 0) {

  001a0	8d 4b 01	 lea	 ecx, DWORD PTR [rbx+1]
  001a3	4c 89 54 24 20	 mov	 QWORD PTR [rsp+32], r10
  001a8	4c 8d 4c 24 30	 lea	 r9, QWORD PTR eset$[rsp]
  001ad	4c 8d 85 50 03
	00 00		 lea	 r8, QWORD PTR wset$[rbp-256]
  001b4	48 8d 95 40 01
	00 00		 lea	 rdx, QWORD PTR rset$[rbp-256]
  001bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_select
  001c1	85 c0		 test	 eax, eax
  001c3	79 20		 jns	 SHORT $LN41@mg_iotest

; 7585 : #if MG_ARCH == MG_ARCH_WIN32
; 7586 :     if (maxfd == 0) Sleep(ms);  // On Windows, select fails if no sockets

  001c5	48 85 db	 test	 rbx, rbx
  001c8	75 08		 jne	 SHORT $LN42@mg_iotest
  001ca	8b cf		 mov	 ecx, edi
  001cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep
$LN42@mg_iotest:

; 7587 : #else
; 7588 :     MG_ERROR(("select: %d %d", rc, MG_SOCK_ERR(rc)));
; 7589 : #endif
; 7590 :     FD_ZERO(&rset);

  001d2	44 89 b5 40 01
	00 00		 mov	 DWORD PTR rset$[rbp-256], r14d

; 7591 :     FD_ZERO(&wset);

  001d9	44 89 b5 50 03
	00 00		 mov	 DWORD PTR wset$[rbp-256], r14d

; 7592 :     FD_ZERO(&eset);

  001e0	44 89 74 24 30	 mov	 DWORD PTR eset$[rsp], r14d
$LN41@mg_iotest:

; 7593 :   }
; 7594 : 
; 7595 :   for (c = mgr->conns; c != NULL; c = c->next) {

  001e5	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
  001e8	e9 93 00 00 00	 jmp	 $LN92@mg_iotest
$LL25@mg_iotest:

; 7596 :     if (FD(c) != MG_INVALID_SOCKET && FD_ISSET(FD(c), &eset)) {

  001ed	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  001f1	48 83 f9 ff	 cmp	 rcx, -1
  001f5	74 20		 je	 SHORT $LN85@mg_iotest
  001f7	48 8d 54 24 30	 lea	 rdx, QWORD PTR eset$[rsp]
  001fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___WSAFDIsSet
  00202	85 c0		 test	 eax, eax
  00204	74 11		 je	 SHORT $LN85@mg_iotest

; 7597 :       mg_error(c, "socket error");

  00206	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@PIIOOFNF@socket?5error@
  0020d	48 8b cb	 mov	 rcx, rbx
  00210	e8 00 00 00 00	 call	 mg_error

; 7598 :     } else {

  00215	eb 66		 jmp	 SHORT $LN23@mg_iotest
$LN85@mg_iotest:

; 7599 :       c->is_readable = FD(c) != MG_INVALID_SOCKET && FD_ISSET(FD(c), &rset);

  00217	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  0021b	48 83 f9 ff	 cmp	 rcx, -1
  0021f	74 16		 je	 SHORT $LN86@mg_iotest
  00221	48 8d 95 40 01
	00 00		 lea	 rdx, QWORD PTR rset$[rbp-256]
  00228	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___WSAFDIsSet
  0022e	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00233	85 c0		 test	 eax, eax
  00235	75 03		 jne	 SHORT $LN48@mg_iotest
$LN86@mg_iotest:
  00237	41 8b ce	 mov	 ecx, r14d
$LN48@mg_iotest:
  0023a	8b 83 10 01 00
	00		 mov	 eax, DWORD PTR [rbx+272]
  00240	0f ba f0 10	 btr	 eax, 16
  00244	0b c1		 or	 eax, ecx

; 7600 :       c->is_writable = FD(c) != MG_INVALID_SOCKET && FD_ISSET(FD(c), &wset);

  00246	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  0024a	89 83 10 01 00
	00		 mov	 DWORD PTR [rbx+272], eax
  00250	48 83 f9 ff	 cmp	 rcx, -1
  00254	74 16		 je	 SHORT $LN87@mg_iotest
  00256	48 8d 95 50 03
	00 00		 lea	 rdx, QWORD PTR wset$[rbp-256]
  0025d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___WSAFDIsSet
  00263	85 c0		 test	 eax, eax
  00265	b8 00 00 02 00	 mov	 eax, 131072		; 00020000H
  0026a	75 03		 jne	 SHORT $LN50@mg_iotest
$LN87@mg_iotest:
  0026c	41 8b c6	 mov	 eax, r14d
$LN50@mg_iotest:
  0026f	0f ba b3 10 01
	00 00 11	 btr	 DWORD PTR [rbx+272], 17
  00277	09 83 10 01 00
	00		 or	 DWORD PTR [rbx+272], eax
$LN23@mg_iotest:

; 7593 :   }
; 7594 : 
; 7595 :   for (c = mgr->conns; c != NULL; c = c->next) {

  0027d	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN92@mg_iotest:
  00280	48 85 db	 test	 rbx, rbx
  00283	0f 85 64 ff ff
	ff		 jne	 $LL25@mg_iotest

; 7601 :       if (mg_tls_pending(c) > 0) c->is_readable = 1;
; 7602 :     }
; 7603 :   }
; 7604 : #endif
; 7605 : }

  00289	4c 8d 9c 24 60
	06 00 00	 lea	 r11, QWORD PTR [rsp+1632]
  00291	49 8b 5b 28	 mov	 rbx, QWORD PTR [r11+40]
  00295	49 8b 73 30	 mov	 rsi, QWORD PTR [r11+48]
  00299	49 8b e3	 mov	 rsp, r11
  0029c	41 5e		 pop	 r14
  0029e	5f		 pop	 rdi
  0029f	5d		 pop	 rbp
  002a0	c3		 ret	 0
mg_iotest ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_socketpair
_TEXT	SEGMENT
n$ = 64
sp$ = 64
usa$ = 72
mg_socketpair PROC					; COMDAT

; 7607 : static bool mg_socketpair(MG_SOCKET_TYPE sp[2], union usa usa[2]) {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00007	48 89 68 18	 mov	 QWORD PTR [rax+24], rbp
  0000b	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00018	0f 57 c0	 xorps	 xmm0, xmm0

; 7608 :   socklen_t n = sizeof(usa[0].sin);

  0001b	c7 40 08 10 00
	00 00		 mov	 DWORD PTR [rax+8], 16

; 7609 :   bool success = false;
; 7610 : 
; 7611 :   sp[0] = sp[1] = MG_INVALID_SOCKET;
; 7612 :   (void) memset(&usa[0], 0, sizeof(usa[0]));

  00022	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0

; 7613 :   usa[0].sin.sin_family = AF_INET;
; 7614 :   *(uint32_t *) &usa->sin.sin_addr = mg_htonl(0x7f000001U);  // 127.0.0.1

  00025	c7 42 04 7f 00
	00 01		 mov	 DWORD PTR [rdx+4], 16777343 ; 0100007fH

; 7615 :   usa[1] = usa[0];

  0002c	48 8d 6a 10	 lea	 rbp, QWORD PTR [rdx+16]
  00030	49 83 ce ff	 or	 r14, -1
  00034	48 8b f2	 mov	 rsi, rdx
  00037	48 8b d9	 mov	 rbx, rcx
  0003a	4c 89 71 08	 mov	 QWORD PTR [rcx+8], r14
  0003e	4c 89 31	 mov	 QWORD PTR [rcx], r14
  00041	33 ff		 xor	 edi, edi

; 7616 : 
; 7617 :   if ((sp[0] = socket(AF_INET, SOCK_DGRAM, 0)) != MG_INVALID_SOCKET &&
; 7618 :       (sp[1] = socket(AF_INET, SOCK_DGRAM, 0)) != MG_INVALID_SOCKET &&
; 7619 :       bind(sp[0], &usa[0].sa, n) == 0 &&          //
; 7620 :       bind(sp[1], &usa[1].sa, n) == 0 &&          //
; 7621 :       getsockname(sp[0], &usa[0].sa, &n) == 0 &&  //
; 7622 :       getsockname(sp[1], &usa[1].sa, &n) == 0 &&  //
; 7623 :       connect(sp[0], &usa[1].sa, n) == 0 &&       //

  00043	45 33 c0	 xor	 r8d, r8d
  00046	44 8d 7f 02	 lea	 r15d, QWORD PTR [rdi+2]
  0004a	66 44 89 3a	 mov	 WORD PTR [rdx], r15w
  0004e	41 8b cf	 mov	 ecx, r15d
  00051	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  00054	41 8b d7	 mov	 edx, r15d
  00057	f3 0f 7f 45 00	 movdqu	 XMMWORD PTR [rbp], xmm0
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket
  00062	48 89 03	 mov	 QWORD PTR [rbx], rax
  00065	49 3b c6	 cmp	 rax, r14
  00068	0f 84 a2 00 00
	00		 je	 $LN9@mg_socketp
  0006e	45 33 c0	 xor	 r8d, r8d
  00071	41 8b d7	 mov	 edx, r15d
  00074	41 8b cf	 mov	 ecx, r15d
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket
  0007d	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
  00081	49 3b c6	 cmp	 rax, r14
  00084	0f 84 86 00 00
	00		 je	 $LN9@mg_socketp
  0008a	44 8b 44 24 40	 mov	 r8d, DWORD PTR n$[rsp]
  0008f	48 8b d6	 mov	 rdx, rsi
  00092	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_bind
  0009b	85 c0		 test	 eax, eax
  0009d	75 71		 jne	 SHORT $LN9@mg_socketp
  0009f	44 8b 44 24 40	 mov	 r8d, DWORD PTR n$[rsp]
  000a4	48 8b d5	 mov	 rdx, rbp
  000a7	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_bind
  000b1	85 c0		 test	 eax, eax
  000b3	75 5b		 jne	 SHORT $LN9@mg_socketp
  000b5	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000b8	4c 8d 44 24 40	 lea	 r8, QWORD PTR n$[rsp]
  000bd	48 8b d6	 mov	 rdx, rsi
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getsockname
  000c6	85 c0		 test	 eax, eax
  000c8	75 46		 jne	 SHORT $LN9@mg_socketp
  000ca	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  000ce	4c 8d 44 24 40	 lea	 r8, QWORD PTR n$[rsp]
  000d3	48 8b d5	 mov	 rdx, rbp
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getsockname
  000dc	85 c0		 test	 eax, eax
  000de	75 30		 jne	 SHORT $LN9@mg_socketp
  000e0	44 8b 44 24 40	 mov	 r8d, DWORD PTR n$[rsp]
  000e5	48 8b d5	 mov	 rdx, rbp
  000e8	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_connect
  000f1	85 c0		 test	 eax, eax
  000f3	75 1b		 jne	 SHORT $LN9@mg_socketp
  000f5	44 8b 44 24 40	 mov	 r8d, DWORD PTR n$[rsp]
  000fa	48 8b d6	 mov	 rdx, rsi
  000fd	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_connect
  00107	85 c0		 test	 eax, eax
  00109	75 05		 jne	 SHORT $LN9@mg_socketp

; 7624 :       connect(sp[1], &usa[0].sa, n) == 0) {       //
; 7625 :     success = true;

  0010b	40 b7 01	 mov	 dil, 1

; 7626 :   }
; 7627 :   if (!success) {

  0010e	eb 24		 jmp	 SHORT $LN3@mg_socketp
$LN9@mg_socketp:

; 7628 :     if (sp[0] != MG_INVALID_SOCKET) closesocket(sp[0]);

  00110	4c 39 33	 cmp	 QWORD PTR [rbx], r14
  00113	74 09		 je	 SHORT $LN4@mg_socketp
  00115	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
$LN4@mg_socketp:

; 7629 :     if (sp[1] != MG_INVALID_SOCKET) closesocket(sp[1]);

  0011e	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00122	49 3b ce	 cmp	 rcx, r14
  00125	74 06		 je	 SHORT $LN5@mg_socketp
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
$LN5@mg_socketp:

; 7630 :     sp[0] = sp[1] = MG_INVALID_SOCKET;

  0012d	4c 89 73 08	 mov	 QWORD PTR [rbx+8], r14
  00131	4c 89 33	 mov	 QWORD PTR [rbx], r14
$LN3@mg_socketp:

; 7631 :   }
; 7632 :   return success;
; 7633 : }

  00134	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00139	40 8a c7	 mov	 al, dil
  0013c	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00141	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00146	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0014a	41 5f		 pop	 r15
  0014c	41 5e		 pop	 r14
  0014e	5f		 pop	 rdi
  0014f	c3		 ret	 0
mg_socketpair ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT wufn
_TEXT	SEGMENT
data$1 = 32
c$ = 64
ev$ = 72
ev_data$ = 80
wufn	PROC						; COMDAT

; 7636 : static void wufn(struct mg_connection *c, int ev, void *ev_data) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b d9	 mov	 rbx, rcx

; 7637 :   if (ev == MG_EV_READ) {

  00012	83 fa 07	 cmp	 edx, 7
  00015	75 56		 jne	 SHORT $LN5@wufn

; 7638 :     unsigned long *id = (unsigned long *) c->recv.buf;
; 7639 :     // MG_INFO(("Got data"));
; 7640 :     // mg_hexdump(c->recv.buf, c->recv.len);
; 7641 :     if (c->recv.len >= sizeof(*id)) {

  00017	48 83 79 58 04	 cmp	 QWORD PTR [rcx+88], 4
  0001c	48 8b 71 48	 mov	 rsi, QWORD PTR [rcx+72]
  00020	72 44		 jb	 SHORT $LN3@wufn

; 7642 :       struct mg_connection *t;
; 7643 :       for (t = c->mgr->conns; t != NULL; t = t->next) {

  00022	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00026	48 8b 38	 mov	 rdi, QWORD PTR [rax]
  00029	eb 36		 jmp	 SHORT $LN17@wufn
$LL4@wufn:

; 7644 :         if (t->id == *id) {

  0002b	8b 06		 mov	 eax, DWORD PTR [rsi]
  0002d	39 47 40	 cmp	 DWORD PTR [rdi+64], eax
  00030	75 2c		 jne	 SHORT $LN2@wufn

; 7645 :           struct mg_str data = mg_str_n((char *) c->recv.buf + sizeof(*id),

  00032	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]

; 7646 :                                         c->recv.len - sizeof(*id));
; 7647 :           mg_call(t, MG_EV_WAKEUP, &data);

  00036	4c 8d 44 24 20	 lea	 r8, QWORD PTR data$1[rsp]
  0003b	48 83 c0 04	 add	 rax, 4
  0003f	ba 12 00 00 00	 mov	 edx, 18
  00044	48 89 44 24 20	 mov	 QWORD PTR data$1[rsp], rax
  00049	48 8b cf	 mov	 rcx, rdi
  0004c	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00050	48 83 e8 04	 sub	 rax, 4
  00054	48 89 44 24 28	 mov	 QWORD PTR data$1[rsp+8], rax
  00059	e8 00 00 00 00	 call	 mg_call
$LN2@wufn:

; 7642 :       struct mg_connection *t;
; 7643 :       for (t = c->mgr->conns; t != NULL; t = t->next) {

  0005e	48 8b 3f	 mov	 rdi, QWORD PTR [rdi]
$LN17@wufn:
  00061	48 85 ff	 test	 rdi, rdi
  00064	75 c5		 jne	 SHORT $LL4@wufn
$LN3@wufn:

; 7648 :         }
; 7649 :       }
; 7650 :     }
; 7651 :     c->recv.len = 0;  // Consume received data

  00066	48 83 63 58 00	 and	 QWORD PTR [rbx+88], 0
  0006b	eb 1c		 jmp	 SHORT $LN9@wufn
$LN5@wufn:

; 7652 :   } else if (ev == MG_EV_CLOSE) {

  0006d	83 fa 09	 cmp	 edx, 9
  00070	75 17		 jne	 SHORT $LN9@wufn

; 7653 :     closesocket(c->mgr->pipe);         // When we're closing, close the other

  00072	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00076	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket

; 7654 :     c->mgr->pipe = MG_INVALID_SOCKET;  // side of the socketpair, too

  00080	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00084	48 83 48 78 ff	 or	 QWORD PTR [rax+120], -1
$LN9@wufn:

; 7655 :   }
; 7656 :   (void) ev_data;
; 7657 : }

  00089	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0008e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00093	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
wufn	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_wakeup_init
_TEXT	SEGMENT
sp$1 = 32
usa$2 = 48
mgr$ = 96
mg_wakeup_init PROC					; COMDAT

; 7659 : bool mg_wakeup_init(struct mg_mgr *mgr) {

$LN19:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  00007	49 89 73 10	 mov	 QWORD PTR [r11+16], rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 7660 :   bool ok = false;

  00010	33 db		 xor	 ebx, ebx

; 7661 :   if (mgr->pipe == MG_INVALID_SOCKET) {

  00012	48 83 c8 ff	 or	 rax, -1
  00016	48 8b f1	 mov	 rsi, rcx
  00019	48 39 41 78	 cmp	 QWORD PTR [rcx+120], rax
  0001d	0f 85 c8 00 00
	00		 jne	 $LN13@mg_wakeup_

; 7662 :     union usa usa[2];
; 7663 :     MG_SOCKET_TYPE sp[2] = {MG_INVALID_SOCKET, MG_INVALID_SOCKET};
; 7664 :     struct mg_connection *c = NULL;
; 7665 :     if (!mg_socketpair(sp, usa)) {

  00023	49 8d 53 d8	 lea	 rdx, QWORD PTR [r11-40]
  00027	49 89 43 c8	 mov	 QWORD PTR [r11-56], rax
  0002b	49 8d 4b c8	 lea	 rcx, QWORD PTR [r11-56]
  0002f	49 89 43 d0	 mov	 QWORD PTR [r11-48], rax
  00033	e8 00 00 00 00	 call	 mg_socketpair
  00038	84 c0		 test	 al, al
  0003a	75 30		 jne	 SHORT $LN9@mg_wakeup_

; 7666 :       MG_ERROR(("Cannot create socket pair"));

  0003c	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR mg_log_level, 1
  00043	0f 8c a2 00 00
	00		 jl	 $LN13@mg_wakeup_
  00049	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0P@BJADDKBJ@mg_wakeup_init@
  00050	41 b8 f2 1d 00
	00		 mov	 r8d, 7666		; 00001df2H
  00056	8d 4b 01	 lea	 ecx, QWORD PTR [rbx+1]
  00059	e8 00 00 00 00	 call	 mg_log_prefix
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@NGAOEDDO@Cannot?5create?5socket?5pair@
  00065	e8 00 00 00 00	 call	 mg_log

; 7667 :     } else if ((c = mg_wrapfd(mgr, (int) sp[1], wufn, NULL)) == NULL) {

  0006a	eb 7f		 jmp	 SHORT $LN13@mg_wakeup_
$LN9@mg_wakeup_:
  0006c	8b 54 24 28	 mov	 edx, DWORD PTR sp$1[rsp+8]
  00070	48 8b ce	 mov	 rcx, rsi
  00073	e8 00 00 00 00	 call	 mg_wrapfd
  00078	48 8b f8	 mov	 rdi, rax
  0007b	48 85 c0	 test	 rax, rax
  0007e	75 18		 jne	 SHORT $LN12@mg_wakeup_

; 7668 :       closesocket(sp[0]);

  00080	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sp$1[rsp]
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket

; 7669 :       closesocket(sp[1]);

  0008b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sp$1[rsp+8]
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket

; 7670 :       sp[0] = sp[1] = MG_INVALID_SOCKET;
; 7671 :     } else {

  00096	eb 53		 jmp	 SHORT $LN13@mg_wakeup_
$LN12@mg_wakeup_:

; 7089 :   a->is_ip6 = is_ip6;

  00098	88 58 37	 mov	 BYTE PTR [rax+55], bl

; 7672 :       tomgaddr(&usa[0], &c->rem, false);
; 7673 :       MG_DEBUG(("%lu %p pipe %lu", c->id, c->fd, (unsigned long) sp[0]));

  0009b	b9 03 00 00 00	 mov	 ecx, 3
  000a0	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx

; 7090 :   a->port = usa->sin.sin_port;

  000a6	0f b7 44 24 32	 movzx	 eax, WORD PTR usa$2[rsp+2]

; 7672 :       tomgaddr(&usa[0], &c->rem, false);
; 7673 :       MG_DEBUG(("%lu %p pipe %lu", c->id, c->fd, (unsigned long) sp[0]));

  000ab	48 8b 5c 24 20	 mov	 rbx, QWORD PTR sp$1[rsp]

; 7090 :   a->port = usa->sin.sin_port;

  000b0	66 89 47 34	 mov	 WORD PTR [rdi+52], ax

; 7091 :   memcpy(&a->ip, &usa->sin.sin_addr, sizeof(uint32_t));

  000b4	8b 44 24 34	 mov	 eax, DWORD PTR usa$2[rsp+4]
  000b8	89 47 24	 mov	 DWORD PTR [rdi+36], eax

; 7672 :       tomgaddr(&usa[0], &c->rem, false);
; 7673 :       MG_DEBUG(("%lu %p pipe %lu", c->id, c->fd, (unsigned long) sp[0]));

  000bb	7c 28		 jl	 SHORT $LN5@mg_wakeup_
  000bd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0P@BJADDKBJ@mg_wakeup_init@
  000c4	41 b8 f9 1d 00
	00		 mov	 r8d, 7673		; 00001df9H
  000ca	e8 00 00 00 00	 call	 mg_log_prefix
  000cf	4c 8b 47 38	 mov	 r8, QWORD PTR [rdi+56]
  000d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@FLEIGMKI@?$CFlu?5?$CFp?5pipe?5?$CFlu@
  000da	8b 57 40	 mov	 edx, DWORD PTR [rdi+64]
  000dd	44 8b cb	 mov	 r9d, ebx
  000e0	e8 00 00 00 00	 call	 mg_log
$LN5@mg_wakeup_:

; 7674 :       mgr->pipe = sp[0];

  000e5	48 89 5e 78	 mov	 QWORD PTR [rsi+120], rbx

; 7675 :       ok = true;

  000e9	b3 01		 mov	 bl, 1
$LN13@mg_wakeup_:

; 7676 :     }
; 7677 :   }
; 7678 :   return ok;
; 7679 : }

  000eb	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  000f0	8a c3		 mov	 al, bl
  000f2	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000f7	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000fb	5f		 pop	 rdi
  000fc	c3		 ret	 0
mg_wakeup_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_wakeup
_TEXT	SEGMENT
mgr$ = 16
conn_id$ = 24
buf$ = 32
len$ = 40
mg_wakeup PROC						; COMDAT

; 7682 :                size_t len) {

$LN6:
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]

; 7683 :   if (mgr->pipe != MG_INVALID_SOCKET && conn_id > 0) {

  0000b	48 83 79 78 ff	 cmp	 QWORD PTR [rcx+120], -1
  00010	48 89 5d 10	 mov	 QWORD PTR [rbp+16], rbx
  00014	48 89 75 18	 mov	 QWORD PTR [rbp+24], rsi
  00018	48 8b f1	 mov	 rsi, rcx
  0001b	48 89 7d 20	 mov	 QWORD PTR [rbp+32], rdi
  0001f	49 8b f9	 mov	 rdi, r9
  00022	4d 8b c8	 mov	 r9, r8
  00025	74 58		 je	 SHORT $LN2@mg_wakeup
  00027	85 d2		 test	 edx, edx
  00029	74 54		 je	 SHORT $LN2@mg_wakeup

; 7684 :     char *extended_buf = (char *) alloca(len + sizeof(conn_id));

  0002b	48 8d 47 04	 lea	 rax, QWORD PTR [rdi+4]
  0002f	4c 8d 50 0f	 lea	 r10, QWORD PTR [rax+15]
  00033	4c 3b d0	 cmp	 r10, rax
  00036	77 0a		 ja	 SHORT $LN4@mg_wakeup
  00038	49 ba f0 ff ff
	ff ff ff ff 0f	 mov	 r10, 1152921504606846960 ; 0ffffffffffffff0H
$LN4@mg_wakeup:
  00042	49 83 e2 f0	 and	 r10, -16
  00046	49 8b c2	 mov	 rax, r10
  00049	e8 00 00 00 00	 call	 __chkstk
  0004e	48 2b e0	 sub	 rsp, rax

; 7685 :     memcpy(extended_buf, &conn_id, sizeof(conn_id));
; 7686 :     memcpy(extended_buf + sizeof(conn_id), buf, len);

  00051	4c 8b c7	 mov	 r8, rdi
  00054	48 8d 5c 24 20	 lea	 rbx, QWORD PTR [rsp+32]
  00059	89 13		 mov	 DWORD PTR [rbx], edx
  0005b	48 8d 4b 04	 lea	 rcx, QWORD PTR [rbx+4]
  0005f	49 8b d1	 mov	 rdx, r9
  00062	e8 00 00 00 00	 call	 memcpy

; 7687 :     send(mgr->pipe, extended_buf, len + sizeof(conn_id), MSG_NONBLOCKING);

  00067	48 8b 4e 78	 mov	 rcx, QWORD PTR [rsi+120]
  0006b	44 8d 47 04	 lea	 r8d, DWORD PTR [rdi+4]
  0006f	45 33 c9	 xor	 r9d, r9d
  00072	48 8b d3	 mov	 rdx, rbx
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send

; 7688 :     return true;

  0007b	b0 01		 mov	 al, 1
  0007d	eb 02		 jmp	 SHORT $LN1@mg_wakeup
$LN2@mg_wakeup:

; 7689 :   }
; 7690 :   return false;

  0007f	32 c0		 xor	 al, al
$LN1@mg_wakeup:

; 7691 : }

  00081	48 8b 5d 10	 mov	 rbx, QWORD PTR [rbp+16]
  00085	48 8b 75 18	 mov	 rsi, QWORD PTR [rbp+24]
  00089	48 8b 7d 20	 mov	 rdi, QWORD PTR [rbp+32]
  0008d	48 8b e5	 mov	 rsp, rbp
  00090	5d		 pop	 rbp
  00091	c3		 ret	 0
mg_wakeup ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_mgr_poll
_TEXT	SEGMENT
n$1 = 112
mgr$ = 112
ms$ = 120
now$ = 128
mg_mgr_poll PROC					; COMDAT

; 7693 : void mg_mgr_poll(struct mg_mgr *mgr, int ms) {

$LN32:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000c	48 8b f1	 mov	 rsi, rcx

; 7694 :   struct mg_connection *c, *tmp;
; 7695 :   uint64_t now;
; 7696 : 
; 7697 :   mg_iotest(mgr, ms);

  0000f	e8 00 00 00 00	 call	 mg_iotest

; 13865:   return GetTickCount();

  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  0001a	8b d0		 mov	 edx, eax

; 7698 :   now = mg_millis();
; 7699 :   mg_timer_poll(&mgr->timers, now);

  0001c	48 8d 4e 58	 lea	 rcx, QWORD PTR [rsi+88]

; 13865:   return GetTickCount();

  00020	48 89 94 24 80
	00 00 00	 mov	 QWORD PTR now$[rsp], rdx

; 7698 :   now = mg_millis();
; 7699 :   mg_timer_poll(&mgr->timers, now);

  00028	e8 00 00 00 00	 call	 mg_timer_poll

; 7700 : 
; 7701 :   for (c = mgr->conns; c != NULL; c = tmp) {

  0002d	48 8b 3e	 mov	 rdi, QWORD PTR [rsi]
  00030	48 85 ff	 test	 rdi, rdi
  00033	0f 84 ad 01 00
	00		 je	 $LN3@mg_mgr_pol
$LL4@mg_mgr_pol:

; 7702 :     bool is_resp = c->is_resp;

  00039	8b 9f 10 01 00
	00		 mov	 ebx, DWORD PTR [rdi+272]

; 7703 :     tmp = c->next;
; 7704 :     mg_call(c, MG_EV_POLL, &now);

  0003f	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR now$[rsp]
  00047	48 8b 2f	 mov	 rbp, QWORD PTR [rdi]
  0004a	ba 02 00 00 00	 mov	 edx, 2
  0004f	48 8b cf	 mov	 rcx, rdi
  00052	c1 eb 0f	 shr	 ebx, 15
  00055	e8 00 00 00 00	 call	 mg_call
  0005a	f6 c3 01	 test	 bl, 1

; 7705 :     if (is_resp && !c->is_resp) {

  0005d	74 23		 je	 SHORT $LN7@mg_mgr_pol
  0005f	f7 87 10 01 00
	00 00 80 00 00	 test	 DWORD PTR [rdi+272], 32768 ; 00008000H
  00069	75 17		 jne	 SHORT $LN7@mg_mgr_pol

; 7706 :       long n = 0;

  0006b	83 64 24 70 00	 and	 DWORD PTR n$1[rsp], 0

; 7707 :       mg_call(c, MG_EV_READ, &n);

  00070	4c 8d 44 24 70	 lea	 r8, QWORD PTR n$1[rsp]
  00075	ba 07 00 00 00	 mov	 edx, 7
  0007a	48 8b cf	 mov	 rcx, rdi
  0007d	e8 00 00 00 00	 call	 mg_call
$LN7@mg_mgr_pol:

; 7708 :     }
; 7709 :     MG_VERBOSE(("%lu %c%c %c%c%c%c%c", c->id, c->is_readable ? 'r' : '-',

  00082	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR mg_log_level, 4
  00089	0f 8c b8 00 00
	00		 jl	 $LN5@mg_mgr_pol
  0008f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0M@OABIKPAM@mg_mgr_poll@
  00096	b9 04 00 00 00	 mov	 ecx, 4
  0009b	41 b8 20 1e 00
	00		 mov	 r8d, 7712		; 00001e20H
  000a1	e8 00 00 00 00	 call	 mg_log_prefix
  000a6	44 8b 87 10 01
	00 00		 mov	 r8d, DWORD PTR [rdi+272]
  000ad	41 8b c8	 mov	 ecx, r8d
  000b0	41 8b d8	 mov	 ebx, r8d
  000b3	d1 e9		 shr	 ecx, 1
  000b5	45 8b d0	 mov	 r10d, r8d
  000b8	c1 eb 08	 shr	 ebx, 8
  000bb	41 8b d0	 mov	 edx, r8d
  000be	41 c1 ea 02	 shr	 r10d, 2
  000c2	46 8d 1c 85 00
	00 00 00	 lea	 r11d, DWORD PTR [r8*4]
  000ca	41 8b c0	 mov	 eax, r8d
  000cd	f7 d2		 not	 edx
  000cf	f7 d1		 not	 ecx
  000d1	83 e2 20	 and	 edx, 32			; 00000020H
  000d4	83 e1 20	 and	 ecx, 32			; 00000020H
  000d7	83 ca 43	 or	 edx, 67			; 00000043H
  000da	83 c9 54	 or	 ecx, 84			; 00000054H
  000dd	41 f7 d3	 not	 r11d
  000e0	41 f7 d2	 not	 r10d
  000e3	41 83 e3 20	 and	 r11d, 32		; 00000020H
  000e7	41 83 e2 20	 and	 r10d, 32		; 00000020H
  000eb	41 83 cb 52	 or	 r11d, 82		; 00000052H
  000ef	41 83 ca 48	 or	 r10d, 72		; 00000048H
  000f3	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  000f8	f7 d3		 not	 ebx
  000fa	83 e3 20	 and	 ebx, 32			; 00000020H
  000fd	83 cb 43	 or	 ebx, 67			; 00000043H
  00100	89 5c 24 40	 mov	 DWORD PTR [rsp+64], ebx
  00104	f7 d8		 neg	 eax
  00106	44 89 5c 24 38	 mov	 DWORD PTR [rsp+56], r11d
  0010b	45 1b c9	 sbb	 r9d, r9d
  0010e	44 89 54 24 30	 mov	 DWORD PTR [rsp+48], r10d
  00113	41 81 e0 00 00
	01 00		 and	 r8d, 65536		; 00010000H
  0011a	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  0011e	8b 57 40	 mov	 edx, DWORD PTR [rdi+64]
  00121	41 83 e1 4a	 and	 r9d, 74			; 0000004aH
  00125	41 83 c1 2d	 add	 r9d, 45			; 0000002dH
  00129	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0012d	41 f7 d8	 neg	 r8d
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@INNKIICP@?$CFlu?5?$CFc?$CFc?5?$CFc?$CFc?$CFc?$CFc?$CFc@
  00137	45 1b c0	 sbb	 r8d, r8d
  0013a	41 83 e0 45	 and	 r8d, 69			; 00000045H
  0013e	41 83 c0 2d	 add	 r8d, 45			; 0000002dH
  00142	e8 00 00 00 00	 call	 mg_log
$LN5@mg_mgr_pol:

; 7710 :                 c->is_writable ? 'w' : '-', c->is_tls ? 'T' : 't',
; 7711 :                 c->is_connecting ? 'C' : 'c', c->is_tls_hs ? 'H' : 'h',
; 7712 :                 c->is_resolving ? 'R' : 'r', c->is_closing ? 'C' : 'c'));
; 7713 :     if (c->is_resolving || c->is_closing) {

  00147	8b 8f 10 01 00
	00		 mov	 ecx, DWORD PTR [rdi+272]
  0014d	f7 c1 08 20 00
	00		 test	 ecx, 8200		; 00002008H
  00153	75 58		 jne	 SHORT $LN12@mg_mgr_pol

; 7714 :       // Do nothing
; 7715 :     } else if (c->is_listening && c->is_udp == 0) {

  00155	8b c1		 mov	 eax, ecx
  00157	25 01 01 00 00	 and	 eax, 257		; 00000101H
  0015c	83 f8 01	 cmp	 eax, 1
  0015f	75 13		 jne	 SHORT $LN13@mg_mgr_pol

; 7716 :       if (c->is_readable) accept_conn(mgr, c);

  00161	0f ba e1 10	 bt	 ecx, 16
  00165	73 46		 jae	 SHORT $LN12@mg_mgr_pol
  00167	48 8b d7	 mov	 rdx, rdi
  0016a	48 8b ce	 mov	 rcx, rsi
  0016d	e8 00 00 00 00	 call	 accept_conn

; 7717 :     } else if (c->is_connecting) {

  00172	eb 39		 jmp	 SHORT $LN12@mg_mgr_pol
$LN13@mg_mgr_pol:
  00174	f6 c1 20	 test	 cl, 32			; 00000020H
  00177	74 12		 je	 SHORT $LN16@mg_mgr_pol

; 7718 :       if (c->is_readable || c->is_writable) connect_conn(c);

  00179	f7 c1 00 00 03
	00		 test	 ecx, 196608		; 00030000H
  0017f	74 2c		 je	 SHORT $LN12@mg_mgr_pol
  00181	48 8b cf	 mov	 rcx, rdi
  00184	e8 00 00 00 00	 call	 connect_conn

; 7719 :       //} else if (c->is_tls_hs) {
; 7720 :       //  if ((c->is_readable || c->is_writable)) mg_tls_handshake(c);
; 7721 :     } else {

  00189	eb 22		 jmp	 SHORT $LN12@mg_mgr_pol
$LN16@mg_mgr_pol:

; 7722 :       if (c->is_readable) read_conn(c);

  0018b	0f ba e1 10	 bt	 ecx, 16
  0018f	73 08		 jae	 SHORT $LN20@mg_mgr_pol
  00191	48 8b cf	 mov	 rcx, rdi
  00194	e8 00 00 00 00	 call	 read_conn
$LN20@mg_mgr_pol:

; 7723 :       if (c->is_writable) write_conn(c);

  00199	f7 87 10 01 00
	00 00 00 02 00	 test	 DWORD PTR [rdi+272], 131072 ; 00020000H
  001a3	74 08		 je	 SHORT $LN12@mg_mgr_pol
  001a5	48 8b cf	 mov	 rcx, rdi
  001a8	e8 00 00 00 00	 call	 write_conn
$LN12@mg_mgr_pol:

; 7724 :     }
; 7725 : 
; 7726 :     if (c->is_draining && c->send.len == 0) c->is_closing = 1;

  001ad	8b 8f 10 01 00
	00		 mov	 ecx, DWORD PTR [rdi+272]
  001b3	8b c1		 mov	 eax, ecx
  001b5	0f ba e1 0c	 bt	 ecx, 12
  001b9	73 11		 jae	 SHORT $LN22@mg_mgr_pol
  001bb	48 83 7f 78 00	 cmp	 QWORD PTR [rdi+120], 0
  001c0	75 0a		 jne	 SHORT $LN22@mg_mgr_pol
  001c2	0f ba e8 0d	 bts	 eax, 13
  001c6	89 87 10 01 00
	00		 mov	 DWORD PTR [rdi+272], eax
$LN22@mg_mgr_pol:

; 7727 :     if (c->is_closing) close_conn(c);

  001cc	0f ba e0 0d	 bt	 eax, 13
  001d0	73 08		 jae	 SHORT $LN2@mg_mgr_pol
  001d2	48 8b cf	 mov	 rcx, rdi
  001d5	e8 00 00 00 00	 call	 close_conn
$LN2@mg_mgr_pol:

; 7700 : 
; 7701 :   for (c = mgr->conns; c != NULL; c = tmp) {

  001da	48 8b fd	 mov	 rdi, rbp
  001dd	48 85 ed	 test	 rbp, rbp
  001e0	0f 85 53 fe ff
	ff		 jne	 $LL4@mg_mgr_pol
$LN3@mg_mgr_pol:

; 7728 :   }
; 7729 : }

  001e6	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  001eb	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001ef	5f		 pop	 rdi
  001f0	5e		 pop	 rsi
  001f1	5d		 pop	 rbp
  001f2	c3		 ret	 0
mg_mgr_poll ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_http_serve_ssi
_TEXT	SEGMENT
c$ = 8
root$dead$ = 16
fullpath$dead$ = 24
mg_http_serve_ssi PROC					; COMDAT

; 7829 :   mg_http_reply(c, 501, NULL, "SSI not enabled");

  00000	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BA@BDBJPBPM@SSI?5not?5enabled@
  00007	45 33 c0	 xor	 r8d, r8d
  0000a	ba f5 01 00 00	 mov	 edx, 501		; 000001f5H
  0000f	e9 00 00 00 00	 jmp	 mg_http_reply
mg_http_serve_ssi ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_str_s
_TEXT	SEGMENT
__$ReturnAddress$ = 8
s$ = 16
mg_str_s PROC						; COMDAT

; 7840 :   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};

  00000	33 c0		 xor	 eax, eax
  00002	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00005	4c 8b c2	 mov	 r8, rdx
  00008	48 85 d2	 test	 rdx, rdx
  0000b	74 10		 je	 SHORT $LN4@mg_str_s
  0000d	48 83 ca ff	 or	 rdx, -1
$LL5@mg_str_s:
  00011	48 ff c2	 inc	 rdx
  00014	41 38 04 10	 cmp	 BYTE PTR [r8+rdx], al
  00018	75 f7		 jne	 SHORT $LL5@mg_str_s
  0001a	48 8b c2	 mov	 rax, rdx
$LN4@mg_str_s:
  0001d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 7841 :   return str;

  00021	48 8b c1	 mov	 rax, rcx

; 7842 : }

  00024	c3		 ret	 0
mg_str_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_str_n
_TEXT	SEGMENT
__$ReturnAddress$ = 8
s$ = 16
n$ = 24
mg_str_n PROC						; COMDAT

; 7845 :   struct mg_str str = {s, n};

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 7846 :   return str;

  00003	48 8b c1	 mov	 rax, rcx
  00006	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 7847 : }

  0000a	c3		 ret	 0
mg_str_n ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_lower
_TEXT	SEGMENT
s$ = 8
mg_lower PROC						; COMDAT

; 7850 :   int c = *s;

  00000	0f be 11	 movsx	 edx, BYTE PTR [rcx]

; 7851 :   if (c >= 'A' && c <= 'Z') c += 'a' - 'A';

  00003	8d 4a bf	 lea	 ecx, DWORD PTR [rdx-65]

; 7852 :   return c;

  00006	83 f9 19	 cmp	 ecx, 25
  00009	8d 42 20	 lea	 eax, DWORD PTR [rdx+32]
  0000c	0f 47 c2	 cmova	 eax, edx

; 7853 : }

  0000f	c3		 ret	 0
mg_lower ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ncasecmp
_TEXT	SEGMENT
s1$ = 8
s2$ = 16
len$ = 24
mg_ncasecmp PROC					; COMDAT

; 7855 : int mg_ncasecmp(const char *s1, const char *s2, size_t len) {

$LN18:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 7856 :   int diff = 0;

  00005	45 33 c9	 xor	 r9d, r9d
  00008	4c 8b da	 mov	 r11, rdx
  0000b	4c 8b d1	 mov	 r10, rcx

; 7857 :   if (len > 0) do {

  0000e	4d 85 c0	 test	 r8, r8
  00011	74 38		 je	 SHORT $LN3@mg_ncasecm
  00013	4c 2b d2	 sub	 r10, rdx
$LL4@mg_ncasecm:

; 7850 :   int c = *s;

  00016	43 0f be 1c 1a	 movsx	 ebx, BYTE PTR [r10+r11]
  0001b	41 0f be 13	 movsx	 edx, BYTE PTR [r11]

; 7851 :   if (c >= 'A' && c <= 'Z') c += 'a' - 'A';

  0001f	8d 43 bf	 lea	 eax, DWORD PTR [rbx-65]

; 7858 :       diff = mg_lower(s1++) - mg_lower(s2++);

  00022	83 f8 19	 cmp	 eax, 25
  00025	44 8d 4b 20	 lea	 r9d, DWORD PTR [rbx+32]

; 7851 :   if (c >= 'A' && c <= 'Z') c += 'a' - 'A';

  00029	8d 42 bf	 lea	 eax, DWORD PTR [rdx-65]

; 7858 :       diff = mg_lower(s1++) - mg_lower(s2++);

  0002c	44 0f 47 cb	 cmova	 r9d, ebx

; 7850 :   int c = *s;

  00030	8d 4a 20	 lea	 ecx, DWORD PTR [rdx+32]
  00033	83 f8 19	 cmp	 eax, 25
  00036	0f 47 ca	 cmova	 ecx, edx

; 7858 :       diff = mg_lower(s1++) - mg_lower(s2++);

  00039	49 ff c3	 inc	 r11
  0003c	44 2b c9	 sub	 r9d, ecx

; 7859 :     } while (diff == 0 && s1[-1] != '\0' && --len > 0);

  0003f	75 0a		 jne	 SHORT $LN3@mg_ncasecm
  00041	84 db		 test	 bl, bl
  00043	74 06		 je	 SHORT $LN3@mg_ncasecm
  00045	49 83 e8 01	 sub	 r8, 1
  00049	75 cb		 jne	 SHORT $LL4@mg_ncasecm
$LN3@mg_ncasecm:

; 7860 :   return diff;
; 7861 : }

  0004b	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00050	41 8b c1	 mov	 eax, r9d
  00053	c3		 ret	 0
mg_ncasecmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_casecmp
_TEXT	SEGMENT
s1$ = 8
s2$ = 16
mg_casecmp PROC						; COMDAT

; 7864 :   return mg_ncasecmp(s1, s2, (size_t) ~0);

  00000	49 83 c8 ff	 or	 r8, -1
  00004	e9 00 00 00 00	 jmp	 mg_ncasecmp
mg_casecmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_vcmp
_TEXT	SEGMENT
s1$ = 48
s2$dead$ = 56
mg_vcmp	PROC						; COMDAT

; 7867 : int mg_vcmp(const struct mg_str *s1, const char *s2) {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 7868 :   size_t n2 = strlen(s2), n1 = s1->len;

  00006	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]

; 7869 :   int r = strncmp(s1->ptr, s2, (n1 < n2) ? n1 : n2);

  0000a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01KMDKNFGN@?1@
  00011	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00014	41 b8 01 00 00
	00		 mov	 r8d, 1
  0001a	49 3b d8	 cmp	 rbx, r8
  0001d	4c 0f 42 c3	 cmovb	 r8, rbx
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp

; 7870 :   if (r == 0) return (int) (n1 - n2);

  00027	85 c0		 test	 eax, eax
  00029	75 03		 jne	 SHORT $LN2@mg_vcmp
  0002b	8d 43 ff	 lea	 eax, DWORD PTR [rbx-1]
$LN2@mg_vcmp:

; 7871 :   return r;
; 7872 : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
mg_vcmp	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_vcasecmp
_TEXT	SEGMENT
str1$ = 48
str2$ = 56
mg_vcasecmp PROC					; COMDAT

; 7874 : int mg_vcasecmp(const struct mg_str *str1, const char *str2) {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 7875 :   size_t n2 = strlen(str2), n1 = str1->len;

  0000a	48 83 cb ff	 or	 rbx, -1
$LL4@mg_vcasecm:
  0000e	48 ff c3	 inc	 rbx
  00011	80 3c 1a 00	 cmp	 BYTE PTR [rdx+rbx], 0
  00015	75 f7		 jne	 SHORT $LL4@mg_vcasecm
  00017	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]

; 7876 :   int r = mg_ncasecmp(str1->ptr, str2, (n1 < n2) ? n1 : n2);

  0001b	4c 8b c3	 mov	 r8, rbx
  0001e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00021	48 3b fb	 cmp	 rdi, rbx
  00024	4c 0f 42 c7	 cmovb	 r8, rdi
  00028	e8 00 00 00 00	 call	 mg_ncasecmp

; 7877 :   if (r == 0) return (int) (n1 - n2);

  0002d	85 c0		 test	 eax, eax
  0002f	75 04		 jne	 SHORT $LN2@mg_vcasecm
  00031	2b fb		 sub	 edi, ebx
  00033	8b c7		 mov	 eax, edi
$LN2@mg_vcasecm:

; 7878 :   return r;
; 7879 : }

  00035	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5f		 pop	 rdi
  0003f	c3		 ret	 0
mg_vcasecmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_strdup
_TEXT	SEGMENT
__$ReturnAddress$ = 48
s$ = 56
mg_strdup PROC						; COMDAT

; 7881 : struct mg_str mg_strdup(const struct mg_str s) {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 7882 :   struct mg_str r = {NULL, 0};

  00014	48 83 21 00	 and	 QWORD PTR [rcx], 0
  00018	48 8b f2	 mov	 rsi, rdx

; 7883 :   if (s.len > 0 && s.ptr != NULL) {

  0001b	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  0001f	48 8b f9	 mov	 rdi, rcx
  00022	48 83 61 08 00	 and	 QWORD PTR [rcx+8], 0
  00027	48 85 d2	 test	 rdx, rdx
  0002a	74 39		 je	 SHORT $LN3@mg_strdup
  0002c	48 83 3e 00	 cmp	 QWORD PTR [rsi], 0
  00030	74 33		 je	 SHORT $LN3@mg_strdup

; 7884 :     char *sc = (char *) calloc(1, s.len + 1);

  00032	48 ff c2	 inc	 rdx
  00035	b9 01 00 00 00	 mov	 ecx, 1
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00040	48 8b e8	 mov	 rbp, rax

; 7885 :     if (sc != NULL) {

  00043	48 85 c0	 test	 rax, rax
  00046	74 1d		 je	 SHORT $LN3@mg_strdup

; 7886 :       memcpy(sc, s.ptr, s.len);

  00048	48 8b 5e 08	 mov	 rbx, QWORD PTR [rsi+8]
  0004c	48 8b c8	 mov	 rcx, rax
  0004f	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  00052	4c 8b c3	 mov	 r8, rbx
  00055	e8 00 00 00 00	 call	 memcpy

; 7887 :       sc[s.len] = '\0';

  0005a	c6 04 2b 00	 mov	 BYTE PTR [rbx+rbp], 0

; 7888 :       r.ptr = sc;

  0005e	48 89 2f	 mov	 QWORD PTR [rdi], rbp

; 7889 :       r.len = s.len;

  00061	48 89 5f 08	 mov	 QWORD PTR [rdi+8], rbx
$LN3@mg_strdup:

; 7890 :     }
; 7891 :   }
; 7892 :   return r;
; 7893 : }

  00065	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006a	48 8b c7	 mov	 rax, rdi
  0006d	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00072	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00077	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
mg_strdup ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_strcmp
_TEXT	SEGMENT
str1$ = 8
str2$ = 16
mg_strcmp PROC						; COMDAT

; 7896 :   size_t i = 0;

  00000	45 33 c0	 xor	 r8d, r8d
  00003	4c 8b c9	 mov	 r9, rcx

; 7897 :   while (i < str1.len && i < str2.len) {

  00006	4c 39 41 08	 cmp	 QWORD PTR [rcx+8], r8
  0000a	76 2c		 jbe	 SHORT $LN3@mg_strcmp
$LL2@mg_strcmp:
  0000c	4c 3b 42 08	 cmp	 r8, QWORD PTR [rdx+8]
  00010	73 26		 jae	 SHORT $LN3@mg_strcmp

; 7898 :     int c1 = str1.ptr[i];

  00012	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00015	41 8a 0c 00	 mov	 cl, BYTE PTR [r8+rax]

; 7899 :     int c2 = str2.ptr[i];

  00019	48 8b 02	 mov	 rax, QWORD PTR [rdx]

; 7900 :     if (c1 < c2) return -1;

  0001c	41 3a 0c 00	 cmp	 cl, BYTE PTR [r8+rax]
  00020	7c 12		 jl	 SHORT $LN16@mg_strcmp

; 7901 :     if (c1 > c2) return 1;

  00022	7f 1a		 jg	 SHORT $LN15@mg_strcmp

; 7902 :     i++;

  00024	49 ff c0	 inc	 r8
  00027	4d 3b 41 08	 cmp	 r8, QWORD PTR [r9+8]
  0002b	72 df		 jb	 SHORT $LL2@mg_strcmp
$LN6@mg_strcmp:

; 7905 :   if (i < str2.len) return -1;

  0002d	4c 3b 42 08	 cmp	 r8, QWORD PTR [rdx+8]
  00031	1b c0		 sbb	 eax, eax

; 7906 :   return 0;
; 7907 : }

  00033	c3		 ret	 0
$LN16@mg_strcmp:

; 7905 :   if (i < str2.len) return -1;

  00034	83 c8 ff	 or	 eax, -1

; 7906 :   return 0;
; 7907 : }

  00037	c3		 ret	 0
$LN3@mg_strcmp:

; 7903 :   }
; 7904 :   if (i < str1.len) return 1;

  00038	4d 3b 41 08	 cmp	 r8, QWORD PTR [r9+8]
  0003c	73 ef		 jae	 SHORT $LN6@mg_strcmp
$LN15@mg_strcmp:
  0003e	b8 01 00 00 00	 mov	 eax, 1

; 7906 :   return 0;
; 7907 : }

  00043	c3		 ret	 0
mg_strcmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_strstr
_TEXT	SEGMENT
haystack$ = 64
needle$ = 72
mg_strstr PROC						; COMDAT

; 7910 :                       const struct mg_str needle) {

$LN16:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 7911 :   size_t i;
; 7912 :   if (needle.len > haystack.len) return NULL;

  00018	48 8b 72 08	 mov	 rsi, QWORD PTR [rdx+8]
  0001c	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
  00020	48 3b f7	 cmp	 rsi, rdi
  00023	77 30		 ja	 SHORT $LN3@mg_strstr

; 7913 :   if (needle.len == 0) return haystack.ptr;

  00025	4c 8b 39	 mov	 r15, QWORD PTR [rcx]
  00028	48 85 f6	 test	 rsi, rsi
  0002b	75 05		 jne	 SHORT $LN6@mg_strstr
  0002d	49 8b c7	 mov	 rax, r15
  00030	eb 25		 jmp	 SHORT $LN1@mg_strstr
$LN6@mg_strstr:

; 7915 :     if (memcmp(haystack.ptr + i, needle.ptr, needle.len) == 0) {

  00032	48 8b 2a	 mov	 rbp, QWORD PTR [rdx]
  00035	33 db		 xor	 ebx, ebx
  00037	48 2b fe	 sub	 rdi, rsi
$LL4@mg_strstr:
  0003a	49 8d 0c 1f	 lea	 rcx, QWORD PTR [r15+rbx]
  0003e	4c 8b c6	 mov	 r8, rsi
  00041	48 8b d5	 mov	 rdx, rbp
  00044	e8 00 00 00 00	 call	 memcmp
  00049	85 c0		 test	 eax, eax
  0004b	74 23		 je	 SHORT $LN10@mg_strstr

; 7914 :   for (i = 0; i <= haystack.len - needle.len; i++) {

  0004d	48 ff c3	 inc	 rbx
  00050	48 3b df	 cmp	 rbx, rdi
  00053	76 e5		 jbe	 SHORT $LL4@mg_strstr
$LN3@mg_strstr:

; 7917 :     }
; 7918 :   }
; 7919 :   return NULL;

  00055	33 c0		 xor	 eax, eax
$LN1@mg_strstr:

; 7920 : }

  00057	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0005c	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00061	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00066	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006a	41 5f		 pop	 r15
  0006c	41 5e		 pop	 r14
  0006e	5f		 pop	 rdi
  0006f	c3		 ret	 0
$LN10@mg_strstr:

; 7916 :       return haystack.ptr + i;

  00070	4a 8d 04 3b	 lea	 rax, QWORD PTR [rbx+r15]
  00074	eb e1		 jmp	 SHORT $LN1@mg_strstr
mg_strstr ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT is_space
_TEXT	SEGMENT
c$ = 8
is_space PROC						; COMDAT

; 7923 :   return c == ' ' || c == '\r' || c == '\n' || c == '\t';

  00000	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00003	77 13		 ja	 SHORT $LN5@is_space
  00005	48 b8 00 26 00
	00 01 00 00 00	 mov	 rax, 4294977024		; 0000000100002600H
  0000f	48 0f a3 c8	 bt	 rax, rcx
  00013	73 03		 jae	 SHORT $LN5@is_space
  00015	b0 01		 mov	 al, 1

; 7924 : }

  00017	c3		 ret	 0
$LN5@is_space:

; 7923 :   return c == ' ' || c == '\r' || c == '\n' || c == '\t';

  00018	32 c0		 xor	 al, al

; 7924 : }

  0001a	c3		 ret	 0
is_space ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_strstrip
_TEXT	SEGMENT
__$ReturnAddress$ = 8
s$ = 16
mg_strstrip PROC					; COMDAT

; 7927 :   while (s.len > 0 && is_space((int) *s.ptr)) s.ptr++, s.len--;

  00000	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00004	49 ba 00 26 00
	00 01 00 00 00	 mov	 r10, 4294977024		; 0000000100002600H
  0000e	4d 85 c0	 test	 r8, r8
  00011	74 46		 je	 SHORT $LN26@mg_strstri
$LL2@mg_strstri:
  00013	4c 8b 0a	 mov	 r9, QWORD PTR [rdx]

; 7923 :   return c == ' ' || c == '\r' || c == '\n' || c == '\t';

  00016	41 80 39 20	 cmp	 BYTE PTR [r9], 32	; 00000020H
  0001a	77 1b		 ja	 SHORT $LN16@mg_strstri
  0001c	49 0f be 01	 movsx	 rax, BYTE PTR [r9]
  00020	49 0f a3 c2	 bt	 r10, rax
  00024	73 11		 jae	 SHORT $LN16@mg_strstri

; 7927 :   while (s.len > 0 && is_space((int) *s.ptr)) s.ptr++, s.len--;

  00026	49 8d 41 01	 lea	 rax, QWORD PTR [r9+1]
  0002a	49 83 e8 01	 sub	 r8, 1
  0002e	48 89 02	 mov	 QWORD PTR [rdx], rax
  00031	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8
  00035	75 dc		 jne	 SHORT $LL2@mg_strstri
$LN16@mg_strstri:

; 7928 :   while (s.len > 0 && is_space((int) *(s.ptr + s.len - 1))) s.len--;

  00037	4d 85 c0	 test	 r8, r8
  0003a	74 1d		 je	 SHORT $LN26@mg_strstri
  0003c	4c 8b 0a	 mov	 r9, QWORD PTR [rdx]
$LL4@mg_strstri:
  0003f	4b 0f be 44 01
	ff		 movsx	 rax, BYTE PTR [r9+r8-1]

; 7923 :   return c == ' ' || c == '\r' || c == '\n' || c == '\t';

  00045	3c 20		 cmp	 al, 32			; 00000020H
  00047	77 10		 ja	 SHORT $LN26@mg_strstri
  00049	49 0f a3 c2	 bt	 r10, rax
  0004d	73 0a		 jae	 SHORT $LN26@mg_strstri

; 7928 :   while (s.len > 0 && is_space((int) *(s.ptr + s.len - 1))) s.len--;

  0004f	49 83 e8 01	 sub	 r8, 1
  00053	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8
  00057	75 e6		 jne	 SHORT $LL4@mg_strstri
$LN26@mg_strstri:

; 7929 :   return s;

  00059	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	f3 0f 7f 01	 movdqu	 XMMWORD PTR [rcx], xmm0

; 7930 : }

  00063	c3		 ret	 0
mg_strstrip ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_match
_TEXT	SEGMENT
s$ = 8
p$ = 16
caps$dead$ = 24
mg_match PROC						; COMDAT

; 7932 : bool mg_match(struct mg_str s, struct mg_str p, struct mg_str *caps) {

$LN40:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	33 f6		 xor	 esi, esi
  00011	4c 8b d9	 mov	 r11, rcx
  00014	44 8b c6	 mov	 r8d, esi

; 7933 :   size_t i = 0, j = 0, ni = 0, nj = 0;

  00017	44 8b d6	 mov	 r10d, esi
  0001a	44 8b ce	 mov	 r9d, esi
  0001d	8b fe		 mov	 edi, esi
  0001f	8b de		 mov	 ebx, esi
$LL2@mg_match:

; 7934 :   if (caps) caps->ptr = NULL, caps->len = 0;
; 7935 :   while (i < p.len || j < s.len) {

  00021	49 8b 4b 08	 mov	 rcx, QWORD PTR [r11+8]
  00025	4c 3b 52 08	 cmp	 r10, QWORD PTR [rdx+8]
  00029	72 29		 jb	 SHORT $LN30@mg_match
  0002b	4c 3b c9	 cmp	 r9, rcx
  0002e	72 5b		 jb	 SHORT $LN14@mg_match

; 7958 :   if (caps && caps->ptr && caps->len == 0) {

  00030	4d 85 c0	 test	 r8, r8
  00033	74 18		 je	 SHORT $LN22@mg_match
  00035	49 39 30	 cmp	 QWORD PTR [r8], rsi
  00038	74 13		 je	 SHORT $LN22@mg_match
  0003a	49 39 70 08	 cmp	 QWORD PTR [r8+8], rsi
  0003e	75 0d		 jne	 SHORT $LN22@mg_match

; 7959 :     caps->len = (size_t) (&s.ptr[j] - caps->ptr);

  00040	49 8b 0b	 mov	 rcx, QWORD PTR [r11]
  00043	49 2b 08	 sub	 rcx, QWORD PTR [r8]
  00046	49 03 c9	 add	 rcx, r9
  00049	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx
$LN22@mg_match:

; 7960 :   }
; 7961 :   return true;

  0004d	b0 01		 mov	 al, 1
  0004f	e9 02 01 00 00	 jmp	 $LN1@mg_match
$LN30@mg_match:

; 7936 :     if (i < p.len && j < s.len && (p.ptr[i] == '?' || s.ptr[j] == p.ptr[i])) {

  00054	4c 3b c9	 cmp	 r9, rcx
  00057	73 19		 jae	 SHORT $LN34@mg_match
  00059	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0005c	41 8a 0c 02	 mov	 cl, BYTE PTR [r10+rax]
  00060	80 f9 3f	 cmp	 cl, 63			; 0000003fH
  00063	74 7e		 je	 SHORT $LN33@mg_match
  00065	49 8b 03	 mov	 rax, QWORD PTR [r11]
  00068	41 38 0c 01	 cmp	 BYTE PTR [r9+rax], cl
  0006c	74 75		 je	 SHORT $LN33@mg_match
  0006e	49 8b 4b 08	 mov	 rcx, QWORD PTR [r11+8]
$LN34@mg_match:

; 7946 :     } else if (i < p.len && (p.ptr[i] == '*' || p.ptr[i] == '#')) {

  00072	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00075	41 80 3c 02 2a	 cmp	 BYTE PTR [r10+rax], 42	; 0000002aH
  0007a	0f 84 ae 00 00
	00		 je	 $LN16@mg_match
  00080	41 80 3c 02 23	 cmp	 BYTE PTR [r10+rax], 35	; 00000023H
  00085	0f 84 a3 00 00
	00		 je	 $LN16@mg_match
$LN14@mg_match:

; 7949 :     } else if (nj > 0 && nj <= s.len && (p.ptr[ni] == '#' || s.ptr[j] != '/')) {

  0008b	48 85 db	 test	 rbx, rbx
  0008e	0f 84 c0 00 00
	00		 je	 $LN18@mg_match
  00094	48 3b d9	 cmp	 rbx, rcx
  00097	0f 87 b7 00 00
	00		 ja	 $LN18@mg_match
  0009d	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  000a0	80 3c 07 23	 cmp	 BYTE PTR [rdi+rax], 35	; 00000023H
  000a4	74 0e		 je	 SHORT $LN32@mg_match
  000a6	49 8b 03	 mov	 rax, QWORD PTR [r11]
  000a9	41 80 3c 01 2f	 cmp	 BYTE PTR [r9+rax], 47	; 0000002fH
  000ae	0f 84 a0 00 00
	00		 je	 $LN18@mg_match
$LN32@mg_match:

; 7950 :       i = ni, j = nj;

  000b4	4c 8b d7	 mov	 r10, rdi
  000b7	4c 8b cb	 mov	 r9, rbx

; 7951 :       if (caps && caps->ptr == NULL && caps->len == 0) {

  000ba	4d 85 c0	 test	 r8, r8
  000bd	0f 84 5e ff ff
	ff		 je	 $LL2@mg_match
  000c3	49 39 30	 cmp	 QWORD PTR [r8], rsi
  000c6	0f 85 55 ff ff
	ff		 jne	 $LL2@mg_match
  000cc	49 39 70 08	 cmp	 QWORD PTR [r8+8], rsi
  000d0	0f 85 4b ff ff
	ff		 jne	 $LL2@mg_match

; 7952 :         caps--, caps->len = 0;  // Restart previous cap

  000d6	49 83 e8 10	 sub	 r8, 16
  000da	49 89 70 08	 mov	 QWORD PTR [r8+8], rsi
  000de	e9 3e ff ff ff	 jmp	 $LL2@mg_match
$LN33@mg_match:

; 7937 :       if (caps == NULL) {

  000e3	4d 85 c0	 test	 r8, r8
  000e6	74 3b		 je	 SHORT $LN13@mg_match

; 7938 :       } else if (p.ptr[i] == '?') {

  000e8	80 f9 3f	 cmp	 cl, 63			; 0000003fH
  000eb	75 13		 jne	 SHORT $LN11@mg_match

; 7939 :         caps->ptr = &s.ptr[j], caps->len = 1;     // Finalize `?` cap

  000ed	49 8b 0b	 mov	 rcx, QWORD PTR [r11]
  000f0	49 03 c9	 add	 rcx, r9
  000f3	49 c7 40 08 01
	00 00 00	 mov	 QWORD PTR [r8+8], 1
  000fb	49 89 08	 mov	 QWORD PTR [r8], rcx

; 7940 :         caps++, caps->ptr = NULL, caps->len = 0;  // Init next cap

  000fe	eb 18		 jmp	 SHORT $LN38@mg_match
$LN11@mg_match:

; 7941 :       } else if (caps->ptr != NULL && caps->len == 0) {

  00100	49 39 30	 cmp	 QWORD PTR [r8], rsi
  00103	74 1e		 je	 SHORT $LN13@mg_match
  00105	49 39 70 08	 cmp	 QWORD PTR [r8+8], rsi
  00109	75 18		 jne	 SHORT $LN13@mg_match

; 7942 :         caps->len = (size_t) (&s.ptr[j] - caps->ptr);  // Finalize current cap

  0010b	49 8b 03	 mov	 rax, QWORD PTR [r11]
  0010e	49 2b 00	 sub	 rax, QWORD PTR [r8]
  00111	49 03 c1	 add	 rax, r9
  00114	49 89 40 08	 mov	 QWORD PTR [r8+8], rax
$LN38@mg_match:

; 7943 :         caps++, caps->len = 0, caps->ptr = NULL;       // Init next cap
; 7944 :       }
; 7945 :       i++, j++;

  00118	49 83 c0 10	 add	 r8, 16
  0011c	49 89 30	 mov	 QWORD PTR [r8], rsi
  0011f	49 89 70 08	 mov	 QWORD PTR [r8+8], rsi
$LN13@mg_match:
  00123	49 ff c2	 inc	 r10
  00126	49 ff c1	 inc	 r9
  00129	e9 f3 fe ff ff	 jmp	 $LL2@mg_match
$LN16@mg_match:

; 7947 :       if (caps && !caps->ptr) caps->len = 0, caps->ptr = &s.ptr[j];  // Init cap

  0012e	4d 85 c0	 test	 r8, r8
  00131	74 12		 je	 SHORT $LN17@mg_match
  00133	49 39 30	 cmp	 QWORD PTR [r8], rsi
  00136	75 0d		 jne	 SHORT $LN17@mg_match
  00138	49 8b 0b	 mov	 rcx, QWORD PTR [r11]
  0013b	49 03 c9	 add	 rcx, r9
  0013e	49 89 70 08	 mov	 QWORD PTR [r8+8], rsi
  00142	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN17@mg_match:

; 7948 :       ni = i++, nj = j + 1;

  00145	49 8b fa	 mov	 rdi, r10
  00148	49 8d 59 01	 lea	 rbx, QWORD PTR [r9+1]
  0014c	49 ff c2	 inc	 r10

; 7956 :     }
; 7957 :   }

  0014f	e9 cd fe ff ff	 jmp	 $LL2@mg_match
$LN18@mg_match:

; 7953 :       }
; 7954 :     } else {
; 7955 :       return false;

  00154	32 c0		 xor	 al, al
$LN1@mg_match:

; 7962 : }

  00156	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0015b	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]
  00160	48 8b 7c 24 18	 mov	 rdi, QWORD PTR [rsp+24]
  00165	c3		 ret	 0
mg_match ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_globmatch
_TEXT	SEGMENT
s1$ = 80
n1$ = 88
s2$ = 96
n2$ = 104
mg_globmatch PROC					; COMDAT

; 7964 : bool mg_globmatch(const char *s1, size_t n1, const char *s2, size_t n2) {

$LN8:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 7965 :   return mg_match(mg_str_n(s2, n2), mg_str_n(s1, n1), NULL);

  00007	48 89 48 d8	 mov	 QWORD PTR [rax-40], rcx
  0000b	48 8d 48 e8	 lea	 rcx, QWORD PTR [rax-24]
  0000f	48 89 50 e0	 mov	 QWORD PTR [rax-32], rdx
  00013	48 8d 50 d8	 lea	 rdx, QWORD PTR [rax-40]
  00017	4c 89 40 e8	 mov	 QWORD PTR [rax-24], r8
  0001b	4c 89 48 f0	 mov	 QWORD PTR [rax-16], r9
  0001f	e8 00 00 00 00	 call	 mg_match

; 7966 : }

  00024	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00028	c3		 ret	 0
mg_globmatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_nce
_TEXT	SEGMENT
s$ = 8
n$ = 16
ofs$dead$ = 24
koff$ = 32
klen$ = 40
voff$ = 48
vlen$ = 56
delim$ = 64
mg_nce	PROC						; COMDAT

; 7970 :   size_t kvlen, kl;
; 7971 :   for (kvlen = 0; ofs + kvlen < n && s[ofs + kvlen] != delim;) kvlen++;

  00000	45 33 c0	 xor	 r8d, r8d
  00003	4c 8b d2	 mov	 r10, rdx
  00006	48 85 d2	 test	 rdx, rdx
  00009	74 12		 je	 SHORT $LN3@mg_nce
  0000b	8a 44 24 40	 mov	 al, BYTE PTR delim$[rsp]
$LL2@mg_nce:
  0000f	41 38 04 08	 cmp	 BYTE PTR [r8+rcx], al
  00013	74 08		 je	 SHORT $LN3@mg_nce
  00015	49 ff c0	 inc	 r8
  00018	4d 3b c2	 cmp	 r8, r10
  0001b	72 f2		 jb	 SHORT $LL2@mg_nce
$LN3@mg_nce:

; 7972 :   for (kl = 0; kl < kvlen && s[ofs + kl] != '=';) kl++;

  0001d	33 d2		 xor	 edx, edx
  0001f	4d 85 c0	 test	 r8, r8
  00022	74 0e		 je	 SHORT $LN6@mg_nce
$LL5@mg_nce:
  00024	80 3c 0a 3d	 cmp	 BYTE PTR [rdx+rcx], 61	; 0000003dH
  00028	74 08		 je	 SHORT $LN6@mg_nce
  0002a	48 ff c2	 inc	 rdx
  0002d	49 3b d0	 cmp	 rdx, r8
  00030	72 f2		 jb	 SHORT $LL5@mg_nce
$LN6@mg_nce:

; 7973 :   if (koff != NULL) *koff = ofs;

  00032	4d 85 c9	 test	 r9, r9
  00035	74 04		 je	 SHORT $LN8@mg_nce
  00037	49 83 21 00	 and	 QWORD PTR [r9], 0
$LN8@mg_nce:

; 7974 :   if (klen != NULL) *klen = kl;

  0003b	48 8b 44 24 28	 mov	 rax, QWORD PTR klen$[rsp]
  00040	48 85 c0	 test	 rax, rax
  00043	74 03		 je	 SHORT $LN9@mg_nce
  00045	48 89 10	 mov	 QWORD PTR [rax], rdx
$LN9@mg_nce:

; 7975 :   if (voff != NULL) *voff = kl < kvlen ? ofs + kl + 1 : 0;

  00048	4c 8b 4c 24 30	 mov	 r9, QWORD PTR voff$[rsp]
  0004d	4d 85 c9	 test	 r9, r9
  00050	74 10		 je	 SHORT $LN10@mg_nce
  00052	49 3b d0	 cmp	 rdx, r8
  00055	48 8d 4a 01	 lea	 rcx, QWORD PTR [rdx+1]
  00059	48 1b c0	 sbb	 rax, rax
  0005c	48 23 c1	 and	 rax, rcx
  0005f	49 89 01	 mov	 QWORD PTR [r9], rax
$LN10@mg_nce:

; 7976 :   if (vlen != NULL) *vlen = kl < kvlen ? kvlen - kl - 1 : 0;

  00062	4c 8b 4c 24 38	 mov	 r9, QWORD PTR vlen$[rsp]
  00067	4d 85 c9	 test	 r9, r9
  0006a	74 15		 je	 SHORT $LN11@mg_nce
  0006c	49 8b c8	 mov	 rcx, r8
  0006f	48 2b ca	 sub	 rcx, rdx
  00072	48 ff c9	 dec	 rcx
  00075	49 3b d0	 cmp	 rdx, r8
  00078	48 1b c0	 sbb	 rax, rax
  0007b	48 23 c1	 and	 rax, rcx
  0007e	49 89 01	 mov	 QWORD PTR [r9], rax
$LN11@mg_nce:

; 7977 :   ofs += kvlen + 1;

  00081	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]

; 7978 :   return ofs > n ? n : ofs;

  00085	49 3b c2	 cmp	 rax, r10
  00088	49 0f 47 c2	 cmova	 rax, r10

; 7979 : }

  0008c	c3		 ret	 0
mg_nce	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_split
_TEXT	SEGMENT
koff$ = 64
vlen$ = 72
voff$ = 80
klen$ = 112
s$ = 112
k$ = 120
v$ = 128
sep$ = 136
mg_split PROC						; COMDAT

; 7981 : bool mg_split(struct mg_str *s, struct mg_str *k, struct mg_str *v, char sep) {

$LN14:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00007	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000b	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  0000f	55		 push	 rbp
  00010	48 8b ec	 mov	 rbp, rsp
  00013	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 7982 :   size_t koff = 0, klen = 0, voff = 0, vlen = 0, off = 0;

  00017	48 83 65 e0 00	 and	 QWORD PTR koff$[rbp-96], 0
  0001c	49 8b d8	 mov	 rbx, r8
  0001f	48 83 65 10 00	 and	 QWORD PTR klen$[rbp-96], 0
  00024	48 8b f2	 mov	 rsi, rdx
  00027	48 83 65 f0 00	 and	 QWORD PTR voff$[rbp-96], 0
  0002c	4c 8b d9	 mov	 r11, rcx
  0002f	48 83 65 e8 00	 and	 QWORD PTR vlen$[rbp-96], 0

; 7983 :   if (s->ptr == NULL || s->len == 0) return 0;

  00034	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
  00037	48 85 ff	 test	 rdi, rdi
  0003a	0f 84 81 00 00
	00		 je	 $LN3@mg_split
  00040	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00044	48 85 d2	 test	 rdx, rdx
  00047	74 78		 je	 SHORT $LN3@mg_split

; 7984 :   off = mg_nce(s->ptr, s->len, 0, &koff, &klen, &voff, &vlen, sep);

  00049	44 88 48 d0	 mov	 BYTE PTR [rax-48], r9b
  0004d	48 8b cf	 mov	 rcx, rdi
  00050	48 8d 45 e8	 lea	 rax, QWORD PTR vlen$[rbp-96]
  00054	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00059	4c 8d 4d e0	 lea	 r9, QWORD PTR koff$[rbp-96]
  0005d	48 8d 45 f0	 lea	 rax, QWORD PTR voff$[rbp-96]
  00061	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00066	48 8d 45 10	 lea	 rax, QWORD PTR klen$[rbp-96]
  0006a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006f	e8 00 00 00 00	 call	 mg_nce
  00074	4c 8b c8	 mov	 r9, rax

; 7985 :   if (k != NULL) *k = mg_str_n(s->ptr + koff, klen);

  00077	48 85 f6	 test	 rsi, rsi
  0007a	74 12		 je	 SHORT $LN4@mg_split
  0007c	48 8b 55 e0	 mov	 rdx, QWORD PTR koff$[rbp-96]

; 7845 :   struct mg_str str = {s, n};

  00080	4c 8b 45 10	 mov	 r8, QWORD PTR klen$[rbp-96]

; 7985 :   if (k != NULL) *k = mg_str_n(s->ptr + koff, klen);

  00084	48 03 d7	 add	 rdx, rdi
  00087	48 89 16	 mov	 QWORD PTR [rsi], rdx
  0008a	4c 89 46 08	 mov	 QWORD PTR [rsi+8], r8
$LN4@mg_split:

; 7986 :   if (v != NULL) *v = mg_str_n(s->ptr + voff, vlen);

  0008e	48 85 db	 test	 rbx, rbx
  00091	74 12		 je	 SHORT $LN5@mg_split
  00093	48 8b 4d f0	 mov	 rcx, QWORD PTR voff$[rbp-96]

; 7845 :   struct mg_str str = {s, n};

  00097	48 8b 55 e8	 mov	 rdx, QWORD PTR vlen$[rbp-96]

; 7986 :   if (v != NULL) *v = mg_str_n(s->ptr + voff, vlen);

  0009b	48 03 cf	 add	 rcx, rdi
  0009e	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  000a1	48 89 53 08	 mov	 QWORD PTR [rbx+8], rdx
$LN5@mg_split:

; 7987 :   *s = mg_str_n(s->ptr + off, s->len - off);

  000a5	49 8b 0b	 mov	 rcx, QWORD PTR [r11]
  000a8	49 8b 43 08	 mov	 rax, QWORD PTR [r11+8]
  000ac	49 03 c9	 add	 rcx, r9
  000af	49 2b c1	 sub	 rax, r9
  000b2	49 89 0b	 mov	 QWORD PTR [r11], rcx

; 7988 :   return off > 0;

  000b5	4d 85 c9	 test	 r9, r9
  000b8	49 89 43 08	 mov	 QWORD PTR [r11+8], rax
  000bc	0f 95 c0	 setne	 al
  000bf	eb 02		 jmp	 SHORT $LN1@mg_split
$LN3@mg_split:

; 7983 :   if (s->ptr == NULL || s->len == 0) return 0;

  000c1	32 c0		 xor	 al, al
$LN1@mg_split:

; 7989 : }

  000c3	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  000c8	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  000cc	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  000d0	49 8b 7b 28	 mov	 rdi, QWORD PTR [r11+40]
  000d4	49 8b e3	 mov	 rsp, r11
  000d7	5d		 pop	 rbp
  000d8	c3		 ret	 0
mg_split ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_commalist
_TEXT	SEGMENT
s$ = 8
k$ = 16
v$ = 24
mg_commalist PROC					; COMDAT

; 7992 :   return mg_split(s, k, v, ',');

  00000	41 b1 2c	 mov	 r9b, 44			; 0000002cH
  00003	e9 00 00 00 00	 jmp	 mg_split
mg_commalist ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_hex
_TEXT	SEGMENT
buf$ = 8
len$ = 16
to$ = 24
mg_hex	PROC						; COMDAT

; 7996 :   const unsigned char *p = (const unsigned char *) buf;
; 7997 :   const char *hex = "0123456789abcdef";
; 7998 :   size_t i = 0;

  00000	45 33 c9	 xor	 r9d, r9d
  00003	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:??_C@_0BB@JCEFLFJE@0123456789abcdef@
$LL4@mg_hex:

; 7999 :   for (; len--; p++) {
; 8000 :     to[i++] = hex[p[0] >> 4];

  0000a	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  0000d	48 c1 e8 04	 shr	 rax, 4
  00011	42 8a 04 10	 mov	 al, BYTE PTR [rax+r10]
  00015	43 88 04 01	 mov	 BYTE PTR [r9+r8], al

; 8001 :     to[i++] = hex[p[0] & 0x0f];

  00019	4d 8d 49 02	 lea	 r9, QWORD PTR [r9+2]
  0001d	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00020	48 ff c1	 inc	 rcx
  00023	83 e0 0f	 and	 eax, 15
  00026	42 8a 04 10	 mov	 al, BYTE PTR [rax+r10]
  0002a	43 88 44 01 ff	 mov	 BYTE PTR [r9+r8-1], al
  0002f	48 83 ea 01	 sub	 rdx, 1
  00033	75 d5		 jne	 SHORT $LL4@mg_hex

; 8002 :   }
; 8003 :   to[i] = '\0';

  00035	43 88 14 01	 mov	 BYTE PTR [r9+r8], dl

; 8004 :   return to;

  00039	49 8b c0	 mov	 rax, r8

; 8005 : }

  0003c	c3		 ret	 0
mg_hex	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_unhex_nimble
_TEXT	SEGMENT
c$ = 8
mg_unhex_nimble PROC					; COMDAT

; 8007 : static unsigned char mg_unhex_nimble(unsigned char c) {

  00000	8a d1		 mov	 dl, cl

; 8008 :   return (c >= '0' && c <= '9')   ? (unsigned char) (c - '0')

  00002	8d 42 d0	 lea	 eax, DWORD PTR [rdx-48]
  00005	3c 09		 cmp	 al, 9
  00007	76 16		 jbe	 SHORT $LN6@mg_unhex_n
  00009	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  0000e	8d 42 bf	 lea	 eax, DWORD PTR [rdx-65]
  00011	3c 05		 cmp	 al, 5
  00013	8a c2		 mov	 al, dl
  00015	44 8d 41 20	 lea	 r8d, QWORD PTR [rcx+32]
  00019	41 0f 47 c8	 cmova	 ecx, r8d
  0001d	2a c1		 sub	 al, cl
$LN6@mg_unhex_n:

; 8009 :          : (c >= 'A' && c <= 'F') ? (unsigned char) (c - '7')
; 8010 :                                   : (unsigned char) (c - 'W');
; 8011 : }

  0001f	c3		 ret	 0
mg_unhex_nimble ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_unhexn
_TEXT	SEGMENT
s$ = 8
len$ = 16
mg_unhexn PROC						; COMDAT

; 8014 :   unsigned long i = 0, v = 0;

  00000	45 33 c0	 xor	 r8d, r8d
  00003	4c 8b d9	 mov	 r11, rcx
  00006	45 8b d0	 mov	 r10d, r8d

; 8015 :   for (i = 0; i < len; i++) v <<= 4, v |= mg_unhex_nimble(((uint8_t *) s)[i]);

  00009	48 85 d2	 test	 rdx, rdx
  0000c	74 34		 je	 SHORT $LN3@mg_unhexn
  0000e	41 8b c0	 mov	 eax, r8d
$LL14@mg_unhexn:
  00011	46 8a 0c 18	 mov	 r9b, BYTE PTR [rax+r11]
  00015	41 c1 e0 04	 shl	 r8d, 4

; 8008 :   return (c >= '0' && c <= '9')   ? (unsigned char) (c - '0')

  00019	41 8d 41 d0	 lea	 eax, DWORD PTR [r9-48]
  0001d	3c 09		 cmp	 al, 9
  0001f	76 10		 jbe	 SHORT $LN17@mg_unhexn
  00021	41 8d 41 bf	 lea	 eax, DWORD PTR [r9-65]
  00025	3c 05		 cmp	 al, 5
  00027	41 8d 41 c9	 lea	 eax, DWORD PTR [r9-55]
  0002b	76 04		 jbe	 SHORT $LN17@mg_unhexn
  0002d	41 8d 41 a9	 lea	 eax, DWORD PTR [r9-87]
$LN17@mg_unhexn:

; 8015 :   for (i = 0; i < len; i++) v <<= 4, v |= mg_unhex_nimble(((uint8_t *) s)[i]);

  00031	0f b6 c8	 movzx	 ecx, al
  00034	41 ff c2	 inc	 r10d
  00037	44 0b c1	 or	 r8d, ecx
  0003a	41 8b c2	 mov	 eax, r10d
  0003d	48 3b c2	 cmp	 rax, rdx
  00040	72 cf		 jb	 SHORT $LL14@mg_unhexn
$LN3@mg_unhexn:

; 8016 :   return v;

  00042	41 8b c0	 mov	 eax, r8d

; 8017 : }

  00045	c3		 ret	 0
mg_unhexn ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_unhex
_TEXT	SEGMENT
buf$ = 48
len$ = 56
to$ = 64
mg_unhex PROC						; COMDAT

; 8019 : void mg_unhex(const char *buf, size_t len, unsigned char *to) {

$LN12:

; 8020 :   size_t i;
; 8021 :   for (i = 0; i < len; i += 2) {

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 50		 je	 SHORT $LN10@mg_unhex
  00005	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  0000a	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000f	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	33 db		 xor	 ebx, ebx
  0001b	48 8b fa	 mov	 rdi, rdx
  0001e	49 8b f0	 mov	 rsi, r8
  00021	48 8b e9	 mov	 rbp, rcx
  00024	8d 53 02	 lea	 edx, QWORD PTR [rbx+2]
$LL4@mg_unhex:

; 8022 :     to[i >> 1] = (unsigned char) mg_unhexn(&buf[i], 2);

  00027	48 8d 0c 2b	 lea	 rcx, QWORD PTR [rbx+rbp]
  0002b	e8 00 00 00 00	 call	 mg_unhexn
  00030	48 8b cb	 mov	 rcx, rbx
  00033	48 03 da	 add	 rbx, rdx
  00036	48 d1 e9	 shr	 rcx, 1
  00039	88 04 31	 mov	 BYTE PTR [rcx+rsi], al
  0003c	48 3b df	 cmp	 rbx, rdi
  0003f	72 e6		 jb	 SHORT $LL4@mg_unhex

; 8023 :   }
; 8024 : }

  00041	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00046	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0004b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5f		 pop	 rdi
$LN10@mg_unhex:
  00055	c3		 ret	 0
mg_unhex ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_path_is_sane
_TEXT	SEGMENT
path$ = 8
mg_path_is_sane PROC					; COMDAT

; 8027 :   const char *s = path;
; 8028 :   for (; s[0] != '\0'; s++) {

  00000	80 39 00	 cmp	 BYTE PTR [rcx], 0
  00003	48 8b c1	 mov	 rax, rcx
$LN15@mg_path_is:

; 8029 :     if (s == path || s[0] == '/' || s[0] == '\\') {  // Subdir?

  00006	74 26		 je	 SHORT $LN14@mg_path_is
  00008	48 3b c1	 cmp	 rax, rcx
  0000b	74 0a		 je	 SHORT $LN6@mg_path_is
  0000d	80 38 2f	 cmp	 BYTE PTR [rax], 47	; 0000002fH
  00010	74 05		 je	 SHORT $LN6@mg_path_is
  00012	80 38 5c	 cmp	 BYTE PTR [rax], 92	; 0000005cH
  00015	75 0c		 jne	 SHORT $LN2@mg_path_is
$LN6@mg_path_is:

; 8030 :       if (s[1] == '.' && s[2] == '.') return false;  // Starts with ..

  00017	80 78 01 2e	 cmp	 BYTE PTR [rax+1], 46	; 0000002eH
  0001b	75 06		 jne	 SHORT $LN2@mg_path_is
  0001d	80 78 02 2e	 cmp	 BYTE PTR [rax+2], 46	; 0000002eH
  00021	74 08		 je	 SHORT $LN10@mg_path_is
$LN2@mg_path_is:

; 8027 :   const char *s = path;
; 8028 :   for (; s[0] != '\0'; s++) {

  00023	48 ff c0	 inc	 rax
  00026	80 38 00	 cmp	 BYTE PTR [rax], 0
  00029	eb db		 jmp	 SHORT $LN15@mg_path_is
$LN10@mg_path_is:

; 8030 :       if (s[1] == '.' && s[2] == '.') return false;  // Starts with ..

  0002b	32 c0		 xor	 al, al

; 8034 : }

  0002d	c3		 ret	 0
$LN14@mg_path_is:

; 8031 :     }
; 8032 :   }
; 8033 :   return true;

  0002e	b0 01		 mov	 al, 1

; 8034 : }

  00030	c3		 ret	 0
mg_path_is_sane ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_timer_init
_TEXT	SEGMENT
head$ = 8
t$ = 16
ms$ = 24
flags$ = 32
fn$ = 40
arg$ = 48
mg_timer_init PROC					; COMDAT

; 8046 :   t->id = 0, t->period_ms = ms, t->expire = 0;
; 8047 :   t->flags = flags, t->fn = fn, t->arg = arg, t->next = *head;

  00000	48 8b 44 24 28	 mov	 rax, QWORD PTR fn$[rsp]
  00005	83 22 00	 and	 DWORD PTR [rdx], 0
  00008	48 83 62 10 00	 and	 QWORD PTR [rdx+16], 0
  0000d	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax
  00011	48 8b 44 24 30	 mov	 rax, QWORD PTR arg$[rsp]
  00016	48 89 42 28	 mov	 QWORD PTR [rdx+40], rax
  0001a	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8
  0001e	44 89 4a 18	 mov	 DWORD PTR [rdx+24], r9d
  00022	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00025	48 89 42 30	 mov	 QWORD PTR [rdx+48], rax

; 8048 :   *head = t;

  00029	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 8049 : }

  0002c	c3		 ret	 0
mg_timer_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_timer_free
_TEXT	SEGMENT
head$ = 8
t$ = 16
mg_timer_free PROC					; COMDAT

; 8052 :   while (*head && *head != t) head = &(*head)->next;

  00000	eb 09		 jmp	 SHORT $LN12@mg_timer_f
$LL2@mg_timer_f:
  00002	48 3b c2	 cmp	 rax, rdx
  00005	74 0d		 je	 SHORT $LN10@mg_timer_f
  00007	48 8d 48 30	 lea	 rcx, QWORD PTR [rax+48]
$LN12@mg_timer_f:
  0000b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0000e	48 85 c0	 test	 rax, rax
  00011	75 ef		 jne	 SHORT $LL2@mg_timer_f

; 8054 : }

  00013	c3		 ret	 0
$LN10@mg_timer_f:

; 8053 :   if (*head) *head = t->next;

  00014	48 8b 42 30	 mov	 rax, QWORD PTR [rdx+48]
  00018	48 89 01	 mov	 QWORD PTR [rcx], rax

; 8054 : }

  0001b	c3		 ret	 0
mg_timer_free ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_timer_expired
_TEXT	SEGMENT
t$ = 8
prd$ = 16
now$ = 24
mg_timer_expired PROC					; COMDAT

; 8058 :   if (now + prd < *t) *t = 0;                    // Time wrapped? Reset timer

  00000	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00003	4a 8d 04 02	 lea	 rax, QWORD PTR [rdx+r8]
  00007	49 3b c1	 cmp	 rax, r9
  0000a	72 05		 jb	 SHORT $LN8@mg_timer_e

; 8059 :   if (*t == 0) *t = now + prd;                   // Firt poll? Set expiration

  0000c	4d 85 c9	 test	 r9, r9
  0000f	75 06		 jne	 SHORT $LN3@mg_timer_e
$LN8@mg_timer_e:
  00011	48 89 01	 mov	 QWORD PTR [rcx], rax
  00014	4c 8b c8	 mov	 r9, rax
$LN3@mg_timer_e:

; 8060 :   if (*t > now) return false;                    // Not expired yet, return

  00017	4d 3b c8	 cmp	 r9, r8
  0001a	76 03		 jbe	 SHORT $LN4@mg_timer_e
  0001c	32 c0		 xor	 al, al

; 8063 : }

  0001e	c3		 ret	 0
$LN4@mg_timer_e:

; 8061 :   *t = (now - *t) > prd ? now + prd : *t + prd;  // Next expiration time

  0001f	49 8b c0	 mov	 rax, r8
  00022	49 2b c1	 sub	 rax, r9
  00025	48 3b c2	 cmp	 rax, rdx

; 8062 :   return true;                                   // Expired, return true

  00028	b0 01		 mov	 al, 1
  0002a	4d 0f 46 c1	 cmovbe	 r8, r9
  0002e	4c 03 c2	 add	 r8, rdx
  00031	4c 89 01	 mov	 QWORD PTR [rcx], r8

; 8063 : }

  00034	c3		 ret	 0
mg_timer_expired ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_timer_poll
_TEXT	SEGMENT
head$ = 48
now_ms$ = 56
mg_timer_poll PROC					; COMDAT

; 8065 : void mg_timer_poll(struct mg_timer **head, uint64_t now_ms) {

$LN20:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 8066 :   struct mg_timer *t, *tmp;
; 8067 :   for (t = *head; t != NULL; t = tmp) {

  0000f	4c 8b 11	 mov	 r10, QWORD PTR [rcx]
  00012	48 8b f2	 mov	 rsi, rdx
  00015	4d 85 d2	 test	 r10, r10
  00018	74 57		 je	 SHORT $LN3@mg_timer_p
$LL4@mg_timer_p:

; 8068 :     bool once = t->expire == 0 && (t->flags & MG_TIMER_RUN_NOW) &&

  0001a	49 8d 4a 10	 lea	 rcx, QWORD PTR [r10+16]
  0001e	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00022	49 8d 5a 18	 lea	 rbx, QWORD PTR [r10+24]
  00026	75 10		 jne	 SHORT $LN18@mg_timer_p
  00028	8b 03		 mov	 eax, DWORD PTR [rbx]
  0002a	24 06		 and	 al, 6
  0002c	3c 02		 cmp	 al, 2
  0002e	75 08		 jne	 SHORT $LN18@mg_timer_p
  00030	41 bb 01 00 00
	00		 mov	 r11d, 1
  00036	eb 03		 jmp	 SHORT $LN10@mg_timer_p
$LN18@mg_timer_p:
  00038	45 33 db	 xor	 r11d, r11d
$LN10@mg_timer_p:

; 8069 :                 !(t->flags & MG_TIMER_CALLED);  // Handle MG_TIMER_NOW only once
; 8070 :     bool expired = mg_timer_expired(&t->expire, t->period_ms, now_ms);

  0003b	49 8b 52 08	 mov	 rdx, QWORD PTR [r10+8]
  0003f	4c 8b c6	 mov	 r8, rsi
  00042	e8 00 00 00 00	 call	 mg_timer_expired

; 8071 :     tmp = t->next;

  00047	49 8b 7a 30	 mov	 rdi, QWORD PTR [r10+48]
  0004b	45 85 db	 test	 r11d, r11d

; 8072 :     if (!once && !expired) continue;

  0004e	75 04		 jne	 SHORT $LN5@mg_timer_p
  00050	84 c0		 test	 al, al
  00052	74 15		 je	 SHORT $LN2@mg_timer_p
$LN5@mg_timer_p:

; 8073 :     if ((t->flags & MG_TIMER_REPEAT) || !(t->flags & MG_TIMER_CALLED)) {

  00054	f6 03 01	 test	 BYTE PTR [rbx], 1
  00057	75 05		 jne	 SHORT $LN7@mg_timer_p
  00059	f6 03 04	 test	 BYTE PTR [rbx], 4
  0005c	75 08		 jne	 SHORT $LN6@mg_timer_p
$LN7@mg_timer_p:

; 8074 :       t->fn(t->arg);

  0005e	49 8b 4a 28	 mov	 rcx, QWORD PTR [r10+40]
  00062	41 ff 52 20	 call	 QWORD PTR [r10+32]
$LN6@mg_timer_p:

; 8075 :     }
; 8076 :     t->flags |= MG_TIMER_CALLED;

  00066	83 0b 04	 or	 DWORD PTR [rbx], 4
$LN2@mg_timer_p:

; 8066 :   struct mg_timer *t, *tmp;
; 8067 :   for (t = *head; t != NULL; t = tmp) {

  00069	4c 8b d7	 mov	 r10, rdi
  0006c	48 85 ff	 test	 rdi, rdi
  0006f	75 a9		 jne	 SHORT $LL4@mg_timer_p
$LN3@mg_timer_p:

; 8077 :   }
; 8078 : }

  00071	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00076	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
mg_timer_poll ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_tls_init
_TEXT	SEGMENT
c$ = 8
opts$dead$ = 16
mg_tls_init PROC					; COMDAT

; 9982 :   (void) opts;
; 9983 :   mg_error(c, "TLS is not enabled");

  00000	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@JJGECGC@TLS?5is?5not?5enabled@
  00007	e9 00 00 00 00	 jmp	 mg_error
mg_tls_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_tls_handshake
_TEXT	SEGMENT
c$dead$ = 8
mg_tls_handshake PROC					; COMDAT

; 9986 :   (void) c;
; 9987 : }

  00000	c2 00 00	 ret	 0
mg_tls_handshake ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_tls_free
_TEXT	SEGMENT
c$dead$ = 8
mg_tls_free PROC					; COMDAT

; 9989 :   (void) c;
; 9990 : }

  00000	c2 00 00	 ret	 0
mg_tls_free ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_tls_recv
_TEXT	SEGMENT
c$ = 8
buf$ = 16
len$ = 24
mg_tls_recv PROC					; COMDAT

; 9992 :   return c == NULL || buf == NULL || len == 0 ? 0 : -1;

  00000	33 c0		 xor	 eax, eax
  00002	48 85 c9	 test	 rcx, rcx
  00005	74 0d		 je	 SHORT $LN4@mg_tls_rec
  00007	48 85 d2	 test	 rdx, rdx
  0000a	74 08		 je	 SHORT $LN4@mg_tls_rec
  0000c	4d 85 c0	 test	 r8, r8
  0000f	74 03		 je	 SHORT $LN4@mg_tls_rec
  00011	83 c8 ff	 or	 eax, -1
$LN4@mg_tls_rec:

; 9993 : }

  00014	c3		 ret	 0
mg_tls_recv ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_tls_send
_TEXT	SEGMENT
c$ = 8
buf$ = 16
len$ = 24
mg_tls_send PROC					; COMDAT

; 9995 :   return c == NULL || buf == NULL || len == 0 ? 0 : -1;

  00000	33 c0		 xor	 eax, eax
  00002	48 85 c9	 test	 rcx, rcx
  00005	74 0d		 je	 SHORT $LN4@mg_tls_sen
  00007	48 85 d2	 test	 rdx, rdx
  0000a	74 08		 je	 SHORT $LN4@mg_tls_sen
  0000c	4d 85 c0	 test	 r8, r8
  0000f	74 03		 je	 SHORT $LN4@mg_tls_sen
  00011	83 c8 ff	 or	 eax, -1
$LN4@mg_tls_sen:

; 9996 : }

  00014	c3		 ret	 0
mg_tls_send ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_tls_pending
_TEXT	SEGMENT
c$dead$ = 8
mg_tls_pending PROC					; COMDAT

; 9998 :   (void) c;
; 9999 :   return 0;

  00000	33 c0		 xor	 eax, eax

; 10000: }

  00002	c3		 ret	 0
mg_tls_pending ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_tls_ctx_init
_TEXT	SEGMENT
mgr$dead$ = 8
mg_tls_ctx_init PROC					; COMDAT

; 10002:   (void) mgr;
; 10003: }

  00000	c2 00 00	 ret	 0
mg_tls_ctx_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_tls_ctx_free
_TEXT	SEGMENT
mgr$dead$ = 8
mg_tls_ctx_free PROC					; COMDAT

; 10005:   (void) mgr;
; 10006: }

  00000	c2 00 00	 ret	 0
mg_tls_ctx_free ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_url_is_ssl
_TEXT	SEGMENT
url$ = 48
mg_url_is_ssl PROC					; COMDAT

; 13670: int mg_url_is_ssl(const char *url) {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 13671:   return strncmp(url, "wss:", 4) == 0 || strncmp(url, "https:", 6) == 0 ||

  0000f	be 04 00 00 00	 mov	 esi, 4
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04HILLDDDP@wss?3@
  0001b	44 8b c6	 mov	 r8d, esi
  0001e	48 8b f9	 mov	 rdi, rcx
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00027	33 db		 xor	 ebx, ebx
  00029	85 c0		 test	 eax, eax
  0002b	74 76		 je	 SHORT $LN3@mg_url_is_
  0002d	44 8d 46 02	 lea	 r8d, QWORD PTR [rsi+2]
  00031	48 8b cf	 mov	 rcx, rdi
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06FOAKIDDH@https?3@
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00041	85 c0		 test	 eax, eax
  00043	74 5e		 je	 SHORT $LN3@mg_url_is_
  00045	44 8d 46 02	 lea	 r8d, QWORD PTR [rsi+2]
  00049	48 8b cf	 mov	 rcx, rdi
  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06NDJNKKHE@mqtts?3@
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00059	85 c0		 test	 eax, eax
  0005b	74 46		 je	 SHORT $LN3@mg_url_is_
  0005d	44 8b c6	 mov	 r8d, esi
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04JKEBHBLC@ssl?3@
  00067	48 8b cf	 mov	 rcx, rdi
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00070	85 c0		 test	 eax, eax
  00072	74 2f		 je	 SHORT $LN3@mg_url_is_
  00074	44 8b c6	 mov	 r8d, esi
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04DHGBAOCG@tls?3@
  0007e	48 8b cf	 mov	 rcx, rdi
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00087	85 c0		 test	 eax, eax
  00089	74 18		 je	 SHORT $LN3@mg_url_is_
  0008b	44 8d 46 01	 lea	 r8d, QWORD PTR [rsi+1]
  0008f	48 8b cf	 mov	 rcx, rdi
  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05BIDNLEPK@tcps?3@
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  0009f	85 c0		 test	 eax, eax
  000a1	75 05		 jne	 SHORT $LN4@mg_url_is_
$LN3@mg_url_is_:
  000a3	bb 01 00 00 00	 mov	 ebx, 1
$LN4@mg_url_is_:

; 13672:          strncmp(url, "mqtts:", 6) == 0 || strncmp(url, "ssl:", 4) == 0 ||
; 13673:          strncmp(url, "tls:", 4) == 0 || strncmp(url, "tcps:", 5) == 0;
; 13674: }

  000a8	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000ad	8b c3		 mov	 eax, ebx
  000af	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b8	5f		 pop	 rdi
  000b9	c3		 ret	 0
mg_url_is_ssl ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT urlparse
_TEXT	SEGMENT
__$ReturnAddress$ = 8
url$ = 16
urlparse PROC						; COMDAT

; 13676: static struct url urlparse(const char *url) {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 13677:   size_t i;
; 13678:   struct url u;
; 13679:   memset(&u, 0, sizeof(u));

  00003	33 c0		 xor	 eax, eax
  00005	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0

; 13680:   for (i = 0; url[i] != '\0'; i++) {

  00008	45 33 d2	 xor	 r10d, r10d
  0000b	4c 8b ca	 mov	 r9, rdx
  0000e	0f 11 41 10	 movups	 XMMWORD PTR [rcx+16], xmm0
  00012	45 8b c2	 mov	 r8d, r10d
  00015	0f 11 41 20	 movups	 XMMWORD PTR [rcx+32], xmm0
  00019	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
  0001d	8a 02		 mov	 al, BYTE PTR [rdx]
  0001f	84 c0		 test	 al, al
  00021	0f 84 82 00 00
	00		 je	 $LN3@urlparse

; 13677:   size_t i;
; 13678:   struct url u;
; 13679:   memset(&u, 0, sizeof(u));

  00027	41 8d 52 01	 lea	 edx, QWORD PTR [r10+1]
$LL4@urlparse:

; 13681:     if (url[i] == '/' && i > 0 && u.host == 0 && url[i - 1] == '/') {

  0002b	3c 2f		 cmp	 al, 47			; 0000002fH
  0002d	75 24		 jne	 SHORT $LN5@urlparse
  0002f	4d 85 c0	 test	 r8, r8
  00032	74 0d		 je	 SHORT $LN19@urlparse
  00034	4c 39 51 18	 cmp	 QWORD PTR [rcx+24], r10
  00038	75 0d		 jne	 SHORT $LN21@urlparse
  0003a	41 38 44 11 fe	 cmp	 BYTE PTR [r9+rdx-2], al
  0003f	74 52		 je	 SHORT $LN22@urlparse
$LN19@urlparse:

; 13691:       u.host = i + 1;
; 13692:       u.port = 0;
; 13693:     } else if (url[i] == '/' && u.host && u.uri == 0) {

  00041	4c 39 51 18	 cmp	 QWORD PTR [rcx+24], r10
  00045	74 54		 je	 SHORT $LN2@urlparse
$LN21@urlparse:
  00047	4c 39 51 28	 cmp	 QWORD PTR [rcx+40], r10
  0004b	75 4e		 jne	 SHORT $LN2@urlparse

; 13694:       u.uri = i;

  0004d	4c 89 41 28	 mov	 QWORD PTR [rcx+40], r8
  00051	eb 48		 jmp	 SHORT $LN2@urlparse
$LN5@urlparse:

; 13682:       u.host = i + 1;
; 13683:       u.port = 0;
; 13684:     } else if (url[i] == ']') {

  00053	3c 5d		 cmp	 al, 93			; 0000005dH
  00055	74 40		 je	 SHORT $LN23@urlparse

; 13685:       u.port = 0;  // IPv6 URLs, like http://[::1]/bar
; 13686:     } else if (url[i] == ':' && u.port == 0 && u.uri == 0) {

  00057	3c 3a		 cmp	 al, 58			; 0000003aH
  00059	75 12		 jne	 SHORT $LN9@urlparse
  0005b	4c 39 51 20	 cmp	 QWORD PTR [rcx+32], r10
  0005f	75 3a		 jne	 SHORT $LN2@urlparse
  00061	4c 39 51 28	 cmp	 QWORD PTR [rcx+40], r10
  00065	75 34		 jne	 SHORT $LN2@urlparse

; 13687:       u.port = i + 1;

  00067	48 89 51 20	 mov	 QWORD PTR [rcx+32], rdx
  0006b	eb 2e		 jmp	 SHORT $LN2@urlparse
$LN9@urlparse:

; 13688:     } else if (url[i] == '@' && u.user == 0 && u.pass == 0 && u.uri == 0) {

  0006d	3c 40		 cmp	 al, 64			; 00000040H
  0006f	75 2a		 jne	 SHORT $LN2@urlparse
  00071	4c 39 51 08	 cmp	 QWORD PTR [rcx+8], r10
  00075	75 24		 jne	 SHORT $LN2@urlparse
  00077	4c 39 51 10	 cmp	 QWORD PTR [rcx+16], r10
  0007b	75 1e		 jne	 SHORT $LN2@urlparse
  0007d	4c 39 51 28	 cmp	 QWORD PTR [rcx+40], r10
  00081	75 18		 jne	 SHORT $LN2@urlparse

; 13689:       u.user = u.host;

  00083	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00087	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 13690:       u.pass = u.port;

  0008b	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]
  0008f	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN22@urlparse:

; 13680:   for (i = 0; url[i] != '\0'; i++) {

  00093	48 89 51 18	 mov	 QWORD PTR [rcx+24], rdx
$LN23@urlparse:
  00097	4c 89 51 20	 mov	 QWORD PTR [rcx+32], r10
$LN2@urlparse:
  0009b	41 8a 04 11	 mov	 al, BYTE PTR [r9+rdx]
  0009f	48 ff c2	 inc	 rdx
  000a2	49 ff c0	 inc	 r8
  000a5	84 c0		 test	 al, al
  000a7	75 82		 jne	 SHORT $LL4@urlparse
$LN3@urlparse:

; 13695:     }
; 13696:   }
; 13697:   u.end = i;

  000a9	4c 89 41 30	 mov	 QWORD PTR [rcx+48], r8

; 13698: #if 0
; 13699:   printf("[%s] %d %d %d %d %d\n", url, u.user, u.pass, u.host, u.port, u.uri);
; 13700: #endif
; 13701:   return u;

  000ad	48 8b c1	 mov	 rax, rcx

; 13702: }

  000b0	c3		 ret	 0
urlparse ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_url_host
_TEXT	SEGMENT
u$ = 32
$T1 = 88
__$ReturnAddress$ = 160
url$ = 168
mg_url_host PROC					; COMDAT

; 13704: struct mg_str mg_url_host(const char *url) {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	4c 8b da	 mov	 r11, rdx

; 13705:   struct url u = urlparse(url);

  0000f	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T1[rsp]
  00014	e8 00 00 00 00	 call	 urlparse
  00019	0f 10 48 20	 movups	 xmm1, XMMWORD PTR [rax+32]
  0001d	0f 10 50 10	 movups	 xmm2, XMMWORD PTR [rax+16]
  00021	f2 0f 10 40 30	 movsd	 xmm0, QWORD PTR [rax+48]

; 13706:   size_t n = u.port  ? u.port - u.host - 1

  00026	66 49 0f 7e ca	 movq	 r10, xmm1

; 13707:              : u.uri ? u.uri - u.host
; 13708:                      : u.end - u.host;
; 13709:   struct mg_str s = mg_str_n(url + u.host, n);

  0002b	66 0f 73 da 08	 psrldq	 xmm2, 8

; 7845 :   struct mg_str str = {s, n};

  00030	4d 8b ca	 mov	 r9, r10

; 13707:              : u.uri ? u.uri - u.host
; 13708:                      : u.end - u.host;
; 13709:   struct mg_str s = mg_str_n(url + u.host, n);

  00033	66 49 0f 7e d0	 movq	 r8, xmm2
  00038	66 0f 73 d9 08	 psrldq	 xmm1, 8

; 7845 :   struct mg_str str = {s, n};

  0003d	4d 2b c8	 sub	 r9, r8

; 13705:   struct url u = urlparse(url);

  00040	f2 0f 11 44 24
	50		 movsd	 QWORD PTR u$[rsp+48], xmm0

; 13706:   size_t n = u.port  ? u.port - u.host - 1

  00046	48 8b 54 24 50	 mov	 rdx, QWORD PTR u$[rsp+48]
  0004b	49 ff c9	 dec	 r9
  0004e	49 2b d0	 sub	 rdx, r8
  00051	66 48 0f 7e c9	 movq	 rcx, xmm1

; 13707:              : u.uri ? u.uri - u.host
; 13708:                      : u.end - u.host;
; 13709:   struct mg_str s = mg_str_n(url + u.host, n);

  00056	4b 8d 04 18	 lea	 rax, QWORD PTR [r8+r11]

; 7845 :   struct mg_str str = {s, n};

  0005a	48 89 03	 mov	 QWORD PTR [rbx], rax

; 13706:   size_t n = u.port  ? u.port - u.host - 1

  0005d	48 8b c1	 mov	 rax, rcx
  00060	49 2b c0	 sub	 rax, r8
  00063	48 85 c9	 test	 rcx, rcx
  00066	48 0f 45 d0	 cmovne	 rdx, rax
  0006a	4d 85 d2	 test	 r10, r10

; 13710:   return s;

  0006d	48 8b c3	 mov	 rax, rbx
  00070	49 0f 45 d1	 cmovne	 rdx, r9

; 7845 :   struct mg_str str = {s, n};

  00074	48 89 53 08	 mov	 QWORD PTR [rbx+8], rdx

; 13711: }

  00078	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  0007f	5b		 pop	 rbx
  00080	c3		 ret	 0
mg_url_host ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_url_uri
_TEXT	SEGMENT
$T1 = 88
url$ = 160
mg_url_uri PROC						; COMDAT

; 13713: const char *mg_url_uri(const char *url) {

$LN4:
  00000	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 13714:   struct url u = urlparse(url);

  00007	48 8b d1	 mov	 rdx, rcx
  0000a	4c 8b d9	 mov	 r11, rcx
  0000d	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T1[rsp]
  00012	e8 00 00 00 00	 call	 urlparse
  00017	0f 10 48 20	 movups	 xmm1, XMMWORD PTR [rax+32]

; 13715:   return u.uri ? url + u.uri : "/";

  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01KMDKNFGN@?1@
  00022	66 0f 73 d9 08	 psrldq	 xmm1, 8
  00027	66 48 0f 7e ca	 movq	 rdx, xmm1
  0002c	48 85 d2	 test	 rdx, rdx
  0002f	4a 8d 0c 1a	 lea	 rcx, QWORD PTR [rdx+r11]
  00033	48 0f 45 c1	 cmovne	 rax, rcx

; 13716: }

  00037	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0003e	c3		 ret	 0
mg_url_uri ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_url_port
_TEXT	SEGMENT
u$ = 32
$T1 = 88
url$ = 160
mg_url_port PROC					; COMDAT

; 13718: unsigned short mg_url_port(const char *url) {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 13719:   struct url u = urlparse(url);

  00012	48 8b d1	 mov	 rdx, rcx
  00015	48 8b f9	 mov	 rdi, rcx
  00018	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T1[rsp]
  0001d	e8 00 00 00 00	 call	 urlparse

; 13720:   unsigned short port = 0;

  00022	33 f6		 xor	 esi, esi

; 13721:   if (strncmp(url, "http:", 5) == 0 || strncmp(url, "ws:", 3) == 0) port = 80;

  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05DDMNBEIG@http?3@
  0002b	48 8b cf	 mov	 rcx, rdi
  0002e	0f b7 de	 movzx	 ebx, si
  00031	0f 10 48 20	 movups	 xmm1, XMMWORD PTR [rax+32]
  00035	44 8d 46 05	 lea	 r8d, QWORD PTR [rsi+5]
  00039	0f 11 4c 24 40	 movups	 XMMWORD PTR u$[rsp+32], xmm1
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00044	85 c0		 test	 eax, eax
  00046	74 18		 je	 SHORT $LN3@mg_url_por
  00048	44 8d 46 03	 lea	 r8d, QWORD PTR [rsi+3]
  0004c	48 8b cf	 mov	 rcx, rdi
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03FLENLALG@ws?3@
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  0005c	85 c0		 test	 eax, eax
  0005e	75 05		 jne	 SHORT $LN2@mg_url_por
$LN3@mg_url_por:
  00060	bb 50 00 00 00	 mov	 ebx, 80			; 00000050H
$LN2@mg_url_por:

; 13722:   if (strncmp(url, "wss:", 4) == 0 || strncmp(url, "https:", 6) == 0)

  00065	41 b8 04 00 00
	00		 mov	 r8d, 4
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04HILLDDDP@wss?3@
  00072	48 8b cf	 mov	 rcx, rdi
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  0007b	85 c0		 test	 eax, eax
  0007d	74 1a		 je	 SHORT $LN5@mg_url_por
  0007f	41 b8 06 00 00
	00		 mov	 r8d, 6
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06FOAKIDDH@https?3@
  0008c	48 8b cf	 mov	 rcx, rdi
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00095	85 c0		 test	 eax, eax
  00097	75 05		 jne	 SHORT $LN4@mg_url_por
$LN5@mg_url_por:

; 13723:     port = 443;

  00099	bb bb 01 00 00	 mov	 ebx, 443		; 000001bbH
$LN4@mg_url_por:

; 13724:   if (strncmp(url, "mqtt:", 5) == 0) port = 1883;

  0009e	41 b8 05 00 00
	00		 mov	 r8d, 5
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KMOJKCJJ@mqtt?3@
  000ab	48 8b cf	 mov	 rcx, rdi
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  000b4	85 c0		 test	 eax, eax
  000b6	75 05		 jne	 SHORT $LN6@mg_url_por
  000b8	bb 5b 07 00 00	 mov	 ebx, 1883		; 0000075bH
$LN6@mg_url_por:

; 13725:   if (strncmp(url, "mqtts:", 6) == 0) port = 8883;

  000bd	41 b8 06 00 00
	00		 mov	 r8d, 6
  000c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06NDJNKKHE@mqtts?3@
  000ca	48 8b cf	 mov	 rcx, rdi
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  000d3	85 c0		 test	 eax, eax
  000d5	75 05		 jne	 SHORT $LN7@mg_url_por
  000d7	bb b3 22 00 00	 mov	 ebx, 8883		; 000022b3H
$LN7@mg_url_por:

; 13726:   if (u.port) port = (unsigned short) atoi(url + u.port);

  000dc	48 8b 44 24 40	 mov	 rax, QWORD PTR u$[rsp+32]
  000e1	48 85 c0	 test	 rax, rax
  000e4	74 0d		 je	 SHORT $LN8@mg_url_por
  000e6	48 8d 0c 38	 lea	 rcx, QWORD PTR [rax+rdi]
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  000f0	0f b7 d8	 movzx	 ebx, ax
$LN8@mg_url_por:

; 13727:   return port;
; 13728: }

  000f3	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  000fb	0f b7 c3	 movzx	 eax, bx
  000fe	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00102	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00106	49 8b e3	 mov	 rsp, r11
  00109	5f		 pop	 rdi
  0010a	c3		 ret	 0
mg_url_port ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_url_user
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
u$ = 48
$T3 = 104
__$ReturnAddress$ = 176
url$ = 184
mg_url_user PROC					; COMDAT

; 13730: struct mg_str mg_url_user(const char *url) {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00009	4c 8b d9	 mov	 r11, rcx
  0000c	48 8b da	 mov	 rbx, rdx

; 13731:   struct url u = urlparse(url);

  0000f	48 8d 4c 24 68	 lea	 rcx, QWORD PTR $T3[rsp]
  00014	e8 00 00 00 00	 call	 urlparse

; 7840 :   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};

  00019	48 83 64 24 28
	00		 and	 QWORD PTR $T2[rsp+8], 0

; 13731:   struct url u = urlparse(url);

  0001f	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [rax+16]
  00023	0f 10 10	 movups	 xmm2, XMMWORD PTR [rax]

; 7840 :   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};

  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
  0002d	48 89 44 24 20	 mov	 QWORD PTR $T2[rsp], rax

; 13731:   struct url u = urlparse(url);

  00032	0f 11 44 24 40	 movups	 XMMWORD PTR u$[rsp+16], xmm0

; 13732:   struct mg_str s = mg_str("");

  00037	0f 10 44 24 20	 movups	 xmm0, XMMWORD PTR $T2[rsp]

; 13733:   if (u.user && (u.pass || u.host)) {

  0003c	66 0f 73 da 08	 psrldq	 xmm2, 8
  00041	66 49 0f 7e d0	 movq	 r8, xmm2
  00046	f3 41 0f 7f 03	 movdqu	 XMMWORD PTR [r11], xmm0
  0004b	4d 85 c0	 test	 r8, r8
  0004e	74 3f		 je	 SHORT $LN2@mg_url_use
  00050	48 8b 54 24 40	 mov	 rdx, QWORD PTR u$[rsp+16]
  00055	48 8b 4c 24 48	 mov	 rcx, QWORD PTR u$[rsp+24]
  0005a	48 85 d2	 test	 rdx, rdx
  0005d	75 05		 jne	 SHORT $LN3@mg_url_use
  0005f	48 85 c9	 test	 rcx, rcx
  00062	74 2b		 je	 SHORT $LN2@mg_url_use
$LN3@mg_url_use:

; 7845 :   struct mg_str str = {s, n};

  00064	49 2b c8	 sub	 rcx, r8

; 13735:     s = mg_str_n(url + u.user, n);

  00067	49 8d 04 18	 lea	 rax, QWORD PTR [r8+rbx]
  0006b	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax

; 7845 :   struct mg_str str = {s, n};

  00070	48 8b c2	 mov	 rax, rdx
  00073	49 2b c0	 sub	 rax, r8

; 13734:     size_t n = u.pass ? u.pass - u.user - 1 : u.host - u.user - 1;

  00076	48 85 d2	 test	 rdx, rdx
  00079	48 0f 45 c8	 cmovne	 rcx, rax
  0007d	48 ff c9	 dec	 rcx

; 7845 :   struct mg_str str = {s, n};

  00080	48 89 4c 24 28	 mov	 QWORD PTR $T1[rsp+8], rcx

; 13735:     s = mg_str_n(url + u.user, n);

  00085	0f 10 44 24 20	 movups	 xmm0, XMMWORD PTR $T1[rsp]
  0008a	f3 41 0f 7f 03	 movdqu	 XMMWORD PTR [r11], xmm0
$LN2@mg_url_use:

; 13736:   }
; 13737:   return s;

  0008f	49 8b c3	 mov	 rax, r11

; 13738: }

  00092	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  00099	5b		 pop	 rbx
  0009a	c3		 ret	 0
mg_url_user ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_url_pass
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
u$ = 48
$T3 = 104
__$ReturnAddress$ = 176
url$ = 184
mg_url_pass PROC					; COMDAT

; 13740: struct mg_str mg_url_pass(const char *url) {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00009	4c 8b d9	 mov	 r11, rcx
  0000c	48 8b da	 mov	 rbx, rdx

; 13741:   struct url u = urlparse(url);

  0000f	48 8d 4c 24 68	 lea	 rcx, QWORD PTR $T3[rsp]
  00014	e8 00 00 00 00	 call	 urlparse

; 7845 :   struct mg_str str = {s, n};

  00019	48 83 64 24 28
	00		 and	 QWORD PTR $T2[rsp+8], 0

; 13741:   struct url u = urlparse(url);

  0001f	0f 10 50 10	 movups	 xmm2, XMMWORD PTR [rax+16]

; 7845 :   struct mg_str str = {s, n};

  00023	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
  0002a	48 89 44 24 20	 mov	 QWORD PTR $T2[rsp], rax

; 13742:   struct mg_str s = mg_str_n("", 0UL);

  0002f	0f 10 44 24 20	 movups	 xmm0, XMMWORD PTR $T2[rsp]

; 13743:   if (u.pass && u.host) {

  00034	66 48 0f 7e d2	 movq	 rdx, xmm2
  00039	f3 41 0f 7f 03	 movdqu	 XMMWORD PTR [r11], xmm0
  0003e	0f 11 54 24 40	 movups	 XMMWORD PTR u$[rsp+16], xmm2
  00043	48 85 d2	 test	 rdx, rdx
  00046	74 28		 je	 SHORT $LN2@mg_url_pas
  00048	48 8b 4c 24 48	 mov	 rcx, QWORD PTR u$[rsp+24]
  0004d	48 85 c9	 test	 rcx, rcx
  00050	74 1e		 je	 SHORT $LN2@mg_url_pas

; 7845 :   struct mg_str str = {s, n};

  00052	48 2b ca	 sub	 rcx, rdx

; 13744:     size_t n = u.host - u.pass - 1;
; 13745:     s = mg_str_n(url + u.pass, n);

  00055	48 8d 04 1a	 lea	 rax, QWORD PTR [rdx+rbx]
  00059	48 ff c9	 dec	 rcx
  0005c	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax

; 7845 :   struct mg_str str = {s, n};

  00061	48 89 4c 24 28	 mov	 QWORD PTR $T1[rsp+8], rcx

; 13744:     size_t n = u.host - u.pass - 1;
; 13745:     s = mg_str_n(url + u.pass, n);

  00066	0f 10 44 24 20	 movups	 xmm0, XMMWORD PTR $T1[rsp]
  0006b	f3 41 0f 7f 03	 movdqu	 XMMWORD PTR [r11], xmm0
$LN2@mg_url_pas:

; 13746:   }
; 13747:   return s;

  00070	49 8b c3	 mov	 rax, r11

; 13748: }

  00073	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  0007a	5b		 pop	 rbx
  0007b	c3		 ret	 0
mg_url_pass ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_bzero
_TEXT	SEGMENT
buf$ = 8
len$ = 16
mg_bzero PROC						; COMDAT

; 13758:   if (buf != NULL) {

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 11		 je	 SHORT $LN7@mg_bzero

; 13759:     while (len--) *buf++ = 0;

  00005	48 85 d2	 test	 rdx, rdx
  00008	74 0c		 je	 SHORT $LN7@mg_bzero
$LL2@mg_bzero:
  0000a	c6 01 00	 mov	 BYTE PTR [rcx], 0
  0000d	48 ff c1	 inc	 rcx
  00010	48 83 ea 01	 sub	 rdx, 1
  00014	75 f4		 jne	 SHORT $LL2@mg_bzero
$LN7@mg_bzero:

; 13760:   }
; 13761: }

  00016	c3		 ret	 0
mg_bzero ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_random
_TEXT	SEGMENT
buf$ = 48
len$ = 56
mg_random PROC						; COMDAT

; 13765: void mg_random(void *buf, size_t len) {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f9	 mov	 rdi, rcx
$LL2@mg_random:

; 13766:   bool done = false;
; 13767:   unsigned char *p = (unsigned char *) buf;
; 13768: #if MG_ARCH == MG_ARCH_ESP32
; 13769:   while (len--) *p++ = (unsigned char) (esp_random() & 255);
; 13770:   done = true;
; 13771: #elif MG_ARCH == MG_ARCH_WIN32
; 13772: #elif MG_ARCH == MG_ARCH_UNIX
; 13773:   FILE *fp = fopen("/dev/urandom", "rb");
; 13774:   if (fp != NULL) {
; 13775:     if (fread(buf, 1, len, fp) == len) done = true;
; 13776:     fclose(fp);
; 13777:   }
; 13778: #endif
; 13779:   // If everything above did not work, fallback to a pseudo random generator
; 13780:   while (!done && len--) *p++ = (unsigned char) (rand() & 255);

  00010	48 8b c3	 mov	 rax, rbx
  00013	48 ff cb	 dec	 rbx
  00016	48 85 c0	 test	 rax, rax
  00019	74 0d		 je	 SHORT $LN3@mg_random
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00021	88 07		 mov	 BYTE PTR [rdi], al
  00023	48 ff c7	 inc	 rdi
  00026	eb e8		 jmp	 SHORT $LL2@mg_random
$LN3@mg_random:

; 13781: }

  00028	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5f		 pop	 rdi
  00032	c3		 ret	 0
mg_random ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_random_str
_TEXT	SEGMENT
buf$ = 48
len$ = 56
mg_random_str PROC					; COMDAT

; 13784: char *mg_random_str(char *buf, size_t len) {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 13785:   size_t i;
; 13786:   mg_random(buf, len);

  00010	e8 00 00 00 00	 call	 mg_random
  00015	45 33 db	 xor	 r11d, r11d
  00018	45 8b cb	 mov	 r9d, r11d

; 13787:   for (i = 0; i < len; i++) {

  0001b	48 85 db	 test	 rbx, rbx
  0001e	74 55		 je	 SHORT $LN3@mg_random_
  00020	4c 8d 53 ff	 lea	 r10, QWORD PTR [rbx-1]
$LL8@mg_random_:

; 13788:     uint8_t c = ((uint8_t *) buf)[i] % 62U;

  00024	45 0f b6 04 39	 movzx	 r8d, BYTE PTR [r9+rdi]
  00029	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H
  0002e	41 f7 e0	 mul	 r8d
  00031	41 8b c0	 mov	 eax, r8d
  00034	2b c2		 sub	 eax, edx
  00036	d1 e8		 shr	 eax, 1
  00038	03 c2		 add	 eax, edx
  0003a	c1 e8 05	 shr	 eax, 5
  0003d	6b c0 3e	 imul	 eax, eax, 62		; 0000003eH
  00040	44 2b c0	 sub	 r8d, eax

; 13789:     buf[i] = i == len - 1 ? (char) '\0'            // 0-terminate last byte

  00043	41 80 f8 34	 cmp	 r8b, 52			; 00000034H
  00047	1a c0		 sbb	 al, al
  00049	24 2b		 and	 al, 43			; 0000002bH
  0004b	04 fc		 add	 al, -4
  0004d	0f b6 c8	 movzx	 ecx, al
  00050	41 80 f8 1a	 cmp	 r8b, 26
  00054	b8 61 00 00 00	 mov	 eax, 97			; 00000061H
  00059	0f 42 c8	 cmovb	 ecx, eax
  0005c	41 02 c8	 add	 cl, r8b
  0005f	4d 3b ca	 cmp	 r9, r10
  00062	0f b6 c1	 movzx	 eax, cl
  00065	41 0f 44 c3	 cmove	 eax, r11d
  00069	41 88 04 39	 mov	 BYTE PTR [r9+rdi], al
  0006d	49 ff c1	 inc	 r9
  00070	4c 3b cb	 cmp	 r9, rbx
  00073	72 af		 jb	 SHORT $LL8@mg_random_
$LN3@mg_random_:

; 13790:              : c < 26     ? (char) ('a' + c)       // lowercase
; 13791:              : c < 52     ? (char) ('A' + c - 26)  // uppercase
; 13792:                           : (char) ('0' + c - 52);     // numeric
; 13793:   }
; 13794:   return buf;
; 13795: }

  00075	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007a	48 8b c7	 mov	 rax, rdi
  0007d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00081	5f		 pop	 rdi
  00082	c3		 ret	 0
mg_random_str ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ntohl
_TEXT	SEGMENT
net$ = 8
mg_ntohl PROC						; COMDAT

; 13798:   uint8_t data[4] = {0, 0, 0, 0};
; 13799:   memcpy(&data, &net, sizeof(data));
; 13800:   return (((uint32_t) data[3]) << 0) | (((uint32_t) data[2]) << 8) |

  00000	8b c1		 mov	 eax, ecx
  00002	0f b6 d1	 movzx	 edx, cl
  00005	c1 e8 08	 shr	 eax, 8
  00008	0f b6 c0	 movzx	 eax, al
  0000b	c1 e2 08	 shl	 edx, 8
  0000e	0b c2		 or	 eax, edx
  00010	8b d1		 mov	 edx, ecx
  00012	c1 e0 08	 shl	 eax, 8
  00015	c1 ea 10	 shr	 edx, 16
  00018	44 0f b6 c2	 movzx	 r8d, dl
  0001c	41 0b c0	 or	 eax, r8d
  0001f	c1 e9 18	 shr	 ecx, 24
  00022	c1 e0 08	 shl	 eax, 8
  00025	0b c1		 or	 eax, ecx

; 13801:          (((uint32_t) data[1]) << 16) | (((uint32_t) data[0]) << 24);
; 13802: }

  00027	c3		 ret	 0
mg_ntohl ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ntohs
_TEXT	SEGMENT
net$ = 8
mg_ntohs PROC						; COMDAT

; 13805:   uint8_t data[2] = {0, 0};
; 13806:   memcpy(&data, &net, sizeof(data));
; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00000	0f b6 c1	 movzx	 eax, cl
  00003	66 c1 e0 08	 shl	 ax, 8
  00007	66 c1 e9 08	 shr	 cx, 8
  0000b	66 0b c1	 or	 ax, cx

; 13808: }

  0000e	c3		 ret	 0
mg_ntohs ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_crc32
_TEXT	SEGMENT
crc$ = 8
buf$ = 16
len$ = 24
mg_crc32 PROC						; COMDAT

; 13810: uint32_t mg_crc32(uint32_t crc, const char *buf, size_t len) {

  00000	44 8b c9	 mov	 r9d, ecx

; 13811:   static const uint32_t crclut[16] = {
; 13812:       // table for polynomial 0xEDB88320 (reflected)
; 13813:       0x00000000, 0x1DB71064, 0x3B6E20C8, 0x26D930AC, 0x76DC4190, 0x6B6B51F4,
; 13814:       0x4DB26158, 0x5005713C, 0xEDB88320, 0xF00F9344, 0xD6D6A3E8, 0xCB61B38C,
; 13815:       0x9B64C2B0, 0x86D3D2D4, 0xA00AE278, 0xBDBDF21C};
; 13816:   crc = ~crc;

  00003	41 f7 d1	 not	 r9d

; 13817:   while (len--) {

  00006	4d 85 c0	 test	 r8, r8
  00009	74 39		 je	 SHORT $LN6@mg_crc32
  0000b	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:?crclut@?1??mg_crc32@@9@9
$LL2@mg_crc32:

; 13818:     uint8_t byte = *(uint8_t *) buf++;

  00012	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]

; 13819:     crc = crclut[(crc ^ byte) & 0x0F] ^ (crc >> 4);

  00015	41 8b c1	 mov	 eax, r9d
  00018	48 33 c1	 xor	 rax, rcx
  0001b	41 c1 e9 04	 shr	 r9d, 4
  0001f	83 e0 0f	 and	 eax, 15

; 13820:     crc = crclut[(crc ^ (byte >> 4)) & 0x0F] ^ (crc >> 4);

  00022	48 c1 e9 04	 shr	 rcx, 4
  00026	48 ff c2	 inc	 rdx
  00029	45 33 0c 82	 xor	 r9d, DWORD PTR [r10+rax*4]
  0002d	41 8b c1	 mov	 eax, r9d
  00030	41 c1 e9 04	 shr	 r9d, 4
  00034	48 33 c8	 xor	 rcx, rax
  00037	83 e1 0f	 and	 ecx, 15
  0003a	45 33 0c 8a	 xor	 r9d, DWORD PTR [r10+rcx*4]
  0003e	49 83 e8 01	 sub	 r8, 1
  00042	75 ce		 jne	 SHORT $LL2@mg_crc32
$LN6@mg_crc32:

; 13821:   }
; 13822:   return ~crc;

  00044	41 f7 d1	 not	 r9d
  00047	41 8b c1	 mov	 eax, r9d

; 13823: }

  0004a	c3		 ret	 0
mg_crc32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT isbyte
_TEXT	SEGMENT
n$ = 8
isbyte	PROC						; COMDAT

; 13826:   return n >= 0 && n <= 255;

  00000	33 c0		 xor	 eax, eax
  00002	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00008	0f 96 c0	 setbe	 al

; 13827: }

  0000b	c3		 ret	 0
isbyte	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT parse_net
_TEXT	SEGMENT
c$ = 64
d$ = 68
a$ = 72
slash$ = 76
n$ = 80
spec$ = 128
net$ = 136
mask$ = 144
b$ = 152
parse_net PROC						; COMDAT

; 13829: static int parse_net(const char *spec, uint32_t *net, uint32_t *mask) {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  00007	49 89 73 10	 mov	 QWORD PTR [r11+16], rsi
  0000b	49 89 7b 18	 mov	 QWORD PTR [r11+24], rdi
  0000f	55		 push	 rbp
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 8b ec	 mov	 rbp, rsp
  00017	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 13830:   int n, a, b, c, d, slash = 32, len = 0;
; 13831:   if ((sscanf(spec, "%d.%d.%d.%d/%d%n", &a, &b, &c, &d, &slash, &n) == 5 ||
; 13832:        sscanf(spec, "%d.%d.%d.%d%n", &a, &b, &c, &d, &n) == 4) &&
; 13833:       isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) && slash >= 0 &&

  0001b	48 8d 45 f0	 lea	 rax, QWORD PTR n$[rbp-96]
  0001f	4d 8b f0	 mov	 r14, r8
  00022	49 89 43 c0	 mov	 QWORD PTR [r11-64], rax
  00026	4c 8d 4d 38	 lea	 r9, QWORD PTR b$[rbp-96]
  0002a	48 8d 45 ec	 lea	 rax, QWORD PTR slash$[rbp-96]
  0002e	4c 8b fa	 mov	 r15, rdx
  00031	49 89 43 b8	 mov	 QWORD PTR [r11-72], rax
  00035	4c 8d 45 e8	 lea	 r8, QWORD PTR a$[rbp-96]
  00039	48 8d 45 e4	 lea	 rax, QWORD PTR d$[rbp-96]
  0003d	bb 20 00 00 00	 mov	 ebx, 32			; 00000020H
  00042	49 89 43 b0	 mov	 QWORD PTR [r11-80], rax
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@DHKKPGMP@?$CFd?4?$CFd?4?$CFd?4?$CFd?1?$CFd?$CFn@
  0004d	48 8d 45 e0	 lea	 rax, QWORD PTR c$[rbp-96]
  00051	89 5d ec	 mov	 DWORD PTR slash$[rbp-96], ebx
  00054	49 89 43 a8	 mov	 QWORD PTR [r11-88], rax
  00058	48 8b f1	 mov	 rsi, rcx
  0005b	33 ff		 xor	 edi, edi
  0005d	e8 00 00 00 00	 call	 sscanf
  00062	83 f8 05	 cmp	 eax, 5
  00065	74 37		 je	 SHORT $LN3@parse_net
  00067	48 8d 45 f0	 lea	 rax, QWORD PTR n$[rbp-96]
  0006b	48 8b ce	 mov	 rcx, rsi
  0006e	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00073	4c 8d 4d 38	 lea	 r9, QWORD PTR b$[rbp-96]
  00077	48 8d 45 e4	 lea	 rax, QWORD PTR d$[rbp-96]
  0007b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00080	4c 8d 45 e8	 lea	 r8, QWORD PTR a$[rbp-96]
  00084	48 8d 45 e0	 lea	 rax, QWORD PTR c$[rbp-96]
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@LGGJJEIN@?$CFd?4?$CFd?4?$CFd?4?$CFd?$CFn@
  0008f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00094	e8 00 00 00 00	 call	 sscanf
  00099	83 f8 04	 cmp	 eax, 4
  0009c	75 50		 jne	 SHORT $LN2@parse_net
$LN3@parse_net:

; 13826:   return n >= 0 && n <= 255;

  0009e	8b 55 e8	 mov	 edx, DWORD PTR a$[rbp-96]
  000a1	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  000a6	3b d0		 cmp	 edx, eax
  000a8	77 44		 ja	 SHORT $LN2@parse_net
  000aa	39 45 38	 cmp	 DWORD PTR b$[rbp-96], eax
  000ad	77 3f		 ja	 SHORT $LN2@parse_net
  000af	39 45 e0	 cmp	 DWORD PTR c$[rbp-96], eax
  000b2	77 3a		 ja	 SHORT $LN2@parse_net
  000b4	39 45 e4	 cmp	 DWORD PTR d$[rbp-96], eax
  000b7	77 35		 ja	 SHORT $LN2@parse_net

; 13830:   int n, a, b, c, d, slash = 32, len = 0;
; 13831:   if ((sscanf(spec, "%d.%d.%d.%d/%d%n", &a, &b, &c, &d, &slash, &n) == 5 ||
; 13832:        sscanf(spec, "%d.%d.%d.%d%n", &a, &b, &c, &d, &n) == 4) &&
; 13833:       isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) && slash >= 0 &&

  000b9	44 8b 45 ec	 mov	 r8d, DWORD PTR slash$[rbp-96]
  000bd	44 3b c3	 cmp	 r8d, ebx
  000c0	77 2c		 ja	 SHORT $LN2@parse_net

; 13834:       slash < 33) {
; 13835:     len = n;

  000c2	8b 7d f0	 mov	 edi, DWORD PTR n$[rbp-96]

; 13836:     *net = ((uint32_t) a << 24) | ((uint32_t) b << 16) | ((uint32_t) c << 8) |
; 13837:            (uint32_t) d;
; 13838:     *mask = slash ? (uint32_t) (0xffffffffU << (32 - slash)) : (uint32_t) 0;

  000c5	41 2b d8	 sub	 ebx, r8d
  000c8	c1 e2 08	 shl	 edx, 8
  000cb	8a cb		 mov	 cl, bl
  000cd	0b 55 38	 or	 edx, DWORD PTR b$[rbp-96]
  000d0	c1 e2 08	 shl	 edx, 8
  000d3	0b 55 e0	 or	 edx, DWORD PTR c$[rbp-96]
  000d6	c1 e2 08	 shl	 edx, 8
  000d9	0b 55 e4	 or	 edx, DWORD PTR d$[rbp-96]
  000dc	41 89 17	 mov	 DWORD PTR [r15], edx
  000df	83 ca ff	 or	 edx, -1			; ffffffffH
  000e2	d3 e2		 shl	 edx, cl
  000e4	41 f7 d8	 neg	 r8d
  000e7	1b c9		 sbb	 ecx, ecx
  000e9	23 ca		 and	 ecx, edx
  000eb	41 89 0e	 mov	 DWORD PTR [r14], ecx
$LN2@parse_net:

; 13839:   }
; 13840:   return len;
; 13841: }

  000ee	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  000f3	8b c7		 mov	 eax, edi
  000f5	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  000f9	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  000fd	49 8b 7b 30	 mov	 rdi, QWORD PTR [r11+48]
  00101	49 8b e3	 mov	 rsp, r11
  00104	41 5f		 pop	 r15
  00106	41 5e		 pop	 r14
  00108	5d		 pop	 rbp
  00109	c3		 ret	 0
parse_net ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_check_ip_acl
_TEXT	SEGMENT
k$ = 32
v$ = 48
mask$1 = 96
acl$ = 96
net$2 = 104
remote_ip$ = 104
mg_check_ip_acl PROC					; COMDAT

; 13843: int mg_check_ip_acl(struct mg_str acl, struct mg_addr *remote_ip) {

$LN26:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 56		 push	 r14
  0000e	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 13844:   struct mg_str k, v;
; 13845:   int allowed = acl.len == 0 ? '+' : '-';  // If any ACL is set, deny by default

  00012	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00016	48 8b e9	 mov	 rbp, rcx
  00019	48 f7 d8	 neg	 rax
  0001c	1b db		 sbb	 ebx, ebx

; 13846:   uint32_t remote_ip4;
; 13847:   if (remote_ip->is_ip6) {

  0001e	33 ff		 xor	 edi, edi
  00020	83 e3 02	 and	 ebx, 2
  00023	83 c3 2b	 add	 ebx, 43			; 0000002bH
  00026	40 38 7a 13	 cmp	 BYTE PTR [rdx+19], dil
  0002a	0f 85 8c 00 00
	00		 jne	 $LN15@mg_check_i

; 13848:     return -1;  // TODO(): handle IPv6 ACL and addresses
; 13849:   } else {      // IPv4
; 13850:     memcpy((void *) &remote_ip4, remote_ip->ip, sizeof(remote_ip4));

  00030	44 8b 32	 mov	 r14d, DWORD PTR [rdx]

; 7992 :   return mg_split(s, k, v, ',');

  00033	eb 5f		 jmp	 SHORT $LN24@mg_check_i
$LL2@mg_check_i:

; 13852:       uint32_t net, mask;
; 13853:       if (k.ptr[0] != '+' && k.ptr[0] != '-') return -1;

  00035	48 8b 74 24 20	 mov	 rsi, QWORD PTR k$[rsp]
  0003a	8a 06		 mov	 al, BYTE PTR [rsi]
  0003c	2c 2b		 sub	 al, 43			; 0000002bH
  0003e	a8 fd		 test	 al, 253			; 000000fdH
  00040	75 7a		 jne	 SHORT $LN15@mg_check_i

; 13854:       if (parse_net(&k.ptr[1], &net, &mask) == 0) return -2;

  00042	48 8d 4e 01	 lea	 rcx, QWORD PTR [rsi+1]
  00046	4c 8d 44 24 60	 lea	 r8, QWORD PTR mask$1[rsp]
  0004b	48 8d 54 24 68	 lea	 rdx, QWORD PTR net$2[rsp]
  00050	e8 00 00 00 00	 call	 parse_net
  00055	85 c0		 test	 eax, eax
  00057	74 5c		 je	 SHORT $LN16@mg_check_i

; 13800:   return (((uint32_t) data[3]) << 0) | (((uint32_t) data[2]) << 8) |

  00059	41 8b c6	 mov	 eax, r14d
  0005c	c1 e8 08	 shr	 eax, 8
  0005f	0f b6 d0	 movzx	 edx, al
  00062	41 0f b6 c6	 movzx	 eax, r14b
  00066	c1 e0 08	 shl	 eax, 8
  00069	0b d0		 or	 edx, eax
  0006b	41 8b c6	 mov	 eax, r14d
  0006e	c1 e2 08	 shl	 edx, 8
  00071	c1 e8 10	 shr	 eax, 16
  00074	0f b6 c8	 movzx	 ecx, al
  00077	41 8b c6	 mov	 eax, r14d
  0007a	0b d1		 or	 edx, ecx
  0007c	c1 e8 18	 shr	 eax, 24
  0007f	c1 e2 08	 shl	 edx, 8
  00082	0b d0		 or	 edx, eax

; 13855:       if ((mg_ntohl(remote_ip4) & mask) == net) allowed = k.ptr[0];

  00084	23 54 24 60	 and	 edx, DWORD PTR mask$1[rsp]
  00088	3b 54 24 68	 cmp	 edx, DWORD PTR net$2[rsp]
  0008c	75 03		 jne	 SHORT $LN20@mg_check_i
  0008e	0f be 1e	 movsx	 ebx, BYTE PTR [rsi]
$LN20@mg_check_i:

; 7992 :   return mg_split(s, k, v, ',');

  00091	48 8b cd	 mov	 rcx, rbp
$LN24@mg_check_i:

; 13851:     while (mg_commalist(&acl, &k, &v)) {

  00094	41 b1 2c	 mov	 r9b, 44			; 0000002cH
  00097	4c 8d 44 24 30	 lea	 r8, QWORD PTR v$[rsp]
  0009c	48 8d 54 24 20	 lea	 rdx, QWORD PTR k$[rsp]
  000a1	e8 00 00 00 00	 call	 mg_split
  000a6	84 c0		 test	 al, al
  000a8	75 8b		 jne	 SHORT $LL2@mg_check_i

; 13856:     }
; 13857:   }
; 13858:   return allowed == '+';

  000aa	83 fb 2b	 cmp	 ebx, 43			; 0000002bH
  000ad	40 0f 94 c7	 sete	 dil
  000b1	8b c7		 mov	 eax, edi
  000b3	eb 0a		 jmp	 SHORT $LN1@mg_check_i
$LN16@mg_check_i:

; 13854:       if (parse_net(&k.ptr[1], &net, &mask) == 0) return -2;

  000b5	b8 fe ff ff ff	 mov	 eax, -2
  000ba	eb 03		 jmp	 SHORT $LN1@mg_check_i
$LN15@mg_check_i:

; 13852:       uint32_t net, mask;
; 13853:       if (k.ptr[0] != '+' && k.ptr[0] != '-') return -1;

  000bc	83 c8 ff	 or	 eax, -1
$LN1@mg_check_i:

; 13859: }

  000bf	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  000c4	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  000c9	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000cd	41 5e		 pop	 r14
  000cf	5f		 pop	 rdi
  000d0	5e		 pop	 rsi
  000d1	c3		 ret	 0
mg_check_ip_acl ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_millis
_TEXT	SEGMENT
mg_millis PROC						; COMDAT

; 13863: uint64_t mg_millis(void) {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 13864: #if MG_ARCH == MG_ARCH_WIN32
; 13865:   return GetTickCount();

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  0000a	8b c0		 mov	 eax, eax

; 13866: #elif MG_ARCH == MG_ARCH_RP2040
; 13867:   return time_us_64() / 1000;
; 13868: #elif MG_ARCH == MG_ARCH_ESP8266 || MG_ARCH == MG_ARCH_ESP32 || \
; 13869:     MG_ARCH == MG_ARCH_FREERTOS
; 13870:   return xTaskGetTickCount() * portTICK_PERIOD_MS;
; 13871: #elif MG_ARCH == MG_ARCH_AZURERTOS
; 13872:   return tx_time_get() * (1000 /* MS per SEC */ / TX_TIMER_TICKS_PER_SECOND);
; 13873: #elif MG_ARCH == MG_ARCH_TIRTOS
; 13874:   return (uint64_t) Clock_getTicks();
; 13875: #elif MG_ARCH == MG_ARCH_ZEPHYR
; 13876:   return (uint64_t) k_uptime_get();
; 13877: #elif MG_ARCH == MG_ARCH_CMSIS_RTOS1
; 13878:   return (uint64_t) rt_time_get();
; 13879: #elif MG_ARCH == MG_ARCH_CMSIS_RTOS2
; 13880:   return (uint64_t) ((osKernelGetTickCount() * 1000) / osKernelGetTickFreq());
; 13881: #elif MG_ARCH == MG_ARCH_RTTHREAD
; 13882:   return (uint64_t) ((rt_tick_get() * 1000) / RT_TICK_PER_SECOND);
; 13883: #elif MG_ARCH == MG_ARCH_UNIX && defined(__APPLE__)
; 13884:   // Apple CLOCK_MONOTONIC_RAW is equivalent to CLOCK_BOOTTIME on linux
; 13885:   // Apple CLOCK_UPTIME_RAW is equivalent to CLOCK_MONOTONIC_RAW on linux
; 13886:   return clock_gettime_nsec_np(CLOCK_UPTIME_RAW) / 1000000;
; 13887: #elif MG_ARCH == MG_ARCH_UNIX
; 13888:   struct timespec ts = {0, 0};
; 13889:   // See #1615 - prefer monotonic clock
; 13890: #if defined(CLOCK_MONOTONIC_RAW)
; 13891:   // Raw hardware-based time that is not subject to NTP adjustment
; 13892:   clock_gettime(CLOCK_MONOTONIC_RAW, &ts);
; 13893: #elif defined(CLOCK_MONOTONIC)
; 13894:   // Affected by the incremental adjustments performed by adjtime and NTP
; 13895:   clock_gettime(CLOCK_MONOTONIC, &ts);
; 13896: #else
; 13897:   // Affected by discontinuous jumps in the system time and by the incremental
; 13898:   // adjustments performed by adjtime and NTP
; 13899:   clock_gettime(CLOCK_REALTIME, &ts);
; 13900: #endif
; 13901:   return ((uint64_t) ts.tv_sec * 1000 + (uint64_t) ts.tv_nsec / 1000000);
; 13902: #elif defined(ARDUINO)
; 13903:   return (uint64_t) millis();
; 13904: #else
; 13905:   return (uint64_t) (time(NULL) * 1000);
; 13906: #endif
; 13907: }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
mg_millis ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ws_vprintf
_TEXT	SEGMENT
c$ = 48
op$ = 56
fmt$ = 64
ap$ = 72
mg_ws_vprintf PROC					; COMDAT

; 13931:                      va_list *ap) {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 13932:   size_t len = c->send.len;

  00014	48 8b 79 78	 mov	 rdi, QWORD PTR [rcx+120]
  00018	8b f2		 mov	 esi, edx

; 13933:   size_t n = mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);

  0001a	48 8d 51 68	 lea	 rdx, QWORD PTR [rcx+104]
  0001e	48 8b e9	 mov	 rbp, rcx
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mg_pfn_iobuf
  00028	e8 00 00 00 00	 call	 mg_vxprintf

; 13934:   mg_ws_wrap(c, c->send.len - len, op);

  0002d	48 8b 55 78	 mov	 rdx, QWORD PTR [rbp+120]
  00031	44 8b c6	 mov	 r8d, esi
  00034	48 2b d7	 sub	 rdx, rdi
  00037	48 8b cd	 mov	 rcx, rbp
  0003a	48 8b d8	 mov	 rbx, rax
  0003d	e8 00 00 00 00	 call	 mg_ws_wrap

; 13935:   return n;
; 13936: }

  00042	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00047	48 8b c3	 mov	 rax, rbx
  0004a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004f	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
mg_ws_vprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ws_printf
_TEXT	SEGMENT
c$ = 64
op$ = 72
fmt$ = 80
mg_ws_printf PROC					; COMDAT

; 13938: size_t mg_ws_printf(struct mg_connection *c, int op, const char *fmt, ...) {

$LN4:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	4d 89 43 18	 mov	 QWORD PTR [r11+24], r8
  00007	4d 89 4b 20	 mov	 QWORD PTR [r11+32], r9
  0000b	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 13939:   size_t len = 0;
; 13940:   va_list ap;
; 13941:   va_start(ap, fmt);

  0000f	49 8d 43 20	 lea	 rax, QWORD PTR [r11+32]

; 13942:   len = mg_ws_vprintf(c, op, fmt, &ap);

  00013	4d 8d 4b e8	 lea	 r9, QWORD PTR [r11-24]
  00017	49 89 43 e8	 mov	 QWORD PTR [r11-24], rax
  0001b	e8 00 00 00 00	 call	 mg_ws_vprintf

; 13943:   va_end(ap);
; 13944:   return len;
; 13945: }

  00020	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00024	c3		 ret	 0
mg_ws_printf ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT ws_handshake
_TEXT	SEGMENT
sha_ctx$ = 32
sha$ = 128
b64_sha$ = 152
c$ = 208
wskey$ = 216
wsproto$ = 224
fmt$ = 232
ap$ = 240
ws_handshake PROC					; COMDAT

; 13949:                          va_list *ap) {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000f	4c 89 70 20	 mov	 QWORD PTR [rax+32], r14
  00013	55		 push	 rbp
  00014	48 8d 68 a9	 lea	 rbp, QWORD PTR [rax-87]
  00018	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H

; 6719 :   context->count[0] = context->count[1] = 0;

  0001f	83 65 c7 00	 and	 DWORD PTR sha_ctx$[rbp-89], 0

; 13949:                          va_list *ap) {

  00023	49 8b d8	 mov	 rbx, r8

; 13950:   const char *magic = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
; 13951:   unsigned char sha[20], b64_sha[30];
; 13952: 
; 13953:   mg_sha1_ctx sha_ctx;
; 13954:   mg_sha1_init(&sha_ctx);
; 13955:   mg_sha1_update(&sha_ctx, (unsigned char *) wskey->ptr, wskey->len);

  00026	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  0002a	48 8b f9	 mov	 rdi, rcx
  0002d	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00030	48 8d 4d af	 lea	 rcx, QWORD PTR sha_ctx$[rbp-113]

; 6719 :   context->count[0] = context->count[1] = 0;

  00034	83 65 c3 00	 and	 DWORD PTR sha_ctx$[rbp-93], 0

; 13949:                          va_list *ap) {

  00038	49 8b f1	 mov	 rsi, r9

; 6714 :   context->state[0] = 0x67452301;

  0003b	c7 45 af 01 23
	45 67		 mov	 DWORD PTR sha_ctx$[rbp-113], 1732584193 ; 67452301H

; 6715 :   context->state[1] = 0xEFCDAB89;

  00042	c7 45 b3 89 ab
	cd ef		 mov	 DWORD PTR sha_ctx$[rbp-109], -271733879 ; efcdab89H

; 6716 :   context->state[2] = 0x98BADCFE;

  00049	c7 45 b7 fe dc
	ba 98		 mov	 DWORD PTR sha_ctx$[rbp-105], -1732584194 ; 98badcfeH

; 6717 :   context->state[3] = 0x10325476;

  00050	c7 45 bb 76 54
	32 10		 mov	 DWORD PTR sha_ctx$[rbp-101], 271733878 ; 10325476H

; 6718 :   context->state[4] = 0xC3D2E1F0;

  00057	c7 45 bf f0 e1
	d2 c3		 mov	 DWORD PTR sha_ctx$[rbp-97], -1009589776 ; c3d2e1f0H

; 13950:   const char *magic = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
; 13951:   unsigned char sha[20], b64_sha[30];
; 13952: 
; 13953:   mg_sha1_ctx sha_ctx;
; 13954:   mg_sha1_init(&sha_ctx);
; 13955:   mg_sha1_update(&sha_ctx, (unsigned char *) wskey->ptr, wskey->len);

  0005e	e8 00 00 00 00	 call	 mg_sha1_update

; 13956:   mg_sha1_update(&sha_ctx, (unsigned char *) magic, 36);

  00063	41 b8 24 00 00
	00		 mov	 r8d, 36			; 00000024H
  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@DPPCDNJI@258EAFA5?9E914?947DA?995CA?9C5AB0DC@
  00070	48 8d 4d af	 lea	 rcx, QWORD PTR sha_ctx$[rbp-113]
  00074	e8 00 00 00 00	 call	 mg_sha1_update

; 13957:   mg_sha1_final(sha, &sha_ctx);

  00079	48 8d 55 af	 lea	 rdx, QWORD PTR sha_ctx$[rbp-113]
  0007d	48 8d 4d 0f	 lea	 rcx, QWORD PTR sha$[rbp-113]
  00081	e8 00 00 00 00	 call	 mg_sha1_final

; 13958:   mg_base64_encode(sha, sizeof(sha), (char *) b64_sha, sizeof(b64_sha));

  00086	4c 8d 45 27	 lea	 r8, QWORD PTR b64_sha$[rbp-113]
  0008a	ba 14 00 00 00	 mov	 edx, 20
  0008f	48 8d 4d 0f	 lea	 rcx, QWORD PTR sha$[rbp-113]
  00093	e8 00 00 00 00	 call	 mg_base64_encode

; 13959:   mg_xprintf(mg_pfn_iobuf, &c->send,

  00098	4c 8d 4d 27	 lea	 r9, QWORD PTR b64_sha$[rbp-113]
  0009c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0GG@POFBIFLO@HTTP?11?41?5101?5Switching?5Protocol@
  000a3	48 8d 57 68	 lea	 rdx, QWORD PTR [rdi+104]
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mg_pfn_iobuf
  000ae	e8 00 00 00 00	 call	 mg_xprintf

; 13960:              "HTTP/1.1 101 Switching Protocols\r\n"
; 13961:              "Upgrade: websocket\r\n"
; 13962:              "Connection: Upgrade\r\n"
; 13963:              "Sec-WebSocket-Accept: %s\r\n",
; 13964:              b64_sha);
; 13965:   if (fmt != NULL) mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);

  000b3	48 85 f6	 test	 rsi, rsi
  000b6	74 17		 je	 SHORT $LN2@ws_handsha
  000b8	4c 8b 4d 7f	 mov	 r9, QWORD PTR ap$[rbp-113]
  000bc	48 8d 57 68	 lea	 rdx, QWORD PTR [rdi+104]
  000c0	4c 8b c6	 mov	 r8, rsi
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mg_pfn_iobuf
  000ca	e8 00 00 00 00	 call	 mg_vxprintf
$LN2@ws_handsha:

; 13966:   if (wsproto != NULL) {

  000cf	48 85 db	 test	 rbx, rbx
  000d2	74 16		 je	 SHORT $LN3@ws_handsha

; 13967:     mg_printf(c, "Sec-WebSocket-Protocol: %.*s\r\n", (int) wsproto->len,

  000d4	4c 8b 0b	 mov	 r9, QWORD PTR [rbx]
  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@DMDNHPGD@Sec?9WebSocket?9Protocol?3?5?$CF?4?$CKs?$AN?6@
  000de	44 8b 43 08	 mov	 r8d, DWORD PTR [rbx+8]
  000e2	48 8b cf	 mov	 rcx, rdi
  000e5	e8 00 00 00 00	 call	 mg_printf
$LN3@ws_handsha:

; 13968:               wsproto->ptr);
; 13969:   }
; 13970:   mg_send(c, "\r\n", 2);

  000ea	41 b8 02 00 00
	00		 mov	 r8d, 2
  000f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02PCIJFNDE@?$AN?6@
  000f7	48 8b cf	 mov	 rcx, rdi
  000fa	e8 00 00 00 00	 call	 mg_send

; 13971: }

  000ff	4c 8d 9c 24 c0
	00 00 00	 lea	 r11, QWORD PTR [rsp+192]
  00107	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  0010b	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  0010f	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  00113	4d 8b 73 28	 mov	 r14, QWORD PTR [r11+40]
  00117	49 8b e3	 mov	 rsp, r11
  0011a	5d		 pop	 rbp
  0011b	c3		 ret	 0
ws_handshake ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT be32
_TEXT	SEGMENT
p$ = 8
be32	PROC						; COMDAT

; 13974:   return (((uint32_t) p[3]) << 0) | (((uint32_t) p[2]) << 8) |

  00000	0f b6 51 01	 movzx	 edx, BYTE PTR [rcx+1]
  00004	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00007	c1 e0 08	 shl	 eax, 8
  0000a	0b c2		 or	 eax, edx
  0000c	0f b6 51 02	 movzx	 edx, BYTE PTR [rcx+2]
  00010	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  00014	c1 e0 08	 shl	 eax, 8
  00017	0b c2		 or	 eax, edx
  00019	c1 e0 08	 shl	 eax, 8
  0001c	0b c1		 or	 eax, ecx

; 13975:          (((uint32_t) p[1]) << 16) | (((uint32_t) p[0]) << 24);
; 13976: }

  0001e	c3		 ret	 0
be32	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT ws_process
_TEXT	SEGMENT
buf$ = 8
len$ = 16
msg$ = 24
ws_process PROC						; COMDAT

; 13978: static size_t ws_process(uint8_t *buf, size_t len, struct ws_msg *msg) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 13979:   size_t i, n = 0, mask_len = 0;

  00005	45 33 d2	 xor	 r10d, r10d

; 13980:   memset(msg, 0, sizeof(*msg));

  00008	33 c0		 xor	 eax, eax
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	48 8b da	 mov	 rbx, rdx
  00010	4c 8b d9	 mov	 r11, rcx
  00013	45 8b ca	 mov	 r9d, r10d
  00016	41 0f 11 00	 movups	 XMMWORD PTR [r8], xmm0
  0001a	49 89 40 10	 mov	 QWORD PTR [r8+16], rax

; 13981:   if (len >= 2) {

  0001e	48 83 fa 02	 cmp	 rdx, 2
  00022	0f 82 c5 00 00
	00		 jb	 $LN10@ws_process

; 13982:     n = buf[1] & 0x7f;                // Frame length

  00028	44 0f b6 49 01	 movzx	 r9d, BYTE PTR [rcx+1]

; 13983:     mask_len = buf[1] & 128 ? 4 : 0;  // last bit is a mask bit
; 13984:     msg->flags = buf[0];

  0002d	41 8a 03	 mov	 al, BYTE PTR [r11]
  00030	41 8b c9	 mov	 ecx, r9d
  00033	49 c1 e9 05	 shr	 r9, 5
  00037	83 e1 7f	 and	 ecx, 127		; 0000007fH
  0003a	41 83 e1 04	 and	 r9d, 4
  0003e	41 88 00	 mov	 BYTE PTR [r8], al

; 13985:     if (n < 126 && len >= mask_len) {

  00041	48 83 f9 7e	 cmp	 rcx, 126		; 0000007eH
  00045	73 16		 jae	 SHORT $LN6@ws_process
  00047	49 3b d1	 cmp	 rdx, r9
  0004a	72 37		 jb	 SHORT $LN8@ws_process

; 13986:       msg->data_len = n;
; 13987:       msg->header_len = 2 + mask_len;

  0004c	49 8d 41 02	 lea	 rax, QWORD PTR [r9+2]
  00050	49 89 48 10	 mov	 QWORD PTR [r8+16], rcx
  00054	49 89 40 08	 mov	 QWORD PTR [r8+8], rax
  00058	e9 90 00 00 00	 jmp	 $LN10@ws_process
$LN6@ws_process:

; 13988:     } else if (n == 126 && len >= 4 + mask_len) {

  0005d	75 24		 jne	 SHORT $LN8@ws_process
  0005f	49 8d 41 04	 lea	 rax, QWORD PTR [r9+4]
  00063	48 3b d8	 cmp	 rbx, rax
  00066	72 1b		 jb	 SHORT $LN8@ws_process

; 13989:       msg->header_len = 4 + mask_len;
; 13990:       msg->data_len = (((size_t) buf[2]) << 8) | buf[3];

  00068	41 0f b6 4b 02	 movzx	 ecx, BYTE PTR [r11+2]
  0006d	49 89 40 08	 mov	 QWORD PTR [r8+8], rax
  00071	41 0f b6 43 03	 movzx	 eax, BYTE PTR [r11+3]
  00076	48 c1 e1 08	 shl	 rcx, 8
  0007a	48 0b c8	 or	 rcx, rax
  0007d	49 89 48 10	 mov	 QWORD PTR [r8+16], rcx
  00081	eb 6a		 jmp	 SHORT $LN10@ws_process
$LN8@ws_process:

; 13991:     } else if (len >= 10 + mask_len) {

  00083	49 8d 41 0a	 lea	 rax, QWORD PTR [r9+10]
  00087	48 3b d8	 cmp	 rbx, rax
  0008a	72 61		 jb	 SHORT $LN10@ws_process

; 13974:   return (((uint32_t) p[3]) << 0) | (((uint32_t) p[2]) << 8) |

  0008c	41 0f b6 53 02	 movzx	 edx, BYTE PTR [r11+2]
  00091	41 0f b6 4b 06	 movzx	 ecx, BYTE PTR [r11+6]
  00096	48 c1 e2 08	 shl	 rdx, 8

; 13992:       msg->header_len = 10 + mask_len;

  0009a	49 89 40 08	 mov	 QWORD PTR [r8+8], rax

; 13974:   return (((uint32_t) p[3]) << 0) | (((uint32_t) p[2]) << 8) |

  0009e	41 0f b6 43 03	 movzx	 eax, BYTE PTR [r11+3]
  000a3	48 0b d0	 or	 rdx, rax
  000a6	48 c1 e1 08	 shl	 rcx, 8
  000aa	41 0f b6 43 04	 movzx	 eax, BYTE PTR [r11+4]
  000af	48 c1 e2 08	 shl	 rdx, 8
  000b3	48 0b d0	 or	 rdx, rax
  000b6	41 0f b6 43 05	 movzx	 eax, BYTE PTR [r11+5]
  000bb	48 c1 e2 08	 shl	 rdx, 8
  000bf	48 0b d0	 or	 rdx, rax
  000c2	41 0f b6 43 07	 movzx	 eax, BYTE PTR [r11+7]
  000c7	48 0b c8	 or	 rcx, rax

; 13993:       msg->data_len =

  000ca	48 c1 e2 20	 shl	 rdx, 32			; 00000020H

; 13974:   return (((uint32_t) p[3]) << 0) | (((uint32_t) p[2]) << 8) |

  000ce	41 0f b6 43 08	 movzx	 eax, BYTE PTR [r11+8]
  000d3	48 c1 e1 08	 shl	 rcx, 8
  000d7	48 0b c8	 or	 rcx, rax
  000da	41 0f b6 43 09	 movzx	 eax, BYTE PTR [r11+9]
  000df	48 c1 e1 08	 shl	 rcx, 8
  000e3	48 0b c8	 or	 rcx, rax

; 13993:       msg->data_len =

  000e6	48 03 d1	 add	 rdx, rcx
  000e9	49 89 50 10	 mov	 QWORD PTR [r8+16], rdx
$LN10@ws_process:

; 13994:           (size_t) (((uint64_t) be32(buf + 2) << 32) + be32(buf + 6));
; 13995:     }
; 13996:   }
; 13997:   // Sanity check, and integer overflow protection for the boundary check below
; 13998:   // data_len should not be larger than 1 Gb
; 13999:   if (msg->data_len > 1024 * 1024 * 1024) return 0;

  000ed	49 8b 50 10	 mov	 rdx, QWORD PTR [r8+16]
  000f1	48 81 fa 00 00
	00 40		 cmp	 rdx, 1073741824		; 40000000H
  000f8	77 39		 ja	 SHORT $LN23@ws_process

; 14000:   if (msg->header_len + msg->data_len > len) return 0;

  000fa	49 8b 48 08	 mov	 rcx, QWORD PTR [r8+8]
  000fe	48 8d 04 11	 lea	 rax, QWORD PTR [rcx+rdx]
  00102	48 3b c3	 cmp	 rax, rbx
  00105	77 2c		 ja	 SHORT $LN23@ws_process

; 14001:   if (mask_len > 0) {

  00107	4d 85 c9	 test	 r9, r9
  0010a	74 29		 je	 SHORT $LN1@ws_process

; 14002:     uint8_t *p = buf + msg->header_len, *m = p - mask_len;

  0010c	4e 8d 04 19	 lea	 r8, QWORD PTR [rcx+r11]
  00110	4d 8b d8	 mov	 r11, r8
  00113	4d 2b d9	 sub	 r11, r9

; 14003:     for (i = 0; i < msg->data_len; i++) p[i] ^= m[i & 3];

  00116	48 85 d2	 test	 rdx, rdx
  00119	74 1a		 je	 SHORT $LN1@ws_process
$LL4@ws_process:
  0011b	49 8b ca	 mov	 rcx, r10
  0011e	83 e1 03	 and	 ecx, 3
  00121	42 8a 0c 19	 mov	 cl, BYTE PTR [rcx+r11]
  00125	43 30 0c 02	 xor	 BYTE PTR [r10+r8], cl
  00129	49 ff c2	 inc	 r10
  0012c	4c 3b d2	 cmp	 r10, rdx
  0012f	72 ea		 jb	 SHORT $LL4@ws_process

; 14004:   }
; 14005:   return msg->header_len + msg->data_len;

  00131	eb 02		 jmp	 SHORT $LN1@ws_process
$LN23@ws_process:

; 14000:   if (msg->header_len + msg->data_len > len) return 0;

  00133	33 c0		 xor	 eax, eax
$LN1@ws_process:

; 14006: }

  00135	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0013a	c3		 ret	 0
ws_process ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mkhdr
_TEXT	SEGMENT
len$ = 48
op$ = 56
is_client$ = 64
buf$ = 72
mkhdr	PROC						; COMDAT

; 14008: static size_t mkhdr(size_t len, int op, bool is_client, uint8_t *buf) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 14009:   size_t n = 0;
; 14010:   buf[0] = (uint8_t) (op | 128);

  0000f	80 ca 80	 or	 dl, 128			; 00000080H
  00012	45 8a d8	 mov	 r11b, r8b
  00015	41 88 11	 mov	 BYTE PTR [r9], dl
  00018	4c 8b d1	 mov	 r10, rcx

; 14011:   if (len < 126) {

  0001b	48 83 f9 7e	 cmp	 rcx, 126		; 0000007eH
  0001f	73 0e		 jae	 SHORT $LN2@mkhdr

; 14012:     buf[1] = (unsigned char) len;

  00021	45 88 51 01	 mov	 BYTE PTR [r9+1], r10b

; 14013:     n = 2;

  00025	bb 02 00 00 00	 mov	 ebx, 2
  0002a	e9 9e 00 00 00	 jmp	 $LN5@mkhdr
$LN2@mkhdr:

; 14014:   } else if (len < 65536) {

  0002f	49 81 fa 00 00
	01 00		 cmp	 r10, 65536		; 00010000H
  00036	73 25		 jae	 SHORT $LN4@mkhdr

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00038	41 0f b6 c2	 movzx	 eax, r10b

; 14018:     n = 4;

  0003c	bb 04 00 00 00	 mov	 ebx, 4

; 13807:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));

  00041	66 41 c1 ea 08	 shr	 r10w, 8
  00046	66 c1 e0 08	 shl	 ax, 8
  0004a	66 41 0b c2	 or	 ax, r10w

; 14015:     uint16_t tmp = mg_htons((uint16_t) len);
; 14016:     buf[1] = 126;

  0004e	41 c6 41 01 7e	 mov	 BYTE PTR [r9+1], 126	; 0000007eH

; 14017:     memcpy(&buf[2], &tmp, sizeof(tmp));

  00053	66 41 89 41 02	 mov	 WORD PTR [r9+2], ax

; 14018:     n = 4;

  00058	41 b2 7e	 mov	 r10b, 126		; 0000007eH

; 14019:   } else {

  0005b	eb 70		 jmp	 SHORT $LN5@mkhdr
$LN4@mkhdr:

; 14020:     uint32_t tmp;
; 14021:     buf[1] = 127;
; 14022:     tmp = mg_htonl((uint32_t) (((uint64_t) len) >> 32));

  0005d	4d 8b c2	 mov	 r8, r10
  00060	41 c6 41 01 7f	 mov	 BYTE PTR [r9+1], 127	; 0000007fH
  00065	49 c1 e8 20	 shr	 r8, 32			; 00000020H

; 14024:     tmp = mg_htonl((uint32_t) (len & 0xffffffffU));
; 14025:     memcpy(&buf[6], &tmp, sizeof(tmp));
; 14026:     n = 10;

  00069	bb 0a 00 00 00	 mov	 ebx, 10

; 13800:   return (((uint32_t) data[3]) << 0) | (((uint32_t) data[2]) << 8) |

  0006e	41 8b c0	 mov	 eax, r8d
  00071	c1 e8 08	 shr	 eax, 8
  00074	0f b6 d0	 movzx	 edx, al
  00077	41 0f b6 c0	 movzx	 eax, r8b
  0007b	c1 e0 08	 shl	 eax, 8
  0007e	0b d0		 or	 edx, eax
  00080	41 8b c0	 mov	 eax, r8d
  00083	c1 e2 08	 shl	 edx, 8
  00086	c1 e8 10	 shr	 eax, 16
  00089	0f b6 c8	 movzx	 ecx, al
  0008c	41 8b c2	 mov	 eax, r10d
  0008f	0b d1		 or	 edx, ecx
  00091	c1 e8 08	 shr	 eax, 8
  00094	c1 e2 08	 shl	 edx, 8
  00097	41 c1 e8 18	 shr	 r8d, 24
  0009b	41 0b d0	 or	 edx, r8d

; 14023:     memcpy(&buf[2], &tmp, sizeof(tmp));

  0009e	41 89 51 02	 mov	 DWORD PTR [r9+2], edx

; 13800:   return (((uint32_t) data[3]) << 0) | (((uint32_t) data[2]) << 8) |

  000a2	0f b6 d0	 movzx	 edx, al
  000a5	41 0f b6 c2	 movzx	 eax, r10b
  000a9	c1 e0 08	 shl	 eax, 8
  000ac	0b d0		 or	 edx, eax
  000ae	41 8b c2	 mov	 eax, r10d
  000b1	c1 e2 08	 shl	 edx, 8
  000b4	c1 e8 10	 shr	 eax, 16
  000b7	41 c1 ea 18	 shr	 r10d, 24
  000bb	0f b6 c8	 movzx	 ecx, al
  000be	0b d1		 or	 edx, ecx
  000c0	c1 e2 08	 shl	 edx, 8
  000c3	41 0b d2	 or	 edx, r10d

; 14024:     tmp = mg_htonl((uint32_t) (len & 0xffffffffU));
; 14025:     memcpy(&buf[6], &tmp, sizeof(tmp));
; 14026:     n = 10;

  000c6	41 b2 7f	 mov	 r10b, 127		; 0000007fH
  000c9	41 89 51 06	 mov	 DWORD PTR [r9+6], edx
$LN5@mkhdr:

; 14027:   }
; 14028:   if (is_client) {

  000cd	45 84 db	 test	 r11b, r11b
  000d0	74 2d		 je	 SHORT $LN6@mkhdr

; 14029:     buf[1] |= 1 << 7;  // Set masking flag

  000d2	41 80 ca 80	 or	 r10b, 128		; 00000080H

; 14030:     mg_random(&buf[n], 4);

  000d6	4a 8d 34 0b	 lea	 rsi, QWORD PTR [rbx+r9]
  000da	45 88 51 01	 mov	 BYTE PTR [r9+1], r10b
  000de	bf 04 00 00 00	 mov	 edi, 4
$LL9@mkhdr:

; 13780:   while (!done && len--) *p++ = (unsigned char) (rand() & 255);

  000e3	48 8b c7	 mov	 rax, rdi
  000e6	48 ff cf	 dec	 rdi
  000e9	48 85 c0	 test	 rax, rax
  000ec	74 0d		 je	 SHORT $LN10@mkhdr
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  000f4	88 06		 mov	 BYTE PTR [rsi], al
  000f6	48 ff c6	 inc	 rsi
  000f9	eb e8		 jmp	 SHORT $LL9@mkhdr
$LN10@mkhdr:

; 14031:     n += 4;

  000fb	48 83 c3 04	 add	 rbx, 4
$LN6@mkhdr:

; 14032:   }
; 14033:   return n;
; 14034: }

  000ff	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00104	48 8b c3	 mov	 rax, rbx
  00107	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0010c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00110	5f		 pop	 rdi
  00111	c3		 ret	 0
mkhdr	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ws_mask
_TEXT	SEGMENT
c$ = 8
len$ = 16
mg_ws_mask PROC						; COMDAT

; 14037:   if (c->is_client && c->send.buf != NULL) {

  00000	f6 81 10 01 00
	00 02		 test	 BYTE PTR [rcx+272], 2
  00007	74 31		 je	 SHORT $LN3@mg_ws_mask
  00009	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
  0000d	45 33 c0	 xor	 r8d, r8d
  00010	48 85 c0	 test	 rax, rax
  00013	74 25		 je	 SHORT $LN3@mg_ws_mask

; 14038:     size_t i;
; 14039:     uint8_t *p = c->send.buf + c->send.len - len, *mask = p - 4;

  00015	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  00019	48 2b ca	 sub	 rcx, rdx
  0001c	48 03 c8	 add	 rcx, rax

; 14040:     for (i = 0; i < len; i++) p[i] ^= mask[i & 3];

  0001f	48 85 d2	 test	 rdx, rdx
  00022	74 16		 je	 SHORT $LN3@mg_ws_mask
$LL4@mg_ws_mask:
  00024	49 8b c0	 mov	 rax, r8
  00027	83 e0 03	 and	 eax, 3
  0002a	8a 44 08 fc	 mov	 al, BYTE PTR [rax+rcx-4]
  0002e	41 30 04 08	 xor	 BYTE PTR [r8+rcx], al
  00032	49 ff c0	 inc	 r8
  00035	4c 3b c2	 cmp	 r8, rdx
  00038	72 ea		 jb	 SHORT $LL4@mg_ws_mask
$LN3@mg_ws_mask:

; 14041:   }
; 14042: }

  0003a	c3		 ret	 0
mg_ws_mask ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ws_send
_TEXT	SEGMENT
header$ = 32
c$ = 64
buf$ = 72
len$ = 80
op$ = 88
mg_ws_send PROC						; COMDAT

; 14045:                   int op) {

$LN8:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00015	49 8b d8	 mov	 rbx, r8
  00018	45 8b d1	 mov	 r10d, r9d

; 14046:   uint8_t header[14];
; 14047:   size_t header_len = mkhdr(len, op, c->is_client, header);

  0001b	44 8b 81 10 01
	00 00		 mov	 r8d, DWORD PTR [rcx+272]
  00022	4c 8d 48 e8	 lea	 r9, QWORD PTR [rax-24]
  00026	41 d1 e8	 shr	 r8d, 1
  00029	48 8b f2	 mov	 rsi, rdx
  0002c	48 8b f9	 mov	 rdi, rcx
  0002f	41 80 e0 01	 and	 r8b, 1
  00033	41 8b d2	 mov	 edx, r10d
  00036	48 8b cb	 mov	 rcx, rbx
  00039	e8 00 00 00 00	 call	 mkhdr

; 14048:   mg_send(c, header, header_len);

  0003e	4c 8b c0	 mov	 r8, rax
  00041	48 8d 54 24 20	 lea	 rdx, QWORD PTR header$[rsp]
  00046	48 8b cf	 mov	 rcx, rdi
  00049	4c 8b f0	 mov	 r14, rax
  0004c	e8 00 00 00 00	 call	 mg_send

; 14049:   MG_VERBOSE(("WS out: %d [%.*s]", (int) len, (int) len, buf));

  00051	b9 04 00 00 00	 mov	 ecx, 4
  00056	39 0d 00 00 00
	00		 cmp	 DWORD PTR mg_log_level, ecx
  0005c	7c 26		 jl	 SHORT $LN2@mg_ws_send
  0005e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0L@OGHHDJDI@mg_ws_send@
  00065	41 b8 e1 36 00
	00		 mov	 r8d, 14049		; 000036e1H
  0006b	e8 00 00 00 00	 call	 mg_log_prefix
  00070	4c 8b ce	 mov	 r9, rsi
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@FGABKOKF@WS?5out?3?5?$CFd?5?$FL?$CF?4?$CKs?$FN@
  0007a	44 8b c3	 mov	 r8d, ebx
  0007d	8b d3		 mov	 edx, ebx
  0007f	e8 00 00 00 00	 call	 mg_log
$LN2@mg_ws_send:

; 14050:   mg_send(c, buf, len);

  00084	4c 8b c3	 mov	 r8, rbx
  00087	48 8b d6	 mov	 rdx, rsi
  0008a	48 8b cf	 mov	 rcx, rdi
  0008d	e8 00 00 00 00	 call	 mg_send

; 14051:   mg_ws_mask(c, len);

  00092	48 8b d3	 mov	 rdx, rbx
  00095	48 8b cf	 mov	 rcx, rdi
  00098	e8 00 00 00 00	 call	 mg_ws_mask

; 14052:   return header_len + len;
; 14053: }

  0009d	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000a2	49 8d 04 1e	 lea	 rax, QWORD PTR [r14+rbx]
  000a6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ab	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  000b0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b4	41 5e		 pop	 r14
  000b6	c3		 ret	 0
mg_ws_send ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ws_client_handshake
_TEXT	SEGMENT
hm$1 = 32
c$ = 1120
mg_ws_client_handshake PROC				; COMDAT

; 14055: static bool mg_ws_client_handshake(struct mg_connection *c) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 81 ec 50 04
	00 00		 sub	 rsp, 1104		; 00000450H

; 14056:   int n = mg_http_get_request_len(c->recv.buf, c->recv.len);

  00018	48 8b 71 48	 mov	 rsi, QWORD PTR [rcx+72]
  0001c	48 8b d9	 mov	 rbx, rcx
  0001f	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  00023	48 8b ce	 mov	 rcx, rsi
  00026	e8 00 00 00 00	 call	 mg_http_get_request_len
  0002b	48 63 f8	 movsxd	 rdi, eax

; 14057:   if (n < 0) {

  0002e	85 c0		 test	 eax, eax
  00030	79 11		 jns	 SHORT $LN12@mg_ws_clie

; 14058:     mg_error(c, "not http");  // Some just, not an HTTP request

  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08KKMPEAED@not?5http@
  00039	48 8b cb	 mov	 rcx, rbx
  0003c	e8 00 00 00 00	 call	 mg_error
  00041	eb 5f		 jmp	 SHORT $LN5@mg_ws_clie
$LN12@mg_ws_clie:

; 14059:   } else if (n > 0) {

  00043	7e 61		 jle	 SHORT $LN4@mg_ws_clie

; 14060:     if (n < 15 || memcmp(c->recv.buf + 9, "101", 3) != 0) {

  00045	83 ff 0f	 cmp	 edi, 15
  00048	7c 3b		 jl	 SHORT $LN8@mg_ws_clie
  0004a	66 81 7e 09 31
	30		 cmp	 WORD PTR [rsi+9], 12337	; 00003031H
  00050	75 33		 jne	 SHORT $LN8@mg_ws_clie
  00052	80 7e 0b 31	 cmp	 BYTE PTR [rsi+11], 49	; 00000031H
  00056	75 2d		 jne	 SHORT $LN8@mg_ws_clie

; 14062:     } else {
; 14063:       struct mg_http_message hm;
; 14064:       if (mg_http_parse((char *) c->recv.buf, c->recv.len, &hm)) {

  00058	4c 8d 44 24 20	 lea	 r8, QWORD PTR hm$1[rsp]
  0005d	48 8b ce	 mov	 rcx, rsi
  00060	e8 00 00 00 00	 call	 mg_http_parse
  00065	48 8b cb	 mov	 rcx, rbx
  00068	85 c0		 test	 eax, eax
  0006a	74 1c		 je	 SHORT $LN9@mg_ws_clie

; 14065:         c->is_websocket = 1;

  0006c	0f ba ab 10 01
	00 00 09	 bts	 DWORD PTR [rbx+272], 9

; 14066:         mg_call(c, MG_EV_WS_OPEN, &hm);

  00074	4c 8d 44 24 20	 lea	 r8, QWORD PTR hm$1[rsp]
  00079	ba 0b 00 00 00	 mov	 edx, 11
  0007e	e8 00 00 00 00	 call	 mg_call

; 14067:       } else {

  00083	eb 0f		 jmp	 SHORT $LN10@mg_ws_clie
$LN8@mg_ws_clie:

; 14061:       mg_error(c, "ws handshake error");

  00085	48 8b cb	 mov	 rcx, rbx
$LN9@mg_ws_clie:

; 14068:         mg_error(c, "ws handshake error");
; 14069:       }
; 14070:     }
; 14071:     mg_iobuf_del(&c->recv, 0, (size_t) n);

  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@GICIJAKK@ws?5handshake?5error@
  0008f	e8 00 00 00 00	 call	 mg_error
$LN10@mg_ws_clie:
  00094	4c 8b c7	 mov	 r8, rdi
  00097	48 8d 4b 48	 lea	 rcx, QWORD PTR [rbx+72]
  0009b	33 d2		 xor	 edx, edx
  0009d	e8 00 00 00 00	 call	 mg_iobuf_del
$LN5@mg_ws_clie:

; 14074:   }
; 14075:   return false;  // Continue event handler

  000a2	32 c0		 xor	 al, al
  000a4	eb 02		 jmp	 SHORT $LN1@mg_ws_clie
$LN4@mg_ws_clie:

; 14072:   } else {
; 14073:     return true;  // Request is not yet received, quit event handler

  000a6	b0 01		 mov	 al, 1
$LN1@mg_ws_clie:

; 14076: }

  000a8	4c 8d 9c 24 50
	04 00 00	 lea	 r11, QWORD PTR [rsp+1104]
  000b0	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000b4	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  000b8	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  000bc	49 8b e3	 mov	 rsp, r11
  000bf	41 5e		 pop	 r14
  000c1	c3		 ret	 0
mg_ws_client_handshake ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ws_cb
_TEXT	SEGMENT
m$1 = 32
msg$ = 56
c$ = 144
final$1$ = 152
ev$ = 152
ev_data$ = 160
mg_ws_cb PROC						; COMDAT

; 14079:   struct ws_msg msg;
; 14080:   size_t ofs = (size_t) c->pfn_data;
; 14081: 
; 14082:   // assert(ofs < c->recv.len);
; 14083:   if (ev == MG_EV_READ) {

  00000	83 fa 07	 cmp	 edx, 7
  00003	0f 85 69 02 00
	00		 jne	 $LN39@mg_ws_cb
  00009	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  0000e	55		 push	 rbp
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	41 54		 push	 r12
  00013	41 55		 push	 r13
  00015	41 56		 push	 r14
  00017	41 57		 push	 r15
  00019	48 8b ec	 mov	 rbp, rsp
  0001c	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 14084:     if (c->is_client && !c->is_websocket && mg_ws_client_handshake(c)) return;

  00020	8b 81 10 01 00
	00		 mov	 eax, DWORD PTR [rcx+272]
  00026	48 8b d9	 mov	 rbx, rcx
  00029	48 8b b9 e0 00
	00 00		 mov	 rdi, QWORD PTR [rcx+224]
  00030	a8 02		 test	 al, 2
  00032	74 13		 je	 SHORT $LN32@mg_ws_cb
  00034	0f ba e0 09	 bt	 eax, 9
  00038	72 0d		 jb	 SHORT $LN32@mg_ws_cb
  0003a	e8 00 00 00 00	 call	 mg_ws_client_handshake
  0003f	84 c0		 test	 al, al
  00041	0f 85 14 02 00
	00		 jne	 $LN3@mg_ws_cb
$LN32@mg_ws_cb:

; 14085: 
; 14086:     while (ws_process(c->recv.buf + ofs, c->recv.len - ofs, &msg) > 0) {

  00047	4c 8d 73 48	 lea	 r14, QWORD PTR [rbx+72]
  0004b	e9 ec 01 00 00	 jmp	 $LN28@mg_ws_cb
$LL2@mg_ws_cb:

; 14087:       char *s = (char *) c->recv.buf + ofs + msg.header_len;
; 14088:       struct mg_ws_message m = {{s, msg.data_len}, msg.flags};

  00050	44 8a 65 e8	 mov	 r12b, BYTE PTR msg$[rbp-80]
  00054	48 8b 75 f0	 mov	 rsi, QWORD PTR msg$[rbp-72]

; 14089:       size_t len = msg.header_len + msg.data_len;
; 14090:       uint8_t final = msg.flags & 128, op = msg.flags & 15;

  00058	41 8a d4	 mov	 dl, r12b
  0005b	48 8b 45 f8	 mov	 rax, QWORD PTR msg$[rbp-64]
  0005f	80 e2 80	 and	 dl, 128			; 00000080H
  00062	4d 8b 2e	 mov	 r13, QWORD PTR [r14]
  00065	4c 03 ee	 add	 r13, rsi
  00068	44 88 65 e0	 mov	 BYTE PTR m$1[rbp-64], r12b
  0006c	4c 03 ef	 add	 r13, rdi
  0006f	48 89 45 d8	 mov	 QWORD PTR m$1[rbp-72], rax
  00073	41 80 e4 0f	 and	 r12b, 15
  00077	4c 89 6d d0	 mov	 QWORD PTR m$1[rbp-80], r13

; 14091:       // MG_VERBOSE ("fin %d op %d len %d [%.*s]", final, op,
; 14092:       //                       (int) m.data.len, (int) m.data.len, m.data.ptr));
; 14093:       switch (op) {

  0007b	45 0f b6 c4	 movzx	 r8d, r12b
  0007f	4c 8d 3c 30	 lea	 r15, QWORD PTR [rax+rsi]
  00083	41 8b c8	 mov	 ecx, r8d
  00086	88 55 48	 mov	 BYTE PTR final$1$[rbp-80], dl
  00089	74 7e		 je	 SHORT $LN14@mg_ws_cb
  0008b	83 e9 01	 sub	 ecx, 1
  0008e	0f 84 01 01 00
	00		 je	 $LN18@mg_ws_cb
  00094	83 e9 01	 sub	 ecx, 1
  00097	0f 84 f8 00 00
	00		 je	 $LN18@mg_ws_cb
  0009d	83 e9 06	 sub	 ecx, 6
  000a0	0f 84 8f 00 00
	00		 je	 $LN11@mg_ws_cb
  000a6	83 e9 01	 sub	 ecx, 1
  000a9	74 16		 je	 SHORT $LN8@mg_ws_cb
  000ab	83 f9 01	 cmp	 ecx, 1
  000ae	74 59		 je	 SHORT $LN14@mg_ws_cb

; 14116:         default:
; 14117:           // Per RFC6455, close conn when an unknown op is recvd
; 14118:           mg_error(c, "unknown WS op %d", op);

  000b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@MNJJIOAL@unknown?5WS?5op?5?$CFd@
  000b7	48 8b cb	 mov	 rcx, rbx
  000ba	e8 00 00 00 00	 call	 mg_error
  000bf	eb 59		 jmp	 SHORT $LN4@mg_ws_cb
$LN8@mg_ws_cb:

; 14094:         case WEBSOCKET_OP_CONTINUE:
; 14095:           mg_call(c, MG_EV_WS_CTL, &m);
; 14096:           break;
; 14097:         case WEBSOCKET_OP_PING:
; 14098:           MG_DEBUG(("%s", "WS PONG"));

  000c1	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR mg_log_level, 3
  000c8	7c 2a		 jl	 SHORT $LN6@mg_ws_cb
  000ca	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_08JNAIHJJA@mg_ws_cb@
  000d1	b9 03 00 00 00	 mov	 ecx, 3
  000d6	41 b8 12 37 00
	00		 mov	 r8d, 14098		; 00003712H
  000dc	e8 00 00 00 00	 call	 mg_log_prefix
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07OOPHNCPN@WS?5PONG@
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  000ef	e8 00 00 00 00	 call	 mg_log
$LN6@mg_ws_cb:

; 14099:           mg_ws_send(c, s, msg.data_len, WEBSOCKET_OP_PONG);

  000f4	4c 8b 45 f8	 mov	 r8, QWORD PTR msg$[rbp-64]
  000f8	41 b9 0a 00 00
	00		 mov	 r9d, 10
  000fe	49 8b d5	 mov	 rdx, r13
  00101	48 8b cb	 mov	 rcx, rbx
  00104	e8 00 00 00 00	 call	 mg_ws_send
$LN14@mg_ws_cb:

; 14119:           break;
; 14120:       }
; 14121: 
; 14122:       // Handle fragmented frames: strip header, keep in c->recv
; 14123:       if (final == 0 || op == 0) {

  00109	4c 8d 45 d0	 lea	 r8, QWORD PTR m$1[rbp-80]
  0010d	ba 0d 00 00 00	 mov	 edx, 13
  00112	48 8b cb	 mov	 rcx, rbx
  00115	e8 00 00 00 00	 call	 mg_call
$LN4@mg_ws_cb:
  0011a	44 8a 6d 48	 mov	 r13b, BYTE PTR final$1$[rbp-80]
  0011e	45 84 ed	 test	 r13b, r13b
  00121	0f 84 8f 00 00
	00		 je	 $LN25@mg_ws_cb
$LN37@mg_ws_cb:
  00127	45 84 e4	 test	 r12b, r12b
  0012a	0f 85 bd 00 00
	00		 jne	 $LN42@mg_ws_cb

; 14100:           mg_call(c, MG_EV_WS_CTL, &m);
; 14101:           break;
; 14102:         case WEBSOCKET_OP_PONG:
; 14103:           mg_call(c, MG_EV_WS_CTL, &m);
; 14104:           break;
; 14105:         case WEBSOCKET_OP_TEXT:
; 14106:         case WEBSOCKET_OP_BINARY:
; 14107:           if (final) mg_call(c, MG_EV_WS_MSG, &m);

  00130	e9 81 00 00 00	 jmp	 $LN25@mg_ws_cb
$LN11@mg_ws_cb:

; 14109:         case WEBSOCKET_OP_CLOSE:
; 14110:           MG_DEBUG(("%lu WS CLOSE", c->id));

  00135	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR mg_log_level, 3
  0013c	7c 26		 jl	 SHORT $LN9@mg_ws_cb
  0013e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_08JNAIHJJA@mg_ws_cb@
  00145	b9 03 00 00 00	 mov	 ecx, 3
  0014a	41 b8 1e 37 00
	00		 mov	 r8d, 14110		; 0000371eH
  00150	e8 00 00 00 00	 call	 mg_log_prefix
  00155	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  00158	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@IFMBNCDN@?$CFlu?5WS?5CLOSE@
  0015f	e8 00 00 00 00	 call	 mg_log
$LN9@mg_ws_cb:

; 14111:           mg_call(c, MG_EV_WS_CTL, &m);

  00164	4c 8d 45 d0	 lea	 r8, QWORD PTR m$1[rbp-80]
  00168	ba 0d 00 00 00	 mov	 edx, 13
  0016d	48 8b cb	 mov	 rcx, rbx
  00170	e8 00 00 00 00	 call	 mg_call

; 14112:           // Echo the payload of the received CLOSE message back to the sender
; 14113:           mg_ws_send(c, m.data.ptr, m.data.len, WEBSOCKET_OP_CLOSE);

  00175	4c 8b 45 d8	 mov	 r8, QWORD PTR m$1[rbp-72]
  00179	41 b9 08 00 00
	00		 mov	 r9d, 8
  0017f	48 8b 55 d0	 mov	 rdx, QWORD PTR m$1[rbp-80]
  00183	48 8b cb	 mov	 rcx, rbx
  00186	e8 00 00 00 00	 call	 mg_ws_send

; 14114:           c->is_draining = 1;

  0018b	0f ba ab 10 01
	00 00 0c	 bts	 DWORD PTR [rbx+272], 12

; 14115:           break;

  00193	eb 85		 jmp	 SHORT $LN4@mg_ws_cb
$LN18@mg_ws_cb:

; 14100:           mg_call(c, MG_EV_WS_CTL, &m);
; 14101:           break;
; 14102:         case WEBSOCKET_OP_PONG:
; 14103:           mg_call(c, MG_EV_WS_CTL, &m);
; 14104:           break;
; 14105:         case WEBSOCKET_OP_TEXT:
; 14106:         case WEBSOCKET_OP_BINARY:
; 14107:           if (final) mg_call(c, MG_EV_WS_MSG, &m);

  00195	84 d2		 test	 dl, dl
  00197	74 1a		 je	 SHORT $LN38@mg_ws_cb
  00199	4c 8d 45 d0	 lea	 r8, QWORD PTR m$1[rbp-80]
  0019d	ba 0c 00 00 00	 mov	 edx, 12
  001a2	48 8b cb	 mov	 rcx, rbx
  001a5	e8 00 00 00 00	 call	 mg_call

; 14108:           break;

  001aa	44 8a 6d 48	 mov	 r13b, BYTE PTR final$1$[rbp-80]
  001ae	e9 74 ff ff ff	 jmp	 $LN37@mg_ws_cb
$LN38@mg_ws_cb:

; 14100:           mg_call(c, MG_EV_WS_CTL, &m);
; 14101:           break;
; 14102:         case WEBSOCKET_OP_PONG:
; 14103:           mg_call(c, MG_EV_WS_CTL, &m);
; 14104:           break;
; 14105:         case WEBSOCKET_OP_TEXT:
; 14106:         case WEBSOCKET_OP_BINARY:
; 14107:           if (final) mg_call(c, MG_EV_WS_MSG, &m);

  001b3	44 8a ea	 mov	 r13b, dl
$LN25@mg_ws_cb:

; 14124:         if (op) ofs++, len--, msg.header_len--;       // First frame

  001b6	45 84 e4	 test	 r12b, r12b
  001b9	74 0d		 je	 SHORT $LN26@mg_ws_cb
  001bb	48 ff c7	 inc	 rdi
  001be	49 ff cf	 dec	 r15
  001c1	48 ff ce	 dec	 rsi
  001c4	48 89 75 f0	 mov	 QWORD PTR msg$[rbp-72], rsi
$LN26@mg_ws_cb:

; 14125:         mg_iobuf_del(&c->recv, ofs, msg.header_len);  // Strip header

  001c8	4c 8b c6	 mov	 r8, rsi
  001cb	48 8b d7	 mov	 rdx, rdi
  001ce	49 8b ce	 mov	 rcx, r14
  001d1	e8 00 00 00 00	 call	 mg_iobuf_del

; 14126:         len -= msg.header_len;

  001d6	4c 2b fe	 sub	 r15, rsi

; 14127:         ofs += len;

  001d9	49 03 ff	 add	 rdi, r15

; 14128:         c->pfn_data = (void *) ofs;

  001dc	48 89 bb e0 00
	00 00		 mov	 QWORD PTR [rbx+224], rdi

; 14129:         // MG_INFO(("FRAG %d [%.*s]", (int) ofs, (int) ofs, c->recv.buf));
; 14130:       }
; 14131:       // Remove non-fragmented frame
; 14132:       if (final && op) mg_iobuf_del(&c->recv, ofs, len);

  001e3	45 84 ed	 test	 r13b, r13b
  001e6	74 54		 je	 SHORT $LN28@mg_ws_cb
  001e8	45 84 e4	 test	 r12b, r12b
  001eb	74 10		 je	 SHORT $LN35@mg_ws_cb
$LN42@mg_ws_cb:
  001ed	4d 8b c7	 mov	 r8, r15
  001f0	48 8b d7	 mov	 rdx, rdi
  001f3	49 8b ce	 mov	 rcx, r14
  001f6	e8 00 00 00 00	 call	 mg_iobuf_del
  001fb	eb 3f		 jmp	 SHORT $LN28@mg_ws_cb
$LN35@mg_ws_cb:

; 14133:       // Last chunk of the fragmented frame
; 14134:       if (final && !op) {
; 14135:         m.flags = c->recv.buf[0];

  001fd	49 8b 0e	 mov	 rcx, QWORD PTR [r14]

; 14136:         m.data = mg_str_n((char *) &c->recv.buf[1], (size_t) (ofs - 1));
; 14137:         mg_call(c, MG_EV_WS_MSG, &m);

  00200	4c 8d 45 d0	 lea	 r8, QWORD PTR m$1[rbp-80]
  00204	ba 0c 00 00 00	 mov	 edx, 12
  00209	8a 01		 mov	 al, BYTE PTR [rcx]
  0020b	88 45 e0	 mov	 BYTE PTR m$1[rbp-64], al
  0020e	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  00212	48 89 45 d0	 mov	 QWORD PTR m$1[rbp-80], rax
  00216	48 8b cb	 mov	 rcx, rbx
  00219	48 8d 47 ff	 lea	 rax, QWORD PTR [rdi-1]
  0021d	48 89 45 d8	 mov	 QWORD PTR m$1[rbp-72], rax
  00221	e8 00 00 00 00	 call	 mg_call

; 14138:         mg_iobuf_del(&c->recv, 0, ofs);

  00226	4c 8b c7	 mov	 r8, rdi
  00229	33 d2		 xor	 edx, edx
  0022b	49 8b ce	 mov	 rcx, r14
  0022e	e8 00 00 00 00	 call	 mg_iobuf_del

; 14139:         ofs = 0;

  00233	33 ff		 xor	 edi, edi

; 14140:         c->pfn_data = NULL;

  00235	48 21 bb e0 00
	00 00		 and	 QWORD PTR [rbx+224], rdi
$LN28@mg_ws_cb:

; 14085: 
; 14086:     while (ws_process(c->recv.buf + ofs, c->recv.len - ofs, &msg) > 0) {

  0023c	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  00240	4c 8d 45 e8	 lea	 r8, QWORD PTR msg$[rbp-80]
  00244	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  00247	48 2b d7	 sub	 rdx, rdi
  0024a	48 03 cf	 add	 rcx, rdi
  0024d	e8 00 00 00 00	 call	 ws_process
  00252	48 85 c0	 test	 rax, rax
  00255	0f 85 f5 fd ff
	ff		 jne	 $LL2@mg_ws_cb
$LN3@mg_ws_cb:

; 14141:       }
; 14142:     }
; 14143:   }
; 14144:   (void) ev_data;
; 14145: }

  0025b	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]
  00263	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00267	41 5f		 pop	 r15
  00269	41 5e		 pop	 r14
  0026b	41 5d		 pop	 r13
  0026d	41 5c		 pop	 r12
  0026f	5f		 pop	 rdi
  00270	5e		 pop	 rsi
  00271	5d		 pop	 rbp
$LN39@mg_ws_cb:
  00272	c3		 ret	 0
mg_ws_cb ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ws_connect
_TEXT	SEGMENT
ap$1 = 64
host$2 = 64
nonce$3 = 80
$T4 = 80
key$5 = 96
mgr$ = 176
url$ = 184
fn$ = 192
fn_data$ = 200
fmt$ = 208
mg_ws_connect PROC					; COMDAT

; 14149:                                     const char *fmt, ...) {

$LN14:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0000c	48 8b ea	 mov	 rbp, rdx

; 14150:   struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);

  0000f	e8 00 00 00 00	 call	 mg_connect
  00014	48 8b d8	 mov	 rbx, rax

; 14151:   if (c != NULL) {

  00017	48 85 c0	 test	 rax, rax
  0001a	0f 84 e2 00 00
	00		 je	 $LN2@mg_ws_conn

; 14152:     char nonce[16], key[30];
; 14153:     struct mg_str host = mg_url_host(url);

  00020	48 8b d5	 mov	 rdx, rbp
  00023	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T4[rsp]
  00028	e8 00 00 00 00	 call	 mg_url_host

; 14154:     mg_random(nonce, sizeof(nonce));

  0002d	bf 10 00 00 00	 mov	 edi, 16

; 13767:   unsigned char *p = (unsigned char *) buf;

  00032	48 8d 74 24 50	 lea	 rsi, QWORD PTR nonce$3[rsp]

; 14152:     char nonce[16], key[30];
; 14153:     struct mg_str host = mg_url_host(url);

  00037	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0003a	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR host$2[rsp], xmm0
$LL6@mg_ws_conn:

; 13780:   while (!done && len--) *p++ = (unsigned char) (rand() & 255);

  00040	48 8b c7	 mov	 rax, rdi
  00043	48 ff cf	 dec	 rdi
  00046	48 85 c0	 test	 rax, rax
  00049	74 0d		 je	 SHORT $LN7@mg_ws_conn
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00051	88 06		 mov	 BYTE PTR [rsi], al
  00053	48 ff c6	 inc	 rsi
  00056	eb e8		 jmp	 SHORT $LL6@mg_ws_conn
$LN7@mg_ws_conn:

; 14155:     mg_base64_encode((unsigned char *) nonce, sizeof(nonce), key, sizeof(key));

  00058	4c 8d 44 24 60	 lea	 r8, QWORD PTR key$5[rsp]
  0005d	ba 10 00 00 00	 mov	 edx, 16
  00062	48 8d 4c 24 50	 lea	 rcx, QWORD PTR nonce$3[rsp]
  00067	e8 00 00 00 00	 call	 mg_base64_encode

; 14156:     mg_xprintf(mg_pfn_iobuf, &c->send,

  0006c	48 8b cd	 mov	 rcx, rbp
  0006f	48 8d 7b 68	 lea	 rdi, QWORD PTR [rbx+104]
  00073	e8 00 00 00 00	 call	 mg_url_uri
  00078	4c 8b c8	 mov	 r9, rax
  0007b	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:mg_pfn_iobuf
  00082	48 8d 44 24 60	 lea	 rax, QWORD PTR key$5[rsp]
  00087	48 8b d7	 mov	 rdx, rdi
  0008a	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0008f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0HJ@GLCKOEAJ@GET?5?$CFs?5HTTP?11?41?$AN?6Upgrade?3?5webso@
  00096	48 8b 44 24 40	 mov	 rax, QWORD PTR host$2[rsp]
  0009b	48 8b ce	 mov	 rcx, rsi
  0009e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000a3	8b 44 24 48	 mov	 eax, DWORD PTR host$2[rsp+8]
  000a7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000ab	e8 00 00 00 00	 call	 mg_xprintf

; 14157:                "GET %s HTTP/1.1\r\n"
; 14158:                "Upgrade: websocket\r\n"
; 14159:                "Host: %.*s\r\n"
; 14160:                "Connection: Upgrade\r\n"
; 14161:                "Sec-WebSocket-Version: 13\r\n"
; 14162:                "Sec-WebSocket-Key: %s\r\n",
; 14163:                mg_url_uri(url), (int) host.len, host.ptr, key);
; 14164:     if (fmt != NULL) {

  000b0	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR fmt$[rsp]
  000b8	4d 85 c0	 test	 r8, r8
  000bb	74 1d		 je	 SHORT $LN3@mg_ws_conn

; 14165:       va_list ap;
; 14166:       va_start(ap, fmt);

  000bd	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR fmt$[rsp+8]

; 14167:       mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, &ap);

  000c5	48 8b d7	 mov	 rdx, rdi
  000c8	4c 8d 4c 24 40	 lea	 r9, QWORD PTR ap$1[rsp]
  000cd	48 89 44 24 40	 mov	 QWORD PTR ap$1[rsp], rax
  000d2	48 8b ce	 mov	 rcx, rsi
  000d5	e8 00 00 00 00	 call	 mg_vxprintf
$LN3@mg_ws_conn:

; 14168:       va_end(ap);
; 14169:     }
; 14170:     mg_xprintf(mg_pfn_iobuf, &c->send, "\r\n");

  000da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02PCIJFNDE@?$AN?6@
  000e1	48 8b d7	 mov	 rdx, rdi
  000e4	48 8b ce	 mov	 rcx, rsi
  000e7	e8 00 00 00 00	 call	 mg_xprintf

; 14171:     c->pfn = mg_ws_cb;
; 14172:     c->pfn_data = NULL;

  000ec	48 83 a3 e0 00
	00 00 00	 and	 QWORD PTR [rbx+224], 0
  000f4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:mg_ws_cb
  000fb	48 89 83 d8 00
	00 00		 mov	 QWORD PTR [rbx+216], rax
$LN2@mg_ws_conn:

; 14173:   }
; 14174:   return c;

  00102	48 8b c3	 mov	 rax, rbx

; 14175: }

  00105	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0010c	5f		 pop	 rdi
  0010d	5e		 pop	 rsi
  0010e	5d		 pop	 rbp
  0010f	5b		 pop	 rbx
  00110	c3		 ret	 0
mg_ws_connect ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ws_upgrade
_TEXT	SEGMENT
ap$1 = 48
c$ = 112
hm$ = 120
fmt$ = 128
mg_ws_upgrade PROC					; COMDAT

; 14178:                    const char *fmt, ...) {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 14179:   struct mg_str *wskey = mg_http_get_header(hm, "Sec-WebSocket-Key");

  00018	48 8b cf	 mov	 rcx, rdi
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@DFHBMDHG@Sec?9WebSocket?9Key@
  00022	49 8b f0	 mov	 rsi, r8
  00025	e8 00 00 00 00	 call	 mg_http_get_header

; 14180:   c->pfn = mg_ws_cb;
; 14181:   c->pfn_data = NULL;

  0002a	48 83 a3 e0 00
	00 00 00	 and	 QWORD PTR [rbx+224], 0
  00032	48 8b e8	 mov	 rbp, rax
  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:mg_ws_cb
  0003c	48 89 83 d8 00
	00 00		 mov	 QWORD PTR [rbx+216], rax

; 14182:   if (wskey == NULL) {

  00043	48 85 ed	 test	 rbp, rbp
  00046	75 25		 jne	 SHORT $LN2@mg_ws_upgr

; 14183:     mg_http_reply(c, 426, "", "WS upgrade expected\n");

  00048	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BF@MMCLFHAA@WS?5upgrade?5expected?6@
  0004f	ba aa 01 00 00	 mov	 edx, 426		; 000001aaH
  00054	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@@
  0005b	48 8b cb	 mov	 rcx, rbx
  0005e	e8 00 00 00 00	 call	 mg_http_reply

; 14184:     c->is_draining = 1;

  00063	0f ba ab 10 01
	00 00 0c	 bts	 DWORD PTR [rbx+272], 12

; 14185:   } else {

  0006b	eb 61		 jmp	 SHORT $LN3@mg_ws_upgr
$LN2@mg_ws_upgr:

; 14186:     struct mg_str *wsproto = mg_http_get_header(hm, "Sec-WebSocket-Protocol");

  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@JBAMIGCM@Sec?9WebSocket?9Protocol@
  00074	48 8b cf	 mov	 rcx, rdi
  00077	e8 00 00 00 00	 call	 mg_http_get_header

; 14187:     va_list ap;
; 14188:     va_start(ap, fmt);

  0007c	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR fmt$[rsp+8]

; 14189:     ws_handshake(c, wskey, wsproto, fmt, &ap);

  00084	4c 8b ce	 mov	 r9, rsi
  00087	48 89 4c 24 30	 mov	 QWORD PTR ap$1[rsp], rcx
  0008c	4c 8b c0	 mov	 r8, rax
  0008f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ap$1[rsp]
  00094	48 8b d5	 mov	 rdx, rbp
  00097	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0009c	48 8b cb	 mov	 rcx, rbx
  0009f	e8 00 00 00 00	 call	 ws_handshake

; 14190:     va_end(ap);
; 14191:     c->is_websocket = 1;

  000a4	8b 83 10 01 00
	00		 mov	 eax, DWORD PTR [rbx+272]

; 14192:     c->is_resp = 0;
; 14193:     mg_call(c, MG_EV_WS_OPEN, hm);

  000aa	4c 8b c7	 mov	 r8, rdi
  000ad	48 83 64 24 30
	00		 and	 QWORD PTR ap$1[rsp], 0
  000b3	0f ba f0 0f	 btr	 eax, 15
  000b7	0f ba e8 09	 bts	 eax, 9
  000bb	ba 0b 00 00 00	 mov	 edx, 11
  000c0	48 8b cb	 mov	 rcx, rbx
  000c3	89 83 10 01 00
	00		 mov	 DWORD PTR [rbx+272], eax
  000c9	e8 00 00 00 00	 call	 mg_call
$LN3@mg_ws_upgr:

; 14194:   }
; 14195: }

  000ce	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d2	5f		 pop	 rdi
  000d3	5e		 pop	 rsi
  000d4	5d		 pop	 rbp
  000d5	5b		 pop	 rbx
  000d6	c3		 ret	 0
mg_ws_upgrade ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\mongoose.c
;	COMDAT mg_ws_wrap
_TEXT	SEGMENT
header$ = 32
c$ = 64
len$ = 72
op$ = 80
mg_ws_wrap PROC						; COMDAT

; 14197: size_t mg_ws_wrap(struct mg_connection *c, size_t len, int op) {

$LN4:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	45 8b d0	 mov	 r10d, r8d

; 14198:   uint8_t header[14], *p;
; 14199:   size_t header_len = mkhdr(len, op, c->is_client, header);

  00017	4c 8d 48 e8	 lea	 r9, QWORD PTR [rax-24]
  0001b	44 8b 81 10 01
	00 00		 mov	 r8d, DWORD PTR [rcx+272]
  00022	48 8b f2	 mov	 rsi, rdx
  00025	41 d1 e8	 shr	 r8d, 1
  00028	48 8b e9	 mov	 rbp, rcx
  0002b	41 80 e0 01	 and	 r8b, 1
  0002f	41 8b d2	 mov	 edx, r10d
  00032	48 8b ce	 mov	 rcx, rsi
  00035	e8 00 00 00 00	 call	 mkhdr

; 14200: 
; 14201:   // NOTE: order of operations is important!
; 14202:   mg_iobuf_add(&c->send, c->send.len, NULL, header_len);

  0003a	48 8b 55 78	 mov	 rdx, QWORD PTR [rbp+120]
  0003e	48 8d 4d 68	 lea	 rcx, QWORD PTR [rbp+104]
  00042	4c 8b c8	 mov	 r9, rax
  00045	45 33 c0	 xor	 r8d, r8d
  00048	48 8b f8	 mov	 rdi, rax
  0004b	e8 00 00 00 00	 call	 mg_iobuf_add
  00050	48 8b 4d 78	 mov	 rcx, QWORD PTR [rbp+120]

; 14203:   p = &c->send.buf[c->send.len - len];         // p points to data
; 14204:   memmove(p, p - header_len, len);             // Shift data

  00054	4c 8b c6	 mov	 r8, rsi
  00057	48 2b ce	 sub	 rcx, rsi
  0005a	48 03 4d 68	 add	 rcx, QWORD PTR [rbp+104]
  0005e	48 8b d9	 mov	 rbx, rcx
  00061	48 2b df	 sub	 rbx, rdi
  00064	48 8b d3	 mov	 rdx, rbx
  00067	e8 00 00 00 00	 call	 memmove

; 14205:   memcpy(p - header_len, header, header_len);  // Prepend header

  0006c	4c 8b c7	 mov	 r8, rdi
  0006f	48 8d 54 24 20	 lea	 rdx, QWORD PTR header$[rsp]
  00074	48 8b cb	 mov	 rcx, rbx
  00077	e8 00 00 00 00	 call	 memcpy

; 14206:   mg_ws_mask(c, len);                          // Mask data

  0007c	48 8b d6	 mov	 rdx, rsi
  0007f	48 8b cd	 mov	 rcx, rbp
  00082	e8 00 00 00 00	 call	 mg_ws_mask

; 14207: 
; 14208:   return c->send.len;

  00087	48 8b 45 78	 mov	 rax, QWORD PTR [rbp+120]

; 14209: }

  0008b	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00090	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00095	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0009a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009e	5f		 pop	 rdi
  0009f	c3		 ret	 0
mg_ws_wrap ENDP
_TEXT	ENDS
END
