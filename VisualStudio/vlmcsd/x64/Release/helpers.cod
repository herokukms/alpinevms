; Listing generated by Microsoft (R) Optimizing Compiler Version 19.32.31332.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DI@HIOFNDD@Fatal?3?5Option?5?$CC?9?$CFc?$CC?5must?5be?5num@ ; `string'
PUBLIC	??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory@	; `string'
PUBLIC	??_C@_0BB@JGGOGLEG@0123456789ABCDEF@		; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_02LIELOMNJ@on@				; `string'
PUBLIC	??_C@_03ICICOMAL@yes@				; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_03MCADLMAF@off@				; `string'
PUBLIC	??_C@_02KAJCLHKP@no@				; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_0BO@DINIIKCC@Fatal?3?5Could?5not?5read?5?$CFs?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CO@ODFKJCLO@Fatal?3?5?$CFs?5is?5not?5a?5KMS?5data?5fil@ ; `string'
PUBLIC	??_C@_0M@OPCADLF@?2vlmcsd?4kmd@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0CF@IKBPGCAJ@Read?5KMS?5data?5file?5version?5?$CFu?4?$CF@ ; `string'
PUBLIC	??_C@_03HOPJGLEN@KMD@				; `string'
PUBLIC	??_C@_0CP@NEIJGKGH@Fatal?3?5Exiting?5on?5warning?5level@ ; `string'
EXTRN	__imp_PathRemoveFileSpecA:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_strerror:PROC
EXTRN	__imp_strrchr:PROC
EXTRN	__imp_GetTickCount:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp_FormatMessageA:PROC
EXTRN	__imp_strncat:PROC
EXTRN	__imp_strchr:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp__strnicmp:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	__imp_GetModuleHandleA:PROC
EXTRN	__imp__strdup:PROC
EXTRN	__imp_fseek:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp_toupper:PROC
EXTRN	__imp__strtoi64:PROC
EXTRN	__imp_srand:PROC
EXTRN	__imp_GetModuleFileNameA:PROC
EXTRN	__imp_ftell:PROC
EXTRN	__imp_exit:PROC
COMM	?buff@?1??gai_strerrorA@@9@9:BYTE:0401H							; `gai_strerrorA'::`2'::buff
COMM	?buff@?1??gai_strerrorW@@9@9:WORD:0401H							; `gai_strerrorW'::`2'::buff
_DATA	ENDS
;	COMDAT ??_C@_0CP@NEIJGKGH@Fatal?3?5Exiting?5on?5warning?5level@
CONST	SEGMENT
??_C@_0CP@NEIJGKGH@Fatal?3?5Exiting?5on?5warning?5level@ DB 'Fatal: Exiti'
	DB	'ng on warning level %i or greater', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HOPJGLEN@KMD@
CONST	SEGMENT
??_C@_03HOPJGLEN@KMD@ DB 'KMD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IKBPGCAJ@Read?5KMS?5data?5file?5version?5?$CFu?4?$CF@
CONST	SEGMENT
??_C@_0CF@IKBPGCAJ@Read?5KMS?5data?5file?5version?5?$CFu?4?$CF@ DB 'Read '
	DB	'KMS data file version %u.%u %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OPCADLF@?2vlmcsd?4kmd@
CONST	SEGMENT
??_C@_0M@OPCADLF@?2vlmcsd?4kmd@ DB '\vlmcsd.kmd', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@ODFKJCLO@Fatal?3?5?$CFs?5is?5not?5a?5KMS?5data?5fil@
CONST	SEGMENT
??_C@_0CO@ODFKJCLO@Fatal?3?5?$CFs?5is?5not?5a?5KMS?5data?5fil@ DB 'Fatal:'
	DB	' %s is not a KMS data file version 2.x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DINIIKCC@Fatal?3?5Could?5not?5read?5?$CFs?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BO@DINIIKCC@Fatal?3?5Could?5not?5read?5?$CFs?3?5?$CFs?6@ DB 'Fatal'
	DB	': Could not read %s: %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02KAJCLHKP@no@
CONST	SEGMENT
??_C@_02KAJCLHKP@no@ DB 'no', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCADLMAF@off@
CONST	SEGMENT
??_C@_03MCADLMAF@off@ DB 'off', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICICOMAL@yes@
CONST	SEGMENT
??_C@_03ICICOMAL@yes@ DB 'yes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LIELOMNJ@on@
CONST	SEGMENT
??_C@_02LIELOMNJ@on@ DB 'on', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JGGOGLEG@0123456789ABCDEF@
CONST	SEGMENT
??_C@_0BB@JGGOGLEG@0123456789ABCDEF@ DB '0123456789ABCDEF', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory@
CONST	SEGMENT
??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory@ DB 'Fatal: Out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@HIOFNDD@Fatal?3?5Option?5?$CC?9?$CFc?$CC?5must?5be?5num@
CONST	SEGMENT
??_C@_0DI@HIOFNDD@Fatal?3?5Option?5?$CC?9?$CFc?$CC?5must?5be?5num@ DB 'Fa'
	DB	'tal: Option "-%c" must be numeric between %u and %u.', 0aH, 00H ; `string'
?hexdigits@?1??hex2bin@@9@9 DQ FLAT:??_C@_0BB@JGGOGLEG@0123456789ABCDEF@ ; `hex2bin'::`2'::hexdigits
PUBLIC	exitOnWarningLevel
PUBLIC	loadKmsData
PUBLIC	getExeName
PUBLIC	getArgumentBool
PUBLIC	hex2bin
PUBLIC	vlmcsd_strdup
PUBLIC	vlmcsd_malloc
PUBLIC	OutOfMemory
PUBLIC	randomNumberInit
PUBLIC	parseAddress
PUBLIC	win_strerror
PUBLIC	optReset
PUBLIC	getOptionArgumentInt
PUBLIC	timeSpanString2Seconds
PUBLIC	string2UuidLE
PUBLIC	stringToInt
PUBLIC	ucs2_to_utf8
PUBLIC	utf8_to_ucs2
PUBLIC	ucs2_to_utf8_char
PUBLIC	utf8_to_ucs2_char
?buffer@?1??win_strerror@@9@9 DB 0100H DUP (?)		; `win_strerror'::`2'::buffer
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$exitOnWarningLevel DD imagerel $LN6
	DD	imagerel $LN6+44
	DD	imagerel $unwind$exitOnWarningLevel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$loadKmsData DD imagerel $LN70
	DD	imagerel $LN70+587
	DD	imagerel $unwind$loadKmsData
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getDefaultDataFile DD imagerel getDefaultDataFile
	DD	imagerel getDefaultDataFile+108
	DD	imagerel $unwind$getDefaultDataFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getExeName DD imagerel $LN11
	DD	imagerel $LN11+90
	DD	imagerel $unwind$getExeName
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dataFileFormatError DD imagerel dataFileFormatError
	DD	imagerel dataFileFormatError+35
	DD	imagerel $unwind$dataFileFormatError
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dataFileReadError DD imagerel dataFileReadError
	DD	imagerel dataFileReadError+53
	DD	imagerel $unwind$dataFileReadError
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getArgumentBool DD imagerel $LN10
	DD	imagerel $LN10+256
	DD	imagerel $unwind$getArgumentBool
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$hex2bin DD imagerel $LN17
	DD	imagerel $LN17+173
	DD	imagerel $unwind$hex2bin
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vlmcsd_strdup DD imagerel $LN7
	DD	imagerel $LN7+26
	DD	imagerel $unwind$vlmcsd_strdup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vlmcsd_malloc DD imagerel $LN7
	DD	imagerel $LN7+26
	DD	imagerel $unwind$vlmcsd_malloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$OutOfMemory DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$OutOfMemory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$randomNumberInit DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$randomNumberInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$parseAddress DD imagerel $LN9
	DD	imagerel $LN9+167
	DD	imagerel $unwind$parseAddress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$win_strerror DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$win_strerror
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getOptionArgumentInt DD imagerel $LN6
	DD	imagerel $LN6+96
	DD	imagerel $unwind$getOptionArgumentInt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$timeSpanString2Seconds DD imagerel $LN17
	DD	imagerel $LN17+129
	DD	imagerel $unwind$timeSpanString2Seconds
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$string2UuidLE DD imagerel $LN24
	DD	imagerel $LN24+329
	DD	imagerel $unwind$string2UuidLE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringToInt DD imagerel $LN6
	DD	imagerel $LN6+126
	DD	imagerel $unwind$stringToInt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs2_to_utf8 DD imagerel $LN15
	DD	imagerel $LN15+156
	DD	imagerel $unwind$ucs2_to_utf8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$utf8_to_ucs2 DD imagerel $LN21
	DD	imagerel $LN21+226
	DD	imagerel $unwind$utf8_to_ucs2
;	COMDAT xdata
xdata	SEGMENT
$unwind$utf8_to_ucs2 DD 081901H
	DD	087419H
	DD	076419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2_to_utf8 DD 0a1c01H
	DD	0b641cH
	DD	09541cH
	DD	08341cH
	DD	0f018321cH
	DD	07014e016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringToInt DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$string2UuidLE DD 081501H
	DD	0e7415H
	DD	0d6415H
	DD	0c3415H
	DD	0e0119215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timeSpanString2Seconds DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getOptionArgumentInt DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win_strerror DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parseAddress DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$randomNumberInit DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OutOfMemory DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vlmcsd_malloc DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vlmcsd_strdup DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hex2bin DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getArgumentBool DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dataFileReadError DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dataFileFormatError DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getExeName DD 020701H
	DD	0450107H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getDefaultDataFile DD 020701H
	DD	0270107H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$loadKmsData DD 081501H
	DD	097415H
	DD	086415H
	DD	073415H
	DD	0f0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$exitOnWarningLevel DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT utf8_to_ucs2_char
_TEXT	SEGMENT
input$ = 8
end_ptr$ = 16
utf8_to_ucs2_char PROC					; COMDAT

; 63   : {

  00000	4c 8b c1	 mov	 r8, rcx

; 64   : 	*end_ptr = input;

  00003	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 65   : 	if (input[0] == 0)

  00006	8a 09		 mov	 cl, BYTE PTR [rcx]
  00008	45 33 c9	 xor	 r9d, r9d
  0000b	84 c9		 test	 cl, cl
  0000d	0f 84 82 00 00
	00		 je	 $LN7@utf8_to_uc

; 66   : 		return (WCHAR)~0;
; 67   : 
; 68   : 	if (input[0] < 0x80) {

  00013	80 f9 80	 cmp	 cl, 128			; 00000080H
  00016	73 0c		 jae	 SHORT $LN3@utf8_to_uc

; 69   : 		*end_ptr = input + 1;

  00018	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]
  0001c	48 89 02	 mov	 QWORD PTR [rdx], rax

; 70   : 		return LE16(input[0]);

  0001f	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]

; 97   : }

  00023	c3		 ret	 0
$LN3@utf8_to_uc:

; 71   : 	}
; 72   : 
; 73   : 	if ((input[0] & 0xE0) == 0xE0) {

  00024	8a c1		 mov	 al, cl
  00026	24 e0		 and	 al, 224			; 000000e0H
  00028	3c e0		 cmp	 al, 224			; 000000e0H
  0002a	75 3a		 jne	 SHORT $LN4@utf8_to_uc

; 74   : 
; 75   : 		if (input[1] == 0 || input[2] == 0)

  0002c	45 38 48 01	 cmp	 BYTE PTR [r8+1], r9b
  00030	74 63		 je	 SHORT $LN7@utf8_to_uc
  00032	45 38 48 02	 cmp	 BYTE PTR [r8+2], r9b
  00036	74 5d		 je	 SHORT $LN7@utf8_to_uc

; 76   : 			return (WCHAR)~0;
; 77   : 
; 78   : 		*end_ptr = input + 3;

  00038	49 8d 40 03	 lea	 rax, QWORD PTR [r8+3]
  0003c	48 89 02	 mov	 QWORD PTR [rdx], rax

; 79   : 
; 80   : 		return

  0003f	41 8a 48 01	 mov	 cl, BYTE PTR [r8+1]
  00043	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00047	80 e1 3f	 and	 cl, 63			; 0000003fH
  0004a	0f b6 c9	 movzx	 ecx, cl
  0004d	66 c1 e0 06	 shl	 ax, 6
  00051	66 0b c1	 or	 ax, cx
  00054	41 8a 48 02	 mov	 cl, BYTE PTR [r8+2]
  00058	80 e1 3f	 and	 cl, 63			; 0000003fH
  0005b	66 c1 e0 06	 shl	 ax, 6
  0005f	0f b6 d1	 movzx	 edx, cl
  00062	66 0b c2	 or	 ax, dx

; 97   : }

  00065	c3		 ret	 0
$LN4@utf8_to_uc:

; 81   : 			LE16((input[0] & 0x0F) << 12 |
; 82   : 			(input[1] & 0x3F) << 6 |
; 83   : 				(input[2] & 0x3F));
; 84   : 	}
; 85   : 
; 86   : 	if ((input[0] & 0xC0) == 0xC0) {

  00066	80 e1 c0	 and	 cl, 192			; 000000c0H
  00069	80 f9 c0	 cmp	 cl, 192			; 000000c0H
  0006c	75 27		 jne	 SHORT $LN7@utf8_to_uc

; 87   : 		if (input[1] == 0)

  0006e	45 38 48 01	 cmp	 BYTE PTR [r8+1], r9b
  00072	74 21		 je	 SHORT $LN7@utf8_to_uc

; 88   : 			return (WCHAR)~0;
; 89   : 
; 90   : 		*end_ptr = input + 2;

  00074	49 8d 40 02	 lea	 rax, QWORD PTR [r8+2]
  00078	48 89 02	 mov	 QWORD PTR [rdx], rax

; 91   : 
; 92   : 		return

  0007b	41 8a 00	 mov	 al, BYTE PTR [r8]
  0007e	41 8a 48 01	 mov	 cl, BYTE PTR [r8+1]
  00082	24 1f		 and	 al, 31
  00084	0f b6 c0	 movzx	 eax, al
  00087	80 e1 3f	 and	 cl, 63			; 0000003fH
  0008a	66 c1 e0 06	 shl	 ax, 6
  0008e	0f b6 c9	 movzx	 ecx, cl
  00091	66 0b c1	 or	 ax, cx

; 97   : }

  00094	c3		 ret	 0
$LN7@utf8_to_uc:

; 93   : 			LE16((input[0] & 0x1F) << 6 |
; 94   : 			(input[1] & 0x3F));
; 95   : 	}
; 96   : 	return (WCHAR)~0;

  00095	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 97   : }

  0009a	c3		 ret	 0
utf8_to_ucs2_char ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT ucs2_to_utf8_char
_TEXT	SEGMENT
ucs2_le$ = 8
utf8$ = 16
ucs2_to_utf8_char PROC					; COMDAT

; 104  : 	const WCHAR ucs2 = LE16(ucs2_le);
; 105  : 
; 106  : 	if (ucs2 < 0x80) {

  00000	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00005	66 3b c8	 cmp	 cx, ax
  00008	73 0c		 jae	 SHORT $LN2@ucs2_to_ut

; 107  : 		utf8[0] = (char)ucs2;

  0000a	88 0a		 mov	 BYTE PTR [rdx], cl

; 108  : 		utf8[1] = '\0';
; 109  : 		return 1;

  0000c	b8 01 00 00 00	 mov	 eax, 1
  00011	c6 42 01 00	 mov	 BYTE PTR [rdx+1], 0

; 134  : }

  00015	c3		 ret	 0
$LN2@ucs2_to_ut:

; 110  : 	}
; 111  : 
; 112  : 	if (ucs2 >= 0x80 && ucs2 < 0x800) {

  00016	b8 00 08 00 00	 mov	 eax, 2048		; 00000800H
  0001b	66 3b c8	 cmp	 cx, ax
  0001e	73 1e		 jae	 SHORT $LN7@ucs2_to_ut

; 113  : 		utf8[0] = (char)((ucs2 >> 6) | 0xC0);

  00020	0f b7 c1	 movzx	 eax, cx

; 114  : 		utf8[1] = (char)((ucs2 & 0x3F) | 0x80);
; 115  : 		utf8[2] = '\0';

  00023	c6 42 02 00	 mov	 BYTE PTR [rdx+2], 0
  00027	66 c1 e8 06	 shr	 ax, 6
  0002b	80 e1 3f	 and	 cl, 63			; 0000003fH
  0002e	0c c0		 or	 al, -64			; ffffffffffffffc0H
  00030	80 c9 80	 or	 cl, -128		; ffffffffffffff80H
  00033	88 02		 mov	 BYTE PTR [rdx], al
  00035	88 4a 01	 mov	 BYTE PTR [rdx+1], cl

; 116  : 		return 2;

  00038	b8 02 00 00 00	 mov	 eax, 2

; 134  : }

  0003d	c3		 ret	 0
$LN7@ucs2_to_ut:

; 117  : 	}
; 118  : 
; 119  : 	if (ucs2 >= 0x800 && ucs2 < 0xFFFF) {

  0003e	b8 ff d7 00 00	 mov	 eax, 55295		; 0000d7ffH
  00043	66 3b c8	 cmp	 cx, ax
  00046	76 17		 jbe	 SHORT $LN5@ucs2_to_ut
  00048	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H
  0004d	41 b8 fe 1f 00
	00		 mov	 r8d, 8190		; 00001ffeH
  00053	03 c1		 add	 eax, ecx
  00055	66 41 3b c0	 cmp	 ax, r8w
  00059	76 04		 jbe	 SHORT $LN5@ucs2_to_ut

; 131  : 	}
; 132  : 
; 133  : 	return -1;

  0005b	83 c8 ff	 or	 eax, -1

; 134  : }

  0005e	c3		 ret	 0
$LN5@ucs2_to_ut:

; 120  : 
; 121  : 		if (ucs2 >= 0xD800 && ucs2 <= 0xDFFF) {
; 122  : 			/* Ill-formed (UTF-16 ouside of BMP) */
; 123  : 			return -1;
; 124  : 		}
; 125  : 
; 126  : 		utf8[0] = ((ucs2 >> 12)) | 0xE0;

  0005f	0f b7 c1	 movzx	 eax, cx

; 127  : 		utf8[1] = ((ucs2 >> 6) & 0x3F) | 0x80;
; 128  : 		utf8[2] = ((ucs2) & 0x3F) | 0x80;
; 129  : 		utf8[3] = '\0';

  00062	c6 42 03 00	 mov	 BYTE PTR [rdx+3], 0
  00066	66 c1 e8 0c	 shr	 ax, 12
  0006a	0c e0		 or	 al, -32			; ffffffffffffffe0H
  0006c	88 02		 mov	 BYTE PTR [rdx], al
  0006e	0f b7 c1	 movzx	 eax, cx
  00071	66 c1 e8 06	 shr	 ax, 6
  00075	80 e1 3f	 and	 cl, 63			; 0000003fH
  00078	24 3f		 and	 al, 63			; 0000003fH
  0007a	80 c9 80	 or	 cl, -128		; ffffffffffffff80H
  0007d	0c 80		 or	 al, -128		; ffffffffffffff80H
  0007f	88 4a 02	 mov	 BYTE PTR [rdx+2], cl
  00082	88 42 01	 mov	 BYTE PTR [rdx+1], al

; 130  : 		return 3;

  00085	b8 03 00 00 00	 mov	 eax, 3

; 134  : }

  0008a	c3		 ret	 0
ucs2_to_utf8_char ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT utf8_to_ucs2
_TEXT	SEGMENT
ucs2_le$ = 48
utf8$ = 56
maxucs2$dead$ = 64
maxutf8$dead$ = 72
current_utf8$ = 72
utf8_to_ucs2 PROC					; COMDAT

; 139  : {

$LN21:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000f	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  00013	41 56		 push	 r14
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 140  : 	const unsigned char* current_utf8 = (unsigned char*)utf8;
; 141  : 	WCHAR* current_ucs2_le = ucs2_le;

  00019	44 8a 02	 mov	 r8b, BYTE PTR [rdx]
  0001c	48 8b d9	 mov	 rbx, rcx

; 142  : 
; 143  : 	for (; *current_utf8; current_ucs2_le++)

  0001f	45 33 f6	 xor	 r14d, r14d
  00022	48 89 50 20	 mov	 QWORD PTR [rax+32], rdx
  00026	48 8b f2	 mov	 rsi, rdx
  00029	48 8b ca	 mov	 rcx, rdx
  0002c	4c 8b db	 mov	 r11, rbx
  0002f	45 84 c0	 test	 r8b, r8b
  00032	0f 84 85 00 00
	00		 je	 $LN3@utf8_to_uc
  00038	49 8d 7e fe	 lea	 rdi, QWORD PTR [r14-2]
  0003c	48 2b fb	 sub	 rdi, rbx
$LL4@utf8_to_uc:

; 144  : 	{
; 145  : 		size_t size = (char*)current_utf8 - utf8;

  0003f	48 8b d1	 mov	 rdx, rcx
  00042	48 2b d6	 sub	 rdx, rsi

; 146  : 
; 147  : 		if (size >= maxutf8) return (size_t)-1;

  00045	48 81 fa c0 00
	00 00		 cmp	 rdx, 192		; 000000c0H
  0004c	0f 83 8a 00 00
	00		 jae	 $LN16@utf8_to_uc

; 148  : 		if (((*current_utf8 & 0xc0) == 0xc0) && (size >= maxutf8 - 1)) return (size_t)-1;

  00052	41 8a c0	 mov	 al, r8b
  00055	24 c0		 and	 al, 192			; 000000c0H
  00057	3c c0		 cmp	 al, 192			; 000000c0H
  00059	75 09		 jne	 SHORT $LN6@utf8_to_uc
  0005b	48 81 fa bf 00
	00 00		 cmp	 rdx, 191		; 000000bfH
  00062	73 78		 jae	 SHORT $LN16@utf8_to_uc
$LN6@utf8_to_uc:

; 149  : 		if (((*current_utf8 & 0xe0) == 0xe0) && (size >= maxutf8 - 2)) return (size_t)-1;

  00064	41 80 e0 e0	 and	 r8b, 224		; 000000e0H
  00068	41 80 f8 e0	 cmp	 r8b, 224		; 000000e0H
  0006c	75 09		 jne	 SHORT $LN7@utf8_to_uc
  0006e	48 81 fa be 00
	00 00		 cmp	 rdx, 190		; 000000beH
  00075	73 65		 jae	 SHORT $LN16@utf8_to_uc
$LN7@utf8_to_uc:

; 150  : 		if (current_ucs2_le - ucs2_le >= (intptr_t)maxucs2 - 1) return (size_t)-1;

  00077	48 8d 47 02	 lea	 rax, QWORD PTR [rdi+2]
  0007b	49 03 c3	 add	 rax, r11
  0007e	48 83 e0 fe	 and	 rax, -2
  00082	48 83 f8 7e	 cmp	 rax, 126		; 0000007eH
  00086	7d 54		 jge	 SHORT $LN16@utf8_to_uc

; 151  : 
; 152  : 		*current_ucs2_le = utf8_to_ucs2_char(current_utf8, &current_utf8);

  00088	48 8d 54 24 48	 lea	 rdx, QWORD PTR current_utf8$[rsp]
  0008d	e8 00 00 00 00	 call	 utf8_to_ucs2_char
  00092	44 0f b7 d0	 movzx	 r10d, ax
  00096	66 41 89 03	 mov	 WORD PTR [r11], ax

; 153  : 		current_ucs2_le[1] = 0;

  0009a	49 8d 43 02	 lea	 rax, QWORD PTR [r11+2]
  0009e	4c 8b d8	 mov	 r11, rax
  000a1	66 44 89 30	 mov	 WORD PTR [rax], r14w

; 154  : 
; 155  : 		if (*current_ucs2_le == (WCHAR)-1) return (size_t)-1;

  000a5	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  000aa	66 44 3b d0	 cmp	 r10w, ax
  000ae	74 2c		 je	 SHORT $LN16@utf8_to_uc

; 142  : 
; 143  : 	for (; *current_utf8; current_ucs2_le++)

  000b0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR current_utf8$[rsp]
  000b5	44 8a 01	 mov	 r8b, BYTE PTR [rcx]
  000b8	45 84 c0	 test	 r8b, r8b
  000bb	75 82		 jne	 SHORT $LL4@utf8_to_uc
$LN3@utf8_to_uc:

; 156  : 	}
; 157  : 	return current_ucs2_le - ucs2_le;

  000bd	4c 2b db	 sub	 r11, rbx
  000c0	49 d1 fb	 sar	 r11, 1
  000c3	49 8b c3	 mov	 rax, r11
$LN1@utf8_to_uc:

; 158  : }

  000c6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000cb	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000d0	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000d5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d9	41 5e		 pop	 r14
  000db	c3		 ret	 0
$LN16@utf8_to_uc:

; 154  : 
; 155  : 		if (*current_ucs2_le == (WCHAR)-1) return (size_t)-1;

  000dc	48 83 c8 ff	 or	 rax, -1
  000e0	eb e4		 jmp	 SHORT $LN1@utf8_to_uc
utf8_to_ucs2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT ucs2_to_utf8
_TEXT	SEGMENT
ucs2_le$ = 64
utf8$ = 72
maxucs2$dead$ = 80
utf8_char$ = 80
maxutf8$ = 88
ucs2_to_utf8 PROC					; COMDAT

; 162  : {

$LN15:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  0000f	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  00013	57		 push	 rdi
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 163  : 	char utf8_char[4];
; 164  : 	const WCHAR* current_ucs2 = ucs2_le;
; 165  : 	unsigned int index_utf8 = 0;

  0001c	45 33 ff	 xor	 r15d, r15d
  0001f	49 8b e9	 mov	 rbp, r9

; 166  : 
; 167  : 	for (*utf8 = 0; *current_ucs2; current_ucs2++)

  00022	44 88 3a	 mov	 BYTE PTR [rdx], r15b
  00025	4c 8b f2	 mov	 r14, rdx
  00028	48 8b f9	 mov	 rdi, rcx
  0002b	48 8b d9	 mov	 rbx, rcx
  0002e	41 8b f7	 mov	 esi, r15d
  00031	66 44 39 39	 cmp	 WORD PTR [rcx], r15w
  00035	74 43		 je	 SHORT $LN3@ucs2_to_ut
$LL4@ucs2_to_ut:

; 168  : 	{
; 169  : 		if (current_ucs2 - ucs2_le > (intptr_t)maxucs2) return FALSE;

  00037	48 8b c3	 mov	 rax, rbx
  0003a	48 2b c7	 sub	 rax, rdi
  0003d	48 83 e0 fe	 and	 rax, -2
  00041	48 3d 80 00 00
	00		 cmp	 rax, 128		; 00000080H
  00047	7f 4f		 jg	 SHORT $LN10@ucs2_to_ut

; 170  : 		int len = ucs2_to_utf8_char(*current_ucs2, utf8_char);

  00049	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  0004c	48 8d 54 24 50	 lea	 rdx, QWORD PTR utf8_char$[rsp]
  00051	e8 00 00 00 00	 call	 ucs2_to_utf8_char

; 171  : 		if (index_utf8 + len > maxutf8) return FALSE;

  00056	03 f0		 add	 esi, eax
  00058	8b ce		 mov	 ecx, esi
  0005a	48 3b cd	 cmp	 rcx, rbp
  0005d	77 39		 ja	 SHORT $LN10@ucs2_to_ut

; 172  : 		strncat(utf8, utf8_char, len);

  0005f	4c 63 c0	 movsxd	 r8, eax
  00062	48 8d 54 24 50	 lea	 rdx, QWORD PTR utf8_char$[rsp]
  00067	49 8b ce	 mov	 rcx, r14
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncat
  00070	48 83 c3 02	 add	 rbx, 2
  00074	66 44 39 3b	 cmp	 WORD PTR [rbx], r15w
  00078	75 bd		 jne	 SHORT $LL4@ucs2_to_ut
$LN3@ucs2_to_ut:

; 173  : 		index_utf8 += len;
; 174  : 	}
; 175  : 
; 176  : 	return TRUE;

  0007a	b8 01 00 00 00	 mov	 eax, 1
$LN1@ucs2_to_ut:

; 177  : }

  0007f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00084	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00089	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0008e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00092	41 5f		 pop	 r15
  00094	41 5e		 pop	 r14
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
$LN10@ucs2_to_ut:

; 171  : 		if (index_utf8 + len > maxutf8) return FALSE;

  00098	33 c0		 xor	 eax, eax
  0009a	eb e3		 jmp	 SHORT $LN1@ucs2_to_ut
ucs2_to_utf8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT stringToInt
_TEXT	SEGMENT
nextchar$ = 32
szValue$ = 64
min$ = 72
max$ = 80
value$ = 88
stringToInt PROC					; COMDAT

; 184  : {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	49 8b f9	 mov	 rdi, r9
  00017	41 8b f0	 mov	 esi, r8d
  0001a	8b ea		 mov	 ebp, edx
  0001c	48 8b d9	 mov	 rbx, rcx

; 185  : 	char *nextchar;
; 186  : 
; 187  : 	errno = 0;

  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 188  : 	long long result = vlmcsd_strtoll(szValue, &nextchar, 10);

  00025	41 b8 0a 00 00
	00		 mov	 r8d, 10
  0002b	48 8d 54 24 20	 lea	 rdx, QWORD PTR nextchar$[rsp]
  00030	48 8b cb	 mov	 rcx, rbx
  00033	83 20 00	 and	 DWORD PTR [rax], 0
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strtoi64
  0003c	48 8b d8	 mov	 rbx, rax

; 189  : 
; 190  : 	if (errno || result < (long long)min || result >(long long)max || *nextchar)

  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00045	83 38 00	 cmp	 DWORD PTR [rax], 0
  00048	75 1d		 jne	 SHORT $LN3@stringToIn
  0004a	48 3b dd	 cmp	 rbx, rbp
  0004d	7c 18		 jl	 SHORT $LN3@stringToIn
  0004f	48 3b de	 cmp	 rbx, rsi
  00052	7f 13		 jg	 SHORT $LN3@stringToIn
  00054	48 8b 4c 24 20	 mov	 rcx, QWORD PTR nextchar$[rsp]
  00059	80 39 00	 cmp	 BYTE PTR [rcx], 0
  0005c	75 09		 jne	 SHORT $LN3@stringToIn

; 193  : 	}
; 194  : 
; 195  : 	*value = (unsigned int)result;

  0005e	89 1f		 mov	 DWORD PTR [rdi], ebx

; 196  : 	return TRUE;

  00060	b8 01 00 00 00	 mov	 eax, 1
  00065	eb 02		 jmp	 SHORT $LN1@stringToIn
$LN3@stringToIn:

; 191  : 	{
; 192  : 		return FALSE;

  00067	33 c0		 xor	 eax, eax
$LN1@stringToIn:

; 197  : }

  00069	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0006e	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00073	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00078	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007c	5f		 pop	 rdi
  0007d	c3		 ret	 0
stringToInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT string2UuidLE
_TEXT	SEGMENT
inputCopy$ = 32
input$ = 96
guid$ = 104
string2UuidLE PROC					; COMDAT

; 202  : {

$LN24:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 203  : 	int i;
; 204  : 
; 205  : 	if (strlen(input) < GUID_STRING_LENGTH) return FALSE;

  00015	48 83 c8 ff	 or	 rax, -1
  00019	4c 8b f2	 mov	 r14, rdx
  0001c	33 ff		 xor	 edi, edi
  0001e	48 8b f1	 mov	 rsi, rcx
$LL22@string2Uui:
  00021	48 ff c0	 inc	 rax
  00024	40 38 3c 01	 cmp	 BYTE PTR [rcx+rax], dil
  00028	75 f7		 jne	 SHORT $LL22@string2Uui
  0002a	48 83 f8 24	 cmp	 rax, 36			; 00000024H
  0002e	0f 82 fd 00 00
	00		 jb	 $LN7@string2Uui

; 206  : 	if (input[8] != '-' || input[13] != '-' || input[18] != '-' || input[23] != '-') return FALSE;

  00034	b0 2d		 mov	 al, 45			; 0000002dH
  00036	38 41 08	 cmp	 BYTE PTR [rcx+8], al
  00039	0f 85 f2 00 00
	00		 jne	 $LN7@string2Uui
  0003f	38 41 0d	 cmp	 BYTE PTR [rcx+13], al
  00042	0f 85 e9 00 00
	00		 jne	 $LN7@string2Uui
  00048	38 41 12	 cmp	 BYTE PTR [rcx+18], al
  0004b	0f 85 e0 00 00
	00		 jne	 $LN7@string2Uui
  00051	38 41 17	 cmp	 BYTE PTR [rcx+23], al
  00054	0f 85 d7 00 00
	00		 jne	 $LN7@string2Uui
  0005a	48 8b df	 mov	 rbx, rdi
$LL4@string2Uui:

; 209  : 	{
; 210  : 		if (i == 8 || i == 13 || i == 18 || i == 23) continue;

  0005d	48 83 fb 17	 cmp	 rbx, 23
  00061	77 0b		 ja	 SHORT $LN19@string2Uui
  00063	b8 00 21 84 00	 mov	 eax, 8659200		; 00842100H
  00068	48 0f a3 d8	 bt	 rax, rbx
  0006c	72 23		 jb	 SHORT $LN2@string2Uui
$LN19@string2Uui:

; 211  : 
; 212  : 		const char c = (char)toupper((int)input[i]);

  0006e	0f be 0c 33	 movsx	 ecx, BYTE PTR [rbx+rsi]
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00078	8b c8		 mov	 ecx, eax

; 213  : 
; 214  : 		if (c < '0' || c > 'F' || (c > '9' && c < 'A')) return FALSE;

  0007a	83 c0 d0	 add	 eax, -48		; ffffffd0H
  0007d	3c 16		 cmp	 al, 22
  0007f	0f 87 ac 00 00
	00		 ja	 $LN7@string2Uui
  00085	80 e9 3a	 sub	 cl, 58			; 0000003aH
  00088	80 f9 06	 cmp	 cl, 6
  0008b	0f 86 a0 00 00
	00		 jbe	 $LN7@string2Uui
$LN2@string2Uui:

; 207  : 
; 208  : 	for (i = 0; i < GUID_STRING_LENGTH; i++)

  00091	48 ff c3	 inc	 rbx
  00094	48 83 fb 24	 cmp	 rbx, 36			; 00000024H
  00098	7c c3		 jl	 SHORT $LL4@string2Uui

; 215  : 	}
; 216  : 
; 217  : 	char inputCopy[GUID_STRING_LENGTH + 1];
; 218  : 	strncpy(inputCopy, input, GUID_STRING_LENGTH + 1);

  0009a	41 b8 25 00 00
	00		 mov	 r8d, 37			; 00000025H
  000a0	48 8d 4c 24 20	 lea	 rcx, QWORD PTR inputCopy$[rsp]
  000a5	48 8b d6	 mov	 rdx, rsi
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 219  : 	inputCopy[8] = inputCopy[13] = inputCopy[18] = 0;
; 220  : 
; 221  : 	hex2bin((BYTE*)&guid->Data1, inputCopy, 8);

  000ae	41 b8 08 00 00
	00		 mov	 r8d, 8
  000b4	40 88 7c 24 32	 mov	 BYTE PTR inputCopy$[rsp+18], dil
  000b9	48 8d 54 24 20	 lea	 rdx, QWORD PTR inputCopy$[rsp]
  000be	40 88 7c 24 2d	 mov	 BYTE PTR inputCopy$[rsp+13], dil
  000c3	49 8b ce	 mov	 rcx, r14
  000c6	40 88 7c 24 28	 mov	 BYTE PTR inputCopy$[rsp+8], dil
  000cb	e8 00 00 00 00	 call	 hex2bin

; 222  : 	hex2bin((BYTE*)&guid->Data2, inputCopy + 9, 4);

  000d0	49 8d 7e 04	 lea	 rdi, QWORD PTR [r14+4]
  000d4	41 b8 04 00 00
	00		 mov	 r8d, 4
  000da	48 8b cf	 mov	 rcx, rdi
  000dd	48 8d 54 24 29	 lea	 rdx, QWORD PTR inputCopy$[rsp+9]
  000e2	e8 00 00 00 00	 call	 hex2bin

; 223  : 	hex2bin((BYTE*)&guid->Data3, inputCopy + 14, 4);

  000e7	49 8d 5e 06	 lea	 rbx, QWORD PTR [r14+6]
  000eb	41 b8 04 00 00
	00		 mov	 r8d, 4
  000f1	48 8b cb	 mov	 rcx, rbx
  000f4	48 8d 54 24 2e	 lea	 rdx, QWORD PTR inputCopy$[rsp+14]
  000f9	e8 00 00 00 00	 call	 hex2bin

; 224  : 	hex2bin(guid->Data4, input + 19, 16);

  000fe	48 8d 56 13	 lea	 rdx, QWORD PTR [rsi+19]
  00102	41 b8 10 00 00
	00		 mov	 r8d, 16
  00108	49 8d 4e 08	 lea	 rcx, QWORD PTR [r14+8]
  0010c	e8 00 00 00 00	 call	 hex2bin

; 225  : 
; 226  : 	guid->Data1 = BS32(guid->Data1);

  00111	41 8b 0e	 mov	 ecx, DWORD PTR [r14]

; 227  : 	guid->Data2 = BS16(guid->Data2);
; 228  : 	guid->Data3 = BS16(guid->Data3);
; 229  : 	return TRUE;

  00114	b0 01		 mov	 al, 1
  00116	0f c9		 bswap	 ecx
  00118	41 89 0e	 mov	 DWORD PTR [r14], ecx
  0011b	0f b7 0f	 movzx	 ecx, WORD PTR [rdi]
  0011e	66 c1 c9 08	 ror	 cx, 8
  00122	66 89 0f	 mov	 WORD PTR [rdi], cx
  00125	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00128	66 c1 c9 08	 ror	 cx, 8
  0012c	66 89 0b	 mov	 WORD PTR [rbx], cx
  0012f	eb 02		 jmp	 SHORT $LN1@string2Uui
$LN7@string2Uui:

; 206  : 	if (input[8] != '-' || input[13] != '-' || input[18] != '-' || input[23] != '-') return FALSE;

  00131	32 c0		 xor	 al, al
$LN1@string2Uui:

; 230  : }

  00133	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00138	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  0013d	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
  00142	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00146	41 5e		 pop	 r14
  00148	c3		 ret	 0
string2UuidLE ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT timeSpanString2Seconds
_TEXT	SEGMENT
argument$ = 48
unitId$ = 56
timeSpanString2Seconds PROC				; COMDAT

; 234  : {

$LN17:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 235  : 	char *unitId;
; 236  : 
; 237  : 	long long val = vlmcsd_strtoll(argument, &unitId, 10);

  00006	41 b8 0a 00 00
	00		 mov	 r8d, 10
  0000c	48 8d 54 24 38	 lea	 rdx, QWORD PTR unitId$[rsp]
  00011	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strtoi64
  00017	48 8b d8	 mov	 rbx, rax

; 238  : 
; 239  : 	switch (toupper((int)*unitId))

  0001a	48 8b 44 24 38	 mov	 rax, QWORD PTR unitId$[rsp]
  0001f	0f be 08	 movsx	 ecx, BYTE PTR [rax]
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00028	85 c0		 test	 eax, eax
  0002a	74 29		 je	 SHORT $LN7@timeSpanSt
  0002c	83 f8 44	 cmp	 eax, 68			; 00000044H
  0002f	74 18		 je	 SHORT $LN5@timeSpanSt
  00031	83 f8 48	 cmp	 eax, 72			; 00000048H
  00034	74 1b		 je	 SHORT $LN6@timeSpanSt
  00036	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  00039	74 1a		 je	 SHORT $LN7@timeSpanSt
  0003b	83 f8 53	 cmp	 eax, 83			; 00000053H
  0003e	74 19		 je	 SHORT $LN9@timeSpanSt
  00040	83 f8 57	 cmp	 eax, 87			; 00000057H
  00043	75 24		 jne	 SHORT $LN14@timeSpanSt

; 240  : 	{
; 241  : 	case 'W':
; 242  : 		val *= 7;

  00045	48 6b db 07	 imul	 rbx, rbx, 7
$LN5@timeSpanSt:

; 243  : 	case 'D':
; 244  : 		val *= 24;

  00049	48 8d 1c 5b	 lea	 rbx, QWORD PTR [rbx+rbx*2]
  0004d	48 c1 e3 03	 shl	 rbx, 3
$LN6@timeSpanSt:

; 245  : 	case 'H':
; 246  : 		val *= 60;

  00051	48 6b db 3c	 imul	 rbx, rbx, 60		; 0000003cH
$LN7@timeSpanSt:

; 247  : 	case 0:
; 248  : 	case 'M':
; 249  : 		val *= 60;

  00055	48 6b db 3c	 imul	 rbx, rbx, 60		; 0000003cH
$LN9@timeSpanSt:

; 250  : 	case 'S':
; 251  : 		break;
; 252  : 	default:
; 253  : 		return 0;
; 254  : 	}
; 255  : 
; 256  : 	if (*unitId && unitId[1]) return 0;

  00059	48 8b 44 24 38	 mov	 rax, QWORD PTR unitId$[rsp]
  0005e	80 38 00	 cmp	 BYTE PTR [rax], 0
  00061	74 0a		 je	 SHORT $LN11@timeSpanSt
  00063	80 78 01 00	 cmp	 BYTE PTR [rax+1], 0
  00067	74 04		 je	 SHORT $LN11@timeSpanSt
$LN14@timeSpanSt:
  00069	33 c0		 xor	 eax, eax
  0006b	eb 0e		 jmp	 SHORT $LN1@timeSpanSt
$LN11@timeSpanSt:

; 257  : 	if (val < 1) val = 1;

  0006d	b8 01 00 00 00	 mov	 eax, 1
  00072	48 3b d8	 cmp	 rbx, rax
  00075	48 0f 4c d8	 cmovl	 rbx, rax

; 258  : 	return (DWORD)(val & UINT_MAX);

  00079	8b c3		 mov	 eax, ebx
$LN1@timeSpanSt:

; 259  : }

  0007b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007f	5b		 pop	 rbx
  00080	c3		 ret	 0
timeSpanString2Seconds ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT getOptionArgumentInt
_TEXT	SEGMENT
o$ = 48
min$ = 56
max$ = 64
result$ = 72
getOptionArgumentInt PROC				; COMDAT

; 265  : {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	0f be f1	 movsx	 esi, cl

; 266  : 	unsigned int result;
; 267  : 
; 268  : 	if (!stringToInt(optarg, min, max, &result))

  00012	4c 8d 4c 24 48	 lea	 r9, QWORD PTR result$[rsp]
  00017	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR optarg
  0001e	41 8b d8	 mov	 ebx, r8d
  00021	8b fa		 mov	 edi, edx
  00023	e8 00 00 00 00	 call	 stringToInt
  00028	85 c0		 test	 eax, eax
  0002a	75 20		 jne	 SHORT $LN2@getOptionA

; 269  : 	{
; 270  : 		printerrorf("Fatal: Option \"-%c\" must be numeric between %u and %u.\n", o, min, max);

  0002c	8b d6		 mov	 edx, esi
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DI@HIOFNDD@Fatal?3?5Option?5?$CC?9?$CFc?$CC?5must?5be?5num@
  00035	44 8b cb	 mov	 r9d, ebx
  00038	44 8b c7	 mov	 r8d, edi
  0003b	e8 00 00 00 00	 call	 printerrorf

; 271  : 		exit(VLMCSD_EINVAL);

  00040	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0004b	cc		 int	 3
$LN2@getOptionA:

; 272  : 	}
; 273  : 
; 274  : 	return result;

  0004c	8b 44 24 48	 mov	 eax, DWORD PTR result$[rsp]

; 275  : }

  00050	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00055	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005e	5f		 pop	 rdi
  0005f	c3		 ret	 0
$LN4@getOptionA:
getOptionArgumentInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT optReset
_TEXT	SEGMENT
optReset PROC						; COMDAT

; 280  : #if __minix__ || defined(__BSD__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || defined(__OpenBSD__)
; 281  : 	optind = 1;
; 282  : 	optreset = 1; // Makes newer BSD getopt happy
; 283  : #elif defined(__UCLIBC__) // uClibc headers also define __GLIBC__ so be careful here
; 284  : 	optind = 0; // uClibc seeks compatibility with GLIBC
; 285  : #elif defined(__GLIBC__)
; 286  : 	optind = 0; // Makes GLIBC getopt happy
; 287  : #else // Standard for most systems
; 288  : 	optind = 1;

  00000	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR optind, 1

; 289  : #endif
; 290  : }

  0000a	c3		 ret	 0
optReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT win_strerror
_TEXT	SEGMENT
message$ = 80
win_strerror PROC					; COMDAT

; 297  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 298  : #define STRERROR_BUFFER_SIZE 256
; 299  : 	static char buffer[STRERROR_BUFFER_SIZE];
; 300  : 
; 301  : 	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK, NULL, message, 0, buffer, STRERROR_BUFFER_SIZE, NULL);

  00006	48 83 64 24 30
	00		 and	 QWORD PTR [rsp+48], 0
  0000c	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:?buffer@?1??win_strerror@@9@9
  00013	44 8b c1	 mov	 r8d, ecx
  00016	c7 44 24 28 00
	01 00 00	 mov	 DWORD PTR [rsp+40], 256	; 00000100H
  0001e	b9 ff 12 00 00	 mov	 ecx, 4863		; 000012ffH
  00023	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00028	45 33 c9	 xor	 r9d, r9d
  0002b	33 d2		 xor	 edx, edx
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatMessageA

; 302  : 	return buffer;

  00033	48 8b c3	 mov	 rax, rbx

; 303  : }

  00036	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
win_strerror ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT parseAddress
_TEXT	SEGMENT
addr$ = 48
szHost$ = 56
szPort$ = 64
parseAddress PROC					; COMDAT

; 313  : {

$LN9:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 314  : 	*szHost = addr;
; 315  : 
; 316  : #	ifndef NO_SOCKETS
; 317  : 	*szPort = (char*)defaultport;

  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR defaultport
  00020	4c 8b f2	 mov	 r14, rdx
  00023	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00026	49 8b f0	 mov	 rsi, r8

; 318  : #	else // NO_SOCKETS
; 319  : 	*szPort = "1688";
; 320  : #	endif // NO_SOCKETS
; 321  : 
; 322  : 	char *lastcolon = strrchr(addr, ':');

  00029	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  0002e	49 89 00	 mov	 QWORD PTR [r8], rax
  00031	48 8b d9	 mov	 rbx, rcx
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strrchr

; 323  : 	char *firstcolon = strchr(addr, ':');

  0003a	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	48 8b e8	 mov	 rbp, rax
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr

; 324  : 	char *closingbracket = strrchr(addr, ']');

  0004b	ba 5d 00 00 00	 mov	 edx, 93			; 0000005dH
  00050	48 8b cb	 mov	 rcx, rbx
  00053	48 8b f8	 mov	 rdi, rax
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strrchr

; 325  : 
; 326  : 	if (*addr == '[' && closingbracket) //Address in brackets

  0005c	80 3b 5b	 cmp	 BYTE PTR [rbx], 91	; 0000005bH
  0005f	75 17		 jne	 SHORT $LN2@parseAddre
  00061	48 85 c0	 test	 rax, rax
  00064	74 12		 je	 SHORT $LN2@parseAddre

; 327  : 	{
; 328  : 		*closingbracket = 0;
; 329  : 		(*szHost)++;

  00066	49 ff 06	 inc	 QWORD PTR [r14]
  00069	c6 00 00	 mov	 BYTE PTR [rax], 0

; 330  : 
; 331  : 		if (closingbracket[1] == ':')

  0006c	80 78 01 3a	 cmp	 BYTE PTR [rax+1], 58	; 0000003aH
  00070	75 1a		 jne	 SHORT $LN5@parseAddre

; 332  : 			*szPort = closingbracket + 2;

  00072	48 83 c0 02	 add	 rax, 2

; 333  : 	}

  00076	eb 11		 jmp	 SHORT $LN7@parseAddre
$LN2@parseAddre:

; 334  : 	else if (firstcolon && firstcolon == lastcolon) //IPv4 address or hostname with port

  00078	48 85 ff	 test	 rdi, rdi
  0007b	74 0f		 je	 SHORT $LN5@parseAddre
  0007d	48 3b fd	 cmp	 rdi, rbp
  00080	75 0a		 jne	 SHORT $LN5@parseAddre

; 335  : 	{
; 336  : 		*firstcolon = 0;

  00082	c6 07 00	 mov	 BYTE PTR [rdi], 0

; 337  : 		*szPort = firstcolon + 1;

  00085	48 8d 47 01	 lea	 rax, QWORD PTR [rdi+1]
$LN7@parseAddre:

; 338  : 	}
; 339  : }

  00089	48 89 06	 mov	 QWORD PTR [rsi], rax
$LN5@parseAddre:
  0008c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00091	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00096	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0009b	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000a0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a4	41 5e		 pop	 r14
  000a6	c3		 ret	 0
parseAddress ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT randomNumberInit
_TEXT	SEGMENT
randomNumberInit PROC					; COMDAT

; 344  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 345  : #	if _MSC_VER
; 346  : 	srand(GetTickCount());

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  0000a	8b c8		 mov	 ecx, eax

; 347  : #	else
; 348  : 	struct timeval tv;
; 349  : 	gettimeofday(&tv, NULL);
; 350  : 	srand((unsigned int)(tv.tv_sec ^ tv.tv_usec));
; 351  : #	endif
; 352  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 345  : #	if _MSC_VER
; 346  : 	srand(GetTickCount());

  00010	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_srand
randomNumberInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT OutOfMemory
_TEXT	SEGMENT
OutOfMemory PROC					; COMDAT

; 357  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 358  : 	errorout("Fatal: Out of memory");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory@
  0000b	e8 00 00 00 00	 call	 errorout

; 359  : 	exit(VLMCSD_ENOMEM);

  00010	b9 0e 00 00 00	 mov	 ecx, 14
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0001b	cc		 int	 3
$LN3@OutOfMemor:
OutOfMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT vlmcsd_malloc
_TEXT	SEGMENT
len$ = 48
vlmcsd_malloc PROC					; COMDAT

; 364  : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 365  : 	void* buf = malloc(len);

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 366  : 	if (!buf) OutOfMemory();

  0000a	48 85 c0	 test	 rax, rax
  0000d	74 05		 je	 SHORT $LN6@vlmcsd_mal

; 367  : 	return buf;
; 368  : }

  0000f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00013	c3		 ret	 0
$LN6@vlmcsd_mal:

; 366  : 	if (!buf) OutOfMemory();

  00014	e8 00 00 00 00	 call	 OutOfMemory
  00019	cc		 int	 3
$LN4@vlmcsd_mal:
vlmcsd_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT vlmcsd_strdup
_TEXT	SEGMENT
src$ = 48
vlmcsd_strdup PROC					; COMDAT

; 371  : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 372  : #	if _MSC_VER
; 373  : 	char* dst = _strdup(src);

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup

; 374  : #	else // !_MSC_VER
; 375  : 	char* dst = strdup(src);
; 376  : #	endif
; 377  : 
; 378  : 	if (!dst) OutOfMemory();

  0000a	48 85 c0	 test	 rax, rax
  0000d	74 05		 je	 SHORT $LN6@vlmcsd_str

; 379  : 	return dst;
; 380  : }

  0000f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00013	c3		 ret	 0
$LN6@vlmcsd_str:

; 374  : #	else // !_MSC_VER
; 375  : 	char* dst = strdup(src);
; 376  : #	endif
; 377  : 
; 378  : 	if (!dst) OutOfMemory();

  00014	e8 00 00 00 00	 call	 OutOfMemory
  00019	cc		 int	 3
$LN4@vlmcsd_str:
vlmcsd_strdup ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT hex2bin
_TEXT	SEGMENT
bin$ = 48
hex$ = 56
maxbin$ = 64
nextchar$ = 72
hex2bin	PROC						; COMDAT

; 388  : {

$LN17:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	49 8b f0	 mov	 rsi, r8

; 389  : 	static const char *const hexdigits = "0123456789ABCDEF";
; 390  : 	char* nextchar;
; 391  : 	size_t i;
; 392  : 
; 393  : 	for (i = 0; (i < 16) && utf8_to_ucs2_char((const unsigned char*)hex, (const unsigned char**)&nextchar) != (WCHAR)-1; hex = nextchar)

  00017	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:??_C@_0BB@JGGOGLEG@0123456789ABCDEF@
  0001e	4c 8b d2	 mov	 r10, rdx
  00021	48 8b f9	 mov	 rdi, rcx
  00024	33 db		 xor	 ebx, ebx
$LL4@hex2bin:
  00026	48 8d 54 24 48	 lea	 rdx, QWORD PTR nextchar$[rsp]
  0002b	49 8b ca	 mov	 rcx, r10
  0002e	e8 00 00 00 00	 call	 utf8_to_ucs2_char
  00033	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00038	66 3b c1	 cmp	 ax, cx
  0003b	74 5b		 je	 SHORT $LN11@hex2bin

; 394  : 	{
; 395  : 		const char* pos = strchr(hexdigits, toupper((int)*hex));

  0003d	41 0f be 0a	 movsx	 ecx, BYTE PTR [r10]
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00047	8b d0		 mov	 edx, eax
  00049	48 8b cd	 mov	 rcx, rbp
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr

; 396  : 		if (!pos) continue;

  00052	48 85 c0	 test	 rax, rax
  00055	74 36		 je	 SHORT $LN2@hex2bin

; 397  : 
; 398  : 		if (!(i & 1)) bin[i >> 1] = 0;

  00057	48 8b d3	 mov	 rdx, rbx
  0005a	48 8b cb	 mov	 rcx, rbx
  0005d	83 e2 01	 and	 edx, 1
  00060	48 d1 e9	 shr	 rcx, 1
  00063	48 85 d2	 test	 rdx, rdx
  00066	75 03		 jne	 SHORT $LN14@hex2bin
  00068	88 14 39	 mov	 BYTE PTR [rcx+rdi], dl
$LN14@hex2bin:

; 399  : 		bin[i >> 1] |= (char)(pos - hexdigits);

  0006b	40 2a c5	 sub	 al, bpl
  0006e	0a 04 39	 or	 al, BYTE PTR [rcx+rdi]
  00071	88 04 39	 mov	 BYTE PTR [rcx+rdi], al

; 400  : 		if (!(i & 1)) bin[i >> 1] <<= 4;

  00074	48 85 d2	 test	 rdx, rdx
  00077	75 06		 jne	 SHORT $LN7@hex2bin
  00079	c0 e0 04	 shl	 al, 4
  0007c	88 04 39	 mov	 BYTE PTR [rcx+rdi], al
$LN7@hex2bin:

; 401  : 		i++;

  0007f	48 ff c3	 inc	 rbx

; 402  : 		if (i >> 1 > maxbin) break;

  00082	48 8b c3	 mov	 rax, rbx
  00085	48 d1 e8	 shr	 rax, 1
  00088	48 3b c6	 cmp	 rax, rsi
  0008b	77 0b		 ja	 SHORT $LN11@hex2bin
$LN2@hex2bin:

; 389  : 	static const char *const hexdigits = "0123456789ABCDEF";
; 390  : 	char* nextchar;
; 391  : 	size_t i;
; 392  : 
; 393  : 	for (i = 0; (i < 16) && utf8_to_ucs2_char((const unsigned char*)hex, (const unsigned char**)&nextchar) != (WCHAR)-1; hex = nextchar)

  0008d	4c 8b 54 24 48	 mov	 r10, QWORD PTR nextchar$[rsp]
  00092	48 83 fb 10	 cmp	 rbx, 16
  00096	72 8e		 jb	 SHORT $LL4@hex2bin
$LN11@hex2bin:

; 403  : 	}
; 404  : }

  00098	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009d	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000a2	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000a7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ab	5f		 pop	 rdi
  000ac	c3		 ret	 0
hex2bin	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT getArgumentBool
_TEXT	SEGMENT
result$ = 48
argument$ = 56
getArgumentBool PROC					; COMDAT

; 408  : {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b da	 mov	 rbx, rdx
  00012	48 8b f9	 mov	 rdi, rcx

; 409  : 	if (
; 410  : 		!strncasecmp(argument, "true", 4) ||
; 411  : 		!strncasecmp(argument, "on", 2) ||
; 412  : 		!strncasecmp(argument, "yes", 3) ||

  00015	48 8b cb	 mov	 rcx, rbx
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04LOAJBDKD@true@
  0001f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0002b	be 01 00 00 00	 mov	 esi, 1
  00030	85 c0		 test	 eax, eax
  00032	0f 84 b3 00 00
	00		 je	 $LN4@getArgumen
  00038	44 8d 46 01	 lea	 r8d, QWORD PTR [rsi+1]
  0003c	48 8b cb	 mov	 rcx, rbx
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02LIELOMNJ@on@
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0004c	85 c0		 test	 eax, eax
  0004e	0f 84 97 00 00
	00		 je	 $LN4@getArgumen
  00054	44 8d 46 02	 lea	 r8d, QWORD PTR [rsi+2]
  00058	48 8b cb	 mov	 rcx, rbx
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03ICICOMAL@yes@
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00068	85 c0		 test	 eax, eax
  0006a	74 7f		 je	 SHORT $LN4@getArgumen
  0006c	44 8b c6	 mov	 r8d, esi
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01HIHLOKLC@1@
  00076	48 8b cb	 mov	 rcx, rbx
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0007f	85 c0		 test	 eax, eax
  00081	74 68		 je	 SHORT $LN4@getArgumen

; 417  : 		return TRUE;
; 418  : 	}
; 419  : 	else if (
; 420  : 		!strncasecmp(argument, "false", 5) ||
; 421  : 		!strncasecmp(argument, "off", 3) ||
; 422  : 		!strncasecmp(argument, "no", 2) ||

  00083	44 8d 46 04	 lea	 r8d, QWORD PTR [rsi+4]
  00087	48 8b cb	 mov	 rcx, rbx
  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LAPONLG@false@
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00097	85 c0		 test	 eax, eax
  00099	74 4b		 je	 SHORT $LN6@getArgumen
  0009b	44 8d 46 02	 lea	 r8d, QWORD PTR [rsi+2]
  0009f	48 8b cb	 mov	 rcx, rbx
  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03MCADLMAF@off@
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  000af	85 c0		 test	 eax, eax
  000b1	74 33		 je	 SHORT $LN6@getArgumen
  000b3	44 8d 46 01	 lea	 r8d, QWORD PTR [rsi+1]
  000b7	48 8b cb	 mov	 rcx, rbx
  000ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02KAJCLHKP@no@
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  000c7	85 c0		 test	 eax, eax
  000c9	74 1b		 je	 SHORT $LN6@getArgumen
  000cb	44 8b c6	 mov	 r8d, esi
  000ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01GBGANLPD@0@
  000d5	48 8b cb	 mov	 rcx, rbx
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  000de	85 c0		 test	 eax, eax
  000e0	74 04		 je	 SHORT $LN6@getArgumen

; 428  : 	}
; 429  : 
; 430  : 	return FALSE;

  000e2	33 c0		 xor	 eax, eax
  000e4	eb 0a		 jmp	 SHORT $LN1@getArgumen
$LN6@getArgumen:

; 423  : 		!strncasecmp(argument, "0", 1)
; 424  : 		)
; 425  : 	{
; 426  : 		*result = FALSE;

  000e6	c6 07 00	 mov	 BYTE PTR [rdi], 0

; 427  : 		return TRUE;

  000e9	eb 03		 jmp	 SHORT $LN8@getArgumen
$LN4@getArgumen:

; 413  : 		!strncasecmp(argument, "1", 1)
; 414  : 		)
; 415  : 	{
; 416  : 		*result = TRUE;

  000eb	40 88 37	 mov	 BYTE PTR [rdi], sil
$LN8@getArgumen:

; 431  : }

  000ee	8b c6		 mov	 eax, esi
$LN1@getArgumen:
  000f0	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000f5	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000fa	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fe	5f		 pop	 rdi
  000ff	c3		 ret	 0
getArgumentBool ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT dataFileReadError
_TEXT	SEGMENT
dataFileReadError PROC					; COMDAT

; 436  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 437  : 	const int error = errno;

  00006	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0000c	8b 18		 mov	 ebx, DWORD PTR [rax]

; 438  : 	errorout("Fatal: Could not read %s: %s\n", fn_data, strerror(error));

  0000e	8b cb		 mov	 ecx, ebx
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00016	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR fn_data
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@DINIIKCC@Fatal?3?5Could?5not?5read?5?$CFs?3?5?$CFs?6@
  00024	4c 8b c0	 mov	 r8, rax
  00027	e8 00 00 00 00	 call	 errorout

; 439  : 	exit(error);

  0002c	8b cb		 mov	 ecx, ebx
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00034	cc		 int	 3
$LN3@dataFileRe:
dataFileReadError ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT dataFileFormatError
_TEXT	SEGMENT
dataFileFormatError PROC				; COMDAT

; 443  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 444  : 	errorout("Fatal: %s is not a KMS data file version 2.x\n", fn_data);

  00004	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR fn_data
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@ODFKJCLO@Fatal?3?5?$CFs?5is?5not?5a?5KMS?5data?5fil@
  00012	e8 00 00 00 00	 call	 errorout

; 445  : 	exit(VLMCSD_EINVAL);

  00017	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00022	cc		 int	 3
$LN3@dataFileFo:
dataFileFormatError ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT getExeName
_TEXT	SEGMENT
path$ = 32
getExeName PROC						; COMDAT

; 451  : {

$LN11:
  00000	48 81 ec 28 02
	00 00		 sub	 rsp, 552		; 00000228H

; 452  : 	if (fn_exe != NULL) return;

  00007	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR fn_exe, 0
  0000f	75 3b		 jne	 SHORT $LN1@getExeName

; 453  : 
; 454  : #	if (__GLIBC__ || __linux__) && defined(USE_AUXV)
; 455  : 
; 456  : 	fn_exe = (char*)getauxval(AT_EXECFN);
; 457  : 
; 458  : #	elif (__ANDROID__ && __ANDROID_API__ < 16) || (__UCLIBC__ && __UCLIBC_MAJOR__ < 1 && !defined(NO_PROCFS)) // Workaround for older uclibc
; 459  : 
; 460  : 	char temp[PATH_MAX + 1];
; 461  : 
; 462  : 	if (realpath("/proc/self/exe", temp) == temp)
; 463  : 	{
; 464  : 		fn_exe = vlmcsd_strdup(temp);
; 465  : 	}
; 466  : 
; 467  : #	elif (__linux__ || __CYGWIN__) && !defined(NO_PROCFS)
; 468  : 
; 469  : 	fn_exe = realpath("/proc/self/exe", NULL);
; 470  : 
; 471  : #	elif (__FreeBSD__ || __FreeBSD_kernel__)
; 472  : 
; 473  : 	int mib[4];
; 474  : 	mib[0] = CTL_KERN;
; 475  : 	mib[1] = KERN_PROC;
; 476  : 	mib[2] = KERN_PROC_PATHNAME;
; 477  : 	mib[3] = -1;
; 478  : 	char path[PATH_MAX + 1];
; 479  : 	size_t cb = sizeof(path);
; 480  : 
; 481  : 	if (!sysctl(mib, 4, path, &cb, NULL, 0))
; 482  : 	{
; 483  : 		fn_exe = vlmcsd_strdup(path);
; 484  : 	}
; 485  : 
; 486  : #	elif (__DragonFly__) && !defined(NO_PROCFS)
; 487  : 
; 488  : 	fn_exe = realpath("/proc/curproc/file", NULL);
; 489  : 
; 490  : #	elif __NetBSD__ && !defined(NO_PROCFS)
; 491  : 
; 492  : 	fn_exe = realpath("/proc/curproc/exe", NULL);
; 493  : 
; 494  : #	elif __sun__
; 495  : 
; 496  : 	fn_exe = getexecname();
; 497  : 
; 498  : #	elif __APPLE__
; 499  : 
; 500  : 	char path[PATH_MAX + 1];
; 501  : 	uint32_t size = sizeof(path);
; 502  : 
; 503  : 	if (_NSGetExecutablePath(path, &size) == 0)
; 504  : 	{
; 505  : 		fn_exe = vlmcsd_strdup(path);
; 506  : 	}
; 507  : 
; 508  : #	elif _WIN32
; 509  : 
; 510  : 	char path[512];
; 511  : 	GetModuleFileName(GetModuleHandle(NULL), path, 512);

  00011	33 c9		 xor	 ecx, ecx
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  00019	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  0001f	48 8d 54 24 20	 lea	 rdx, QWORD PTR path$[rsp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleFileNameA

; 373  : 	char* dst = _strdup(src);

  0002d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR path$[rsp]

; 512  : 	path[511] = 0;

  00032	c6 84 24 1f 02
	00 00 00	 mov	 BYTE PTR path$[rsp+511], 0

; 373  : 	char* dst = _strdup(src);

  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup

; 374  : #	else // !_MSC_VER
; 375  : 	char* dst = strdup(src);
; 376  : #	endif
; 377  : 
; 378  : 	if (!dst) OutOfMemory();

  00040	48 85 c0	 test	 rax, rax
  00043	74 0f		 je	 SHORT $LN10@getExeName

; 513  : 	fn_exe = vlmcsd_strdup(path);

  00045	48 89 05 00 00
	00 00		 mov	 QWORD PTR fn_exe, rax
$LN1@getExeName:

; 514  : 
; 515  : #	else
; 516  : 	// Sorry no exe detection
; 517  : #	endif
; 518  : }

  0004c	48 81 c4 28 02
	00 00		 add	 rsp, 552		; 00000228H
  00053	c3		 ret	 0
$LN10@getExeName:

; 378  : 	if (!dst) OutOfMemory();

  00054	e8 00 00 00 00	 call	 OutOfMemory
  00059	cc		 int	 3
$LN8@getExeName:
getExeName ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT getDefaultDataFile
_TEXT	SEGMENT
fileName$ = 32
getDefaultDataFile PROC					; COMDAT

; 524  : {

  00000	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H

; 525  : 	char fileName[MAX_PATH];
; 526  : 	getExeName();

  00007	e8 00 00 00 00	 call	 getExeName

; 527  : 	strncpy(fileName, fn_exe, MAX_PATH);

  0000c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR fn_exe
  00013	48 8d 4c 24 20	 lea	 rcx, QWORD PTR fileName$[rsp]
  00018	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 528  : 	PathRemoveFileSpec(fileName);

  00024	48 8d 4c 24 20	 lea	 rcx, QWORD PTR fileName$[rsp]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PathRemoveFileSpecA

; 529  : 	strncat(fileName, "\\vlmcsd.kmd", MAX_PATH - 11);

  0002f	41 b8 f9 00 00
	00		 mov	 r8d, 249		; 000000f9H
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@OPCADLF@?2vlmcsd?4kmd@
  0003c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR fileName$[rsp]
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncat

; 373  : 	char* dst = _strdup(src);

  00047	48 8d 4c 24 20	 lea	 rcx, QWORD PTR fileName$[rsp]
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup

; 374  : #	else // !_MSC_VER
; 375  : 	char* dst = strdup(src);
; 376  : #	endif
; 377  : 
; 378  : 	if (!dst) OutOfMemory();

  00052	48 85 c0	 test	 rax, rax
  00055	74 0f		 je	 SHORT $LN9@getDefault

; 530  : 	fn_data = vlmcsd_strdup(fileName);

  00057	48 89 05 00 00
	00 00		 mov	 QWORD PTR fn_data, rax

; 531  : }

  0005e	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  00065	c3		 ret	 0
$LN9@getDefault:

; 378  : 	if (!dst) OutOfMemory();

  00066	e8 00 00 00 00	 call	 OutOfMemory
  0006b	cc		 int	 3
$LN7@getDefault:
getDefaultDataFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT loadKmsData
_TEXT	SEGMENT
tv506 = 48
tv488 = 48
loadKmsData PROC					; COMDAT

; 554  : {

$LN70:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 57		 push	 r15
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 555  : #	ifndef NO_INTERNAL_DATA
; 556  : 	KmsData = (PVlmcsdHeader_t)DefaultKmsData;
; 557  : #	endif // NO_INTERNAL_DATA
; 558  : 
; 559  : #	ifndef NO_EXTERNAL_DATA
; 560  : 	long size;
; 561  : #	ifndef NO_INTERNAL_DATA
; 562  : 	size = (long)getDefaultKmsDataSize();
; 563  : #	endif // NO_INTERNAL_DATA
; 564  : 
; 565  : #	ifndef DATA_FILE
; 566  : 	if (!fn_data) getDefaultDataFile();

  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fn_data
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:DefaultKmsData
  00023	48 89 15 00 00
	00 00		 mov	 QWORD PTR KmsData, rdx
  0002a	bf 42 07 00 00	 mov	 edi, 1858		; 00000742H
  0002f	48 85 c9	 test	 rcx, rcx
  00032	75 13		 jne	 SHORT $LN14@loadKmsDat
  00034	e8 00 00 00 00	 call	 getDefaultDataFile
  00039	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR KmsData
  00040	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fn_data
$LN14@loadKmsDat:

; 567  : #	endif // DATA_FILE
; 568  : 
; 569  : 	if (strcmp(fn_data, "-"))

  00047	80 39 2d	 cmp	 BYTE PTR [rcx], 45	; 0000002dH
  0004a	41 bf 02 00 00
	00		 mov	 r15d, 2
  00050	75 0a		 jne	 SHORT $LN65@loadKmsDat
  00052	80 79 01 00	 cmp	 BYTE PTR [rcx+1], 0
  00056	0f 84 da 00 00
	00		 je	 $LN23@loadKmsDat
$LN65@loadKmsDat:

; 570  : 	{
; 571  : 		FILE *file = fopen(fn_data, "rb");

  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb@
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  00069	48 8b d8	 mov	 rbx, rax

; 572  : 
; 573  : 		if (!file)

  0006c	48 85 c0	 test	 rax, rax
  0006f	75 11		 jne	 SHORT $LN16@loadKmsDat

; 574  : 		{
; 575  : #			ifndef NO_INTERNAL_DATA
; 576  : 			if (ExplicitDataLoad)

  00071	38 05 00 00 00
	00		 cmp	 BYTE PTR ExplicitDataLoad, al
  00077	0f 85 c2 01 00
	00		 jne	 $LN60@loadKmsDat
  0007d	e9 ad 00 00 00	 jmp	 $LN66@loadKmsDat
$LN16@loadKmsDat:

; 577  : #			endif // NO_INTERNAL_DATA
; 578  : 			{
; 579  : 				dataFileReadError();
; 580  : 			}
; 581  : 		}
; 582  : 		else
; 583  : 		{
; 584  : 			if (fseek(file, 0, SEEK_END)) dataFileReadError();

  00082	45 8b c7	 mov	 r8d, r15d
  00085	33 d2		 xor	 edx, edx
  00087	48 8b cb	 mov	 rcx, rbx
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek
  00090	85 c0		 test	 eax, eax
  00092	0f 85 a7 01 00
	00		 jne	 $LN60@loadKmsDat

; 585  : 			size = ftell(file);

  00098	48 8b cb	 mov	 rcx, rbx
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ftell
  000a1	48 63 f8	 movsxd	 rdi, eax

; 586  : 			if (size == -1L) dataFileReadError();

  000a4	83 ff ff	 cmp	 edi, -1
  000a7	0f 84 92 01 00
	00		 je	 $LN60@loadKmsDat

; 365  : 	void* buf = malloc(len);

  000ad	48 8b cf	 mov	 rcx, rdi
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 366  : 	if (!buf) OutOfMemory();

  000b6	48 85 c0	 test	 rax, rax
  000b9	0f 84 86 01 00
	00		 je	 $LN69@loadKmsDat

; 587  : 
; 588  : 			KmsData = (PVlmcsdHeader_t)vlmcsd_malloc(size);

  000bf	45 33 c0	 xor	 r8d, r8d
  000c2	48 89 05 00 00
	00 00		 mov	 QWORD PTR KmsData, rax

; 589  : 			if (fseek(file, 0, SEEK_SET)) dataFileReadError();

  000c9	33 d2		 xor	 edx, edx
  000cb	48 8b cb	 mov	 rcx, rbx
  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek
  000d4	85 c0		 test	 eax, eax
  000d6	0f 85 63 01 00
	00		 jne	 $LN60@loadKmsDat

; 590  : 
; 591  : 			const size_t bytesRead = fread(KmsData, 1, size, file);

  000dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsData
  000e3	8d 50 01	 lea	 edx, QWORD PTR [rax+1]
  000e6	4c 8b cb	 mov	 r9, rbx
  000e9	4c 8b c7	 mov	 r8, rdi
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread

; 592  : 			if ((long)bytesRead != size) dataFileReadError();

  000f2	3b c7		 cmp	 eax, edi
  000f4	0f 85 45 01 00
	00		 jne	 $LN60@loadKmsDat

; 593  : 			fclose(file);

  000fa	48 8b cb	 mov	 rcx, rbx
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 594  : 
; 595  : #			if !defined(NO_LOG) && !defined(NO_SOCKETS)
; 596  : 			if (!InetdMode) logger("Read KMS data file version %u.%u %s\n", (unsigned int)LE16(KmsData->MajorVer), (unsigned int)LE16(KmsData->MinorVer), fn_data);

  00103	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  0010a	75 23		 jne	 SHORT $LN66@loadKmsDat
  0010c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR KmsData
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@IKBPGCAJ@Read?5KMS?5data?5file?5version?5?$CFu?4?$CF@
  0011a	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR fn_data
  00121	44 0f b7 40 04	 movzx	 r8d, WORD PTR [rax+4]
  00126	0f b7 50 06	 movzx	 edx, WORD PTR [rax+6]
  0012a	e8 00 00 00 00	 call	 logger
$LN66@loadKmsDat:

; 597  : #			endif // NO_LOG
; 598  : 		}
; 599  : 	}
; 600  : 
; 601  : 
; 602  : #	endif // NO_EXTERNAL_DATA
; 603  : 
; 604  : #	ifndef UNSAFE_DATA_LOAD
; 605  : 	if (((BYTE*)KmsData)[size - 1] != 0) dataFileFormatError();

  0012f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR KmsData
$LN23@loadKmsDat:
  00136	4c 63 cf	 movsxd	 r9, edi
  00139	41 80 7c 11 ff
	00		 cmp	 BYTE PTR [r9+rdx-1], 0
  0013f	0f 85 f4 00 00
	00		 jne	 $LN29@loadKmsDat

; 606  : #	endif // UNSAFE_DATA_LOAD
; 607  : 
; 608  : 	KmsData->MajorVer = LE16(KmsData->MajorVer);
; 609  : 	KmsData->MinorVer = LE16(KmsData->MinorVer);
; 610  : 	KmsData->AppItemCount = LE32(KmsData->AppItemCount);
; 611  : 	KmsData->KmsItemCount = LE32(KmsData->KmsItemCount);
; 612  : 	KmsData->SkuItemCount = LE32(KmsData->SkuItemCount);
; 613  : 	KmsData->HostBuildCount = LE32(KmsData->HostBuildCount);
; 614  : 
; 615  : 	uint32_t i;
; 616  : 
; 617  : 	for (i = 0; i < vlmcsd_countof(KmsData->Datapointers); i++)

  00145	33 c9		 xor	 ecx, ecx
  00147	4d 8d 1c 11	 lea	 r11, QWORD PTR [r9+rdx]
  0014b	48 8d 42 20	 lea	 rax, QWORD PTR [rdx+32]
$LL4@loadKmsDat:

; 618  : 	{
; 619  : 		KmsData->Datapointers[i].Pointer = (BYTE*)KmsData + LE64(KmsData->Datapointers[i].Offset);

  0014f	48 01 10	 add	 QWORD PTR [rax], rdx

; 620  : #		ifndef UNSAFE_DATA_LOAD
; 621  : 		if ((BYTE*)KmsData->Datapointers[i].Pointer > (BYTE*)KmsData + size) dataFileFormatError();

  00152	4c 39 18	 cmp	 QWORD PTR [rax], r11
  00155	0f 87 de 00 00
	00		 ja	 $LN29@loadKmsDat

; 606  : #	endif // UNSAFE_DATA_LOAD
; 607  : 
; 608  : 	KmsData->MajorVer = LE16(KmsData->MajorVer);
; 609  : 	KmsData->MinorVer = LE16(KmsData->MinorVer);
; 610  : 	KmsData->AppItemCount = LE32(KmsData->AppItemCount);
; 611  : 	KmsData->KmsItemCount = LE32(KmsData->KmsItemCount);
; 612  : 	KmsData->SkuItemCount = LE32(KmsData->SkuItemCount);
; 613  : 	KmsData->HostBuildCount = LE32(KmsData->HostBuildCount);
; 614  : 
; 615  : 	uint32_t i;
; 616  : 
; 617  : 	for (i = 0; i < vlmcsd_countof(KmsData->Datapointers); i++)

  0015b	ff c1		 inc	 ecx
  0015d	48 83 c0 08	 add	 rax, 8
  00161	83 f9 05	 cmp	 ecx, 5
  00164	72 e9		 jb	 SHORT $LL4@loadKmsDat

; 622  : #		endif // UNSAFE_DATA_LOAD
; 623  : 	}
; 624  : 
; 625  : 	for (i = 0; i < KmsData->CsvlkCount; i++)

  00166	33 c9		 xor	 ecx, ecx
  00168	38 4a 08	 cmp	 BYTE PTR [rdx+8], cl
  0016b	76 20		 jbe	 SHORT $LN6@loadKmsDat
$LL7@loadKmsDat:

; 626  : 	{
; 627  : 		PCsvlkData_t csvlkData = &KmsData->CsvlkData[i];

  0016d	8b c1		 mov	 eax, ecx
  0016f	48 c1 e0 05	 shl	 rax, 5

; 628  : 		csvlkData->EPid = (char*)KmsData + LE64(csvlkData->EPidOffset);

  00173	48 01 54 10 48	 add	 QWORD PTR [rax+rdx+72], rdx

; 629  : 		csvlkData->ReleaseDate = LE64(csvlkData->ReleaseDate);
; 630  : #		ifndef UNSAFE_DATA_LOAD
; 631  : 		if (csvlkData->EPid > (char*)KmsData + size) dataFileFormatError();

  00178	4c 39 5c 10 48	 cmp	 QWORD PTR [rax+rdx+72], r11
  0017d	0f 87 b6 00 00
	00		 ja	 $LN29@loadKmsDat

; 622  : #		endif // UNSAFE_DATA_LOAD
; 623  : 	}
; 624  : 
; 625  : 	for (i = 0; i < KmsData->CsvlkCount; i++)

  00183	0f b6 42 08	 movzx	 eax, BYTE PTR [rdx+8]
  00187	ff c1		 inc	 ecx
  00189	3b c8		 cmp	 ecx, eax
  0018b	72 e0		 jb	 SHORT $LL7@loadKmsDat
$LN6@loadKmsDat:

; 632  : #		endif // UNSAFE_DATA_LOAD
; 633  : 
; 634  : #		ifndef NO_RANDOM_EPID
; 635  : 		csvlkData->GroupId = LE32(csvlkData->GroupId);
; 636  : 		csvlkData->MinKeyId = LE32(csvlkData->MinKeyId);
; 637  : 		csvlkData->MaxKeyId = LE32(csvlkData->MaxKeyId);
; 638  : #		endif // NO_RANDOM_EPID
; 639  : 	}
; 640  : 
; 641  : 	for (i = 0; i < (uint32_t)KmsData->HostBuildCount; i++)

  0018d	45 33 c0	 xor	 r8d, r8d
  00190	44 39 42 18	 cmp	 DWORD PTR [rdx+24], r8d
  00194	76 20		 jbe	 SHORT $LN9@loadKmsDat
$LL10@loadKmsDat:

; 642  : 	{
; 643  : 		PHostBuild_t hostBuild = &KmsData->HostBuildList[i];

  00196	41 8b c8	 mov	 ecx, r8d
  00199	48 c1 e1 05	 shl	 rcx, 5
  0019d	48 03 4a 38	 add	 rcx, QWORD PTR [rdx+56]

; 644  : 		hostBuild->BuildNumber = LE32(hostBuild->BuildNumber);
; 645  : 		hostBuild->Flags = LE32(hostBuild->Flags);
; 646  : 		hostBuild->PlatformId = LE32(hostBuild->PlatformId);
; 647  : 		hostBuild->ReleaseDate = LE64(hostBuild->ReleaseDate);
; 648  : 		hostBuild->DisplayName = (char*)KmsData + LE64(hostBuild->DisplayNameOffset);

  001a1	48 01 11	 add	 QWORD PTR [rcx], rdx

; 649  : #		ifndef UNSAFE_DATA_LOAD
; 650  : 		if (hostBuild->DisplayName > (char*)KmsData + size) dataFileFormatError();

  001a4	4c 39 19	 cmp	 QWORD PTR [rcx], r11
  001a7	0f 87 8c 00 00
	00		 ja	 $LN29@loadKmsDat

; 632  : #		endif // UNSAFE_DATA_LOAD
; 633  : 
; 634  : #		ifndef NO_RANDOM_EPID
; 635  : 		csvlkData->GroupId = LE32(csvlkData->GroupId);
; 636  : 		csvlkData->MinKeyId = LE32(csvlkData->MinKeyId);
; 637  : 		csvlkData->MaxKeyId = LE32(csvlkData->MaxKeyId);
; 638  : #		endif // NO_RANDOM_EPID
; 639  : 	}
; 640  : 
; 641  : 	for (i = 0; i < (uint32_t)KmsData->HostBuildCount; i++)

  001ad	41 ff c0	 inc	 r8d
  001b0	44 3b 42 18	 cmp	 r8d, DWORD PTR [rdx+24]
  001b4	72 e0		 jb	 SHORT $LL10@loadKmsDat
$LN9@loadKmsDat:

; 651  : #		endif // UNSAFE_DATA_LOAD
; 652  : 	}
; 653  : 
; 654  : 	const uint32_t totalItemCount = KmsData->AppItemCount + KmsData->KmsItemCount + KmsData->SkuItemCount;

  001b6	44 8b 42 14	 mov	 r8d, DWORD PTR [rdx+20]
  001ba	44 03 42 10	 add	 r8d, DWORD PTR [rdx+16]
  001be	44 03 42 0c	 add	 r8d, DWORD PTR [rdx+12]

; 655  : 
; 656  : #	ifndef NO_EXTERNAL_DATA
; 657  : 	if (
; 658  : 		memcmp(KmsData->Magic, "KMD", sizeof(KmsData->Magic)) ||
; 659  : 		KmsData->MajorVer != 2
; 660  : #		ifndef UNSAFE_DATA_LOAD
; 661  : 		||

  001c2	81 3a 4b 4d 44
	00		 cmp	 DWORD PTR [rdx], 4476235 ; 00444d4bH
  001c8	75 6f		 jne	 SHORT $LN29@loadKmsDat
  001ca	66 44 39 7a 06	 cmp	 WORD PTR [rdx+6], r15w
  001cf	75 68		 jne	 SHORT $LN29@loadKmsDat
  001d1	41 8b c0	 mov	 eax, r8d
  001d4	48 c1 e0 05	 shl	 rax, 5
  001d8	48 83 c0 68	 add	 rax, 104		; 00000068H
  001dc	49 3b c1	 cmp	 rax, r9
  001df	73 58		 jae	 SHORT $LN29@loadKmsDat

; 667  : 	}
; 668  : #	endif // NO_EXTERNAL_DATA
; 669  : 
; 670  : 	for (i = 0; i < totalItemCount; i++)

  001e1	45 33 d2	 xor	 r10d, r10d
  001e4	45 85 c0	 test	 r8d, r8d
  001e7	74 3a		 je	 SHORT $LN12@loadKmsDat
  001e9	33 c9		 xor	 ecx, ecx
$LL13@loadKmsDat:

; 671  : 	{
; 672  : 		PVlmcsdData_t item = &KmsData->AppItemList[i];

  001eb	4c 8b 4a 20	 mov	 r9, QWORD PTR [rdx+32]

; 673  : 		item->Name = (char*)KmsData + LE64(item->NameOffset);

  001ef	4a 01 54 09 10	 add	 QWORD PTR [rcx+r9+16], rdx

; 674  : 
; 675  : #		ifndef UNSAFE_DATA_LOAD
; 676  : 		if (
; 677  : 			item->Name >= (char*)KmsData + (uint64_t)size ||
; 678  : 			(KmsData->AppItemCount && item->AppIndex >= KmsData->AppItemCount) ||

  001f4	4e 39 5c 09 10	 cmp	 QWORD PTR [rcx+r9+16], r11
  001f9	73 3e		 jae	 SHORT $LN29@loadKmsDat
  001fb	83 7a 0c 00	 cmp	 DWORD PTR [rdx+12], 0
  001ff	74 0b		 je	 SHORT $LN32@loadKmsDat
  00201	42 0f b6 44 09
	18		 movzx	 eax, BYTE PTR [rcx+r9+24]
  00207	3b 42 0c	 cmp	 eax, DWORD PTR [rdx+12]
  0020a	7d 2d		 jge	 SHORT $LN29@loadKmsDat
$LN32@loadKmsDat:
  0020c	42 0f b6 44 09
	19		 movzx	 eax, BYTE PTR [rcx+r9+25]
  00212	3b 42 10	 cmp	 eax, DWORD PTR [rdx+16]
  00215	7d 22		 jge	 SHORT $LN29@loadKmsDat

; 667  : 	}
; 668  : #	endif // NO_EXTERNAL_DATA
; 669  : 
; 670  : 	for (i = 0; i < totalItemCount; i++)

  00217	41 ff c2	 inc	 r10d
  0021a	48 83 c1 20	 add	 rcx, 32			; 00000020H
  0021e	45 3b d0	 cmp	 r10d, r8d
  00221	72 c8		 jb	 SHORT $LL13@loadKmsDat
$LN12@loadKmsDat:

; 679  : 			item->KmsIndex >= KmsData->KmsItemCount
; 680  : 			)
; 681  : 		{
; 682  : 			dataFileFormatError();
; 683  : 		}
; 684  : #		endif // UNSAFE_DATA_LOAD
; 685  : 	}
; 686  : }

  00223	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00228	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0022d	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00232	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00236	41 5f		 pop	 r15
  00238	c3		 ret	 0
$LN29@loadKmsDat:

; 662  : 		sizeof(VlmcsdHeader_t) + totalItemCount * sizeof(VlmcsdData_t) >= ((uint64_t)size)
; 663  : #		endif //UNSAFE_DATA_LOAD
; 664  : 		)
; 665  : 	{
; 666  : 		dataFileFormatError();

  00239	e8 00 00 00 00	 call	 dataFileFormatError
  0023e	cc		 int	 3
$LN60@loadKmsDat:

; 592  : 			if ((long)bytesRead != size) dataFileReadError();

  0023f	e8 00 00 00 00	 call	 dataFileReadError
  00244	cc		 int	 3
$LN69@loadKmsDat:

; 366  : 	if (!buf) OutOfMemory();

  00245	e8 00 00 00 00	 call	 OutOfMemory
  0024a	cc		 int	 3
$LN67@loadKmsDat:
loadKmsData ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
;	COMDAT exitOnWarningLevel
_TEXT	SEGMENT
level$dead$ = 48
exitOnWarningLevel PROC					; COMDAT

; 690  : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 691  : 	if (ExitLevel >= level)

  00004	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR ExitLevel
  0000b	3c 01		 cmp	 al, 1
  0000d	7c 18		 jl	 SHORT $LN2@exitOnWarn

; 692  : 	{
; 693  : 		printerrorf("Fatal: Exiting on warning level %i or greater\n", (int)ExitLevel);

  0000f	8b d0		 mov	 edx, eax
  00011	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CP@NEIJGKGH@Fatal?3?5Exiting?5on?5warning?5level@
  00018	e8 00 00 00 00	 call	 printerrorf

; 694  : 		exit(-1);

  0001d	83 c9 ff	 or	 ecx, -1
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00026	cc		 int	 3
$LN2@exitOnWarn:

; 695  : 	}
; 696  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
$LN4@exitOnWarn:
exitOnWarningLevel ENDP
_TEXT	ENDS
END
