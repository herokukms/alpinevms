; Listing generated by Microsoft (R) Optimizing Compiler Version 19.32.31332.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@NDMDBMPG@10?410?410?49@		; `string'
PUBLIC	??_C@_02PJNFELNH@30@				; `string'
PUBLIC	??_C@_02CEIGAHOJ@1d@				; `string'
PUBLIC	??_C@_0CH@DOIKMOID@Fatal?3?5?$CFs?5is?5not?5a?5valid?5IPv4?5a@ ; `string'
PUBLIC	??_C@_0DI@JFHCCLJH@Fatal?3?5?1?$CFs?5is?5not?5a?5valid?5CIDR?5@ ; `string'
PUBLIC	??_C@_0DB@CHHGCPLE@Fatal?3?5For?5this?5subnet?5the?5IPv4@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_0BD@FPKCLNPH@between?5?$CFs?5and?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BJ@MHDDEOLE@Registry?5read?5error?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0EO@PDNJMHLD@SYSTEM?2CurrentControlSet?2Contro@ ; `string'
PUBLIC	??_C@_0M@OCLPIPDG@ComponentId@			; `string'
PUBLIC	??_C@_07OCKMHPIG@tap0801@			; `string'
PUBLIC	??_C@_07FKBABIOD@tap0901@			; `string'
PUBLIC	??_C@_0O@LGAJAMKD@TEAMVIEWERVPN@		; `string'
PUBLIC	??_C@_0BB@BKNOGGLI@NetCfgInstanceId@		; `string'
PUBLIC	??_C@_0FB@DAALEALL@SYSTEM?2CurrentControlSet?2Contro@ ; `string'
PUBLIC	??_C@_0M@CGLKMMLF@?2Connection@			; `string'
PUBLIC	??_C@_04FABLJDN@Name@				; `string'
PUBLIC	??_C@_0M@KLEKCEEC@?2?2?4?2Global?2@		; `string'
PUBLIC	??_C@_04MFFLHGKN@?4tap@				; `string'
PUBLIC	??_C@_04PFKDJIIE@?4dgt@				; `string'
PUBLIC	??_C@_0CB@PJHCNLCC@Fatal?3?5No?5compatible?5VPN?5adapte@ ; `string'
PUBLIC	??_C@_01LKDEMHDF@s@				; `string'
PUBLIC	??_C@_0BA@KFDACIEA@?5with?5name?5?$CC?$CFs?$CC@	; `string'
PUBLIC	??_C@_0BE@BMEHODCL@?5available?5for?5use?6@	; `string'
PUBLIC	??_C@_0BO@KPKEIBCK@Fatal?3?5VPN?5adapter?5error?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0DB@GOGKGJOK@Warning?3?5VPN?5thread?5for?5device?5@ ; `string'
PUBLIC	??_C@_0CH@NAGFFDOL@Fatal?3?5Unable?5to?5start?5VPN?5thre@ ; `string'
PUBLIC	??_C@_0CB@OMLABOLI@?$CFs?5?$CFu?4?$CFu?4?$CFu?5device?5?$CC?$CFs?$CC?5started@ ; `string'
PUBLIC	??_C@_0CH@JFGMNELN@Warning?3?5IPv4?5address?5?$CFs?5not?5as@ ; `string'
PUBLIC	??_C@_0BK@BLPEDMFB@IPv4?5address?5?$CFs?5assigned?6@ ; `string'
EXTRN	__imp_RegCloseKey:PROC
EXTRN	__imp_RegQueryValueExA:PROC
EXTRN	__imp_GetIpAddrTable:PROC
EXTRN	__imp_CreateFileA:PROC
EXTRN	__imp_inet_addr:PROC
EXTRN	__imp_inet_ntoa:PROC
EXTRN	__imp_RegOpenKeyExA:PROC
EXTRN	__imp_DeviceIoControl:PROC
EXTRN	__imp_WriteFile:PROC
EXTRN	__imp_RegEnumKeyExA:PROC
EXTRN	__imp_ReadFile:PROC
;	COMDAT ??_C@_0BK@BLPEDMFB@IPv4?5address?5?$CFs?5assigned?6@
CONST	SEGMENT
??_C@_0BK@BLPEDMFB@IPv4?5address?5?$CFs?5assigned?6@ DB 'IPv4 address %s '
	DB	'assigned', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JFGMNELN@Warning?3?5IPv4?5address?5?$CFs?5not?5as@
CONST	SEGMENT
??_C@_0CH@JFGMNELN@Warning?3?5IPv4?5address?5?$CFs?5not?5as@ DB 'Warning:'
	DB	' IPv4 address %s not assigned', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OMLABOLI@?$CFs?5?$CFu?4?$CFu?4?$CFu?5device?5?$CC?$CFs?$CC?5started@
CONST	SEGMENT
??_C@_0CB@OMLABOLI@?$CFs?5?$CFu?4?$CFu?4?$CFu?5device?5?$CC?$CFs?$CC?5started@ DB '%'
	DB	's %u.%u.%u device "%s" started', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NAGFFDOL@Fatal?3?5Unable?5to?5start?5VPN?5thre@
CONST	SEGMENT
??_C@_0CH@NAGFFDOL@Fatal?3?5Unable?5to?5start?5VPN?5thre@ DB 'Fatal: Unab'
	DB	'le to start VPN thread: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GOGKGJOK@Warning?3?5VPN?5thread?5for?5device?5@
CONST	SEGMENT
??_C@_0DB@GOGKGJOK@Warning?3?5VPN?5thread?5for?5device?5@ DB 'Warning: VP'
	DB	'N thread for device "%s" exiting: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KPKEIBCK@Fatal?3?5VPN?5adapter?5error?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BO@KPKEIBCK@Fatal?3?5VPN?5adapter?5error?3?5?$CFs?6@ DB 'Fatal: VP'
	DB	'N adapter error: %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BMEHODCL@?5available?5for?5use?6@
CONST	SEGMENT
??_C@_0BE@BMEHODCL@?5available?5for?5use?6@ DB ' available for use', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KFDACIEA@?5with?5name?5?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_0BA@KFDACIEA@?5with?5name?5?$CC?$CFs?$CC@ DB ' with name "%s"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s@
CONST	SEGMENT
??_C@_01LKDEMHDF@s@ DB 's', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PJHCNLCC@Fatal?3?5No?5compatible?5VPN?5adapte@
CONST	SEGMENT
??_C@_0CB@PJHCNLCC@Fatal?3?5No?5compatible?5VPN?5adapte@ DB 'Fatal: No co'
	DB	'mpatible VPN adapter', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PFKDJIIE@?4dgt@
CONST	SEGMENT
??_C@_04PFKDJIIE@?4dgt@ DB '.dgt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MFFLHGKN@?4tap@
CONST	SEGMENT
??_C@_04MFFLHGKN@?4tap@ DB '.tap', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KLEKCEEC@?2?2?4?2Global?2@
CONST	SEGMENT
??_C@_0M@KLEKCEEC@?2?2?4?2Global?2@ DB '\\.\Global\', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04FABLJDN@Name@
CONST	SEGMENT
??_C@_04FABLJDN@Name@ DB 'Name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CGLKMMLF@?2Connection@
CONST	SEGMENT
??_C@_0M@CGLKMMLF@?2Connection@ DB '\Connection', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@DAALEALL@SYSTEM?2CurrentControlSet?2Contro@
CONST	SEGMENT
??_C@_0FB@DAALEALL@SYSTEM?2CurrentControlSet?2Contro@ DB 'SYSTEM\CurrentC'
	DB	'ontrolSet\Control\Network\{4D36E972-E325-11CE-BFC1-08002BE103'
	DB	'18}\', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BKNOGGLI@NetCfgInstanceId@
CONST	SEGMENT
??_C@_0BB@BKNOGGLI@NetCfgInstanceId@ DB 'NetCfgInstanceId', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LGAJAMKD@TEAMVIEWERVPN@
CONST	SEGMENT
??_C@_0O@LGAJAMKD@TEAMVIEWERVPN@ DB 'TEAMVIEWERVPN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FKBABIOD@tap0901@
CONST	SEGMENT
??_C@_07FKBABIOD@tap0901@ DB 'tap0901', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OCKMHPIG@tap0801@
CONST	SEGMENT
??_C@_07OCKMHPIG@tap0801@ DB 'tap0801', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OCLPIPDG@ComponentId@
CONST	SEGMENT
??_C@_0M@OCLPIPDG@ComponentId@ DB 'ComponentId', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@PDNJMHLD@SYSTEM?2CurrentControlSet?2Contro@
CONST	SEGMENT
??_C@_0EO@PDNJMHLD@SYSTEM?2CurrentControlSet?2Contro@ DB 'SYSTEM\CurrentC'
	DB	'ontrolSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002BE10318'
	DB	'}', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MHDDEOLE@Registry?5read?5error?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BJ@MHDDEOLE@Registry?5read?5error?3?5?$CFs?6@ DB 'Registry read er'
	DB	'ror: %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FPKCLNPH@between?5?$CFs?5and?5?$CFs?6@
CONST	SEGMENT
??_C@_0BD@FPKCLNPH@between?5?$CFs?5and?5?$CFs?6@ DB 'between %s and %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@CHHGCPLE@Fatal?3?5For?5this?5subnet?5the?5IPv4@
CONST	SEGMENT
??_C@_0DB@CHHGCPLE@Fatal?3?5For?5this?5subnet?5the?5IPv4@ DB 'Fatal: For '
	DB	'this subnet the IPv4 address must be ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@JFHCCLJH@Fatal?3?5?1?$CFs?5is?5not?5a?5valid?5CIDR?5@
CONST	SEGMENT
??_C@_0DI@JFHCCLJH@Fatal?3?5?1?$CFs?5is?5not?5a?5valid?5CIDR?5@ DB 'Fatal'
	DB	': /%s is not a valid CIDR mask between /8 and /30', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DOIKMOID@Fatal?3?5?$CFs?5is?5not?5a?5valid?5IPv4?5a@
CONST	SEGMENT
??_C@_0CH@DOIKMOID@Fatal?3?5?$CFs?5is?5not?5a?5valid?5IPv4?5a@ DB 'Fatal:'
	DB	' %s is not a valid IPv4 address', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02CEIGAHOJ@1d@
CONST	SEGMENT
??_C@_02CEIGAHOJ@1d@ DB '1d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PJNFELNH@30@
CONST	SEGMENT
??_C@_02PJNFELNH@30@ DB '30', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NDMDBMPG@10?410?410?49@
CONST	SEGMENT
??_C@_0L@NDMDBMPG@10?410?410?49@ DB '10.10.10.9', 00H	; `string'
PUBLIC	startTap
	ALIGN	4

IpAddress DD	01H DUP (?)
Mtu	DD	01H DUP (?)
	ALIGN	8

ActiveTapName DQ 01H DUP (?)
IpPacket DQ	01H DUP (?)
Mask	DD	01H DUP (?)
	ALIGN	8

TapHandle DQ	01H DUP (?)
AdapterClass DQ	01H DUP (?)
szTapName DQ	01H DUP (?)
DriverVersion DB 010H DUP (?)
Cidr	DB	01H DUP (?)
	ALIGN	4

DhcpLeaseDuration DD 01H DUP (?)
Broadcast DD	01H DUP (?)
Network	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TapMirror DD imagerel TapMirror
	DD	imagerel TapMirror+178
	DD	imagerel $unwind$TapMirror
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DevCtl DD imagerel DevCtl
	DD	imagerel DevCtl+107
	DD	imagerel $unwind$DevCtl
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$OpenTapHandle DD imagerel OpenTapHandle
	DD	imagerel OpenTapHandle+1218
	DD	imagerel $unwind$OpenTapHandle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$WinErrorExit DD imagerel WinErrorExit
	DD	imagerel WinErrorExit+37
	DD	imagerel $unwind$WinErrorExit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$parseTapArgument DD imagerel parseTapArgument
	DD	imagerel parseTapArgument+514
	DD	imagerel $unwind$parseTapArgument
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$isAddressAssigned DD imagerel isAddressAssigned
	DD	imagerel isAddressAssigned+222
	DD	imagerel $unwind$isAddressAssigned
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$startTap DD imagerel $LN25
	DD	imagerel $LN25+492
	DD	imagerel $unwind$startTap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$startTap DD 020a01H
	DD	03006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$isAddressAssigned DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parseTapArgument DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WinErrorExit DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OpenTapHandle DD 091a01H
	DD	08a011aH
	DD	0e009f00bH
	DD	07005c007H
	DD	030036004H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DevCtl DD 020c01H
	DD	03008720cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TapMirror DD 020601H
	DD	030025206H
	ORG $+4
szMask	DQ	FLAT:??_C@_02PJNFELNH@30@
szIpAddress DQ	FLAT:??_C@_0L@NDMDBMPG@10?410?410?49@
szLeaseDuration DQ FLAT:??_C@_02CEIGAHOJ@1d@
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c
;	COMDAT startTap
_TEXT	SEGMENT
tapTunCfg$ = 48
tapDhcpCfg$ = 64
argument$dead$ = 96
isCableConnected$ = 96
startTap PROC						; COMDAT

; 306  : {

$LN25:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR tapArgument

; 307  : 	if (!strcmp(argument, "-")) return;

  00011	80 39 2d	 cmp	 BYTE PTR [rcx], 45	; 0000002dH
  00014	75 0a		 jne	 SHORT $LN19@startTap
  00016	80 79 01 00	 cmp	 BYTE PTR [rcx+1], 0
  0001a	0f 84 ab 01 00
	00		 je	 $LN8@startTap
$LN19@startTap:

; 308  : 	parseTapArgument(argument);

  00020	e8 00 00 00 00	 call	 parseTapArgument

; 309  : 
; 310  : 	TapHandle = OpenTapHandle();

  00025	e8 00 00 00 00	 call	 OpenTapHandle

; 311  : 
; 312  : 	// Get MTU and driver version
; 313  : 	DevCtl(TAP_WIN_IOCTL_GET_MTU, &Mtu, sizeof(Mtu));

  0002a	41 b8 04 00 00
	00		 mov	 r8d, 4
  00030	48 89 05 00 00
	00 00		 mov	 QWORD PTR TapHandle, rax
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Mtu
  0003e	b9 0c 00 22 00	 mov	 ecx, 2228236		; 0022000cH
  00043	e8 00 00 00 00	 call	 DevCtl

; 314  : 	DevCtl(TAP_WIN_IOCTL_GET_VERSION, &DriverVersion, sizeof(DriverVersion));

  00048	bb 10 00 00 00	 mov	 ebx, 16
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:DriverVersion
  00054	44 8b c3	 mov	 r8d, ebx
  00057	b9 08 00 22 00	 mov	 ecx, 2228232		; 00220008H
  0005c	e8 00 00 00 00	 call	 DevCtl

; 315  : 
; 316  : 	// Configure TUN mode
; 317  : 	TapConfigTun_t tapTunCfg;
; 318  : 	tapTunCfg.Address.s_addr = BE32(IpAddress);

  00061	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR IpAddress

; 319  : 	tapTunCfg.Network.s_addr = BE32(Network);
; 320  : 	tapTunCfg.Mask.s_addr = BE32(Mask);
; 321  : 	DevCtl(TAP_WIN_IOCTL_CONFIG_TUN, &tapTunCfg, sizeof(tapTunCfg));

  00067	44 8d 43 fc	 lea	 r8d, QWORD PTR [rbx-4]
  0006b	0f c8		 bswap	 eax
  0006d	89 44 24 30	 mov	 DWORD PTR tapTunCfg$[rsp], eax
  00071	48 8d 54 24 30	 lea	 rdx, QWORD PTR tapTunCfg$[rsp]
  00076	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Network
  0007c	b9 28 00 22 00	 mov	 ecx, 2228264		; 00220028H
  00081	0f c8		 bswap	 eax
  00083	89 44 24 34	 mov	 DWORD PTR tapTunCfg$[rsp+4], eax
  00087	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Mask
  0008d	0f c8		 bswap	 eax
  0008f	89 44 24 38	 mov	 DWORD PTR tapTunCfg$[rsp+8], eax
  00093	e8 00 00 00 00	 call	 DevCtl

; 322  : 
; 323  : 	// Setup the drivers internal DHCP server
; 324  : 	TapConfigDhcp_t tapDhcpCfg;
; 325  : 	tapDhcpCfg.Address.s_addr = BE32(IpAddress);

  00098	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR IpAddress

; 326  : 	tapDhcpCfg.Mask.s_addr = BE32(Mask);
; 327  : 	tapDhcpCfg.DhcpServer.s_addr = BE32(IpAddress + 1);
; 328  : 	tapDhcpCfg.LeaseDuration = DhcpLeaseDuration;
; 329  : 	DevCtl(TAP_WIN_IOCTL_CONFIG_DHCP_MASQ, &tapDhcpCfg, sizeof(tapDhcpCfg));

  0009e	48 8d 54 24 40	 lea	 rdx, QWORD PTR tapDhcpCfg$[rsp]
  000a3	8b c1		 mov	 eax, ecx
  000a5	44 8b c3	 mov	 r8d, ebx
  000a8	0f c8		 bswap	 eax
  000aa	89 44 24 40	 mov	 DWORD PTR tapDhcpCfg$[rsp], eax
  000ae	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Mask
  000b4	0f c8		 bswap	 eax
  000b6	89 44 24 44	 mov	 DWORD PTR tapDhcpCfg$[rsp+4], eax
  000ba	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  000bd	0f c8		 bswap	 eax
  000bf	89 44 24 48	 mov	 DWORD PTR tapDhcpCfg$[rsp+8], eax
  000c3	b9 1c 00 22 00	 mov	 ecx, 2228252		; 0022001cH
  000c8	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DhcpLeaseDuration
  000ce	89 44 24 4c	 mov	 DWORD PTR tapDhcpCfg$[rsp+12], eax
  000d2	e8 00 00 00 00	 call	 DevCtl

; 330  : 
; 331  : 	// Connect the virtual network cable
; 332  : 	BOOL isCableConnected = TRUE;
; 333  : 	DevCtl(TAP_WIN_IOCTL_SET_MEDIA_STATUS, &isCableConnected, sizeof(isCableConnected));

  000d7	44 8d 43 f4	 lea	 r8d, QWORD PTR [rbx-12]
  000db	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR isCableConnected$[rsp], 1
  000e3	48 8d 54 24 60	 lea	 rdx, QWORD PTR isCableConnected$[rsp]
  000e8	b9 18 00 22 00	 mov	 ecx, 2228248		; 00220018H
  000ed	e8 00 00 00 00	 call	 DevCtl

; 334  : 
; 335  : 	// Allocate buffer and start mirror thread
; 336  : 	IpPacket = (IpPacket_t*)vlmcsd_malloc(Mtu);

  000f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR Mtu
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 366  : 	if (!buf) OutOfMemory();

  000fe	48 85 c0	 test	 rax, rax
  00101	0f 84 df 00 00
	00		 je	 $LN24@startTap
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c

; 337  : 	HANDLE threadHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)TapMirror, NULL, 0, NULL);

  00107	48 83 64 24 28
	00		 and	 QWORD PTR [rsp+40], 0
  0010d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:TapMirror
  00114	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  00119	45 33 c9	 xor	 r9d, r9d
  0011c	33 d2		 xor	 edx, edx
  0011e	48 89 05 00 00
	00 00		 mov	 QWORD PTR IpPacket, rax
  00125	33 c9		 xor	 ecx, ecx
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateThread

; 338  : 
; 339  : 	if (!threadHandle)

  0012d	48 85 c0	 test	 rax, rax
  00130	75 27		 jne	 SHORT $LN6@startTap

; 340  : 	{
; 341  : 		DWORD error = GetLastError();

  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 342  : 		printerrorf("Fatal: Unable to start VPN thread: %s\n", win_strerror(error));

  00138	8b c8		 mov	 ecx, eax
  0013a	8b d8		 mov	 ebx, eax
  0013c	e8 00 00 00 00	 call	 win_strerror
  00141	48 8b d0	 mov	 rdx, rax
  00144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@NAGFFDOL@Fatal?3?5Unable?5to?5start?5VPN?5thre@
  0014b	e8 00 00 00 00	 call	 printerrorf

; 343  : 		exit(error);

  00150	8b cb		 mov	 ecx, ebx
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00158	cc		 int	 3
$LN6@startTap:

; 344  : 	}
; 345  : 
; 346  : 	CloseHandle(threadHandle);

  00159	48 8b c8	 mov	 rcx, rax
  0015c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 347  : 
; 348  : #	ifndef NO_LOG
; 349  : 	logger("%s %u.%u.%u device \"%s\" started\n", AdapterClass, DriverVersion.Major, DriverVersion.Minor, DriverVersion.Build, ActiveTapName);

  00162	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ActiveTapName
  00169	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@OMLABOLI@?$CFs?5?$CFu?4?$CFu?4?$CFu?5device?5?$CC?$CFs?$CC?5started@
  00170	44 8b 0d 04 00
	00 00		 mov	 r9d, DWORD PTR DriverVersion+4
  00177	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR DriverVersion
  0017e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR AdapterClass
  00185	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0018a	8b 05 08 00 00
	00		 mov	 eax, DWORD PTR DriverVersion+8
  00190	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00194	e8 00 00 00 00	 call	 logger

; 350  : #	endif // NO_LOG
; 351  : 
; 352  : 	DWORD i;
; 353  : 	BOOL isAssigned;
; 354  : 
; 355  : 	// Wait up to 4 seconds until the IP address is up and running
; 356  : 	// so vlmcsd can actually bind to and listen on it
; 357  : 	for (i = 0; !((isAssigned = isAddressAssigned())) && i < 20; i++) Sleep(200);

  00199	33 db		 xor	 ebx, ebx
  0019b	eb 12		 jmp	 SHORT $LN22@startTap
$LL4@startTap:
  0019d	83 fb 14	 cmp	 ebx, 20
  001a0	73 2f		 jae	 SHORT $LN18@startTap
  001a2	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
  001a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep
  001ad	ff c3		 inc	 ebx
$LN22@startTap:
  001af	e8 00 00 00 00	 call	 isAddressAssigned
  001b4	85 c0		 test	 eax, eax
  001b6	74 e5		 je	 SHORT $LL4@startTap

; 363  : 	else
; 364  : 	{
; 365  : #		ifndef NO_LOG
; 366  : 		logger("IPv4 address %s assigned\n", szIpAddress);

  001b8	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR szIpAddress
  001bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BLPEDMFB@IPv4?5address?5?$CFs?5assigned?6@
  001c6	e8 00 00 00 00	 call	 logger
$LN8@startTap:

; 369  : }

  001cb	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001cf	5b		 pop	 rbx
  001d0	c3		 ret	 0
$LN18@startTap:

; 358  : 
; 359  : 	if (!isAssigned)
; 360  : 	{
; 361  : 		printerrorf("Warning: IPv4 address %s not assigned\n", szIpAddress);

  001d1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR szIpAddress
  001d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@JFGMNELN@Warning?3?5IPv4?5address?5?$CFs?5not?5as@
  001df	e8 00 00 00 00	 call	 printerrorf

; 362  : 	}

  001e4	eb e5		 jmp	 SHORT $LN8@startTap
$LN24@startTap:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 366  : 	if (!buf) OutOfMemory();

  001e6	e8 00 00 00 00	 call	 OutOfMemory
  001eb	cc		 int	 3
$LN20@startTap:
startTap ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c
;	COMDAT isAddressAssigned
_TEXT	SEGMENT
dwSize$ = 48
isAddressAssigned PROC					; COMDAT

; 39   : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 40   : 	PMIB_IPADDRTABLE pIPAddrTable;
; 41   : 	DWORD dwSize = 0;

  0000f	33 ff		 xor	 edi, edi
  00011	89 7c 24 30	 mov	 DWORD PTR dwSize$[rsp], edi
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  00015	8d 4f 1c	 lea	 ecx, QWORD PTR [rdi+28]
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0001e	48 8b f0	 mov	 rsi, rax

; 366  : 	if (!buf) OutOfMemory();

  00021	48 85 c0	 test	 rax, rax
  00024	0f 84 ae 00 00
	00		 je	 $LN21@isAddressA
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c

; 45   : 	const DWORD status = GetIpAddrTable(pIPAddrTable, &dwSize, 0);

  0002a	45 33 c0	 xor	 r8d, r8d
  0002d	48 8d 54 24 30	 lea	 rdx, QWORD PTR dwSize$[rsp]
  00032	48 8b c8	 mov	 rcx, rax
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetIpAddrTable

; 46   : 	free(pIPAddrTable);

  0003b	48 8b ce	 mov	 rcx, rsi
  0003e	8b d8		 mov	 ebx, eax
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 47   : 
; 48   : 	if (status != ERROR_INSUFFICIENT_BUFFER) return FALSE;

  00046	83 fb 7a	 cmp	 ebx, 122		; 0000007aH
  00049	74 12		 je	 SHORT $LN5@isAddressA
$LN25@isAddressA:

; 72   : }

  0004b	33 c0		 xor	 eax, eax
$LN1@isAddressA:
  0004d	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00052	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00057	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005b	5f		 pop	 rdi
  0005c	c3		 ret	 0
$LN5@isAddressA:

; 49   : 	pIPAddrTable = (MIB_IPADDRTABLE *)vlmcsd_malloc(dwSize);

  0005d	8b 4c 24 30	 mov	 ecx, DWORD PTR dwSize$[rsp]
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 365  : 	void* buf = malloc(len);

  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00067	48 8b d8	 mov	 rbx, rax

; 366  : 	if (!buf) OutOfMemory();

  0006a	48 85 c0	 test	 rax, rax
  0006d	74 69		 je	 SHORT $LN21@isAddressA
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c

; 51   : 	if (GetIpAddrTable(pIPAddrTable, &dwSize, 0))

  0006f	45 33 c0	 xor	 r8d, r8d
  00072	48 8d 54 24 30	 lea	 rdx, QWORD PTR dwSize$[rsp]
  00077	48 8b c8	 mov	 rcx, rax
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetIpAddrTable
  00080	85 c0		 test	 eax, eax
  00082	74 0b		 je	 SHORT $LN6@isAddressA

; 52   : 	{
; 53   : 		free(pIPAddrTable);

  00084	48 8b cb	 mov	 rcx, rbx
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 54   : 		return FALSE;

  0008d	eb bc		 jmp	 SHORT $LN25@isAddressA
$LN6@isAddressA:

; 55   : 	}
; 56   : 
; 57   : 	PMIB_IPADDRROW row;
; 58   : 	for (row = pIPAddrTable->table; row < pIPAddrTable->table + pIPAddrTable->dwNumEntries; row++)

  0008f	8b 03		 mov	 eax, DWORD PTR [rbx]
  00091	4c 8d 43 04	 lea	 r8, QWORD PTR [rbx+4]
  00095	48 8d 53 04	 lea	 rdx, QWORD PTR [rbx+4]
  00099	48 8d 0c 40	 lea	 rcx, QWORD PTR [rax+rax*2]
  0009d	4d 8d 04 c8	 lea	 r8, QWORD PTR [r8+rcx*8]
  000a1	49 3b d0	 cmp	 rdx, r8
  000a4	73 22		 jae	 SHORT $LN23@isAddressA
  000a6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR IpAddress
  000ac	0f c8		 bswap	 eax
$LL4@isAddressA:

; 59   : 	{
; 60   : 		if (
; 61   : 			row->dwAddr == BE32(IpAddress) &&

  000ae	39 02		 cmp	 DWORD PTR [rdx], eax
  000b0	75 06		 jne	 SHORT $LN2@isAddressA
  000b2	f6 42 16 c8	 test	 BYTE PTR [rdx+22], 200	; 000000c8H
  000b6	74 0b		 je	 SHORT $LN17@isAddressA
$LN2@isAddressA:

; 55   : 	}
; 56   : 
; 57   : 	PMIB_IPADDRROW row;
; 58   : 	for (row = pIPAddrTable->table; row < pIPAddrTable->table + pIPAddrTable->dwNumEntries; row++)

  000b8	48 83 c2 18	 add	 rdx, 24
  000bc	49 3b d0	 cmp	 rdx, r8
  000bf	73 07		 jae	 SHORT $LN23@isAddressA
  000c1	eb eb		 jmp	 SHORT $LL4@isAddressA
$LN17@isAddressA:

; 62   : 			!(row->wType & (MIB_IPADDR_DELETED | MIB_IPADDR_DISCONNECTED | MIB_IPADDR_TRANSIENT))
; 63   : 			)
; 64   : 		{
; 65   : 			result = TRUE;

  000c3	bf 01 00 00 00	 mov	 edi, 1
$LN23@isAddressA:

; 66   : 			break;
; 67   : 		}
; 68   : 	}
; 69   : 
; 70   : 	free(pIPAddrTable);

  000c8	48 8b cb	 mov	 rcx, rbx
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 71   : 	return result;

  000d1	8b c7		 mov	 eax, edi
  000d3	e9 75 ff ff ff	 jmp	 $LN1@isAddressA
$LN21@isAddressA:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 366  : 	if (!buf) OutOfMemory();

  000d8	e8 00 00 00 00	 call	 OutOfMemory
  000dd	cc		 int	 3
$LN24@isAddressA:
isAddressAssigned ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c
;	COMDAT parseTapArgument
_TEXT	SEGMENT
next$ = 48
argument$ = 48
parseTapArgument PROC					; COMDAT

; 76   : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 77   : 	char* equalSignPosition = strchr(argument, (int)'=');

  00014	ba 3d 00 00 00	 mov	 edx, 61			; 0000003dH
  00019	48 8b d9	 mov	 rbx, rcx
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr

; 78   : 	char* slashPosition = strchr(argument, (int)'/');

  00022	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  00027	48 8b cb	 mov	 rcx, rbx
  0002a	48 8b f0	 mov	 rsi, rax
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr

; 79   : 	char* colonPosition = strchr(argument, (int)':');

  00033	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  00038	48 8b cb	 mov	 rcx, rbx
  0003b	48 8b f8	 mov	 rdi, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr

; 80   : 
; 81   : 	szTapName = argument;
; 82   : 
; 83   : 	if (equalSignPosition)

  00044	33 ed		 xor	 ebp, ebp
  00046	48 89 1d 00 00
	00 00		 mov	 QWORD PTR szTapName, rbx
  0004d	48 8b d0	 mov	 rdx, rax
  00050	48 85 f6	 test	 rsi, rsi
  00053	74 10		 je	 SHORT $LN14@parseTapAr

; 84   : 	{
; 85   : 		*equalSignPosition = 0;
; 86   : 		szIpAddress = equalSignPosition + 1;

  00055	48 8d 4e 01	 lea	 rcx, QWORD PTR [rsi+1]
  00059	40 88 2e	 mov	 BYTE PTR [rsi], bpl
  0005c	48 89 0d 00 00
	00 00		 mov	 QWORD PTR szIpAddress, rcx
  00063	eb 07		 jmp	 SHORT $LN2@parseTapAr
$LN14@parseTapAr:

; 80   : 
; 81   : 	szTapName = argument;
; 82   : 
; 83   : 	if (equalSignPosition)

  00065	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR szIpAddress
$LN2@parseTapAr:

; 87   : 	}
; 88   : 
; 89   : 	if (slashPosition)

  0006c	48 85 ff	 test	 rdi, rdi
  0006f	74 0e		 je	 SHORT $LN3@parseTapAr

; 90   : 	{
; 91   : 		*slashPosition = 0;
; 92   : 		szMask = slashPosition + 1;

  00071	48 8d 47 01	 lea	 rax, QWORD PTR [rdi+1]
  00075	40 88 2f	 mov	 BYTE PTR [rdi], bpl
  00078	48 89 05 00 00
	00 00		 mov	 QWORD PTR szMask, rax
$LN3@parseTapAr:

; 93   : 	}
; 94   : 
; 95   : 	if (colonPosition)

  0007f	48 85 d2	 test	 rdx, rdx
  00082	74 0e		 je	 SHORT $LN4@parseTapAr

; 96   : 	{
; 97   : 		*colonPosition = 0;
; 98   : 		szLeaseDuration = colonPosition + 1;

  00084	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  00088	40 88 2a	 mov	 BYTE PTR [rdx], bpl
  0008b	48 89 05 00 00
	00 00		 mov	 QWORD PTR szLeaseDuration, rax
$LN4@parseTapAr:

; 99   : 	}
; 100  : 
; 101  : 	IpAddress = BE32(inet_addr(szIpAddress));

  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_addr
  00098	0f c8		 bswap	 eax
  0009a	83 cb ff	 or	 ebx, -1			; ffffffffH
  0009d	89 05 00 00 00
	00		 mov	 DWORD PTR IpAddress, eax
  000a3	3b c3		 cmp	 eax, ebx

; 102  : 
; 103  : 	if (IpAddress == BE32(INADDR_NONE))

  000a5	75 1f		 jne	 SHORT $LN5@parseTapAr

; 104  : 	{
; 105  : 		printerrorf("Fatal: %s is not a valid IPv4 address\n", szIpAddress);

  000a7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR szIpAddress
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@DOIKMOID@Fatal?3?5?$CFs?5is?5not?5a?5valid?5IPv4?5a@
  000b5	e8 00 00 00 00	 call	 printerrorf

; 106  : 		exit(VLMCSD_EINVAL);

  000ba	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  000c5	cc		 int	 3
$LN5@parseTapAr:

; 107  : 	}
; 108  : 
; 109  : 	char* next;
; 110  : 	Cidr = (uint8_t)strtol(szMask, &next, 10);

  000c6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR szMask
  000cd	48 8d 54 24 30	 lea	 rdx, QWORD PTR next$[rsp]
  000d2	41 b8 0a 00 00
	00		 mov	 r8d, 10
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtol

; 111  : 
; 112  : 	if (*next || Cidr < 8 || Cidr > 30)

  000de	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  000e3	88 05 00 00 00
	00		 mov	 BYTE PTR Cidr, al
  000e9	40 38 29	 cmp	 BYTE PTR [rcx], bpl
  000ec	0f 85 dc 00 00
	00		 jne	 $LN7@parseTapAr
  000f2	2c 08		 sub	 al, 8
  000f4	3c 16		 cmp	 al, 22
  000f6	0f 87 d2 00 00
	00		 ja	 $LN7@parseTapAr

; 116  : 	}
; 117  : 
; 118  : 	if (!((DhcpLeaseDuration = timeSpanString2Seconds(szLeaseDuration))))

  000fc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR szLeaseDuration
  00103	e8 00 00 00 00	 call	 timeSpanString2Seconds
  00108	89 05 00 00 00
	00		 mov	 DWORD PTR DhcpLeaseDuration, eax
  0010e	85 c0		 test	 eax, eax
  00110	75 1b		 jne	 SHORT $LN8@parseTapAr

; 119  : 	{
; 120  : 		printerrorf("Fatal: No valid time span specified in option -%c.\n", 'O');

  00112	8d 50 4f	 lea	 edx, QWORD PTR [rax+79]
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DE@FKNLKBBJ@Fatal?3?5No?5valid?5time?5span?5speci@
  0011c	e8 00 00 00 00	 call	 printerrorf

; 121  : 		exit(VLMCSD_EINVAL);

  00121	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0012c	cc		 int	 3
$LN8@parseTapAr:

; 122  : 	}
; 123  : 
; 124  : 	Mask = (uint32_t)~(0xffffffff >> Cidr);

  0012d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR IpAddress
  00133	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR Cidr
  00139	d3 eb		 shr	 ebx, cl
  0013b	8b fb		 mov	 edi, ebx

; 125  : 	Network = IpAddress & Mask;
; 126  : 	Broadcast = IpAddress | ~Mask;

  0013d	0b d8		 or	 ebx, eax
  0013f	f7 d7		 not	 edi
  00141	89 1d 00 00 00
	00		 mov	 DWORD PTR Broadcast, ebx
  00147	89 3d 00 00 00
	00		 mov	 DWORD PTR Mask, edi
  0014d	23 f8		 and	 edi, eax
  0014f	89 3d 00 00 00
	00		 mov	 DWORD PTR Network, edi
  00155	3b c7		 cmp	 eax, edi

; 127  : 	DhcpServer = IpAddress + 1;
; 128  : 
; 129  : 	if (IpAddress <= Network || IpAddress + 1 >= Broadcast)

  00157	76 0a		 jbe	 SHORT $LN10@parseTapAr
  00159	ff c0		 inc	 eax
  0015b	3b c3		 cmp	 eax, ebx
  0015d	0f 82 8a 00 00
	00		 jb	 $LN9@parseTapAr
$LN10@parseTapAr:

; 130  : 	{
; 131  : 		uint32_t lowerIpBE = BE32(Network + 1);

  00163	ff c7		 inc	 edi
  00165	83 c3 fe	 add	 ebx, -2			; fffffffeH
  00168	0f cf		 bswap	 edi

; 132  : 		uint32_t upperIpBE = BE32(Broadcast - 2);
; 133  : 		const char* szLower = vlmcsd_strdup(inet_ntoa(*(struct in_addr*)&lowerIpBE));

  0016a	8b cf		 mov	 ecx, edi
  0016c	0f cb		 bswap	 ebx
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  00174	48 8b c8	 mov	 rcx, rax
  00177	e8 00 00 00 00	 call	 vlmcsd_strdup

; 134  : 		const char* szUpper = vlmcsd_strdup(inet_ntoa(*(struct in_addr*)&upperIpBE));

  0017c	8b cb		 mov	 ecx, ebx
  0017e	48 8b f0	 mov	 rsi, rax
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  00187	48 8b c8	 mov	 rcx, rax
  0018a	e8 00 00 00 00	 call	 vlmcsd_strdup

; 135  : 
; 136  : 		printerrorf("Fatal: For this subnet the IPv4 address must be ");

  0018f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@CHHGCPLE@Fatal?3?5For?5this?5subnet?5the?5IPv4@
  00196	48 8b e8	 mov	 rbp, rax
  00199	e8 00 00 00 00	 call	 printerrorf

; 137  : 
; 138  : 		if (lowerIpBE == upperIpBE)

  0019e	48 8b d6	 mov	 rdx, rsi
  001a1	3b fb		 cmp	 edi, ebx
  001a3	75 0e		 jne	 SHORT $LN11@parseTapAr

; 139  : 		{
; 140  : 			printerrorf("%s\n", szLower);

  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03OFAPEBGM@?$CFs?6@
  001ac	e8 00 00 00 00	 call	 printerrorf

; 141  : 		}

  001b1	eb 0f		 jmp	 SHORT $LN12@parseTapAr
$LN11@parseTapAr:

; 142  : 		else
; 143  : 		{
; 144  : 			printerrorf("between %s and %s\n", szLower, szUpper);

  001b3	4c 8b c5	 mov	 r8, rbp
  001b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@FPKCLNPH@between?5?$CFs?5and?5?$CFs?6@
  001bd	e8 00 00 00 00	 call	 printerrorf
$LN12@parseTapAr:

; 145  : 		}
; 146  : 
; 147  : 		exit(VLMCSD_EINVAL);

  001c2	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  001c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  001cd	cc		 int	 3
$LN7@parseTapAr:

; 113  : 	{
; 114  : 		printerrorf("Fatal: /%s is not a valid CIDR mask between /8 and /30\n", szMask);

  001ce	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR szMask
  001d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DI@JFHCCLJH@Fatal?3?5?1?$CFs?5is?5not?5a?5valid?5CIDR?5@
  001dc	e8 00 00 00 00	 call	 printerrorf

; 115  : 		exit(VLMCSD_EINVAL);

  001e1	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  001ec	cc		 int	 3
$LN9@parseTapAr:

; 148  : 	}
; 149  : }

  001ed	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  001f2	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  001f7	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  001fc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00200	5f		 pop	 rdi
  00201	c3		 ret	 0
$LN15@parseTapAr:
parseTapArgument ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c
;	COMDAT WinErrorExit
_TEXT	SEGMENT
error$ = 48
WinErrorExit PROC					; COMDAT

; 153  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b d9		 mov	 ebx, ecx

; 154  : 	printerrorf("Registry read error: %s\n", win_strerror((int)error));

  00008	e8 00 00 00 00	 call	 win_strerror
  0000d	48 8b d0	 mov	 rdx, rax
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@MHDDEOLE@Registry?5read?5error?3?5?$CFs?6@
  00017	e8 00 00 00 00	 call	 printerrorf

; 155  : 	exit(error);

  0001c	8b cb		 mov	 ecx, ebx
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00024	cc		 int	 3
$LN3@WinErrorEx:
WinErrorExit ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c
;	COMDAT OpenTapHandle
_TEXT	SEGMENT
regSubKey$1 = 64
connectionKey$2 = 72
deviceName$3 = 80
regData$4 = 336
connectionKeyName$5 = 592
subKeyName$ = 848
regDataSize$6 = 1168
type$7 = 1176
subKeySize$ = 1184
regAdapterKey$ = 1192
OpenTapHandle PROC					; COMDAT

; 160  : {

  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 56		 push	 r14
  00009	41 57		 push	 r15
  0000b	48 8d ac 24 b0
	fc ff ff	 lea	 rbp, QWORD PTR [rsp-848]
  00013	48 81 ec 50 04
	00 00		 sub	 rsp, 1104		; 00000450H

; 161  : 	HANDLE handle = INVALID_HANDLE_VALUE;
; 162  : 	HKEY regAdapterKey;
; 163  : 	DWORD regResult;
; 164  : 	if ((regResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, ADAPTER_KEY, 0, KEY_READ | KEY_WOW64_64KEY, &regAdapterKey)) != ERROR_SUCCESS)

  0001a	48 8d 85 a8 03
	00 00		 lea	 rax, QWORD PTR regAdapterKey$[rbp-256]
  00021	49 83 cf ff	 or	 r15, -1
  00025	41 b9 19 01 02
	00		 mov	 r9d, 131353		; 00020119H
  0002b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00030	45 33 c0	 xor	 r8d, r8d
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EO@PDNJMHLD@SYSTEM?2CurrentControlSet?2Contro@
  0003a	48 c7 c1 02 00
	00 80		 mov	 rcx, -2147483646	; ffffffff80000002H
  00041	49 8b df	 mov	 rbx, r15
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegOpenKeyExA
  0004a	33 f6		 xor	 esi, esi
  0004c	85 c0		 test	 eax, eax
  0004e	0f 85 52 04 00
	00		 jne	 $LN46@OpenTapHan

; 167  : 	}
; 168  : 
; 169  : 	char subKeyName[TAP_REGISTRY_DATA_SIZE];
; 170  : 	DWORD i, subKeySize = sizeof(subKeyName);
; 171  : 
; 172  : 	for (i = 0; (regResult = RegEnumKeyEx(regAdapterKey, i, subKeyName, &subKeySize, NULL, NULL, NULL, NULL)) != ERROR_NO_MORE_ITEMS; i++)

  00054	48 8b 8d a8 03
	00 00		 mov	 rcx, QWORD PTR regAdapterKey$[rbp-256]
  0005b	4c 8d 8d a0 03
	00 00		 lea	 r9, QWORD PTR subKeySize$[rbp-256]
  00062	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00067	4c 8d 85 50 02
	00 00		 lea	 r8, QWORD PTR subKeyName$[rbp-256]
  0006e	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00073	41 be 00 01 00
	00		 mov	 r14d, 256		; 00000100H
  00079	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  0007e	33 d2		 xor	 edx, edx
  00080	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00085	8b fe		 mov	 edi, esi
  00087	44 89 b5 a0 03
	00 00		 mov	 DWORD PTR subKeySize$[rbp-256], r14d
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegEnumKeyExA
  00094	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  00099	0f 84 90 03 00
	00		 je	 $LN33@OpenTapHan
  0009f	45 8d 66 ff	 lea	 r12d, QWORD PTR [r14-1]
$LL4@OpenTapHan:

; 178  : 		if (regResult) WinErrorExit(regResult);

  000a3	85 c0		 test	 eax, eax
  000a5	0f 85 0f 04 00
	00		 jne	 $LN30@OpenTapHan

; 179  : 
; 180  : 		if ((regResult = RegOpenKeyEx(regAdapterKey, subKeyName, 0, KEY_READ | KEY_WOW64_64KEY, &regSubKey)) == ERROR_SUCCESS)

  000ab	48 8b 8d a8 03
	00 00		 mov	 rcx, QWORD PTR regAdapterKey$[rbp-256]
  000b2	48 8d 44 24 40	 lea	 rax, QWORD PTR regSubKey$1[rsp]
  000b7	41 b9 19 01 02
	00		 mov	 r9d, 131353		; 00020119H
  000bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c2	45 33 c0	 xor	 r8d, r8d
  000c5	48 8d 95 50 02
	00 00		 lea	 rdx, QWORD PTR subKeyName$[rbp-256]
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegOpenKeyExA
  000d2	85 c0		 test	 eax, eax
  000d4	0f 85 00 03 00
	00		 jne	 $LN16@OpenTapHan

; 181  : 		{
; 182  : 			regDataSize = sizeof(regData);
; 183  : 
; 184  : 			if (RegQueryValueEx(regSubKey, "ComponentId", NULL, &type, (LPBYTE)regData, &regDataSize) == ERROR_SUCCESS)

  000da	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regSubKey$1[rsp]
  000df	48 8d 85 90 03
	00 00		 lea	 rax, QWORD PTR regDataSize$6[rbp-256]
  000e6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000eb	4c 8d 8d 98 03
	00 00		 lea	 r9, QWORD PTR type$7[rbp-256]
  000f2	48 8d 45 50	 lea	 rax, QWORD PTR regData$4[rbp-256]
  000f6	44 89 b5 90 03
	00 00		 mov	 DWORD PTR regDataSize$6[rbp-256], r14d
  000fd	45 33 c0	 xor	 r8d, r8d
  00100	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00105	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@OCLPIPDG@ComponentId@
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueExA
  00112	85 c0		 test	 eax, eax
  00114	0f 85 c0 02 00
	00		 jne	 $LN16@OpenTapHan

; 185  : 			{
; 186  : 				if (
; 187  : 					type == REG_SZ &&

  0011a	83 bd 98 03 00
	00 01		 cmp	 DWORD PTR type$7[rbp-256], 1
  00121	0f 85 b3 02 00
	00		 jne	 $LN16@OpenTapHan
  00127	4d 8b c6	 mov	 r8, r14
  0012a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07OCKMHPIG@tap0801@
  00131	48 8d 4d 50	 lea	 rcx, QWORD PTR regData$4[rbp-256]
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  0013b	85 c0		 test	 eax, eax
  0013d	74 34		 je	 SHORT $LN10@OpenTapHan
  0013f	4d 8b c6	 mov	 r8, r14
  00142	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07FKBABIOD@tap0901@
  00149	48 8d 4d 50	 lea	 rcx, QWORD PTR regData$4[rbp-256]
  0014d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00153	85 c0		 test	 eax, eax
  00155	74 1c		 je	 SHORT $LN10@OpenTapHan
  00157	4d 8b c6	 mov	 r8, r14
  0015a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@LGAJAMKD@TEAMVIEWERVPN@
  00161	48 8d 4d 50	 lea	 rcx, QWORD PTR regData$4[rbp-256]
  00165	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  0016b	85 c0		 test	 eax, eax
  0016d	0f 85 67 02 00
	00		 jne	 $LN16@OpenTapHan
$LN10@OpenTapHan:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 373  : 	char* dst = _strdup(src);

  00173	48 8d 4d 50	 lea	 rcx, QWORD PTR regData$4[rbp-256]
  00177	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup

; 378  : 	if (!dst) OutOfMemory();

  0017d	48 85 c0	 test	 rax, rax
  00180	0f 84 2e 03 00
	00		 je	 $LN31@OpenTapHan
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c

; 198  : 					if (RegQueryValueEx(regSubKey, "NetCfgInstanceId", NULL, &type, (LPBYTE)regData, &regDataSize) == ERROR_SUCCESS && type == REG_SZ)

  00186	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regSubKey$1[rsp]
  0018b	4c 8d 8d 98 03
	00 00		 lea	 r9, QWORD PTR type$7[rbp-256]
  00192	48 89 05 00 00
	00 00		 mov	 QWORD PTR AdapterClass, rax
  00199	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@BKNOGGLI@NetCfgInstanceId@
  001a0	48 8d 85 90 03
	00 00		 lea	 rax, QWORD PTR regDataSize$6[rbp-256]
  001a7	44 89 b5 90 03
	00 00		 mov	 DWORD PTR regDataSize$6[rbp-256], r14d
  001ae	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b3	45 33 c0	 xor	 r8d, r8d
  001b6	48 8d 45 50	 lea	 rax, QWORD PTR regData$4[rbp-256]
  001ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueExA
  001c5	85 c0		 test	 eax, eax
  001c7	0f 85 00 02 00
	00		 jne	 $LN37@OpenTapHan
  001cd	83 bd 98 03 00
	00 01		 cmp	 DWORD PTR type$7[rbp-256], 1
  001d4	0f 85 f3 01 00
	00		 jne	 $LN37@OpenTapHan

; 199  : 					{
; 200  : 						HKEY connectionKey;
; 201  : 						char connectionKeyName[TAP_REGISTRY_DATA_SIZE];
; 202  : 
; 203  : 						strncpy(connectionKeyName, NETWORK_CONNECTIONS_KEY "\\", sizeof(connectionKeyName));

  001da	4d 8b c6	 mov	 r8, r14
  001dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FB@DAALEALL@SYSTEM?2CurrentControlSet?2Contro@
  001e4	48 8d 8d 50 01
	00 00		 lea	 rcx, QWORD PTR connectionKeyName$5[rbp-256]
  001eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 204  : 						strncat(connectionKeyName, regData, sizeof(connectionKeyName) - strlen(connectionKeyName) - 1);

  001f1	48 8d 8d 50 01
	00 00		 lea	 rcx, QWORD PTR connectionKeyName$5[rbp-256]
  001f8	49 8b c7	 mov	 rax, r15
$LL43@OpenTapHan:
  001fb	48 ff c0	 inc	 rax
  001fe	40 38 34 01	 cmp	 BYTE PTR [rcx+rax], sil
  00202	75 f7		 jne	 SHORT $LL43@OpenTapHan
  00204	4d 8b c4	 mov	 r8, r12
  00207	48 8d 55 50	 lea	 rdx, QWORD PTR regData$4[rbp-256]
  0020b	4c 2b c0	 sub	 r8, rax
  0020e	48 8d 8d 50 01
	00 00		 lea	 rcx, QWORD PTR connectionKeyName$5[rbp-256]
  00215	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncat

; 205  : 						strncat(connectionKeyName, "\\Connection", sizeof(connectionKeyName) - strlen(connectionKeyName) - 1);

  0021b	48 8d 8d 50 01
	00 00		 lea	 rcx, QWORD PTR connectionKeyName$5[rbp-256]
  00222	49 8b c7	 mov	 rax, r15
$LL42@OpenTapHan:
  00225	48 ff c0	 inc	 rax
  00228	40 38 34 01	 cmp	 BYTE PTR [rcx+rax], sil
  0022c	75 f7		 jne	 SHORT $LL42@OpenTapHan
  0022e	4d 8b c4	 mov	 r8, r12
  00231	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@CGLKMMLF@?2Connection@
  00238	4c 2b c0	 sub	 r8, rax
  0023b	48 8d 8d 50 01
	00 00		 lea	 rcx, QWORD PTR connectionKeyName$5[rbp-256]
  00242	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncat

; 206  : 
; 207  : 						if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, connectionKeyName, 0, KEY_READ | KEY_WOW64_64KEY, &connectionKey) == ERROR_SUCCESS)

  00248	48 8d 44 24 48	 lea	 rax, QWORD PTR connectionKey$2[rsp]
  0024d	41 b9 19 01 02
	00		 mov	 r9d, 131353		; 00020119H
  00253	45 33 c0	 xor	 r8d, r8d
  00256	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0025b	48 8d 95 50 01
	00 00		 lea	 rdx, QWORD PTR connectionKeyName$5[rbp-256]
  00262	48 c7 c1 02 00
	00 80		 mov	 rcx, -2147483646	; ffffffff80000002H
  00269	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegOpenKeyExA
  0026f	85 c0		 test	 eax, eax
  00271	0f 85 46 01 00
	00		 jne	 $LN14@OpenTapHan

; 208  : 						{
; 209  : 							char deviceName[TAP_REGISTRY_DATA_SIZE];
; 210  : 							regDataSize = sizeof(deviceName);
; 211  : 
; 212  : 							if (RegQueryValueEx(connectionKey, "Name", NULL, &type, (LPBYTE)deviceName, &regDataSize) == ERROR_SUCCESS && type == REG_SZ)

  00277	48 8b 4c 24 48	 mov	 rcx, QWORD PTR connectionKey$2[rsp]
  0027c	48 8d 85 90 03
	00 00		 lea	 rax, QWORD PTR regDataSize$6[rbp-256]
  00283	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00288	4c 8d 8d 98 03
	00 00		 lea	 r9, QWORD PTR type$7[rbp-256]
  0028f	48 8d 44 24 50	 lea	 rax, QWORD PTR deviceName$3[rsp]
  00294	44 89 b5 90 03
	00 00		 mov	 DWORD PTR regDataSize$6[rbp-256], r14d
  0029b	45 33 c0	 xor	 r8d, r8d
  0029e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04FABLJDN@Name@
  002aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueExA
  002b0	85 c0		 test	 eax, eax
  002b2	0f 85 05 01 00
	00		 jne	 $LN14@OpenTapHan
  002b8	83 bd 98 03 00
	00 01		 cmp	 DWORD PTR type$7[rbp-256], 1
  002bf	0f 85 f8 00 00
	00		 jne	 $LN14@OpenTapHan

; 213  : 							{
; 214  : 								if (!strcmp(szTapName, ".") || !strncasecmp(szTapName, deviceName, sizeof(deviceName)))

  002c5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR szTapName
  002cc	80 39 2e	 cmp	 BYTE PTR [rcx], 46	; 0000002eH
  002cf	75 06		 jne	 SHORT $LN41@OpenTapHan
  002d1	40 38 71 01	 cmp	 BYTE PTR [rcx+1], sil
  002d5	74 16		 je	 SHORT $LN15@OpenTapHan
$LN41@OpenTapHan:
  002d7	4d 8b c6	 mov	 r8, r14
  002da	48 8d 54 24 50	 lea	 rdx, QWORD PTR deviceName$3[rsp]
  002df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  002e5	85 c0		 test	 eax, eax
  002e7	0f 85 d0 00 00
	00		 jne	 $LN14@OpenTapHan
$LN15@OpenTapHan:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 373  : 	char* dst = _strdup(src);

  002ed	48 8d 4c 24 50	 lea	 rcx, QWORD PTR deviceName$3[rsp]
  002f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup

; 378  : 	if (!dst) OutOfMemory();

  002f8	48 85 c0	 test	 rax, rax
  002fb	0f 84 ad 01 00
	00		 je	 $LN32@OpenTapHan
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c

; 216  : 									ActiveTapName = vlmcsd_strdup(deviceName);

  00301	4d 8b c6	 mov	 r8, r14
  00304	48 89 05 00 00
	00 00		 mov	 QWORD PTR ActiveTapName, rax

; 217  : 									strncpy(deviceName, USERMODEDEVICEDIR, sizeof(deviceName));

  0030b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@KLEKCEEC@?2?2?4?2Global?2@
  00312	48 8d 4c 24 50	 lea	 rcx, QWORD PTR deviceName$3[rsp]
  00317	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 218  : 									strncat(deviceName, regData, sizeof(deviceName) - strlen(deviceName) - 1);

  0031d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR deviceName$3[rsp]
  00322	49 8b c7	 mov	 rax, r15
$LL40@OpenTapHan:
  00325	48 ff c0	 inc	 rax
  00328	40 38 34 01	 cmp	 BYTE PTR [rcx+rax], sil
  0032c	75 f7		 jne	 SHORT $LL40@OpenTapHan
  0032e	4d 8b c4	 mov	 r8, r12
  00331	48 8d 55 50	 lea	 rdx, QWORD PTR regData$4[rbp-256]
  00335	4c 2b c0	 sub	 r8, rax
  00338	48 8d 4c 24 50	 lea	 rcx, QWORD PTR deviceName$3[rsp]
  0033d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncat

; 219  : 									strncat(deviceName, strcmp(AdapterClass, "TEAMVIEWERVPN") ? TAP_WIN_SUFFIX : ".dgt", sizeof(deviceName) - strlen(deviceName) - 1);

  00343	48 8d 4c 24 50	 lea	 rcx, QWORD PTR deviceName$3[rsp]
  00348	49 8b c7	 mov	 rax, r15
$LL39@OpenTapHan:
  0034b	48 ff c0	 inc	 rax
  0034e	40 38 34 01	 cmp	 BYTE PTR [rcx+rax], sil
  00352	75 f7		 jne	 SHORT $LL39@OpenTapHan
  00354	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AdapterClass
  0035b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@LGAJAMKD@TEAMVIEWERVPN@
  00362	49 8b dc	 mov	 rbx, r12
  00365	48 2b d8	 sub	 rbx, rax
  00368	e8 00 00 00 00	 call	 strcmp
  0036d	85 c0		 test	 eax, eax
  0036f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04MFFLHGKN@?4tap@
  00376	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04PFKDJIIE@?4dgt@
  0037d	4c 8b c3	 mov	 r8, rbx
  00380	48 0f 45 d1	 cmovne	 rdx, rcx
  00384	48 8d 4c 24 50	 lea	 rcx, QWORD PTR deviceName$3[rsp]
  00389	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncat

; 220  : 									handle = CreateFile(deviceName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM, NULL);

  0038f	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00394	48 8d 4c 24 50	 lea	 rcx, QWORD PTR deviceName$3[rsp]
  00399	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR [rsp+40], 4
  003a1	45 33 c9	 xor	 r9d, r9d
  003a4	45 33 c0	 xor	 r8d, r8d
  003a7	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  003af	ba 00 00 00 c0	 mov	 edx, -1073741824	; c0000000H
  003b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  003ba	48 8b d8	 mov	 rbx, rax
$LN14@OpenTapHan:

; 221  : 								}
; 222  : 							}
; 223  : 						}
; 224  : 
; 225  : 						RegCloseKey(connectionKey);

  003bd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR connectionKey$2[rsp]
  003c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegCloseKey

; 226  : 					}
; 227  : 
; 228  : 					if (handle == INVALID_HANDLE_VALUE) free(AdapterClass);

  003c8	49 3b df	 cmp	 rbx, r15
  003cb	75 0d		 jne	 SHORT $LN16@OpenTapHan
$LN37@OpenTapHan:
  003cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AdapterClass
  003d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN16@OpenTapHan:

; 229  : 				}
; 230  : 			}
; 231  : 		}
; 232  : 
; 233  : 		RegCloseKey(regSubKey);

  003da	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regSubKey$1[rsp]
  003df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegCloseKey

; 234  : 		subKeySize = sizeof(subKeyName);

  003e5	44 89 b5 a0 03
	00 00		 mov	 DWORD PTR subKeySize$[rbp-256], r14d

; 235  : 		if (handle != INVALID_HANDLE_VALUE) break;

  003ec	49 3b df	 cmp	 rbx, r15
  003ef	75 3e		 jne	 SHORT $LN33@OpenTapHan

; 167  : 	}
; 168  : 
; 169  : 	char subKeyName[TAP_REGISTRY_DATA_SIZE];
; 170  : 	DWORD i, subKeySize = sizeof(subKeyName);
; 171  : 
; 172  : 	for (i = 0; (regResult = RegEnumKeyEx(regAdapterKey, i, subKeyName, &subKeySize, NULL, NULL, NULL, NULL)) != ERROR_NO_MORE_ITEMS; i++)

  003f1	48 8b 8d a8 03
	00 00		 mov	 rcx, QWORD PTR regAdapterKey$[rbp-256]
  003f8	4c 8d 8d a0 03
	00 00		 lea	 r9, QWORD PTR subKeySize$[rbp-256]
  003ff	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00404	4c 8d 85 50 02
	00 00		 lea	 r8, QWORD PTR subKeyName$[rbp-256]
  0040b	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00410	ff c7		 inc	 edi
  00412	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  00417	8b d7		 mov	 edx, edi
  00419	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0041e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegEnumKeyExA
  00424	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  00429	0f 85 74 fc ff
	ff		 jne	 $LL4@OpenTapHan
$LN33@OpenTapHan:

; 236  : 	}
; 237  : 
; 238  : 	RegCloseKey(regAdapterKey);

  0042f	48 8b 8d a8 03
	00 00		 mov	 rcx, QWORD PTR regAdapterKey$[rbp-256]
  00436	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegCloseKey

; 239  : 
; 240  : 	if (handle == INVALID_HANDLE_VALUE)

  0043c	49 3b df	 cmp	 rbx, r15
  0043f	75 50		 jne	 SHORT $LN18@OpenTapHan

; 241  : 	{
; 242  : 		printerrorf("Fatal: No compatible VPN adapter");

  00441	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@PJHCNLCC@Fatal?3?5No?5compatible?5VPN?5adapte@
  00448	e8 00 00 00 00	 call	 printerrorf

; 243  : 
; 244  : 		if (!strcmp(szTapName, "."))

  0044d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR szTapName
  00454	80 3a 2e	 cmp	 BYTE PTR [rdx], 46	; 0000002eH
  00457	75 14		 jne	 SHORT $LN19@OpenTapHan
  00459	40 38 72 01	 cmp	 BYTE PTR [rdx+1], sil
  0045d	75 0e		 jne	 SHORT $LN19@OpenTapHan

; 245  : 		{
; 246  : 			printerrorf("s");

  0045f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01LKDEMHDF@s@
  00466	e8 00 00 00 00	 call	 printerrorf

; 247  : 		}

  0046b	eb 0c		 jmp	 SHORT $LN20@OpenTapHan
$LN19@OpenTapHan:

; 248  : 		else
; 249  : 		{
; 250  : 			printerrorf(" with name \"%s\"", szTapName);

  0046d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@KFDACIEA@?5with?5name?5?$CC?$CFs?$CC@
  00474	e8 00 00 00 00	 call	 printerrorf
$LN20@OpenTapHan:

; 251  : 		}
; 252  : 
; 253  : 		printerrorf(" available for use\n");

  00479	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@BMEHODCL@?5available?5for?5use?6@
  00480	e8 00 00 00 00	 call	 printerrorf

; 254  : 		exit(ERROR_DEVICE_NOT_AVAILABLE);

  00485	b9 df 10 00 00	 mov	 ecx, 4319		; 000010dfH
  0048a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00490	cc		 int	 3
$LN18@OpenTapHan:

; 255  : 	}
; 256  : 
; 257  : 	return handle;

  00491	48 8b c3	 mov	 rax, rbx

; 258  : }

  00494	48 81 c4 50 04
	00 00		 add	 rsp, 1104		; 00000450H
  0049b	41 5f		 pop	 r15
  0049d	41 5e		 pop	 r14
  0049f	41 5c		 pop	 r12
  004a1	5f		 pop	 rdi
  004a2	5e		 pop	 rsi
  004a3	5b		 pop	 rbx
  004a4	5d		 pop	 rbp
  004a5	c3		 ret	 0
$LN46@OpenTapHan:

; 165  : 	{
; 166  : 		WinErrorExit(regResult);

  004a6	8b c8		 mov	 ecx, eax
  004a8	e8 00 00 00 00	 call	 WinErrorExit
  004ad	cc		 int	 3
$LN32@OpenTapHan:
; File C:\Users\dev\source\repos\alpinevms\src\helpers.c

; 378  : 	if (!dst) OutOfMemory();

  004ae	e8 00 00 00 00	 call	 OutOfMemory
  004b3	cc		 int	 3
$LN31@OpenTapHan:
  004b4	e8 00 00 00 00	 call	 OutOfMemory
  004b9	cc		 int	 3
$LN30@OpenTapHan:
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c

; 178  : 		if (regResult) WinErrorExit(regResult);

  004ba	8b c8		 mov	 ecx, eax
  004bc	e8 00 00 00 00	 call	 WinErrorExit
  004c1	cc		 int	 3
$LN44@OpenTapHan:
OpenTapHandle ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c
;	COMDAT DevCtl
_TEXT	SEGMENT
code$ = 80
data$ = 88
len$ = 96
DevCtl	PROC						; COMDAT

; 262  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	45 89 43 18	 mov	 DWORD PTR [r11+24], r8d
  00007	53		 push	 rbx
  00008	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 263  : 	if (!DeviceIoControl(TapHandle, code, data, len, data, len, &len, NULL))

  0000c	49 83 63 f0 00	 and	 QWORD PTR [r11-16], 0
  00011	49 8d 43 18	 lea	 rax, QWORD PTR [r11+24]
  00015	49 89 43 e8	 mov	 QWORD PTR [r11-24], rax
  00019	45 8b c8	 mov	 r9d, r8d
  0001c	45 89 43 e0	 mov	 DWORD PTR [r11-32], r8d
  00020	4c 8b c2	 mov	 r8, rdx
  00023	49 89 53 d8	 mov	 QWORD PTR [r11-40], rdx
  00027	8b d1		 mov	 edx, ecx
  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR TapHandle
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeviceIoControl
  00036	85 c0		 test	 eax, eax
  00038	75 27		 jne	 SHORT $LN2@DevCtl

; 264  : 	{
; 265  : 		const DWORD error = GetLastError();

  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 266  : 		printerrorf("Fatal: VPN adapter error: %s\n", win_strerror(error));

  00040	8b c8		 mov	 ecx, eax
  00042	8b d8		 mov	 ebx, eax
  00044	e8 00 00 00 00	 call	 win_strerror
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@KPKEIBCK@Fatal?3?5VPN?5adapter?5error?3?5?$CFs?6@
  00053	e8 00 00 00 00	 call	 printerrorf

; 267  : 		exit(error);

  00058	8b cb		 mov	 ecx, ebx
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00060	cc		 int	 3
$LN2@DevCtl:

; 268  : 	}
; 269  : 
; 270  : 	return len;

  00061	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]

; 271  : }

  00065	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00069	5b		 pop	 rbx
  0006a	c3		 ret	 0
$LN4@DevCtl:
DevCtl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Users\dev\source\repos\alpinevms\src\wintap.c
;	COMDAT TapMirror
_TEXT	SEGMENT
data_unused$ = 64
bytesRead$1 = 72
bytesWritten$2 = 80
TapMirror PROC						; COMDAT

; 275  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 276  : 	while (TRUE)
; 277  : 	{
; 278  : 		DWORD bytesRead, bytesWritten;
; 279  : 		if (!ReadFile(TapHandle, IpPacket, Mtu, &bytesRead, NULL)) break;

  00006	33 db		 xor	 ebx, ebx
  00008	eb 33		 jmp	 SHORT $LN15@TapMirror
$LL2@TapMirror:

; 280  : 
; 281  : 		const uint32_t temp = IpPacket->ip_src;

  0000a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR IpPacket

; 282  : 		IpPacket->ip_src = IpPacket->ip_dst;
; 283  : 		IpPacket->ip_dst = temp;
; 284  : 
; 285  : 		if (!WriteFile(TapHandle, IpPacket, bytesRead, &bytesWritten, NULL)) break;

  00011	4c 8d 4c 24 50	 lea	 r9, QWORD PTR bytesWritten$2[rsp]
  00016	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0001b	8b 4a 0c	 mov	 ecx, DWORD PTR [rdx+12]
  0001e	8b 42 10	 mov	 eax, DWORD PTR [rdx+16]
  00021	89 4a 10	 mov	 DWORD PTR [rdx+16], ecx
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR TapHandle
  0002b	89 42 0c	 mov	 DWORD PTR [rdx+12], eax
  0002e	44 8b 44 24 48	 mov	 r8d, DWORD PTR bytesRead$1[rsp]
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile
  00039	85 c0		 test	 eax, eax
  0003b	74 29		 je	 SHORT $LN9@TapMirror
$LN15@TapMirror:

; 276  : 	while (TRUE)
; 277  : 	{
; 278  : 		DWORD bytesRead, bytesWritten;
; 279  : 		if (!ReadFile(TapHandle, IpPacket, Mtu, &bytesRead, NULL)) break;

  0003d	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR Mtu
  00044	4c 8d 4c 24 48	 lea	 r9, QWORD PTR bytesRead$1[rsp]
  00049	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR IpPacket
  00050	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR TapHandle
  00057	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReadFile
  00062	85 c0		 test	 eax, eax
  00064	75 a4		 jne	 SHORT $LL2@TapMirror
$LN9@TapMirror:

; 286  : 
; 287  : #		if !defined(NO_LOG) && defined(_PEDANTIC)
; 288  : 		if (bytesRead != bytesWritten) logger("Warning: VPN device \"%s\": %u bytes could not be written\n", ActiveTapName, bytesRead - bytesWritten);
; 289  : #		endif // !defined(NO_LOG) && defined(_PEDANTIC)
; 290  : 	}
; 291  : 
; 292  : 	const DWORD error = GetLastError();

  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 293  : 
; 294  : #	ifndef NO_LOG
; 295  : 	logger("Warning: VPN thread for device \"%s\" exiting: %s\n", ActiveTapName, win_strerror(error));

  0006c	8b c8		 mov	 ecx, eax
  0006e	8b d8		 mov	 ebx, eax
  00070	e8 00 00 00 00	 call	 win_strerror
  00075	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ActiveTapName
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@GOGKGJOK@Warning?3?5VPN?5thread?5for?5device?5@
  00083	4c 8b c0	 mov	 r8, rax
  00086	e8 00 00 00 00	 call	 logger

; 296  : #	endif // NO_LOG
; 297  : 
; 298  : 	free(ActiveTapName);

  0008b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ActiveTapName
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 299  : 	CloseHandle(TapHandle);

  00098	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR TapHandle
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 300  : 	exitOnWarningLevel(1);

  000a5	e8 00 00 00 00	 call	 exitOnWarningLevel

; 301  : 	return error;

  000aa	8b c3		 mov	 eax, ebx

; 302  : }

  000ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b0	5b		 pop	 rbx
  000b1	c3		 ret	 0
TapMirror ENDP
_TEXT	ENDS
END
